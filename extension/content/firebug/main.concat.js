/* See license.txt for terms of usage */

define("firebug/accessible/a11y",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/xml",
    "firebug/lib/xpath",
    "firebug/console/console",
    "firebug/chrome/infotip",
],
function(Module, Obj, Firebug, Domplate, Locale, Events, Url, Css, Dom, Xml, Xpath) {

// ************************************************************************************************
// Constants

var singleSpaceTag = Domplate.DIV({"class" : "a11y1emSize"}, "x");

var KeyEvent = window.KeyEvent;

// ************************************************************************************************
// Module Management

Firebug.A11yModel = Obj.extend(Module,
{
    dispatchName: "a11y",

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        this.handleTabBarFocus = Obj.bind(this.handleTabBarFocus, this);
        this.handleTabBarBlur = Obj.bind(this.handleTabBarBlur, this);
        this.handlePanelBarKeyPress = Obj.bind(this.handlePanelBarKeyPress, this);
        this.onNavigablePanelKeyPress = Obj.bind(this.onNavigablePanelKeyPress, this);
        this.onConsoleMouseDown = Obj.bind(this.onConsoleMouseDown, this);
        this.onLayoutKeyPress = Obj.bind(this.onLayoutKeyPress, this);
        this.onCSSKeyPress = Obj.bind(this.onCSSKeyPress, this);
        this.onCSSMouseDown = Obj.bind(this.onCSSMouseDown, this);
        this.onHTMLKeyPress = Obj.bind(this.onHTMLKeyPress, this);
        this.onHTMLFocus = Obj.bind(this.onHTMLFocus, this);
        this.onHTMLBlur = Obj.bind(this.onHTMLBlur, this);
        this.onPanelFocus = Obj.bind(this.onPanelFocus, this);
        this.onLayoutFocus = Obj.bind(this.onLayoutFocus, this);
        this.onLayoutBlur = Obj.bind(this.onLayoutBlur, this);
        this.onScriptContextMenu = Obj.bind(this.onScriptContextMenu, this);
        this.onCSSPanelContextMenu = Obj.bind(this.onCSSPanelContextMenu, this);
        this.onScriptKeyPress = Obj.bind(this.onScriptKeyPress, this);
        this.onScriptKeyUp = Obj.bind(this.onScriptKeyUp, this);
        this.onScriptMouseUp = Obj.bind(this.onScriptMouseUp, this);
        this.onNetMouseDown = Obj.bind(this.onNetMouseDown, this);
        this.onNetFocus = Obj.bind(this.onNetFocus, this);
        this.onNetBlur = Obj.bind(this.onNetBlur, this);

        // Mark ourselves disabled, so we don't performDisable() if we are not enabled.
        Firebug.chrome.window.a11yEnabled = false;

        Firebug.connection.addListener(this);
        Firebug.Console.addListener(this);
        Firebug.DOMModule.addListener(this);
    },

    shutdown: function()
    {
        Firebug.connection.removeListener(this);
        Firebug.Console.removeListener(this);
        Firebug.DOMModule.removeListener(this);

        Module.shutdown.apply(this, arguments);
    },

    initializeUI: function()
    {
        //Initialize according to the current pref value.
        this.updateOption("a11y.enable", this.isEnabled());
    },

    isEnabled: function()
    {
        return Firebug.Options.get("a11y.enable");
    },

    updateOption: function(name, value)
    {
        if (FBTrace.DBG_A11Y)
        {
            FBTrace.sysout("a11y.updateOption; " + name + ": " + value +
                ", Current chrome: " + Firebug.chrome.getName() +
                ", Original chrome: " + Firebug.originalChrome.getName());
        }

        if (name == "a11y.enable")
        {
            // Update for current chrome
            this.set(value, Firebug.chrome);
            // If the current chrome is an external window, update also the original chrome.
            if (Firebug.chrome != Firebug.originalChrome)
            {
                this.set(value, Firebug.originalChrome);
                if (FBTrace.DBG_A11Y)
                    FBTrace.sysout("a11y.updateOption; (original chrome)");
            }
        }
    },

    set: function(enable, chrome)
    {
        if (chrome.window.a11yEnabled == enable)
            return;

        if (enable)
            this.performEnable(chrome);
        else
            this.performDisable(chrome);
        chrome.window.a11yEnabled = enable;
    },

    performEnable: function(chrome)
    {
        var tmpElem;
        //add class used by all a11y related css styles (e.g. :focus and -moz-user-focus styles)
        Css.setClass(chrome.$("fbContentBox"), "useA11y");
        //Css.setClass(chrome.$("fbStatusBar"), "useA11y");
        tmpElem = chrome.$("fbStatusPrefix");
        if (tmpElem) tmpElem.setAttribute("value", Locale.$STR("a11y.labels.firebug status"));

        //manage all key events in toolbox (including tablists)
        tmpElem = chrome.$("fbContentBox");
        if (tmpElem)
            Events.addEventListener(tmpElem, "keypress", this.handlePanelBarKeyPress, true);

        //make focus stick to inspect button when clicked
        tmpElem = chrome.$("fbInspectButton");
        if (tmpElem)
            Events.addEventListener(tmpElem, "mousedown", this.focusTarget, true);

        tmpElem = chrome.$("fbPanelBar1-panelTabs");
        if (tmpElem)
            Events.addEventListener(tmpElem, "focus", this.handleTabBarFocus, true);

        tmpElem = chrome.$("fbPanelBar1-panelTabs");
        if (tmpElem)
            Events.addEventListener(tmpElem, "blur", this.handleTabBarBlur, true);

        tmpElem = chrome.$("fbPanelBar2-panelTabs");
        if (tmpElem)
            Events.addEventListener(tmpElem, "focus", this.handleTabBarFocus, true);

        tmpElem = chrome.$("fbPanelBar2-panelTabs");
        if (tmpElem)
            Events.addEventListener(tmpElem, "blur", this.handleTabBarBlur, true);

        tmpElem = chrome.$("fbPanelBar1");
        if (tmpElem)
            Css.setClass(tmpElem.browser.contentDocument.body, "useA11y");

        tmpElem = chrome.$("fbPanelBar2");
        if (tmpElem)
            Css.setClass(tmpElem.browser.contentDocument.body, "useA11y");
        Firebug.Editor.addListener(this);
        this.listeningToEditor = true;
    },

    performDisable: function(chrome)
    {
        var tmpElem;
        //undo everything we did in performEnable
        Css.removeClass(chrome.$("fbContentBox"), "useA11y");
        Css.removeClass(chrome.$("fbStatusBar"), "useA11y");

        tmpElem = chrome.$("fbPanelBar1");
        if (tmpElem)
            Events.removeEventListener(tmpElem, "keypress", this.handlePanelBarKeyPress, true);

        tmpElem = chrome.$("fbInspectButton");
        if (tmpElem)
            Events.removeEventListener(tmpElem, "mousedown", this.focusTarget, true);

        tmpElem = chrome.$("fbPanelBar1-panelTabs");
        if (tmpElem)
            Events.removeEventListener(tmpElem, "focus", this.handleTabBarFocus, true);

        tmpElem = chrome.$("fbPanelBar1-panelTabs");
        if (tmpElem)
            Events.removeEventListener(tmpElem, "blur", this.handleTabBarBlur, true);

        tmpElem = chrome.$("fbPanelBar2-panelTabs");
        if (tmpElem)
            Events.removeEventListener(tmpElem, "focus", this.handleTabBarFocus, true);

        tmpElem = chrome.$("fbPanelBar2-panelTabs");
        if (tmpElem)
            Events.removeEventListener(tmpElem, "blur", this.handleTabBarBlur, true);

        tmpElem = chrome.$("fbPanelBar1");
        if (tmpElem)
        {
            Css.removeClass(tmpElem.browser.contentDocument.body, "useA11y");
            tmpElem.browser.setAttribute("showcaret", false);
        }

        tmpElem = chrome.$("fbPanelBar2");
        if (tmpElem)
            Css.removeClass(tmpElem.browser.contentDocument.body, "useA11y");

        if (this.listeningToEditor)
            Firebug.Editor.removeListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

    onCreatePanel: function(context, panel, panelType)
    {
        if (!panel.enableA11y)
            return;

        if (panel.addListener)
            panel.addListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Context & Panel Management

    onInitializeNode: function(panel)
    {
        var panelA11y = this.getPanelA11y(panel, true);
        if (!panelA11y)
            return;

        panelA11y.tabStop = null;
        panelA11y.manageFocus = false;
        panelA11y.lastIsDefault = false;
        panelA11y.type = panel.deriveA11yFrom ? panel.deriveA11yFrom : panel.name;

        //panel.context.chrome.$("fbContentBox").addEventListener("focus", this.reportFocus, true);
        this.makeFocusable(panel.panelNode, false);

        switch (panelA11y.type)
        {
            case "console":
                panelA11y.manageFocus = true;
                switch (panel.name)
                {
                    case "console":
                        panel.panelNode.setAttribute("aria-label",
                            Locale.$STR("a11y.labels.log rows"));
                        panelA11y.lastIsDefault = true;
                        panel.panelNode.setAttribute("role", "list");
                        break;

                    case "callstack":
                        panel.panelNode.setAttribute("role", "list");
                        panel.panelNode.setAttribute("aria-label",
                            Locale.$STR("a11y.labels.call stack"));
                        break;

                    default:
                        panel.panelNode.setAttribute("role", "presentation");
                }
                panel.panelNode.setAttribute("aria-live", "polite");
                panel.panelNode.setAttribute("aria-relevant", "additions");
                Events.addEventListener(panel.panelNode, "keypress", this.onNavigablePanelKeyPress, false);
                Events.addEventListener(panel.panelNode, "focus", this.onPanelFocus, true);
                Events.addEventListener(panel.panelNode, "mousedown", this.onConsoleMouseDown, false);
                if (panel.name == "breakpoints")
                    panel.panelNode.style.overflowX = "hidden";
                break;

            case "html":
                panel.panelNode.setAttribute("role", "tree");
                panel.panelNode.setAttribute("aria-label",
                    Locale.$STR("a11y.labels.document structure"));
                Events.addEventListener(panel.panelNode, "keypress", this.onHTMLKeyPress, false);
                Events.addEventListener(panel.panelNode, "focus", this.onHTMLFocus, true);
                Events.addEventListener(panel.panelNode, "blur", this.onHTMLBlur, true);
                break;

            case "css":
                panelA11y.manageFocus = true;
                Events.addEventListener(panel.panelNode, "keypress", this.onCSSKeyPress, false);
                Events.addEventListener(panel.panelNode, "mousedown", this.onCSSMouseDown, false);
                Events.addEventListener(panel.panelNode, "focus", this.onPanelFocus, true);
                Events.addEventListener(panel.panelNode, "contextmenu", this.onCSSPanelContextMenu, false);
                this.insertHiddenText(panel, panel.panelNode,
                    Locale.$STR("a11y.labels.overridden"), false, "CSSOverriddenDescription");
                panel.panelNode.setAttribute("role", panel.name == "stylesheet" ?
                    "list" : "presentation");
                break;

            case "layout":
                panelA11y.manageFocus = true;
                Events.addEventListener(panel.panelNode, "keypress", this.onLayoutKeyPress, false);
                Events.addEventListener(panel.panelNode, "focus", this.onLayoutFocus, true);
                Events.addEventListener(panel.panelNode, "blur", this.onLayoutBlur, true);
                break;

            case "script":
                Events.addEventListener(panel.panelNode, "contextmenu", this.onScriptContextMenu, true);
                Events.addEventListener(panel.panelNode, "keypress", this.onScriptKeyPress, true);
                Events.addEventListener(panel.panelNode, "keyup", this.onScriptKeyUp, true);
                Events.addEventListener(panel.panelNode, "mouseup", this.onScriptMouseUp, true);
                panelA11y.oneEmElem = this.addSingleSpaceElem(panel.panelNode);
                break;

            case "net":
                panelA11y.manageFocus = true;
                Events.addEventListener(panel.panelNode, "keypress", this.onNavigablePanelKeyPress, false);
                Events.addEventListener(panel.panelNode, "focus", this.onPanelFocus, true);
                Events.addEventListener(panel.panelNode, "focus", this.onNetFocus, true);
                Events.addEventListener(panel.panelNode, "blur", this.onNetBlur, true);
                Events.addEventListener(panel.panelNode, "mousedown", this.onNetMouseDown, false);
                break;
        }
    },

    onDestroyNode: function(panel)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        panelA11y = null;

        // Remove all event handlers we added in onInitializeNode.
        var actAsPanel = panel.deriveA11yFrom ? panel.deriveA11yFrom : panel.name;
        switch (actAsPanel)
        {
            case "console":
                Events.removeEventListener(panel.panelNode, "keypress", this.onNavigablePanelKeyPress,
                    false);
                Events.removeEventListener(panel.panelNode, "focus", this.onPanelFocus, true);
                Events.removeEventListener(panel.panelNode, "mousedown", this.onConsoleMouseDown, false);
                break;

            case "html":
                Events.removeEventListener(panel.panelNode, "keypress", this.onHTMLKeyPress, false);
                Events.removeEventListener(panel.panelNode, "focus", this.onHTMLFocus, true);
                Events.removeEventListener(panel.panelNode, "blur", this.onHTMLBlur, true);
                break;

            case "css":
                Events.removeEventListener(panel.panelNode, "keypress", this.onCSSKeyPress, false);
                Events.removeEventListener(panel.panelNode, "mousedown", this.onCSSMouseDown, false);
                Events.removeEventListener(panel.panelNode, "focus", this.onPanelFocus, true);
                Events.removeEventListener(panel.panelNode, "blur", this.onPanelBlur, true);
                Events.removeEventListener(panel.panelNode, "contextmenu", this.onCSSPanelContextMenu,
                    false);
                break;

            case "layout":
                Events.removeEventListener(panel.panelNode, "keypress", this.onLayoutKeyPress, false);
                Events.removeEventListener(panel.panelNode, "focus", this.onLayoutFocus, true);
                Events.removeEventListener(panel.panelNode, "blur", this.onLayoutBlur, true);
                break;

            case "script":
                Events.removeEventListener(panel.panelNode, "contextmenu", this.onScriptContextMenu, true);
                Events.removeEventListener(panel.panelNode, "keypress", this.onScriptKeyPress, true);
                Events.removeEventListener(panel.panelNode, "keyup", this.onScriptKeyUp, true);
                Events.removeEventListener(panel.panelNode, "mouseup", this.onScriptMouseUp, true);
                break;

            case "net":
                Events.removeEventListener(panel.panelNode, "keypress", this.onNavigablePanelKeyPress,
                    false);
                Events.removeEventListener(panel.panelNode, "focus", this.onPanelFocus, true);
                Events.removeEventListener(panel.panelNode, "focus", this.onNetFocus, true);
                Events.removeEventListener(panel.panelNode, "blur", this.onNetBlur, true);
                Events.removeEventListener(panel.panelNode, "mousedown", this.onNetMouseDown, false);
                break;
        }
    },

    showPanel: function(browser, panel)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;
        var title = panel.name;
        var panelType = Firebug.getPanelType(panel.name);
        if (panelType)
            title = Firebug.getPanelTitle(panelType);
        Firebug.chrome.$("fbToolbar").setAttribute("aria-label", title + " " +
            Locale.$STR("a11y.labels.panel tools"));
        var panelBrowser = Firebug.chrome.getPanelBrowser(panel);
        panelBrowser.setAttribute("showcaret", (panel.name == "script"));
        panelBrowser.contentDocument.body.setAttribute("aria-label",
            Locale.$STRF("a11y.labels.title panel", [title]));
    },

    showSidePanel: function(browser, sidePanel)
    {
        var panelA11y = this.getPanelA11y(sidePanel);
        if (!panelA11y)
            return;
        var panelBrowser = Firebug.chrome.getPanelBrowser(sidePanel);
        var panelType = Firebug.getPanelType(sidePanel.name);
        if (panelType)
            title = Firebug.getPanelTitle(panelType);
        panelBrowser.contentDocument.body.setAttribute("aria-label",
            Locale.$STRF("a11y.labels.title side panel", [title]));
    },

    addLiveElem: function(panel, role, politeness)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;
        if (panelA11y.liveElem && Dom.isElement(panelA11y.liveElem))
            return;

        var attrName = attrValue = "";
        if (role)
        {
            attrName = "role";
            attrValue = role;
        }
        else
        {
            attrName = "aria-live";
            attrValue = politeness ? politeness : "polite";
        }
        var elem = panel.document.createElement("div");
        elem.setAttribute(attrName, attrValue);
        elem.className = "offScreen";
        panel.document.body.appendChild(elem);
        panelA11y.liveElem = elem;
        return elem;
    },

    updateLiveElem: function(panel, msg, useAlert)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;
        var elem = panelA11y.liveElem;
        if (!elem)
            elem = this.addLiveElem(panel);
        elem.textContent = msg;
        if (useAlert)
            elem.setAttribute("role", "alert");
    },

    addSingleSpaceElem: function(parent)
    {
        return singleSpaceTag.append({}, parent, this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Toolbars & Tablists

    focusTarget: function(event)
    {
        this.focus(event.target);
    },

    handlePanelBarKeyPress: function (event)
    {
        var target = event.originalTarget;
        var isTab = target.nodeName.toLowerCase() == "paneltab";
        var isButton = target.nodeName.search(/(xul:)?((toolbar)?button)|(checkbox)/) != -1;
        var isDropDownMenu = isButton && (target.getAttribute("type") == "menu" ||
            target.id == "fbLocationList");
        var siblingTab, forward, toolbar;
        var keyCode = event.keyCode || (event.type == "keypress" ? event.charCode : null);
        if (keyCode == KeyEvent.DOM_VK_TAB)
            this.ensurePanelTabStops(); //TODO: need a better solution to prevent loss of panel tabstop
        if (isTab || isButton)
        {
            switch (keyCode)
            {
                case KeyEvent.DOM_VK_LEFT:
                case KeyEvent.DOM_VK_RIGHT:
                case KeyEvent.DOM_VK_UP:
                case KeyEvent.DOM_VK_DOWN:
                    forward = (event.keyCode == KeyEvent.DOM_VK_RIGHT ||
                        event.keyCode == KeyEvent.DOM_VK_DOWN);
                    if (isTab)
                    {
                        //will only work as long as long as siblings only consist of paneltab elements
                        siblingTab = target[forward ? "nextSibling" : "previousSibling"];
                        if (!siblingTab)
                            siblingTab = target.parentNode[forward ? "firstChild" : "lastChild"];
                        if (siblingTab)
                        {
                            var panelBar = Dom.getAncestorByClass(target, "panelBar");
                            setTimeout(Obj.bindFixed(function()
                            {
                                panelBar.selectTab(siblingTab);
                                this.focus(siblingTab);
                            }, this));
                        }
                    }
                    else if (isButton)
                    {
                        if (target.id == "fbFirebugMenu" && !forward)
                        {
                             Events.cancelEvent(event);
                             return;
                        }
                        toolbar = Dom.getAncestorByClass(target, "innerToolbar");
                        if (toolbar)
                        {
                            var doc = target.ownerDocument;
                            //temporarily make all buttons in the toolbar part of the tab order,
                            //to allow smooth, native focus advancement
                            Css.setClass(toolbar, "hasTabOrder");
                            setTimeout(Obj.bindFixed(function() // time out needed to fix this behavior in 3.6
                            {
                                doc.commandDispatcher[forward ? "advanceFocus" : "rewindFocus"]();
                                //remove the buttons from the tab order again, so that it will remain uncluttered
                                //Very ugly hack, but it works well. This prevents focus to 'spill out' of a
                                //toolbar when using the left and right arrow keys
                                if (!Dom.isAncestor(doc.commandDispatcher.focusedElement, toolbar))
                                {
                                    //we moved focus to somewhere out of the toolbar: not good. Move it back to where it was.
                                    doc.commandDispatcher[!forward ?
                                        "advanceFocus" : "rewindFocus"]();
                                }
                                Css.removeClass(toolbar, "hasTabOrder");
                            }, this));
                        }
                        Events.cancelEvent(event);
                        return;
                    }
                break;
 
                case KeyEvent.DOM_VK_RETURN:
                case KeyEvent.DOM_VK_SPACE:
                    if (isTab && target.tabMenu)
                    {
                        target.tabMenu.popup.showPopup(target.tabMenu, -1, -1, "popup",
                            "bottomleft", "topleft");
                    }
                    else if (isButton && isDropDownMenu)
                    {
                        if (target.id == "fbLocationList")
                            target.showPopup();
                        else
                            target.open = true;
                        Events.cancelEvent(event);
                        return false;
                    }
                break;

                case KeyEvent.DOM_VK_F4:
                    if (isTab && target.tabMenu)
                    {
                        target.tabMenu.popup.showPopup(target.tabMenu, -1, -1, "popup",
                            "bottomleft", "topleft");
                    }
                break;
            }
        }
    },

    handleTabBarFocus: function(event)
    {
        this.tabFocused = true;
    },

    handleTabBarBlur: function(event)
    {
        this.tabFocused = false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Panel Focus & Tab Order Management

    getPanelTabStop: function(panel)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (panelA11y)
            return panelA11y.tabStop;
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("a11y.getPanelTabStop null panel.context");
        return null;
    },

    ensurePanelTabStops: function()
    {
        // XXXjjb: seems like this should be !Firebug.chrome
        if (!Firebug.currentContext || !Firebug.currentContext.chrome)
            return;
        var panel = Firebug.chrome.getSelectedPanel();
        var sidePanel = Firebug.chrome.getSelectedSidePanel();
        this.ensurePanelTabStop(panel);
        if (sidePanel)
            this.ensurePanelTabStop(sidePanel);
    },

    ensurePanelTabStop: function(panel)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        if (panelA11y.manageFocus)
        {
            var tabStop = this.getPanelTabStop(panel);
            if (!tabStop || !this.isVisibleByStyle(tabStop) || !Xml.isVisible(tabStop))
            {
                this.tabStop = null;
                this.findPanelTabStop(panel, "focusRow", panelA11y.lastIsDefault);
            }
            else if (tabStop.getAttribute("tabindex") !== "0")
            {
                tabStop.setAttribute("tabindex", "0");
            }

            if (tabStop)
                this.checkModifiedState(panel, tabStop, true);
        }
    },

    checkModifiedState: function(panel, elem, makeTab)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !elem)
            return;

        if (panelA11y.type == "console" && Css.hasClass(elem, "focusRow"))
            this.modifyPanelRow(panel, elem, makeTab);
    },

    setPanelTabStop: function (panel, elem)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var tabStop = this.getPanelTabStop(panel);
        if (tabStop)
        {
            this.makeFocusable(tabStop, false);
            if (["treeitem", "listitem", "option"].indexOf(tabStop.getAttribute("role")) != -1)
                tabStop.setAttribute("aria-selected", "false");
        }
        panelA11y.tabStop = elem;
        if (elem)
        {
            panelA11y.reFocusId = null;
            this.makeFocusable(elem, true);
            if (["treeitem", "listitem", "option"].indexOf(elem.getAttribute("role")) != -1)
                elem.setAttribute("aria-selected", "true");
        }
    },

    findPanelTabStop: function(panel, className, last)
    {
        var candidates = panel.panelNode.getElementsByClassName(className);
        candidates= Array.filter(candidates, function(e, i, a){return this.isVisibleByStyle(e)
          && Xml.isVisible(e);}, this);
        if (candidates.length > 0)
        {
            var chosenRow = candidates[last ? candidates.length -1 : 0];
            this.modifyPanelRow(panel, chosenRow, true);
            this.setPanelTabStop(panel, chosenRow);
        }
        else
        {
            this.setPanelTabStop(panel, null);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Console Panel

    onLogRowCreated: function(panel, row)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        if (Css.hasClass(row, "logRow-dir"))
        {
            row.setAttribute("role", "listitem");
            Css.setClass(row, "outerFocusRow");
            var memberRows = row.getElementsByClassName("memberRow");
            if (memberRows.length > 0)
                this.onMemberRowsAdded(panel, memberRows);
        }
        else if (Css.hasClass(row, "logRow-group") || Css.hasClass(row, "logRow-profile"))
        {
            row.setAttribute("role", "presentation");
            var focusRow = row.getElementsByClassName("logGroupLabel").item(0);
            if (focusRow)
            {
                this.setPanelTabStop(panel, focusRow);
                focusRow.setAttribute("aria-expanded", Css.hasClass(row, "opened") + "");
                if (!Css.hasClass(row, "logRow-profile"))
                    this.insertHiddenText(panel, focusRow, "group label: ");
            }
        }
        else if (Css.hasClass(row, "logRow-errorMessage") || Css.hasClass(row,
            "logRow-warningMessage"))
        {
            Css.setClass(row, "outerFocusRow");
            row.setAttribute("role", "presentation");
            var focusRow = row.getElementsByClassName("errorTitle").item(0);
            if (focusRow)
            {
                this.setPanelTabStop(panel, focusRow);
                focusRow.setAttribute("aria-expanded",
                    Css.hasClass(focusRow.parentNode, "opened") + "");
            }
        }
        else if (Css.hasClass(row, "logRow-stackTrace"))
        {
            Css.setClass(row, "outerFocusRow");
            row.setAttribute("role", "listitem");
            var stackFrames = row.getElementsByClassName("focusRow");
            Array.forEach(stackFrames, function(e, i, a)
            {
                e.setAttribute("role", "listitem");
                if ((panelA11y.lastIsDefault && i === stackFrames.length - 1) ||
                    (!panelA11y.lastIsDefault && i === 0))
                {
                    this.setPanelTabStop(panel, e);
                }
                else
                {
                    this.makeFocusable(e, false);
                }
            }, this);
        }
        else if (Css.hasClass(row, "logRow-spy"))
        {
            var focusRow = Dom.getChildByClass(row, "spyHeadTable");
            if (focusRow)
                this.makeFocusable(focusRow, true);
        }
        else
        {
            row.setAttribute("role", "listitem");
            Css.setClass(row, "focusRow");
            Css.setClass(row, "outerFocusRow");
            if (Xml.isVisible(row))
                this.setPanelTabStop(panel, row);
        }
    },

    modifyLogRow: function(panel, row, inTabOrder)
    {
        this.makeFocusable(row, inTabOrder);
        var logRowType = this.getLogRowType(row);
        if (logRowType)
            this.insertHiddenText(panel, row, logRowType + ": ");
        var arrayNode = Dom.getChildByClass(row, "objectBox-array");
        if (arrayNode)
        {
            arrayNode.setAttribute("role", "group");
            this.insertHiddenText(panel, row, "array" + ": ");
        }
        var focusObjects = this.getFocusObjects(row);
        Array.forEach(focusObjects, function(e, i, a)
        {
            this.makeFocusable(e);
            var prepend = "";
            var append = " (" + this.getObjectType(e) + ") ";
            if (e.textContent != "")
                e.setAttribute("aria-label", prepend + e.textContent + append);
            if (arrayNode)
                e.setAttribute("role", "listitem");
        }, this);
    },

    onNavigablePanelKeyPress: function(event)
    {
        var target = event.target;
        var keyCode = event.keyCode || (event.type == "keypress" ? event.charCode : null);
        if (!this.isTabWorthy(target) && !this.isFocusNoTabObject(target))
            return;
        else if (event.shiftKey || event.altKey)
            return;
        else if ([13, 32, 33, 34, 35, 36, 37, 38, 39, 40, 46].indexOf(keyCode) == -1)
            return; //not interested in any other keys, than arrows, pg, home/end, del space & enter
        var panel = Firebug.getElementPanel(target);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var newTarget = target;
        if (!this.isOuterFocusRow(target))
        {
            if (Events.isControl(event))
            {
                newTarget = this.getAncestorRow(target);
                if (newTarget)
                {
                    newTarget = [33, 38].indexOf(keyCode) == -1 ?
                        this.getLastFocusChild(newTarget) : this.getFirstFocusChild(newTarget);
                }
            }
            else if (!this.isDirCell(target) || Css.hasClass(target, "netInfoTab") ||
                Css.hasClass(target, "netCol"))
            {
                newTarget = this.getAncestorRow(target, true);
            }

            if (!newTarget)
                newTarget = target;
        }
        switch (keyCode)
        {
            case KeyEvent.DOM_VK_UP:
            case KeyEvent.DOM_VK_DOWN:
                if (!this.isFocusNoTabObject(target))
                {
                    this.focusSiblingRow(panel, newTarget, keyCode == 38);
                    Events.cancelEvent(event);
                }
                break;

            case KeyEvent.DOM_VK_LEFT:
            case KeyEvent.DOM_VK_RIGHT:
                var goLeft = keyCode == KeyEvent.DOM_VK_LEFT;
                if (this.isDirCell(target))
                {
                    var row = Dom.getAncestorByClass(target, "memberRow");
                    var toggleElem = Dom.getChildByClass(row.cells[1], "memberLabel");
                    if (!goLeft && Css.hasClass(row, "hasChildren"))
                    {
                        if (Css.hasClass(row, "opened"))
                        {
                            this.focusSiblingRow(panel, target, false);
                        }
                        else if (toggleElem)
                        {
                            if (Css.hasClass(row, "hasChildren"))
                                target.setAttribute("aria-expanded", "true");
                            this.dispatchMouseEvent(toggleElem, "click");
                        }
                    }
                    else if (goLeft)
                    {
                        var level = parseInt(row.getAttribute("level"));
                        if (Css.hasClass(row, "opened"))
                        {
                            if (Css.hasClass(row, "hasChildren"))
                                target.setAttribute("aria-expanded", "false");
                            this.dispatchMouseEvent(toggleElem, "click");
                        }
                        else if (level > 0)
                        {
                            var targetLevel = (level - 1) + "";
                            var newRows = Array.filter(row.parentNode.rows, function(e, i, a)
                            {
                                return e.rowIndex < row.rowIndex &&
                                    e.getAttribute("level") == targetLevel;
                            }, this);

                            if (newRows.length)
                                this.focus(newRows[newRows.length -1].cells[2].firstChild);
                        }
                    }
                    Events.cancelEvent(event);
                }
                else if (this.isOuterFocusRow(target, true))
                {
                    if (target.hasAttribute("aria-expanded"))
                    {
                        if (target.getAttribute("role") == "row" ||
                            Css.hasClass(target, "spyHeadTable"))
                        {
                            if (goLeft && target.getAttribute("aria-expanded") == "true")
                            {
                                var toggleElem = Css.hasClass(target, "spyHeadTable") ?
                                    target.getElementsByClassName("spyTitleCol").item(0) : target;
                                if (toggleElem)
                                    this.dispatchMouseEvent(toggleElem, "click");
                            }
                        }
                        else if (target.getAttribute("aria-expanded") == (goLeft ?
                            "true" : "false"))
                        {
                            this.dispatchMouseEvent(target, Css.hasClass(target, "logGroupLabel") ?
                                "mousedown" : "click");
                        }
                    }
                    if (goLeft)
                    {
                        //check if we"re in an expanded section
                        var inExpanded = false, groupClass, groupLabelClass, group, groupLabel;
                        if (Css.hasClass(target, "objectBox-stackFrame"))
                        {
                            inExpanded = true;
                            groupClass = "errorTrace";
                            groupLabelClass = "errorTitle";
                        }
                        else if (Dom.getAncestorByClass(target, "logGroupBody"))
                        {
                            inExpanded = true;
                            groupClass = "logGroupBody";
                            groupLabelClass = "logGroupLabel";
                        }
                        if (inExpanded)
                        {
                            group = Dom.getAncestorByClass(target, groupClass);
                            if (group)
                            {
                                groupLabel = this.getPreviousByClass(target, groupLabelClass,
                                    false, panel.panelNode);
                                if (groupLabel)
                                {
                                    this.modifyPanelRow(panel, groupLabel);
                                    this.focus(groupLabel);
                                }
                            }
                        }
                    }
                    else if (!goLeft)
                    {
    
                        var focusItems = this.getFocusObjects(target);
                        if (focusItems.length > 0)
                        {
                            this.focus(Events.isControl(event) ?
                                focusItems[focusItems.length -1] : focusItems[0]);
                        }
                    }
                }
                else if (this.isFocusObject(target))
                {
                    var parentRow = this.getAncestorRow(target, true);
                    var focusObjects = this.getFocusObjects(parentRow);
                    if (!Events.isControl(event))
                    {
                        var focusIndex = Array.indexOf(focusObjects, target);
                        var newIndex = goLeft ? --focusIndex : ++focusIndex;
                        this.focus(goLeft && newIndex < 0 ? parentRow : focusObjects[newIndex]);
                    }
                    else
                    {
                        this.focus(goLeft ? parentRow : focusObjects[focusObjects.length -1]);
                    }
                    Events.cancelEvent(event);
                }
                break;

            case KeyEvent.DOM_VK_END:
            case KeyEvent.DOM_VK_HOME:
                this.focusEdgeRow(panel, newTarget, keyCode == KeyEvent.DOM_VK_HOME);
                Events.cancelEvent(event);
                break;

            case KeyEvent.DOM_VK_PAGE_UP:
            case KeyEvent.DOM_VK_PAGE_DOWN:
                this.focusPageSiblingRow(panel, newTarget, keyCode == KeyEvent.DOM_VK_PAGE_UP);
                Events.cancelEvent(event);
                break;

            case KeyEvent.DOM_VK_RETURN:
                if (this.isFocusObject(target))
                {
                    this.dispatchMouseEvent(target, "click");
                }
                else if (Css.hasClass(target, "watchEditBox"))
                {
                    this.dispatchMouseEvent(target, "mousedown");
                    Events.cancelEvent(event);
                }
                else if (Css.hasClass(target, "breakpointRow"))
                {
                    var sourceLink =
                        target.getElementsByClassName("objectLink-sourceLink").item(0);
                    if (sourceLink)
                        this.dispatchMouseEvent(sourceLink, "click");
                }
                else if (target.hasAttribute("aria-expanded") &&
                    (target.getAttribute("role") == "row" ||
                    target.getAttribute("role") == "listitem"))
                {
                    var toggleElem = Css.hasClass(target, "spyHeadTable") ?
                        target.getElementsByClassName("spyTitleCol").item(0) : target;
                    if (toggleElem)
                        this.dispatchMouseEvent(toggleElem, "click");
                }
                break;

            case KeyEvent.DOM_VK_SPACE:
                if (this.isFocusObject(target) && target.hasAttribute("role", "checkbox"))
                {
                    this.dispatchMouseEvent(target, "click");
                    var objectBox = Dom.getAncestorByClass(target, "hasBreakSwitch");
                    if (objectBox)
                    {
                        target.setAttribute("aria-checked",
                            Css.hasClass(objectBox, "breakForError") + "");
                    }
                }
                else if (Css.hasClass(target, "breakpointRow"))
                {
                    var checkbox = target.getElementsByClassName("breakpointCheckbox").item(0);
                    if (checkbox)
                    {
                        target.setAttribute("aria-checked", checkbox.checked ? "false" : "true");
                        this.dispatchMouseEvent(checkbox, "click");
                    }
                }
                break;

            case KeyEvent.DOM_VK_DELETE:
                if (Css.hasClass(target, "breakpointRow"))
                {
                    var closeBtn = target.getElementsByClassName("closeButton").item(0);
                    if (closeBtn)
                    {
                        var prevBreakpoint = Dom.getPreviousByClass(target, "breakpointRow");
                        if (prevBreakpoint)
                            this.makeFocusable(prevBreakpoint, true);
                        Firebug.chrome.window.document.commandDispatcher.rewindFocus();
                        this.dispatchMouseEvent(closeBtn, "click");
                    }
                }
                break;
        }
    },

    focusPanelRow: function(panel, row)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !row)
            return;
        this.modifyPanelRow(panel, row, false);

        //allows up / down navigation in columns, if columns are used in this panel
        if (panelA11y.cellIndex !== undefined && row.cells && row.cells[panelA11y.cellIndex])
        {
            var cell = row.cells[panelA11y.cellIndex];
            if (!Css.hasClass(cell, "a11yFocus"))
                cell = Dom.getChildByClass(cell, "a11yFocus");
            this.focus(cell);
        }
        // for Net Panel. Focus selected tab rather than the tab list
        else if (Css.hasClass(row, "netInfoTabs"))
        {
            var tabs = row.getElementsByClassName("netInfoTab");
            tabs = Array.filter(tabs, function(e, i, a)
            {
                return e.hasAttribute("selected");
            });
            this.focus(tabs.length > 0 ? tabs[0] : row);
        }
        else
        {
            this.focus(row);
        }
    },

    getRowIndex: function(rows, target)
    {
        return Array.indexOf(rows, target);
    },

    getAncestorRow: function(elem, useSubRow)
    {
        return Dom.getAncestorByClass(elem, useSubRow ? "focusRow" : "outerFocusRow");
    },

    onConsoleMouseDown: function(event)
    {
        var node = Dom.getAncestorByClass(event.target, "focusRow");
        if (node)
        {
            this.modifyPanelRow(Firebug.getElementPanel(node), node, false);
        }
        else
        {
            node = Dom.getAncestorByClass(event.target, "memberRow");
            if (!node)
                return;
            var focusRow = node.getElementsByClassName("focusRow").item(0);
            if (!focusRow)
                return;

            this.focusPanelRow(Firebug.getElementPanel(focusRow), focusRow);
            node = Dom.getAncestorByClass(event.target, "memberLabel");
            if (!(node && Css.hasClass(node, "hasChildren")))
                Events.cancelEvent(event);
        }
    },

    getValidRow: function(rows, index)
    {
        var min = 0; var max = rows.length -1;
        if (index < min || index > max)
            index = index < min ? 0 : max;
        return rows[index];
    },

    getFocusObjects: function(container)
    {
        var nodes = container.getElementsByClassName("a11yFocus");
        return Array.filter(nodes, this.isVisibleByStyle, this);
    },

    modifyConsoleRow: function(panel, row, inTabOrder)
    {
        if (this.isDirCell(row))
        {
            this.modifyMemberRow(panel, row, inTabOrder);
        }
        else if (this.isProfileRow(row))
        {
            this.modifyProfileRow(panel, row, inTabOrder);
        }
        else if (this.isOuterFocusRow(row, true))
        {
            if (Css.hasClass(row, "spyHeadTable") || Css.hasClass(row, "netInfoTabs"))
                this.modifyNetRow(panel, row, row.getAttribute("tabindex") === "0");
            else
                this.modifyLogRow(panel, row, row.getAttribute("tabindex") === "0");
        }
        else return;
    },

    modifyProfileRow: function(panel, row, inTabOrder)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !row)
            return;

        this.makeFocusable(row, inTabOrder);
        var focusObjects = this.getFocusObjects(row);
        Array.forEach(focusObjects, function(e, i, a)
        {
            this.makeFocusable(e);
            if (Css.hasClass(e.parentNode, "profileCell"))
                e.setAttribute("role", "gridcell");
        }, this);
    },

    onConsoleSearchMatchFound: function(panel, text, matches)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var matchFeedback = "";
        if (!matches || matches.length == 0)
        {
            matchFeedback = Locale.$STRF("a11y.updates.no matches found", [text]);
        }
        else
        {
            matchFeedback = Locale.$STRF("a11y.updates.match found in logrows",
                [text, matches.length]);
        }
        this.updateLiveElem(panel, matchFeedback, true); //should not use alert
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // HTML Panel

    onHTMLKeyPress: function(event)
    {
        var target = event.target;
        var keyCode = event.keyCode || (event.type == "keypress" ? event.charCode : null);
        if ([KeyEvent.DOM_VK_RETURN, KeyEvent.DOM_VK_SPACE,
             KeyEvent.DOM_VK_F2].indexOf(keyCode) == -1)
        {
            return;
        }
        if (!Css.hasClass(target, "nodeLabelBox"))
            return;

        var panel = Firebug.getElementPanel(target);
        switch (keyCode)
        {
            case KeyEvent.DOM_VK_RETURN:
            case KeyEvent.DOM_VK_SPACE:
                var isEnter = (keyCode == KeyEvent.DOM_VK_RETURN);
                var nodeLabels = [];
                if (isEnter)
                {
                    nodeLabels = target.getElementsByClassName("nodeName");
                    if (nodeLabels.length > 0)
                    {
                        Firebug.Editor.startEditing(nodeLabels[0]);
                        Events.cancelEvent(event);
                    }
                }
                if (!isEnter || nodeLabels.length == 0)
                {
                    var nodeBox = Dom.getAncestorByClass(target, "nodeBox");
                    if (nodeBox.repObject && panel.editNewAttribute)
                    {
                        panel.editNewAttribute(nodeBox.repObject);
                        Events.cancelEvent(event);
                    }
                }
                break;

            case KeyEvent.DOM_VK_F2:
                if (Css.hasClass(target.parentNode.parentNode, "textNodeBox"))
                {
                    var textNode = Dom.getChildByClass(target, "nodeText");
                    if (textNode)
                        Firebug.Editor.startEditing(textNode);
                }
                break;
        }
    },

    onHTMLFocus: function(event)
    {
        if (Css.hasClass(event.target, "nodeLabelBox"))
        {
            this.dispatchMouseEvent(event.target, "mouseover");
            var nodeLabel = Dom.getAncestorByClass(event.target, "nodeLabel");
            if (nodeLabel)
                Css.setClass(nodeLabel, "focused");
            event.target.setAttribute("aria-selected", "true");
            Events.cancelEvent(event);
        }
    },

    onHTMLBlur: function(event)
    {
        if (Css.hasClass(event.target, "nodeLabelBox"))
        {
            this.dispatchMouseEvent(event.target, "mouseout");
            var nodeLabel = Dom.getAncestorByClass(event.target, "nodeLabel");
            if (nodeLabel)
                Css.removeClass(nodeLabel, "focused");
            event.target.setAttribute("aria-selected", "false");
            Events.cancelEvent(event);
        }
    },

    onObjectBoxSelected: function(objectBox, forceFocus)
    {
        var panel = Firebug.getElementPanel(objectBox);

        // See issue 5934
        if (panel.editing)
            return;

        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;
        var label = objectBox.firstChild.getElementsByClassName("nodeLabelBox").item(0);
        if (label)
        {
            this.makeFocusable(label, true);
            if (this.panelHasFocus(panel) || forceFocus)
                this.focus(label);
        }
    },

    onObjectBoxUnselected: function(objectBox)
    {
        if (!this.isEnabled() || !objectBox)
            return;
        var label = objectBox.firstChild.getElementsByClassName("nodeLabelBox").item(0);
        if (label)
            this.makeUnfocusable(label, true);
    },

    onHTMLSearchMatchFound: function(panel, match)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var node = match.node;
        var elem;
        var matchFeedback = "";
        switch (node.nodeType)
        {
            case Node.ELEMENT_NODE:
                elem = node;
                matchFeedback += Locale.$STRF("a11y.updates.match found in element",
                    [match.match[0], elem.nodeName, Xpath.getElementTreeXPath(elem)]);
                break;

            case Node.ATTRIBUTE_NODE:
                elem = node.ownerElement;
                matchFeedback += Locale.$STRF("a11y.updates.match found in attribute",
                    [match.match[0], node.name, node.value, elem.nodeName,
                        Xpath.getElementTreeXPath(elem)]);
                break;

            case Node.TEXT_NODE:
                elem = node.parentNode;
                matchFeedback += Locale.$STRF("a11y.updates.match found in text content",
                    [match.match[0], match.match.input]);
                break;
        }
        this.updateLiveElem(panel, matchFeedback, true); //should not use alert
    },

    onHTMLSearchNoMatchFound: function(panel, text)
    {
        this.updateLiveElem(panel, Locale.$STRF("a11y.updates.no matches found", [text]), true);
    },

    moveToSearchMatch: function()
    {
        if (!this.isEnabled())
            return;
        var panel = Firebug.chrome.getSelectedPanel();
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !panel.searchable)
            return;

        var popup = Firebug.chrome.$("fbSearchOptionsPopup");
        if (popup)
            popup.hidePopup();
        var type = panel.searchType ? panel.searchType : panelA11y.type;
        switch (type)
        {
            case "html":
                var match = panel.lastSearch.lastMatch;
                if (!match)
                    return;
                var nodeBox = panel.lastSearch.openToNode(match.node, match.isValue);
                if (!nodeBox)
                    return;

                nodeBox = Dom.getAncestorByClass(nodeBox, "nodeBox");
                //select call will not trigger focus because focus is outside the HTML panel (i.e. the search field),
                panel.select(nodeBox.repObject, true);
                // Manually force selected node to be focused
                this.onObjectBoxSelected(nodeBox, true);
                break;

            case "css":
                if (panel.currentSearch && panel.currentSearch.currentNode)
                {
                    var focusRow = Dom.getAncestorByClass(panel.currentSearch.currentNode,
                        "focusRow");
                    if (focusRow)
                        this.focusPanelRow(panel, focusRow);
                }
                break;

            case "script":
                if (panel.currentSearch && panel.selectedSourceBox)
                {
                    var box = panel.selectedSourceBox;
                    var lineNo = panel.currentSearch.mark;
                    box.a11yCaretLine = lineNo + 1;
                    box.a11yCaretOffset = 0;
                    panel.scrollToLine(box.repObject.href, lineNo,
                        panel.jumpHighlightFactory(lineNo+1, panel.context));
                    var viewport = box.getElementsByClassName("sourceViewport").item(0);
                    if (viewport)
                    {
                        this.focus(viewport);
                        this.insertCaretIntoLine(panel, box);
                    }
                }
                break;

            case "dom":
                if (panel.currentSearch && panel.currentSearch.currentNode)
                {
                    var focusRow =
                      panel.currentSearch.currentNode.getElementsByClassName("focusRow").item(0);
                    if (focusRow)
                        this.focusPanelRow(panel, focusRow);
                }
                break;

            case "net":
                if (panel.currentSearch && panel.currentSearch.currentNode)
                {
                    var focusRow = Dom.getAncestorByClass(panel.currentSearch.currentNode,
                        "focusRow");
                    if (focusRow)
                        this.focusPanelRow(panel, focusRow);
                }
                break;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // CSS Panel

    onCSSKeyPress: function(event)
    {
        var target = event.target;
        var keyCode = event.keyCode || (event.type == "keypress" ? event.charCode : null);
        if (!this.isFocusRow(target) || event.altKey)
            return;

        if ([KeyEvent.DOM_VK_RETURN, KeyEvent.DOM_VK_SPACE, KeyEvent.DOM_VK_PAGE_UP,
            KeyEvent.DOM_VK_PAGE_DOWN, KeyEvent.DOM_VK_END, KeyEvent.DOM_VK_HOME,
            KeyEvent.DOM_VK_UP, KeyEvent.DOM_VK_DOWN].indexOf(keyCode) == -1)
        {
            return; //not interested in any other keys than arrows, pg, home/end, space & enter
        }
        var panel = Firebug.getElementPanel(target);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        switch (keyCode)
        {
            case KeyEvent.DOM_VK_UP:
            case KeyEvent.DOM_VK_DOWN:
                var goUp = keyCode == 38;
                if (Events.isControl(event))
                {
                    if (event.shiftKey)
                    {
                        var node = this[goUp ? "getPreviousByClass" : "getNextByClass"](target,
                            "cssInheritHeader", panel.panelNode);
                        if (node)
                            this.focusPanelRow(panel, node);
                        else if (goUp)
                           this.focusEdgeCSSRow(panel, target, true);
                    }
                    else
                        this.focusSiblingHeadRow(panel, target, goUp);
                }
                else
                    this.focusSiblingCSSRow(panel, target, goUp);
                break;

            case KeyEvent.DOM_VK_END:
            case KeyEvent.DOM_VK_HOME:
                if (Events.isControl(event))
                    this.focusEdgeHeadRow(panel, target, keyCode == 36);
                else
                    this.focusEdgeCSSRow(panel, target, keyCode == 36);
                break;

            case KeyEvent.DOM_VK_PAGE_UP:
            case KeyEvent.DOM_VK_PAGE_DOWN:
                if (Events.isControl(event))
                    this.focusPageSiblingHeadRow(panel, target, keyCode == 33);
                else
                    this.focusPageSiblingCSSRow(panel, target, keyCode == 33);
                break;

            case KeyEvent.DOM_VK_RETURN:
                if (Css.hasClass(target, "cssProp"))
                {
                    var node = Dom.getChildByClass(target, "cssPropName");
                    if (node)
                        Firebug.Editor.startEditing(node);
                    Events.cancelEvent(event);
                }
                else if (Css.hasClass(target, "cssHead"))
                {
                    var node = Dom.getChildByClass(target, "cssSelector");
                    if (node && Css.hasClass(node, "editable"))
                        Firebug.Editor.startEditing(node);
                    Events.cancelEvent(event);
                }
                else if (Css.hasClass(target, "importRule"))
                {
                    var node = Dom.getChildByClass(target, "objectLink");
                    if (node)
                        this.dispatchMouseEvent(node, "click");
                }
                break;

            case KeyEvent.DOM_VK_SPACE:
                if (Css.hasClass(target, "cssProp"))
                {
                    //our focus is about to be wiped out, we'll try to get it back after
                    panelA11y.reFocusId = Xpath.getElementXPath(target);
                    panel.disablePropertyRow(target);
                    if (panel.name == "stylesheet")
                    {
                        target.setAttribute("aria-checked",
                            !Css.hasClass(target, "disabledStyle"));
                    }
                    Events.cancelEvent(event);
                }
                break;
        }
        if (!event.shiftKey)
            event.preventDefault();
    },

    onCSSMouseDown: function(event)
    {
        var row = Dom.getAncestorByClass(event.target, "focusRow");
        if (row)
            this.modifyPanelRow(Firebug.getElementPanel(row), row, false);
    },

    focusSiblingCSSRow: function(panel, target, goUp)
    {
        var newRow = this[goUp ? "getPreviousByClass" : "getNextByClass"](target, "focusRow",
            panel.panelNode);
        if (!newRow)
            return;
        this.focusPanelRow(panel, newRow, false);
    },

    focusPageSiblingCSSRow: function(panel, target, goUp)
    {
        var rows = this.getFocusRows(panel);
        var index = this.getRowIndex(rows, target);
        var newRow = this.getValidRow(rows, goUp ? index - 10 : index + 10);
        this.focusPanelRow(panel, newRow, false);
    },

    focusEdgeCSSRow: function(panel, target, goUp)
    {
        var rows = this.getFocusRows(panel);
        var newRow = this.getValidRow(rows, goUp ? 0 : rows.length -1);
        this.focusPanelRow(panel, newRow, false);
    },

    getHeadRowsAndIndex: function(panel, elem)
    {
        var rows = this.getFocusRows(panel);
        var headRow = Css.hasClass(elem, "cssHead") ?
            elem : Dom.getPreviousByClass(elem, "cssHead");
        var headRows = Array.filter(rows, function(e, i, a) {
            return Css.hasClass(e, "cssHead");
        });
        var index = Array.indexOf(headRows, headRow);
        if (index == -1)
            index = 0;
        return [headRows, index];
    },

    focusSiblingHeadRow: function(panel, elem, goUp)
    {
        var rowInfo = this.getHeadRowsAndIndex(panel, elem);
        var newRow = this.getValidRow(rowInfo[0], goUp ? rowInfo[1] - 1 : rowInfo[1] + 1);
        this.focusPanelRow(panel, newRow, false);
    },

    focusPageSiblingHeadRow: function(panel, elem, goUp)
    {
        var rowInfo = this.getHeadRowsAndIndex(panel, elem);
        var newRow = this.getValidRow(rowInfo[0], goUp ? rowInfo[1] - 10 : rowInfo[1] + 10);
        this.focusPanelRow(panel, newRow, false);
    },

    focusEdgeHeadRow: function(panel, elem, goUp)
    {
        var rowInfo = this.getHeadRowsAndIndex(panel, elem);
        var newRow = this.getValidRow(rowInfo[0], goUp ? 0 : rowInfo[0].length - 1);
        this.focusPanelRow(panel, newRow, false);
    },

    onBeforeCSSRulesAdded: function(panel)
    {
        // Panel content is about to be recreated, possibly wiping out focus.
        // Use the focused element's xpath to remember which rule had focus,
        // so that it can be refocused when the panel content is drawn again
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !this.panelHasFocus(panel))
            return;
        if (panelA11y.tabStop && Css.hasClass(panelA11y.tabStop, "focusRow"))
            panelA11y.reFocusId = Xpath.getElementXPath(panelA11y.tabStop);
    },

    onCSSRulesAdded: function(panel, rootNode)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;
        var row;
        if (panelA11y.reFocusId)
        {   //we need to put focus back to where it was before it was wiped out
            var reFocusRows = Xpath.getElementsByXPath(rootNode.ownerDocument,
                panelA11y.reFocusId);
            panelA11y.reFocusId = null;
            if (reFocusRows.length > 0)
            {
                row = reFocusRows[0];
                this.modifyPanelRow(panel, row, true);
                this.focus(row, true);
                this.setPanelTabStop(panel, row);
                return;
            }
        }
        //no refocus needed, just make first rule the panel's tab stop
        row = rootNode.getElementsByClassName("focusRow").item(0);
        this.modifyPanelRow(panel, row, true);
        return;
    },
    //applies a11y changes (keyboard and screen reader related) to an individual row
    //To improve performance, this only happens when absolutely necessary, e.g. when the user navigates to the row in question

    modifyCSSRow: function(panel, row, inTabOrder)
    {
        if (!panel || !row)
            return;
        var rule = Dom.getAncestorByClass(row, "cssRule");
        if (inTabOrder)
            this.setPanelTabStop(panel, row);
        else
            this.makeFocusable(row);
        if (rule && !Css.hasClass(rule, "a11yModified"))
        {
            var listBox = rule.getElementsByClassName("cssPropertyListBox").item(0);
            var selector = rule.getElementsByClassName("cssSelector").item(0);
            if (listBox && selector)
            {
                listBox.setAttribute("aria-label",
                    Locale.$STRF("a11y.labels.declarations for selector", [selector.textContent]));
            }
            Css.setClass(rule, "a11yModified");
        }
        if (Css.hasClass(row, "cssHead"))
        {
            if (panel.name == "css")
            {
                var sourceLink = rule.parentNode.lastChild;
                if (sourceLink && Css.hasClass(sourceLink, "objectLink"))
                {
                    row.setAttribute("aria-label", row.textContent + " " +
                        Locale.$STRF("a11y.labels.defined in file", [sourceLink.textContent]));
                }
            }
        }
        else if (Css.hasClass(row, "cssProp"))
        {
            row.setAttribute("aria-checked", !Css.hasClass(row, "disabledStyle"));
            if (Css.hasClass(row, "cssOverridden"))
            {
                row.setAttribute("aria-label", Locale.$STR("aria.labels.overridden") + " " +
                    row.textContent);
            }
        }
        return;
    },

    onCSSPanelContextMenu: function(event)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        if (event.button == 0) //the event was created by keyboard, not right mouse click
        {
            var panel = Firebug.getElementPanel(event.target);
            if (panel && Css.hasClass(event.target, "focusRow"))
            {
                var node = event.target;
                if (panel.name == "css")
                {
                    if (Css.hasClass(event.target, "cssHead"))
                    {
                        node = event.target.parentNode.getElementsByClassName("objectLink")
                            .item(0);
                    }
                    else if (Css.hasClass(event.target, "cssInheritHeader"))
                    {
                        node = event.target.getElementsByClassName("objectLink").item(0);
                    }

                    if (!node || Css.hasClass(node, "collapsed"))
                    {
                        node = event.target;
                    }
                }
                //these context menu options are likely to destroy current focus
                panelA11y.reFocusId = Xpath.getElementXPath(event.target);
                document.popupNode = node;
                Firebug.chrome.$("fbContextMenu").openPopup(node, "overlap", 0,0,true);
                Events.cancelEvent(event); //no need for default handlers anymore
            }
        }
    },

    onCSSSearchMatchFound: function(panel, text, matchRow)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !text)
            return;

        if (!matchRow)
        {
            this.updateLiveElem(panel,
                Locale.$STRF("a11y.updates.no matches found", [text]), true); //should not use alert
            return;
        }
        var matchFeedback = "";
        var selector;
        if (Css.hasClass(matchRow, "cssSelector"))
        {
            matchFeedback = " " + Locale.$STRF("a11y.updates.match found in selector",
                [text, matchRow.textContent]);
        }
        else
        {
            selector = Dom.getPreviousByClass(matchRow, "cssSelector");
            selector = selector ? selector.textContent : "";
            if (Css.hasClass(matchRow, "cssPropName") || Css.hasClass(matchRow, "cssPropValue"))
            {
                var propRow = Dom.getAncestorByClass(matchRow, "cssProp");
                if (propRow)
                {
                    matchFeedback = Locale.$STRF("a11y.updates.match found in style declaration",
                        [text, propRow.textContent, selector]);
                }
            }
        }
        this.updateLiveElem(panel, matchFeedback, true); // should not use alert
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Layout Panel

    onLayoutBoxCreated: function(panel, node, detailsObj)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var focusGroups = node.getElementsByClassName("focusGroup");
        Array.forEach(focusGroups, function(e, i, a) {
            this.makeFocusable(e, Css.hasClass(e, "positionLayoutBox"));
            e.setAttribute("role", "group");
            e.setAttribute("aria-label", this.getLayoutBoxLabel(e, detailsObj));
            e.setAttribute("aria-setsize", a.length);
            e.setAttribute("aria-posinset", i + 1);
        }, this);
    },

    getLayoutBoxLabel: function(elem, detailsObj)
    {
        var className = elem.className.match(/\b(\w+)LayoutBox\b/);
        if (!className)
            return "";

        var styleName = className[1];
        var output = "";
        switch (styleName)
        {
            case "position":
                output += Css.hasClass(elem, "blankEdge") ?
                    "" : Locale.$STR("a11y.layout.position");
                styleName = "outer";
                break;

            case "margin":
                output += Locale.$STR("a11y.layout.margin");
                break;

            case "border":
                output += Locale.$STR("a11y.layout.border");
                break;

            case "padding":
                output += Locale.$STR("a11y.layout.padding");
                break;

            case "content":
                output += Locale.$STR("a11y.layout.size");
                break;
        }
        output += ": ";
        var valNames = [];
        var vals = {};
        switch (styleName)
        {
            case "outer":
                valNames = ["top", "left", "position", "z-index"];
                vals.top = detailsObj[styleName + "Top"];
                vals.left = detailsObj[styleName + "Left"];
                vals.position = detailsObj.position;
                vals["z-index"] = detailsObj.zIndex;
                break;

            case "content":
                valNames = ["width", "height"];
                vals.width = detailsObj["width"];
                vals.height = detailsObj["height"];
                break;

            default:
                valNames = ["top", "right", "bottom", "left"];
                vals.top = detailsObj[styleName + "Top"];
                vals.right = detailsObj[styleName + "Right"];
                vals.bottom = detailsObj[styleName + "Bottom"];
                vals.left = detailsObj[styleName + "Left"];
                break;
        }

        for (var i = 0; i < valNames.length; i++)
        {
            output += Locale.$STR("a11y.layout." + valNames[i]) + " = " + vals[valNames[i]];
            output += i == valNames.length -1 ? "" : ", ";
        }
        return output;
    },

    onLayoutKeyPress: function(event)
    {
        var target = event.target;
        var keyCode = event.keyCode || (event.type == "keypress" ? event.charCode : null);
        if ([KeyEvent.DOM_VK_RETURN, KeyEvent.DOM_VK_LEFT, KeyEvent.DOM_VK_UP,
            KeyEvent.DOM_VK_RIGHT, KeyEvent.DOM_VK_DOWN].indexOf(keyCode) == -1)
        {
            return;
        }
        if (!Css.hasClass(target, "focusGroup"))
            return;

        switch (keyCode)
        {
            case KeyEvent.DOM_VK_LEFT:
            case KeyEvent.DOM_VK_UP:
            case KeyEvent.DOM_VK_RIGHT:
            case KeyEvent.DOM_VK_DOWN:
                var node, goLeft = (keyCode == KeyEvent.DOM_VK_LEFT ||
                    keyCode == KeyEvent.DOM_VK_UP);
                if (goLeft)
                    node = Dom.getAncestorByClass(target.parentNode, "focusGroup");
                else
                    node = Dom.getChildByClass(target, "focusGroup");

                if (node)
                    this.focus(node);
                break;

            case KeyEvent.DOM_VK_RETURN:
                var editable = target.getElementsByClassName("editable").item(0);
                if (editable)
                    Firebug.Editor.startEditing(editable);
                Events.cancelEvent(event);
                break;
        }
    },

    onLayoutFocus: function(event)
    {
        if (Css.hasClass(event.target, "focusGroup"))
        {
            this.dispatchMouseEvent(event.target, "mouseover");
            this.setPanelTabStop(Firebug.getElementPanel(event.target), event.target);
        }
    },

    onLayoutBlur: function(event)
    {
        if (Css.hasClass(event.target, "focusGroup"))
            this.dispatchMouseEvent(event.target, "mouseout");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Inline Editing
    onInlineEditorShow: function(panel, editor)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        //recreate the input element rather than reusing the old one, otherwise AT won't pick it up
        editor.input.onkeypress = editor.input.oninput = editor.input.onoverflow = null;
        editor.inputTag.replace({}, editor.box.childNodes[1].firstChild, editor);
        editor.input = editor.box.childNodes[1].firstChild.firstChild;
    },

    onBeginEditing: function(panel, editor, target, value)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        switch (panelA11y.type)
        {
            case "html":
                var nodeName = null;
                var setSize = posInSet = 0; var setElems;
                var label = Locale.$STR("a11y.labels.inline editor") + ": ";
                if (Css.hasClass(target, "nodeName") || Css.hasClass(target, "nodeValue"))
                {
                    var isName = Css.hasClass(target, "nodeName");
                    setElems = target.parentNode.parentNode
                        .getElementsByClassName(isName ? "nodeName" : "nodeValue");
                    setSize = (setElems.length * 2);
                    posInSet = ((Array.indexOf(setElems, target) + 1) * 2) - (isName ? 1 : 0);
                    editor.input.setAttribute("role", "listitem");
                    editor.input.setAttribute("aria-setsize", setSize);
                    editor.input.setAttribute("aria-posinset", posInSet);
                    nodeTag = Dom.getPreviousByClass(target, "nodeTag");
                    if (!isName)
                    {
                        nodeName = Dom.getPreviousByClass(target, "nodeName");
                        label += Locale.$STRF("a11y.labels.value for attribute in element",
                            [nodeName.textContent, nodeTag.textContent]);
                    }
                    else
                    {
                        label += Locale.$STRF("a11y.label.attribute for element",
                            [nodeTag.textContent]);
                    }
                }
                else if (Css.hasClass(target, "nodeText"))
                {
                    nodeTag = Dom.getPreviousByClass(target, "nodeTag");
                    label += Locale.$STRF("a11y.labels.text contents for element",
                        [nodeTag.textContent]);
                }
                editor.input.setAttribute("aria-label", label);
                break;

            case "css":
            case "stylesheet":
                var selector = Dom.getPreviousByClass(target, "cssSelector");
                selector = selector ? selector.textContent : "";
                var label = Locale.$STR("a11y.labels.inline editor") + ": ";
                if (Css.hasClass(target, "cssPropName"))
                {
                    label += Locale.$STRF("a11y.labels.property for selector", [selector]);
                }
                else if (Css.hasClass(target, "cssPropValue"))
                {
                    var propName = Dom.getPreviousByClass(target, "cssPropName");
                    propName = propName ? propName.textContent : "";
                    label += Locale.$STRF("a11y.labels.value property in selector",
                        [propName, selector]);
                }
                else if (Css.hasClass(target, "cssSelector"))
                {
                    label += Locale.$STR("a11y.labels.css selector");
                }

                editor.input.setAttribute("aria-label", label);
                editor.setAttribute("aria-autocomplete", "inline");
                break;

            case "layout":
                editor.input.setAttribute("aria-label", target.getAttribute("aria-label"));
                break;

            case "dom":
            case "domSide":
                if (target.cells && target.cells[1])
                    editor.input.setAttribute("aria-label", target.cells[1].textContent);
                break;
        }
    },

    onInlineEditorClose: function(panel, target, removeGroup)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        switch (panelA11y.type)
        {
            case "layout":
                var box = Dom.getAncestorByClass(target, "focusGroup");
                if (box)
                    this.focus(box, true);
                break;

            case "css":
            case "stylesheet":
                var node = target.parentNode;
                if (removeGroup)
                    node = this.getPreviousByClass(node, "focusRow", panel.panelNode);
                if (node)
                    this.focusPanelRow(panel, node, true);
                break;

            case "html":
                var box = Dom.getAncestorByClass(target, "nodeBox");
                if (box)
                    panel.select(box.repObject, true);
                break;

            case "watches":
                var node = target.getElementsByClassName("watchEditBox").item(0);
                if (node)
                    this.focus(node, true);
                break;

            case "script":
                panel.selectedSourceBox.focus();
                break;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Script Panel

    onStartDebugging: function(context)
    {
        if (!context)
            return;

        var panel = context.getPanel("script");
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var frame = context.stoppedFrame;
        var fileName =  frame.script.fileName.split("/");  // XXXjjb I think this should be contxt.executingSourceFile.href
        fileName = fileName.pop();
        // XXXjjb the frame.functionName is often anonymous, since the compiler is lame.
        var alertString = Locale.$STRF("a11y.updates.script_suspended_on_line_in_file",
            [frame.line, frame.functionName, fileName]);
        this.updateLiveElem(panel, alertString, true);
        this.onShowSourceLink(panel, frame.line);
    },

    onShowSourceLink: function (panel, lineNo)
    {
        if (!this.isEnabled())
            return;

        var box = panel.selectedSourceBox;
        var viewport = box.getElementsByClassName("sourceViewport").item(0);
        box.a11yCaretLine = lineNo;
        if (viewport && this.panelHasFocus(panel))
        {
            this.focus(viewport);
            this.insertCaretIntoLine(panel, box, lineNo);
        }
    },

    onScriptKeyPress: function(event)
    {
        var target = event.target;
        var keyCode = event.keyCode || (event.type == "keypress" ? event.charCode : null);
        if (!Css.hasClass(target, "sourceViewport"))
            return;

        if ([KeyEvent.DOM_VK_RETURN, KeyEvent.DOM_VK_PAGE_UP, KeyEvent.DOM_VK_PAGE_DOWN,
            KeyEvent.DOM_VK_END, KeyEvent.DOM_VK_HOME, KeyEvent.DOM_VK_LEFT, KeyEvent.DOM_VK_UP,
            KeyEvent.DOM_VK_RIGHT, KeyEvent.DOM_VK_DOWN].indexOf(keyCode) == -1)
        {
            return;
        }

        var panel = Firebug.getElementPanel(target);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var box = panel.selectedSourceBox;
        var lastLineNo = box.lastViewableLine;
        var firstLineNo = box.firstViewableLine;
        var caretDetails = this.getCaretDetails(event.target.ownerDocument);
        if (!caretDetails || caretDetails.length != 2)
            return;

        var lineNode = Dom.getAncestorByClass(caretDetails[0].parentNode, "sourceRow");
        if (!lineNode)
            return;

        var lineNo = parseInt(lineNode.getElementsByClassName("sourceLine").item(0).textContent);
        box.a11yCaretLine = lineNo;
        box.a11yCaretOffset = caretDetails[1];
        var linesToScroll = 0;
        var goUp;
        switch (keyCode)
        {
            case KeyEvent.DOM_VK_UP:
            case KeyEvent.DOM_VK_DOWN:
                goUp = (keyCode == KeyEvent.DOM_VK_UP);
                linesToScroll = goUp ? -1 : 1;
                if (!Events.isControl(event))
                {
                    if ((goUp && lineNo > firstLineNo + 1) ||
                        (!goUp && lineNo < lastLineNo - 1))
                    {
                        return;
                    }

                    box.a11yCaretLine = goUp ? lineNo - 1 : lineNo +1;
                }
                box.scrollTop = box.scrollTop + (linesToScroll * box.lineHeight);
                break;

            case KeyEvent.DOM_VK_PAGE_UP:
            case KeyEvent.DOM_VK_PAGE_DOWN:
                goUp = (keyCode == KeyEvent.DOM_VK_PAGE_UP);
                if ((goUp && box.scrollTop == 0) ||
                    (!goUp && box.scrollTop == box.scrollHeight - box.clientHeight))
                {
                    box.a11yCaretLine = goUp ? 0 : box.totalMax;
                    box.a11yCaretOffset = 0;
                    this.insertCaretIntoLine(panel, box);
                    Events.cancelEvent(event);
                    return;
                }
                box.a11yCaretLine = goUp ? lineNo - box.viewableLines : lineNo + box.viewableLines;
                linesToScroll = goUp ? -box.viewableLines : box.viewableLines;
                box.scrollTop = box.scrollTop + (linesToScroll * box.lineHeight);
                Events.cancelEvent(event);
                break;

            case KeyEvent.DOM_VK_HOME:
            case KeyEvent.DOM_VK_END:
                goUp = (keyCode == KeyEvent.DOM_VK_HOME);
                if (Events.isControl(event))
                {
                    box.a11yCaretLine = goUp ? 0 : box.totalMax;
                    box.a11yCaretOffset = 0;
                    if ((goUp && box.scrollTop == 0) ||
                        (!goUp && box.scrollTop == box.scrollHeight - box.clientHeight))
                    {
                        this.insertCaretIntoLine(panel, box);
                    }
                    else
                    {
                        box.scrollTop = goUp ? 0 : box.scrollHeight - box.clientHeight;;
                    }
                    Events.cancelEvent(event);
                    return;
                }

                if (goUp)
                {
                    //move caret to beginning of line. Override default behavior, as that would take the caret into the line number
                    this.insertCaretIntoLine(panel, box, lineNo, 0);
                    box.scrollLeft = 0; //in case beginning of line is scrolled out of view
                    Events.cancelEvent(event);
                }
                break;

            case KeyEvent.DOM_VK_RETURN:
                var liveString = "";
                var caretDetails = this.getCaretDetails(event.target.ownerDocument);
                var lineNode = Dom.getAncestorByClass(caretDetails[0].parentNode, "sourceRow");
                var lineNo = parseInt(lineNode.getElementsByClassName("sourceLine").item(0)
                    .textContent);
                liveString += "Line " + lineNo;
                if (lineNode.getAttribute("breakpoint") == "true")
                {
                    var breakpointStr = "";
                    if (lineNode.getAttribute("disabledbreakpoint") == "true")
                        breakpointStr = "a11y.updates.has disabled breakpoint";
                    if (lineNode.getAttribute("condition") == "true")
                        breakpointStr = "a11y.updates.has conditional breakpoint";
                    liveString += ", " + Locale.$STR(breakpointStr);
                }
                if (lineNode.getAttribute("executable") == "true")
                    liveString += ", executable";
                if (lineNode.getAttribute("exe_line") == "true")
                    liveString += ", currently stopped";
                var sourceText = lineNode.getElementsByClassName("sourceRowText").item(0);
                if (sourceText)
                    liveString += ": " + sourceText.textContent;
                this.updateLiveElem(panel, liveString, true); //should not use alert
                break;
        }
    },

    onScriptKeyUp: function(event)
    {
        var target = event.target;
        var keyCode = event.keyCode || (event.type == "keypress" ? event.charCode : null);
        if (!Css.hasClass(target, "sourceViewport"))
            return;

        if ([KeyEvent.DOM_VK_RETURN, KeyEvent.DOM_VK_PAGE_UP, KeyEvent.DOM_VK_PAGE_DOWN,
            KeyEvent.DOM_VK_END, KeyEvent.DOM_VK_HOME, KeyEvent.DOM_VK_LEFT, KeyEvent.DOM_VK_UP,
            KeyEvent.DOM_VK_RIGHT, KeyEvent.DOM_VK_DOWN].indexOf(keyCode) == -1)
        {
            return;
        }

        var panel = Firebug.getElementPanel(target);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var box = panel.selectedSourceBox;
        var caretDetails = this.getCaretDetails(target.ownerDocument);
        var lineNode = Dom.getAncestorByClass(caretDetails[0].parentNode, "sourceRow");
        if (!lineNode)
            return;

        var lineNo = parseInt(lineNode.getElementsByClassName("sourceLine").item(0).textContent);
        box.a11yCaretLine = lineNo;
        box.a11yCaretOffset = caretDetails[1];
    },

    onScriptMouseUp: function(event)
    {
        var target = event.target;
        if (event.button !== 0)
            return;

        var panel = Firebug.getElementPanel(target);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var box = panel.selectedSourceBox;
        var caretDetails = this.getCaretDetails(target.ownerDocument);
        var lineNode = null;
        if (caretDetails[0] && caretDetails[0].parentNode)
            lineNode = Dom.getAncestorByClass(caretDetails[0].parentNode, "sourceRow");
        if (!lineNode)
            return;

        var lineNo = parseInt(lineNode.getElementsByClassName("sourceLine").item(0).textContent);
        box.a11yCaretLine = lineNo;
        box.a11yCaretOffset = caretDetails[1];
    },

    onBeforeViewportChange: function(panel)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var box = panel.selectedSourceBox;
        if (!box)
            return;

        this.insertCaretIntoLine(panel, box);
    },

    insertCaretIntoLine: function(panel, box, lineNo, offset)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !box)
            return;

        if (typeof lineNo == "undefined")
            lineNo = box.a11yCaretLine ?  box.a11yCaretLine : 0;
        //to prevent the caret from (partially) being placed just out of sight,
        //adjust the viewable line boundaries by 1 (unless the current line is the first or last line)
        var lineAdjust = lineNo == 0 || lineNo == box.totalMax ? 0 : 1;
        var firstLine = box.firstViewableLine + lineAdjust;
        var lastLine = box.lastViewableLine - lineAdjust;
        if (lineNo < (firstLine) || lineNo > lastLine)
            box.a11yCaretLine = lineNo = lineNo < firstLine ? firstLine : lastLine;
        var node = box.getLineNode(lineNo);
        if (!node)
            return;

        if (typeof offset == "undefined")
        {
            if (box.a11yCaretOffset)
                offset = box.a11yCaretOffset;
            else
                box.a11yCaretOffset = offset = 0;
        }
        var startNode = node.getElementsByClassName("sourceRowText").item(0);
        if (startNode && startNode.firstChild && startNode.firstChild.nodeType == Node.TEXT_NODE)
        {
            startNode = startNode.firstChild;
            if (offset >= startNode.length)
                box.a11yCaretOffset = offset = startNode.length - 1;
        }
        else
        {
            startNode = node; //offset is now the number of nodes, not characters within a text node
            offset = 1;
        }
        this.insertCaretToNode(panel, startNode, offset);
    },

    getCaretDetails: function(doc)
    {
        var sel = doc.defaultView.getSelection();
        return [sel.focusNode, sel.focusOffset];
    },

    onUpdateScriptLocation: function(panel, file)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var box = panel.selectedSourceBox;
        var viewport = panel.selectedSourceBox.getElementsByClassName("sourceViewport").item(0);
        box.tabIndex = -1;
        viewport.tabIndex = 0;
        viewport.setAttribute("role", "textbox");
        viewport.setAttribute("aria-multiline", "true");
        viewport.setAttribute("aria-readonly", "true");
        fileName = Url.getFileName(file.href);
        viewport.setAttribute("aria-label", Locale.$STRF("a11y.labels.source code for file",
            [fileName]));
        //bit ugly, but not sure how else I can get the caret into the sourcebox without a mouse
        var focusElem = Firebug.chrome.window.document.commandDispatcher.focusedElement;
        var line = box.getLineNode(box.firstViewableLine);
        if (!line)
            return;

        var node = line.getElementsByClassName("sourceRowText").item(0);
        this.insertCaretToNode(panel, node);
        // move focus back to where it was
        this.focus(focusElem);
    },

    insertCaretToNode: function(panel, node, startOffset)
    {
        if (!startOffset)
            startOffset = 0;
        var sel = panel.document.defaultView.getSelection();
        sel.removeAllRanges();
        var range = panel.document.createRange();
        range.setStart(node, startOffset);
        range.setEnd(node, startOffset);
        sel.addRange(range);
    },

    onScriptContextMenu: function(event)
    {
        if (event.button == 0) //i.e. keyboard, not right mouse click
        {
            //Try to find the line node based on the caret and manually trigger the context menu
            var panel = Firebug.getElementPanel(event.target);
            var panelA11y = this.getPanelA11y(panel);
            if (!panelA11y)
                return;

            var sel = event.target.ownerDocument.defaultView.getSelection();
            var node = sel.focusNode.parentNode;
            var x = event.pageX;
            if (x == 0)
            {
                //TODO: This is ugly and way too inaccurate, how to get xy coordinates from selection object?
                var charWidth = panelA11y.oneEmElem ? panelA11y.oneEmElem.clientWidth * 0.65 : 7.5;
                x = node.offsetLeft + sel.focusOffset * charWidth;
            }
            var y = event.pageY;
            if (y >= event.target.clientHeight)
               y = node.offsetTop;
            Firebug.chrome.window.document.popupNode = node;
            Firebug.chrome.$("fbContextMenu").openPopup(node.ownerDocument.body, "overlap", x, y,
                true);
            Events.cancelEvent(event);
        }
    },

    onWatchPanelRefreshed: function(panel)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var watchEditTrigger = panel.panelNode.getElementsByClassName("watchEditCell").item(0);
        if (watchEditTrigger)
            this.makeFocusable(watchEditTrigger, true);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Call Stack Panel

    onStackCreated: function(panel)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;
        var rows = panel.panelNode.getElementsByClassName("focusRow");
        Array.forEach(rows, function(e, i, a) {
            if ((panelA11y.lastIsDefault && i === rows.length - 1) ||
                (!panelA11y.lastIsDefault && i === 0))
            {
                this.setPanelTabStop(panel, e);
            }
            else
            {
                this.makeFocusable(e, false);
            }
        }, this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Breakpoints Panel

    onBreakRowsRefreshed: function(panel, rootNode)
    {
        var rows = rootNode.getElementsByClassName("focusRow");
        for (var i = 0; i < rows.length; i++)
        {
            this.makeFocusable(rows[i], i == 0);
            if (i == 0)
                this.setPanelTabStop(panel, rows[i]);
        }
        var groupHeaders = rootNode.getElementsByClassName("breakpointHeader");
        for (var i = 0; i < groupHeaders.length; i++)
        {
            var listBox = Dom.getNextByClass(groupHeaders[i], "breakpointsGroupListBox");
            if (listBox)
                listBox.setAttribute("aria-label", groupHeaders[i].textContent);
        }
    },

    onScriptSearchMatchFound: function(panel, text, sourceBox, lineNo)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !text)
            return;

        var matchFeedback = "";
        if (!sourceBox || lineNo === null)
        {
            matchFeedback = Locale.$STRF("a11y.updates.no matches found", [text]);
        }
        else
        {
            var line = sourceBox.getLine(panel.context, lineNo + 1);
            if (!line)
                line = "";
            matchFeedback = Locale.$STRF("a11y.updates.match found for on line",
                [text, lineNo + 1, Url.getFileName(sourceBox.href)]);
        }
        this.updateLiveElem(panel, matchFeedback, true);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // DOM Panel

    onMemberRowsAdded: function(panel, rows)
    {
        if (!panel)
            panel = Firebug.getElementPanel(rows[0]);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !rows)
            return;

        var setSize = rows.length;
        var posInset = 0;
        for (var i = 0; i < rows.length; i++)
        {
            var makeTab = (panelA11y.lastIsDefault && i === rows.length - 1) ||
                (!panelA11y.lastIsDefault && i === 0);
            this.prepareMemberRow(panel, rows[i], makeTab, ++posInset, setSize);
        }
    },

    onMemberRowSliceAdded: function(panel, borderRows, posInSet, setSize)
    {
        if (!borderRows)
            return;
        var startRow = borderRows[0];
        var endRow = borderRows[1];
        if (!panel)
            panel = Firebug.getElementPanel(startRow);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var reFocusId = panelA11y.reFocusId;
        var row = startRow;
        do
        {
            this.prepareMemberRow(panel, row, false, posInSet++, setSize, reFocusId);
            if (row === endRow)
                break;
        }
        while (row = row.nextSibling);
    },

    prepareMemberRow: function(panel, row, makeTab, posInSet, setSize, reFocusId)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y|| !row)
            return;

        if (!row.cells[2])
            return;

        var cellChild = row.cells[2].firstChild;
        if (cellChild)
        {
            if (Css.hasClass(row, "hasChildren"))
                cellChild.setAttribute("aria-expanded", Css.hasClass(row, "opened"));
            if (makeTab)
                this.modifyPanelRow(panel, cellChild, true);
            cellChild.setAttribute("role", "treeitem");
            cellChild.setAttribute("aria-level", parseInt(row.getAttribute("level")) + 1);
            if (posInSet && setSize)
            {
                cellChild.setAttribute("aria-setsize", setSize);
                cellChild.setAttribute("aria-posinset", posInSet);
            }
            Css.setClass(cellChild, "focusRow");
            if (typeof reFocusId == "number" && row.rowIndex == reFocusId)
            {
                this.modifyMemberRow(panel, cellChild, true);
                this.focus(cellChild, true, true);
                panelA11y.reFocusId = null;
            }
        }
    },

    modifyMemberRow: function(panel, row, inTabOrder)
    {
        var type = this.getObjectType(row);
        var labelCell = row.parentNode.previousSibling;
        row.setAttribute("aria-label", labelCell.textContent +
            ": " + " " + row.textContent + (type ? " (" + type + ")" : ""));
        if (inTabOrder)
            this.setPanelTabStop(panel, row);
        else
            this.makeFocusable(row, false);
    },

    onBeforeDomUpdateSelection: function (panel)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var focusNode = panel.document.activeElement;
        if (this.isDirCell(focusNode))
            panelA11y.reFocusId = focusNode.parentNode.parentNode.rowIndex;
    },

    onWatchEndEditing: function(panel, row)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        panelA11y.reFocusId = 2;
    },

    onDomSearchMatchFound: function (panel, text, matchRow)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !text)
            return;

        var matchFeedback = "";
        if (matchRow && matchRow.cells)
        {
            var dirCell = matchRow.getElementsByClassName("focusRow").item(0);
            if (dirCell)
            {
                this.modifyPanelRow(panel, dirCell);
                var rowLabel = dirCell.getAttribute("aria-label");
                matchFeedback = Locale.$STRF("a11y.updates.match found in dom property",
                    [text, rowLabel]);
            }
        }
        else
        {
            matchFeedback = Locale.$STRF("a11y.updates.no matches found", [text]);
        }
        this.updateLiveElem(panel, matchFeedback, true);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Net Panel

    isSubFocusRow: function(elem)
    {
        return Css.hasClass(elem, "focusRow") || Css.hasClass(elem, "wrappedText");
    },

    modifyNetRow: function(panel, row, inTabOrder)
    {
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !row)
            return;

        if (this.isOuterFocusRow(row, true))
        {
            if (!Css.hasClass(row, "netInfoTabs"))
                this.makeFocusable(row, inTabOrder);
            if ((Css.hasClass(row, "netRow") ||
                Css.hasClass(row, "spyHeadTable")) && !row.hasAttribute("aria-expanded"))
            {
                row.setAttribute("aria-expanded", Css.hasClass(row, "opened") + "");
            }
            var focusObjects = this.getFocusObjects(row);
            Array.forEach(focusObjects, function(e, i, a) {
                this.makeFocusable(e);
                if (Css.hasClass(e, "netTimeCol") && Dom.getAncestorByClass(e, "fromCache"))
                {
                    e.setAttribute("aria-label", e.textContent + " (" +
                        Locale.$STR("a11y.labels.cached") +")");
                }
            }, this);
        }
        else return;
    },

    getNetAncestorRow: function(elem, useSubRow)
    {
        return useSubRow ? Dom.getAncestorByClass(elem, "subFocusRow") ||
            Dom.getAncestorByClass(elem, "netRow") : Dom.getAncestorByClass(elem, "netRow");
    },

    onNetMouseDown: function(event)
    {
        var node = Dom.getAncestorByClass(event.target, "focusRow");
        if (node)
        {
            this.modifyPanelRow(Firebug.getElementPanel(node), node, false);
        }
        else
        {
            node = Dom.getAncestorByClass(event.target, "subFocusRow");
            if (!node)
                return;

            var focusRow = node.getElementsByClassName("focusRow").item(0);
            if (!focusRow)
                return;

            this.modifyPanelRow(Firebug.getElementPanel(focusRow), focusRow, false);
            this.focus(focusRow);
        }
    },

    onNetFocus: function(e) {
        var target = e.target;
        var panel = Firebug.getElementPanel(target);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        if (!Css.hasClass(target, "netCol") && !Css.hasClass(target, "netHeaderCell"))
            return;

        if (Css.hasClass(target, "netHrefCol"))
        {
            var hrefLabel = target.getElementsByClassName("netHrefLabel").item(0);
            var fullHrefLabel = target.getElementsByClassName("netFullHrefLabel").item(0);
            if (hrefLabel && fullHrefLabel)
            {
                Css.setClass(fullHrefLabel, "a11yShowFullLabel");
                fullHrefLabel.style.marginTop = (hrefLabel.offsetHeight  + 4) + "px";
                return;
            }
        }
        var rangeParent = Dom.getAncestorByClass(target, "netRow");
        var browser = Firebug.chrome.getPanelBrowser(panel);
        // these two lines are necessary, because otherwise the info tip will not have the correct
        // dimensions when it's positioned, and the contentscould be placed outside of Firebug's
        // viewport (making it impossible to read for keyboard users)
        // This will be called again in showInfoTip
        panel.showInfoTip(browser.infoTip, target, target.offsetLeft, target.offsetTop,
            rangeParent, 0);
        browser.infoTip.setAttribute("active", "true");
        var left = Css.hasClass(target, "netTimeCol") ?
            target.offsetLeft - browser.infoTip.offsetWidth - 12 :
            target.offsetLeft + target.offsetWidth - 4;
        Firebug.InfoTip.showInfoTip(browser.infoTip, panel, target, left,
            target.offsetTop - panel.panelNode.scrollTop - 12, rangeParent, 0);
    },

    onNetBlur: function(e) {
        var target = e.target;
        var panel = Firebug.getElementPanel(target);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        if (Css.hasClass(target, "netHrefCol"))
        {
            var hrefLabel = target.getElementsByClassName("netHrefLabel").item(0);
            var fullHrefLabel = target.getElementsByClassName("netFullHrefLabel").item(0);
            if (hrefLabel && fullHrefLabel)
            {
                Css.removeClass(fullHrefLabel, "a11yShowFullLabel");
                fullHrefLabel.style.marginTop = "0px";
            }
        }
        var browser = Firebug.chrome.getPanelBrowser(panel);
        Firebug.InfoTip.hideInfoTip(browser.infoTip);
    },

    onNetMatchFound: function(panel, text, row)
    {
        //TODO localize for 1.5
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var matchFeedback = "";
        if (!row)
        {
            matchFeedback = Locale.$STRF("a11y.updates.no matches found", [text]);
        }
        else
        {
            var foundWhere = "";
            var parentRow = Dom.getAncestorByClass(row, "netRow");
            if (!parentRow)
            {
                parentRow = Dom.getAncestorByClass(row, "netInfoRow");
                if (parentRow)
                    parentRow = parentRow.previousSibling;
            }
            if (Css.hasClass(row, "netHrefLabel"))
                foundWhere = Locale.$STR("net.header.URL");
            else if (Css.hasClass(row, "netStatusLabel"))
                foundWhere = Locale.$STR("net.header.Status");
            else if (Css.hasClass(row, "netDomainLabel"))
                foundWhere = Locale.$STR("net.header.Domain");
            else if (Css.hasClass(row, "netSizeLabel"))
                foundWhere = Locale.$STR("net.header.Size");
            else if (Css.hasClass(row, "netTimeLabel"))
                foundWhere = Locale.$STR("net.header.Timeline");
            else
                foundWhere = "request details";
            if (parentRow && parentRow.repObject)
            {
                var file = parentRow.repObject;
                var href =  (file.method ? file.method.toUpperCase() : "?") + " " +
                    Url.getFileName(file.href);
                matchFeedback = Locale.$STRF("a11y.updates.match found in net row",
                    [text, href, foundWhere, row.textContent]);
            }
            else if (Dom.getAncestorByClass(row, "netSummaryRow"))
            {
                matchFeedback = Locale.$STRF("a11y.updates.match found in net summary row",
                    [text, row.textContent]);
            }
        }
        this.updateLiveElem(panel, matchFeedback, true); //should not use alert
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Panel Navigation

    insertHiddenText: function(panel, elem, text, asLastNode, id)
    {
        var span = panel.document.createElement("span");
        span.className ="offScreen";
        span.textContent = text;

        if (id)
            span.id = id;

        if (asLastNode)
            elem.appendChild(span);
        else
            elem.insertBefore(span, elem.firstChild);
    },

    getLogRowType: function(elem)
    {
        var type = "";
        if (!elem)
            return type;

        var className = elem.className.match(/\logRow-(\w+)\b/);
        if (className)
            type = className[1];

        if (!type)
        {
            if (Css.hasClass(elem, "errorTitle"))
                type = "detailed error";
            else if (Css.hasClass(elem, "errorSourceBox"))
                type = "error source line";
            else
                type = this.getObjectType(elem);
        }

        if (type == "stackFrame")
            type="";

        return type;
    },

    getObjectType: function(elem)
    {
        var type = "";
        if (elem.nodeName == "img")
            return type;

        var className = elem.className.match(/\bobject(Box|Link)-(\w+)/);
        if (className)
            type = className[2];

        switch (type)
        {
            case "null":
            case "undefined":
                type = "";
                break;

            case "number":
                if (elem.textContent == "true" || elem.textContent == "false")
                    type = "boolean";

            case "":
            case "object":
                if (elem.repObject)
                {
                    try
                    {
                        var obj = elem.repObject;
                        if (!obj)
                            return type;

                        type = typeof obj;
                        if (obj instanceof Array)
                            type = "array";

                        if (typeof obj.lineNo != "undefined")
                            type = "function call";
                    }
                    catch(e) {}
                }
        }

        return type;
    },

    modifyPanelRow: function (panel, row, inTabOrder)
    {
        if (Css.hasClass(row, "a11yModified"))
            return;

        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y || !row)
            return;

        switch (panelA11y.type)
        {
            case "console":
                this.modifyConsoleRow(panel,row, inTabOrder);
                break;

            case "css":
                this.modifyCSSRow(panel, row, inTabOrder);
                break;

            case "net":
                this.modifyNetRow(panel, row, inTabOrder);
                break;
        }
        Css.setClass(row, "a11yModified");
    },

    focusSiblingRow: function(panel, target, goUp)
    {
        var newRow = this[goUp ? "getPreviousByClass" : "getNextByClass"](target, "focusRow",
            true, panel.panelNode);
        if (!newRow)
            return;

        this.focusPanelRow(panel, newRow);
    },

    focusPageSiblingRow: function(panel, target, goUp)
    {
        var rows = this.getFocusRows(panel);
        var index = this.getRowIndex(rows, target);
        var newRow = this.getValidRow(rows, goUp ? index - 10 : index + 10);
        this.focusPanelRow(panel, newRow);
    },

    focusEdgeRow: function(panel, target, goUp)
    {
        var rows = this.getFocusRows(panel);
        var newRow = this.getValidRow(rows, goUp ? 0 : rows.length -1);
        this.focusPanelRow(panel, newRow);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Utils

    onPanelFocus: function(event)
    {
        var panel = Firebug.getElementPanel(event.target);
        var panelA11y = this.getPanelA11y(panel);
        if (!panelA11y)
            return;

        var target = event.target;
        if (this.isTabWorthy(target) && target !== this.getPanelTabStop(panel))
            this.setPanelTabStop(panel, target);
        if (target.getAttribute("role").match(/gridcell|rowheader|columnheader/))
        {
            var cell = (target.nodeName.toLowerCase() == "td" ||
                (target.nodeName.toLowerCase() == "th" ? target : target.parentNode));
            panelA11y.cellIndex = (cell.cellIndex !== undefined ? cell.cellIndex : undefined);
        }
        else
        {
            if (Css.hasClass(target, "netInfoTab"))
                this.dispatchMouseEvent(target, "click");
            panelA11y.cellIndex = undefined; //reset if no longer in grid
        }
    },

    getFocusRows: function(panel)
    {
        var nodes = panel.panelNode.getElementsByClassName("focusRow");
        return Array.filter(nodes, function(e, i, a)
        {
            return this.isVisibleByStyle(e) && Xml.isVisible(e);
        }, this);
    },

    getLastFocusChild: function(target)
    {
        var focusChildren = target.getElementsByClassName("focusRow");
        return focusChildren.length > 0 ? focusChildren[focusChildren.length -1] : null;
    },

    getFirstFocusChild: function(target)
    {
        var focusChildren = target.getElementsByClassName("focusRow");
        return focusChildren.length > 0 ? focusChildren[0] : null;
    },

    focus: function(elem, noVisiCheck, needsMoreTime)
    {
        if (Dom.isElement(elem) && (noVisiCheck || this.isVisibleByStyle(elem)))
        {
            Firebug.currentContext.setTimeout(function() {
                    elem.focus();
                }, needsMoreTime ? 500 : 10
            );
        }
    },

    makeFocusable: function(elem, inTabOrder)
    {
        if (elem)
            elem.setAttribute("tabindex", inTabOrder ? "0" : "-1");
    },

    makeUnfocusable: function(elem)
    {
        if (elem)
            elem.removeAttribute("tabindex");
    },

    reportFocus: function(event)
    {
        FBTrace.sysout("focus: " + event.target.nodeName + "#" + event.target.id + "." +
            event.target.className, event.target);
    },

    dispatchMouseEvent: function (node, eventType, clientX, clientY, button)
    {
        if (!clientX)
            clientX = 0;
        if (!clientY)
            clientY = 0;
        if (!button)
            button = 0;
        if (typeof node == "string")
            throw new Error("a11y.dispatchMouseEvent obsolete API");
        var doc = node.ownerDocument;
        var event = doc.createEvent("MouseEvents");
        event.initMouseEvent(eventType, true, true, doc.defaultView,
            0, 0, 0, clientX, clientY, false, false, false, false, button, null);
        node.dispatchEvent(event);
    },

    isVisibleByStyle: function (elem)
    {
        if (!elem || elem.nodeType != Node.ELEMENT_NODE)
            return false;
        var style = elem.ownerDocument.defaultView.getComputedStyle(elem, null);
        return style.visibility !== "hidden" && style.display !== "none";
    },

    isTabWorthy: function (elem)
    {
        return this.isFocusRow(elem) || this.isFocusObject(elem);
    },

    isOuterFocusRow: function(elem, includeSubRow)
    {
        return includeSubRow ? this.isSubFocusRow(elem) : Css.hasClass(elem, "outerFocusRow");
    },

    isProfileRow: function(elem)
    {
        return Css.hasClass(elem, "profileRow");
    },

    isFocusRow: function(elem)
    {
        return Css.hasClass(elem, "focusRow");
    },

    isFocusObject: function(elem)
    {
        return Css.hasClass(elem, "a11yFocus");
    },

    isFocusNoTabObject: function(elem)
    {
        return Css.hasClass(elem, "a11yFocusNoTab");
    },

    isDirCell: function(elem)
    {
        return Css.hasClass(elem.parentNode, "memberValueCell");
    },

    panelHasFocus: function(panel)
    {
        if (!panel || !panel.context)
            return false;
        var focusedElement = Firebug.chrome.window.document.commandDispatcher.focusedElement;
        var focusedPanel = Firebug.getElementPanel(focusedElement);
        return focusedPanel && (focusedPanel.name == panel.name);
    },

    getPanelA11y: function(panel, create)
    {
        var a11yPanels, panelA11y;
        if (!this.isEnabled() || !panel || !panel.name || !panel.context)
            return false;

        a11yPanels = panel.context.a11yPanels;
        if (!a11yPanels)
            a11yPanels = panel.context.a11yPanels = {};
        panelA11y = a11yPanels[panel.name];
        if (!panelA11y)
        {
            if (create)
                panelA11y = a11yPanels[panel.name] = {};
            else
                return false;
        }
        return panelA11y;
    },

    // These utils are almost the same as their DOM namesakes,
    // except that the routine skips invisible containers
    // (rather than wasting time on their child nodes)
    getPreviousByClass: function (node, className, downOnly, maxRoot)
    {
        if (!node)
            return null;

        function criteria(node) {
            return node.nodeType == Node.ELEMENT_NODE && Css.hasClass(node, className);
        }

        for (var sib = node.previousSibling; sib; sib = sib.previousSibling)
        {
            if (!this.isVisibleByStyle(sib) || !Xml.isVisible(sib))
                continue;

            var prev = this.findPreviousUp(sib, criteria);
            if (prev)
                return prev;

            if (criteria(sib))
                return sib;
        }
        if (!downOnly)
        {
            var next = this.findPreviousUp(node, criteria);
            if (next)
                return next;
        }
        if (node.parentNode && node.parentNode != maxRoot)
        {
            if (criteria(node.parentNode))
                return node.parentNode;
            return this.getPreviousByClass(node.parentNode, className, true);
        }
    },

    getNextByClass: function (node, className, upOnly, maxRoot)
    {
        if (!node)
            return null;

        function criteria(node) {
            return node.nodeType == Node.ELEMENT_NODE && Css.hasClass(node, className);
        }

        if (!upOnly)
        {
            var next = this.findNextDown(node, criteria);
            if (next)
                return next;
        }

        for (var sib = node.nextSibling; sib; sib = sib.nextSibling)
        {
            if (!this.isVisibleByStyle(sib) || !Xml.isVisible(sib))
                continue;
            if (criteria(sib))
                return sib;

            var next = this.findNextDown(sib, criteria);
            if (next)
                return next;
        }

        if (node.parentNode && node.parentNode != maxRoot)
            return this.getNextByClass(node.parentNode, className, true);
    },

    findNextDown: function(node, criteria)
    {
        if (!node)
            return null;

        for (var child = node.firstChild; child; child = child.nextSibling)
        {
            if (!this.isVisibleByStyle(child) || !Xml.isVisible(child))
                continue;

            if (criteria(child))
                return child;

            var next = this.findNextDown(child, criteria);
            if (next)
                return next;
        }
    },

    findPreviousUp: function(node, criteria)
    {
        if (!node)
            return null;

        for (var child = node.lastChild; child; child = child.previousSibling)
        {
            if (!this.isVisibleByStyle(child) || !Xml.isVisible(child))
                continue;

            var next = this.findPreviousUp(child, criteria);
            if (next)
                return next;

            if (criteria(child))
                return child;
        }
    }
});

// ************************************************************************************************
// Registration

Firebug.registerModule(Firebug.A11yModel);

return Firebug.A11yModel;

// ************************************************************************************************
});
/* See license.txt for terms of usage */

// ********************************************************************************************* //
// Module

define("firebug/bti/inProcess/browser",
[
    "firebug/lib/lib",
    "firebug/lib/events",
    "firebug/chrome/firefox",
    "firebug/chrome/window",
    "arch/webApp",
    "firebug/lib/options",
    "firebug/chrome/tabWatcher",
],
function factoryBrowser(FBL, Events, Firefox, Win, WebApp, Options, TabWatcher) {

// ********************************************************************************************* //
// Browser

/**
 * Proxy to a debuggable web browser. A browser may be remote and contain one or more
 * JavaScript execution contexts. Each JavaScript execution context may contain one or
 * more compilation units. A browser provides notification to registered listeners describing
 * events that occur in the browser.
 *
 * @constructor
 * @type Browser
 * @return a new Browser
 * @version 1.0
 */
function Browser()
{
    //this.contexts = []; // metadata instances
    this.activeContext = null;
    this.listeners = [];  // array of Browser.listener objects
    this.tools = {};  // registry of known tools
    this.connected = false;
}

// ********************************************************************************************* //
// API

Browser.debug = {handlers: true};
Browser.onDebug = function()
{
    if (Browser.debug)
        throw new Error("Browser.debug set but no Brower.onDebug is defined");
};

Browser.unimplementedHandler = function()
{
    if (Browser.debug && Browser.debug.handlers)
        Browser.onDebug("Browser.listener unimplemented event handler called ",
            {handler: this, args: arguments});
};

Browser.listener =
{
    onBreak: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onConsoleDebug: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onConsoleError: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onConsoleInfo: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onConsoleLog: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onConsoleWarn: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onContextCreated: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onContextDestroyed: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onContextChanged: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onContextLoaded: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onInspectNode: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onResume: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onScript: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onSuspend: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onToggleBreakpoint: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onBreakpointError: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    },

    onDisconnect: function()
    {
        Browser.unimplementedHandler.apply(this, arguments);
    }
};

/**
 * Testing and sanity: clearAllBreakpoints
 */
Browser.prototype.clearAllBreakpoints = function()
{
    Firebug.Debugger.clearAllBreakpoints();
};

/**
 * Command: clearAnnotations
 */
Browser.prototype.clearAnnotations = function()
{
    // should trigger event onClearAnnotations
    Firebug.Activation.clearAnnotations();
};

Browser.prototype.getWebAppByWindow = function(win)
{
    if (win && win.top)
        return new WebApp(win.top);
};

Browser.prototype.getContextByWebApp = function(webApp)
{
    var topMost = webApp.getTopMostWindow();
    var context = TabWatcher.getContextByWindow(topMost);
    return context;

    /*for (var i = 0; i < this.contexts.length; i++)
    {
        var context = this.contexts[i];
        if (context.window === topMost)
            return context
    }*/
};

Browser.prototype.getContextByWindow = function(win)
{
    var webApp = this.getWebAppByWindow(win);
    if (webApp)
        return this.getContextByWebApp(webApp);
};

/**
 * get local metadata for the remote WebApp if it exists
 * @return ToolInterface.WebAppContext or null if the webApp is not being debugged
 */
Browser.prototype.setContextByWebApp = function(webApp, context)
{
    var topMost = webApp.getTopMostWindow();
    if (context.window !== topMost)
    {
        FBTrace.sysout("Browser setContextByWebApp mismatched context ",
            {context: context, win: topMost});
    }

    // xxxHonza: possible mem leak, the context object isn't removed from the array sometimes
    // Do not use for now (this will be used for remoting).
    //this.contexts.push(context);
};

/**
 * Stop debugging a WebApp and cause the destruction of a ToolsInterface.WebAppContext
 * @param webAppContext metadata for the page that we are not going to debug any more
 * @param userCommands true if the user of this UI said to close (vs algorithm)
 */
Browser.prototype.closeContext = function(context, userCommands)
{
    if (context)
    {
        var topWindow = context.window;

        /*if (index === -1)
        {
            if (FBTrace.DBG_ERRORS)
            {
                var loc = Win.safeGetWindowLocation(topWindow);
                FBTrace.sysout("Browser.closeContext ERROR, no context matching " + loc);
            }
        }
        else
        {
            this.contexts.splice(index, 1);
        }*/

        // TEMP
        TabWatcher.unwatchWindow(topWindow);

        var browser = Win.getBrowserByWindow(topWindow);
        if (!browser)
            throw new Error("Browser.closeContext ERROR, no browser for top most window of context "+
                context.getName());

        delete browser.showFirebug;

        var shouldDispatch = TabWatcher.unwatchTopWindow(browser.contentWindow);

        if (shouldDispatch)
        {
            // TODO remove
            Events.dispatch(TabWatcher.fbListeners, "unwatchBrowser", [browser, null]);
            return true;
        }
        return false;
    }
};

/**
 * get local metadata for the remote WebApp or create one
 * @param webApp, ToolsInterface.WebApp representing top level window
 * @return ToolInterface.WebAppContext
 */
Browser.prototype.getOrCreateContextByWebApp = function(webApp)
{
    var context = this.getContextByWebApp(webApp);
    if (!context)
    {
        var topWindow = webApp.getTopMostWindow();
        var browser = Win.getBrowserByWindow(topWindow);
        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("BTI.tabWatcher.watchBrowser for: " + (topWindow.location));

        // TEMP
        var context = TabWatcher.watchTopWindow(topWindow, browser.currentURI, true);
        this.setContextByWebApp(webApp, context);

        // TEMP; Watch also all iframes. Firebug has been initialized when the page is already
        // loaded and so, we can't rely on auto-registration done by FrameProgressListener.
        Win.iterateWindows(context.window, function (win)
        {
            TabWatcher.watchWindow(win, context, false);
        });

        browser.showFirebug = true;

        // TODO remove
        Events.dispatch(TabWatcher.fbListeners, "watchBrowser", [browser]);
    }
    return context;
};

/**
 * The WebApp on the selected tab of the selected window of this Browser
 * @return WebApp ( never null )
 */
Browser.prototype.getCurrentSelectedWebApp = function()
{
    // Remote version must seek selected XUL window first.
    var browser = Firefox.getCurrentBrowser();
    var webApp = new WebApp(browser.contentWindow);
    if (FBTrace.DBG_ACTIVATION)
        FBTrace.sysout("BTI.WebApp ", {browser: browser, webApp: webApp});
    return webApp;
};


/**
 * Returns current status of tools
 *
 * @function
 * @returns  an array of Tools, an object with {toolName: string, enabled: boolean,
 *  enable:function(boolean, fnOfBoolean),}
 */
Browser.prototype.getTools = function()
{
    return [];
};

/**
 * Return the status of a tool
 * @param name, eg "console"
 * @returns an object with properties including toolName and enabled
 */
Browser.prototype.getTool = function(name)
{
    // This pollutes the FBTrace console too much.
    //if (FBTrace.DBG_ERRORS && !this.tools[name])
    //    FBTrace.sysout("BTI.Browser.getTool; Unknown tool: " + name);

    return this.tools[name];
};

/**
 * Call on the backend
 */
Browser.prototype.registerTool = function(tool)
{
    var name = tool.getName();
    if (name)
    {
        if (FBTrace.DBG_ERRORS && this.tools[name])
            FBTrace.sysout("BTI.Browser.unregisterTool; Already registered tool: " + name);

        this.tools[name] = tool;
    }
};

Browser.prototype.unregisterTool = function(tool)
{
    var name = tool.getName();
    if (name)
    {
        if (FBTrace.DBG_ERRORS && !this.tools[name])
            FBTrace.sysout("BTI.Browser.unregisterTool; Unknown tool: " + name);
        else
            delete this.tools[name];
    }
};

Browser.prototype.eachContext = function(fnOfContext)
{
    try
    {
        return Firebug.TabWatcher.iterateContexts(fnOfContext);
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("BTI.browser.eachContext; EXCEPTION " + e, e);
    }
};

/**
 * Returns the {@link BrowserContext} that currently has focus in the browser
 * or <code>null</code> if none.
 *
 * @function
 * @returns the {@link BrowserContext} that has focus or <code>null</code>
 */
Browser.prototype.getFocusBrowserContext = function()
{
    return this.activeContext;
};

/**
 * Returns whether this proxy is currently connected to the underlying browser it
 * represents.
 *
 *  @function
 *  @returns whether connected to the underlying browser
 */
Browser.prototype.isConnected = function()
{
    return this.connected;
};

/**
 * Registers a listener (function) for a specific type of event. Listener
 * call back functions are specified in {@link BrowserEventListener}.
 * <p>
 * The supported event types are:
 * <ul>
 *   <li>onBreak</li>
 *   <li>onConsoleDebug</li>
 *   <li>onConsoleError</li>
 *   <li>onConsoleInfo</li>
 *   <li>onConsoleLog</li>
 *   <li>onConsoleWarn</li>
 *   <li>onContextCreated</li>
 *   <li>onContextChanged</li>
 *   <li>onContextDestroyed</li>
 *   <li>onDisconnect</li>
 *   <li>onInspectNode</li>
 *   <li>onResume</li>
 *   <li>onScript</li>
 *   <li>onToggleBreakpoint</li>
 * </ul>
 * <ul>
 * <li>TODO: how can clients remove (deregister) listeners?</li>
 * </ul>
 * </p>
 * @function
 * @param eventType an event type ({@link String}) listed above
 * @param listener a listener (function) that handles the event as specified
 *   by {@link BrowserEventListener}
 * @exception Error if an unsupported event type is specified
 */
Browser.prototype.addListener = function(listener)
{
    var list = this.listeners;
    var i = list.indexOf(listener);
    if (i === -1)
        list.push(listener);
    else
        FBTrace.sysout("BTI.Browser.addListener; ERROR The listener is already appended " +
            (listener.dispatchName ? listener.dispatchName : ""));
};

Browser.prototype.removeListener = function(listener)
{
    var list = this.listeners;
    var i = list.indexOf(listener);
    if (i !== -1)
        list.splice(i, 1);
    else
        FBTrace.sysout("BTI.Browser.removeListener; ERROR Unknown listener " +
            (listener.dispatchName ? listener.dispatchName : ""));
};

/**
 * Among listeners, return the first truthy value of eventName(args) or false
 */
Browser.prototype.dispatch = function(eventName, args)
{
    try
    {
        return Events.dispatch2(this.listeners, eventName, args);
    }
    catch (exc)
    {
        FBTrace.sysout("BTI.Browser.dispatch; EXCEPTION " + exc, exc);
    }
};

/**
 * Disconnects this client from the browser it is associated with.
 *
 * @function
 */
Browser.prototype.disconnect = function()
{
    this.removeListener(Firebug);
    TabWatcher.destroy();

    // Remove the listener after the Firebug.TabWatcher.destroy() method is called, so
    // that the destroyContext event is properly dispatched to the Firebug object and
    // consequently to all registered modules.
    TabWatcher.removeListener(this);

    this._setConnected(false);
};

// ********************************************************************************************* //
// Private, subclasses may call these functions

/**
 * Command to resume/suspend backend
 */
Browser.prototype.toggleResume = function(resume)
{
    if (FBTrace.DBG_ACTIVATION)
        FBTrace.sysout("BTI.toggleResume" + (Firebug.getSuspended() ? "OFF" : "ON") +
            " -> " + (!!resume ? "ON" : "OFF"));

    // This should be the only method to call suspend() and resume().
    // either a new context or revisiting an old one
    if (resume)
    {
        if (Firebug.getSuspended())
        {
            // This will cause onResumeFirebug for every context including this one.
            Firebug.resume();
        }
    }
    // this browser has no context
    else
    {
        Firebug.suspend();
    }
},

/**
 * Sets the browser context that has focus, possibly <code>null</code>.
 *
 * @function
 * @param context a {@link BrowserContext} or <code>null</code>
 */
Browser.prototype._setFocusContext = function(context)
{
    var prev = this.activeContext;
    this.activeContext = context;
    if (prev !== context)
        this.dispatch("onContextChanged", [prev, this.activeContext]);
};

/**
 * Sets whether this proxy is connected to its underlying browser.
 * Sends 'onDisconnect' notification when the browser becomes disconnected.
 *
 * @function
 * @param connected whether this proxy is connected to its underlying browser
 */
Browser.prototype._setConnected = function(connected)
{
    if (FBTrace.DBG_ACTIVATION)
        FBTrace.sysout("BTI.Browser._setConnected " + connected + " this.connected " +
            this.connected);

    var wasConnected = this.connected;
    this.connected = connected;

    if (wasConnected && !connected)
        this.dispatch("onDisconnect", [this]);
    else if (!wasConnected && connected)
        this.dispatch("onConnect", [this]);
};

// ********************************************************************************************* //
// Event Listener

/**
 * Describes the event listener functions supported by a {@link Browser}.
 *
 * @constructor
 * @type BrowserEventListener
 * @return a new {@link BrowserEventListener}
 * @version 1.0
 */
Browser.EventListener = {

    /**
     * Notification that execution has suspended in the specified
     * compilation unit.
     *
     * @function
     * @param compilationUnit the {@link CompilationUnit} execution has suspended in
     * @param lineNumber the line number execution has suspended at
     */
    onBreak: function(compilationUnit, lineNumber) {},

    /**
     * TODO:
     */
    onConsoleDebug: function() {},

    /**
     * TODO:
     */
    onConsoleError: function() {},

    /**
     * Notification the specified information messages have been logged.
     *
     * @function
     * @param browserContext the {@link BrowserContext} the messages were logged from
     * @param messages array of messages as {@link String}'s
     */
    onConsoleInfo: function(browserContext, messages) {},

    /**
     * Notification the specified messages have been logged.
     *
     * @function
     * @param browserContext the {@link BrowserContext} the messages were logged from
     * @param messages array of messages as {@link String}'s
     */
    onConsoleLog: function(browserContext, messages) {},

    /**
     * Notification the specified warning messages have been logged.
     *
     * @function
     * @param browserContext the {@link BrowserContext} the messages were logged from
     * @param messages array of messages as {@link String}'s
     */
    onConsoleWarn: function(browserContext, messages) {},

    /**
     * Notification the specified browser context has been created. This notification
     * is sent when a new context is created and before any scripts are compiled in
     * the new context.
     *
     * @function
     * @param browserContext the {@link BrowserContext} that was created
     */
    onContextCreated: function(browserContext) {},

    /**
     * Notification the focus browser context has been changed.
     *
     * @function
     * @param fromContext the previous {@link BrowserContext} that had focus or <code>null</code>
     * @param toContext the {@link BrowserContext} that now has focus or <code>null</code>
     */
    onContextChanged: function(fromContext, toContext) {},

    /**
     * Notification the specified browser context has been destroyed.
     *
     * @function
     * @param browserContext the {@link BrowserContext} that was destroyed
     */
    onContextDestroyed: function(browserContext) {},

    /**
     * Notification the specified browser context has completed loading.
     *
     * @function
     * @param browserContext the {@link BrowserContext} that has completed loading
     */
    onContextLoaded: function(browserContext) {},

    /**
     * Notification the connection to the remote browser has been closed.
     *
     * @function
     * @param browser the {@link Browser} that has been disconnected
     */
    onDisconnect: function(browser) {},

    /**
     * TODO:
     */
    onInspectNode: function() {},

    /**
     * Notification the specified execution context has resumed execution.
     *
     * @function
     * @param stack the {@link JavaScriptStack} that has resumed
     */
    onResume: function(stack) {},

    /**
     * Notification the specified compilation unit has been compiled (loaded)
     * in its browser context.
     *
     * @function
     * @param compilationUnit the {@link CompilationUnit} that has been compiled
     */
    onScript: function(compilationUnit) {},

    /**
     * Notification the specified breakpoint has been installed or cleared.
     * State can be retrieved from the breakpoint to determine whether the
     * breakpoint is installed or cleared.
     *
     * @function
     * @param breakpoint the {@link Breakpoint} that has been toggled
     */
    onToggleBreakpoint: function(breakpoint) {},

    /**
     * Notification the specified breakpoint has failed to install or clear.
     * State can be retrieved from the breakpoint to determine what failed.
     *
     * @function
     * @param breakpoint the {@link Breakpoint} that failed to install or clear
     */
    onBreakpointError: function(breakpoint) {}
};

// ********************************************************************************************* //

/**
 * @object
 */
var TabWatchListener =
/** @lends TabWatchListener */
{
    dispatchName: "TabWatchListener",

    // called after a context is created.
    initContext: function(context, persistedState)
    {
        context.panelName = context.browser.panelName;
        if (context.browser.sidePanelNames)
            context.sidePanelNames = context.browser.sidePanelNames;

        if (FBTrace.DBG_ERRORS && !context.sidePanelNames)
            FBTrace.sysout("BTI.firebug.initContext sidePanelNames:", context.sidePanelNames);

        Events.dispatch(Firebug.modules, "initContext", [context, persistedState]);

        // a newly created context becomes the default for the view
        Firebug.chrome.setFirebugContext(context);

        // a newly created context is active
        Firebug.connection.toggleResume(context);
    },

    // To be called from Firebug.TabWatcher only, see selectContext
    // null as context means we don't debug that browser
    showContext: function(browser, context)
    {
        // the context becomes the default for its view
        Firebug.chrome.setFirebugContext(context);

        // resume, after setting Firebug.currentContext
        // The condition is appended to solve issue 5916
        // 1) If a new tab is opened by clicking a link in an existing tab, HTTP request
        //    is started in the existing tab.
        // 2) New tab is always set to about:blank at the beginning and there is no
        //    context for it.
        // 3) Consequently the tab watcher calls 'showContext' with context == null
        //    and Firebug.connection.toggleResume suspends Firebug for all existing
        //    contexts including the one which started the new tab.
        // 4) The request displayed in the HTTP panel never finishes since even the
        //    Net panel stops listening and calls unmonitorContext, see
        //    {@Firebug.NetMonitor.onSuspendFirebug}
        //
        // So, do not resume/suspend for "about:blank" pages.
        if (browser.contentWindow.location.href != "about:blank")
            Firebug.connection.toggleResume(context);

        // tell modules we may show UI
        Events.dispatch(Firebug.modules, "showContext", [browser, context]);

        Firebug.showContext(browser, context);
    },

    // The context for this browser has been destroyed and removed.
    unwatchBrowser: function(browser)
    {
        Firebug.connection.toggleResume(false);
    },

    // Either a top level or a frame (interior window) for an existing context is seen by the TabWatcher.
    watchWindow: function(context, win)
    {
        for (var panelName in context.panelMap)
        {
            var panel = context.panelMap[panelName];
            panel.watchWindow(context, win);
        }

        Events.dispatch(Firebug.modules, "watchWindow", [context, win]);
    },

    unwatchWindow: function(context, win)
    {
        for (var panelName in context.panelMap)
        {
            var panel = context.panelMap[panelName];
            panel.unwatchWindow(context, win);
        }

        Events.dispatch(Firebug.modules, "unwatchWindow", [context, win]);
    },

    loadWindow: function(context, win)
    {
        for (var panelName in context.panelMap)
        {
            var panel = context.panelMap[panelName];
            panel.loadWindow(context, win);
        }

        Events.dispatch(Firebug.modules, "loadWindow", [context, win]);
    },

    loadedContext: function(context)
    {
        if (!context.browser.currentURI)
            FBTrace.sysout("BTI.firebug.loadedContext problem browser ", context.browser);

        Events.dispatch(Firebug.modules, "loadedContext", [context]);
    },

    destroyContext: function(context, persistedState, browser)
    {
        // then we are called just to clean up
        if (!context)
            return;

        Events.dispatch(Firebug.modules, "destroyContext", [context, persistedState]);

        // xxxHonza: Not sure if this code is correct. Test case: Firebug active, reload
        // 1) The Firebug.currentContext can be already set to the new one
        // 2) The Firebug.currentContext can be already null.
        // Calling clearPanels() is important, because it also clears the statusPath, which
        // contains references to panel objects (e.g. the page document in case of the HTML panel)
        if (Firebug.currentContext == context || !Firebug.currentContext)
        {
            // disconnect the to-be-destroyed panels from the panelBar
            Firebug.chrome.clearPanels();
            // Firebug.currentContext is about to be destroyed
            Firebug.chrome.setFirebugContext(null);
        }

        var browser = context.browser;

        // Persist remnants of the context for restoration if the user reloads
        try
        {
            browser.panelName = context.panelName;
            browser.sidePanelNames = context.sidePanelNames;
        }
        catch (e)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("browser.destroyContext; " + e, e);
        }

        // Next time the context is deleted and removed from the Firebug.TabWatcher,
        // we clean up in unWatchBrowser.
    },

    onSourceFileCreated: function()
    {
        Events.dispatch(Firebug.modules, "onSourceFileCreated", arguments);
    },

    shouldCreateContext: function()
    {
        if (Events.dispatch2(Firebug.modules, "shouldCreateContext", arguments))
            return true;
        else
            return false;
    },

    shouldNotCreateContext: function()
    {
        if (Events.dispatch2(Firebug.modules, "shouldNotCreateContext", arguments))
            return true;
        else
            return false;
    },

    shouldShowContext: function()
    {
        if (Events.dispatch2(Firebug.modules, "shouldShowContext", arguments))
            return true;
        else
            return false;
    }
};

// ********************************************************************************************* //

Browser.prototype.connect = function ()
{
    // Events fired on browser are re-broadcasted to Firebug.modules
    Firebug.connection.addListener(Firebug);

    // Listen for preference changes. This way the options module is not dependent on tools
    // xxxHonza: can this be in Browser interface?
    Options.addListener(
    {
        updateOption: function(name, value)
        {
            Firebug.connection.dispatch("updateOption", [name, value]);
        }
    });

    TabWatcher.initialize();
    TabWatcher.addListener(TabWatchListener);

    this._setConnected(true);
};

// ********************************************************************************************* //

return exports = Browser;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

// ********************************************************************************************* //
// Module

var EXPORTED_SYMBOLS = ["CompilationUnit"];

define("firebug/bti/inProcess/compilationunit",
[], function(){

// ********************************************************************************************* //
// Compilation Unit

/**
 * Describes a compilation unit in a browser context. A compilation unit
 * may originate from a JavaScript source file or a script element in HTML.
 *
 * @constructor
 * @param url compilation unit URL - a {@link String} or <code>null</code> if none
 * @param context the {@link BrowserContext} this compilation unit is contained in
 * @type CompilationUnit
 * @return a new CompilationUnit
 * @version 1.0
 */
function CompilationUnit(url, context)
{
    this.url = url;
    this.context = context;
    this.breakpoints = [];
    this.numberOfLines = 0;
    this.kind = CompilationUnit.SCRIPT_TAG;

    // Compatibility with SourceLink. There are places where 'href' field is expected.
    // xxxHonza: should be investigated in 1.9
    this.href = url;
}

/**
 * Kinds of Compilation Units
 */
CompilationUnit.SCRIPT_TAG = "script_tag";
CompilationUnit.EVAL = "eval";
CompilationUnit.BROWSER_GENERATED = "event";

// ********************************************************************************************* //
// API

/**
 * Returns the Kind of Compilation Unit
 * <p>
 * This function does not require communication with
 * the browser.
 * </p>
 */
CompilationUnit.prototype.getKind = function getKind()
{
    return this.kind;
};

CompilationUnit.prototype.isExecutableLine = function isExecutableLine(lineNo)
{
    // TODO no sourceFiles!
    return this.sourceFile.isExecutableLine(lineNo);
};

/**
 * Returns the URL of this compilation unit.
 * <p>
 * This function does not require communication with
 * the browser.
 * </p>
 *
 * @function
 * @returns compilation unit identifier as a {@link String}
 */
CompilationUnit.prototype.getURL = function()
{
    return this.url;
};

/**
 * Returns the browser context this compilation unit was compiled in.
 * <p>
 * This function does not require communication with
 * the browser.
 * </p>
 *
 * @function
 * @returns a {@link BrowserContext}
 */
CompilationUnit.prototype.getBrowserContext = function()
{
    return this.context;
};

/**
 * Returns the breakpoints that have been created in this compilation unit and
 * have not been cleared.
 * <p>
 * This function does not require communication with
 * the browser.
 * </p>
 * @function
 * @returns an array of {@link Breakpoint}'s
 */
CompilationUnit.prototype.getBreakpoints = function()
{
    // Return a copy of the breakpoints, so the master copy is not corrupted.
    var bps = [];
    for ( var i = 0; i < this.breakpoints.length; i++)
        bps.push(this.breakpoints[i]);
    return bps;
};

CompilationUnit.prototype.eachBreakpoint = function( fnOfLineProps )
{
     Firebug.Debugger.fbs.enumerateBreakpoints(this.getURL(), { call:
         function(url, line, props, scripts)
         {
              fnOfLineProps(line, props);
         }
     });
};

/**
 * Requests the source of this compilation unit asynchronously. Source will be
 * retrieved from the browser and reported back to the listener function when available.
 * The handler may be called before or after this function returns.
 * <p>
 * TODO: what if the compilation unit no longer exists in the browser
 * </p>
 * @function
 * @param firstLineNumber requested line number starting point; < 1 means from lowest line number
 * @param lastLineNumber request last line number; < 1 means up to maximum line
 * @param listener a listener (function) that accepts (compilationUnit, firstLineNumber,
 *      lastLineNumber, array of source code lines)
 */
CompilationUnit.prototype.getSourceLines = function(firstLine, lastLine, listener)
{
    // xxxHonza: Do not cache the source lines in the compilation unit.
    // The Script panel doesn't display the whole script if it's downloaded
    // partially and the following caching happens sooner.
    // Or tabCache.storeSplitLines should trigger an update.
    //if (!this.lines)

    // TODO remove - a comment from xxxJJB.
    this.lines = this.sourceFile.loadScriptLines(this.context);

    this.numberOfLines = (this.lines ? this.lines.length : 0);
    listener(this, 1, this.numberOfLines, this.lines);
};

/**
 * Request the current estimated number of source lines in the entire compilationUnit
 */
CompilationUnit.prototype.getNumberOfLines = function()
{
    return this.numberOfLines;
};

/**
 * Requests to create a breakpoint in this compilation unit asynchronously. A breakpoint
 * creation request will be sent to the browser and an <code>onToggleBreakpoint</code>
 * event will be sent by the browser when the breakpoint is installed.
 * <p>
 * <ul>
 * <li>TODO: onToggleBreakpoint event is not spec'd - is this the intended use?</li>
 * <li>TODO: line number out of range</li>
 * <li>TODO: compilation unit no longer exists in the browser</li>
 * <li>TODO: breakpoint already set</li>
 * <li>TODO: is line number 0 or 1 based</li>
 * </ul>
 * </p>
 * @function
 * @param lineNumber the source line number in this compilation unit to set the breakpoint on
 * @return the {@link Breakpoint} that was created
 */

// ********************************************************************************************* //
// Private

/**
 * Adds the specified breakpoint to this compilation unit's collection of breakpoints.
 * Implementation should call this method when a breakpoint is created in a compilation
 * unit.
 *
 * @param breakpoint the breakpoint that was created
 * @function
 */
CompilationUnit.prototype._addBreakpoint = function(breakpoint)
{
    this.breakpoints.push(breakpoint);
};

/**
 * Removes the specified breakpoint from this compilation unit's collection of breakpoints.
 * Implementation should call this method when a breakpoint is cleared from a compilation
 * unit.
 *
 * @param breakpoint the breakpoint that was removed
 * @function
 */
CompilationUnit.prototype._removeBreakpoint = function(breakpoint)
{
    for ( var i = 0; i < this.breakpoints.length; i++)
    {
        if (this.breakpoints[i] === breakpoint)
        {
            this.breakpoints.splice(i, 1);
            return;
        }
    }
};

// ********************************************************************************************* //
// CommonJS

exports = CompilationUnit;
return CompilationUnit;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

// ********************************************************************************************* //
// Module

define("firebug/bti/inProcess/javascripttool",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/tool",
    "firebug/js/debugger",  // TODO firefox/jsdebugger
    "arch/compilationunit"
],
function initializeJavaScriptTool(Module, Obj, Firebug, Tool, JSDebugger, CompilationUnit) {

// ********************************************************************************************* //
// Implement JavaScript tool for Firefox inProcess

var JavaScriptTool = Obj.extend(Module,
{
    dispatchName: "JavaScriptTool",
});

/**
 * A Turn is an call stack for an active being-handled event, similar to a thread.
 * Currently it only makes sense, when we have stopped the server.
 * Currently only one or zero Turn objects can exist ("single-threaded").
 */
JavaScriptTool.Turn =
{
};

JavaScriptTool.breakOnNext = function(context, enable)
{
    if (enable)
        JSDebugger.suspend(context);
    else
        JSDebugger.unSuspend(context);
};

JavaScriptTool.setBreakpoint = function(context, url, lineNumber)
{
    // TODO we should be sending URLs over, not compilation units
    var compilationUnit = context.getCompilationUnit(url);
    JSDebugger.setBreakpoint(compilationUnit, lineNumber);
};

JavaScriptTool.clearBreakpoint = function(context, url, lineNumber)
{
    // This is more correct, but bypasses Debugger
    JSDebugger.fbs.clearBreakpoint(url, lineNumber);
};

JavaScriptTool.enableBreakpoint = function(context, url, lineNumber)
{
    JSDebugger.fbs.enableBreakpoint(url, lineNumber);
};

JavaScriptTool.disableBreakpoint = function(context, url, lineNumber)
{
    JSDebugger.fbs.disableBreakpoint(url, lineNumber);
};

JavaScriptTool.isBreakpointDisabled = function(context, url, lineNumber)
{
    return JSDebugger.fbs.isBreakpointDisabled(url, lineNumber);
};

JavaScriptTool.getBreakpointCondition = function(context, url, lineNumber)
{
    return JSDebugger.fbs.getBreakpointCondition(url, lineNumber);
};

// ********************************************************************************************* //
// These functions should be on the stack instead.

JavaScriptTool.rerun = function(context)
{
    JSDebugger.rerun(context);
};

JavaScriptTool.resumeJavaScript = function(context)
{
  JSDebugger.resume(context);
};

JavaScriptTool.stepOver = function(context)
{
    JSDebugger.stepOver(context);
};

JavaScriptTool.stepInto = function(context)
{
    JSDebugger.stepInto(context);
};

JavaScriptTool.stepOut = function(context)
{
    JSDebugger.stepOut(context);
};

JavaScriptTool.runUntil = function(compilationUnit, lineNumber)
{
    JSDebugger.runUntil(compilationUnit.getBrowserContext(), compilationUnit,
        lineNumber, JSDebugger);
};

/**
 * Browser connection
 */
JavaScriptTool.onConnect = function(connection)
{
    if (!Firebug.connection.getTool("script"))
    {
        // this is the script tool
        JavaScriptTool.asTool = new Tool("script"),
        connection.registerTool(JavaScriptTool.asTool);
    }
    else
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("JavaScriptTool onConnect ERROR script tool already registered");
    }
};

JavaScriptTool.onDisconnect = function(connection)
{
    if (JavaScriptTool.asTool)
        connection.unregisterTool(JavaScriptTool.asTool);
};

/**
 * Command the backend to enable JS
 */
JavaScriptTool.setActivation = function(enable)
{
    if (FBTrace.DBG_CONSOLE || FBTrace.DBG_ACTIVATION)
        FBTrace.sysout("ScriptPanel.onActivationChanged; " + enable);

    if (enable)
        JSDebugger.addObserver(this);
    else
        JSDebugger.removeObserver(this);
};

/**
 * A previously enabled tool becomes active and sends us an event.
 */
JavaScriptTool.onActivateTool = function(toolname, active)
{
    if (FBTrace.DBG_ACTIVATION)
    {
        FBTrace.sysout("JavaScriptTool.onActivateTool "+toolname+" = "+active+" asTool "+
            JavaScriptTool.asTool);
    }

    if (toolname === "script")
    {
        Firebug.ScriptPanel.prototype.onJavaScriptDebugging(active);
        Firebug.connection.eachContext(function refresh(context)
        {
            context.invalidatePanels('script');
        });
        JavaScriptTool.asTool.setActive(active);
        Firebug.connection.dispatch("onDebuggerEnabled", [active]);
    }
},

/**
 * @param context context of the newest frame, where the breakpoint hit
 * @param frame newest StackFrame (crossbrowser) eg where the break point hit
 */
JavaScriptTool.onStartDebugging = function(context, frame)
{
    Firebug.selectContext(context);
    var panel = Firebug.chrome.selectPanel("script");
    if (!panel)
    {
        // Bail out if there is no UI
        JavaScriptTool.resumeJavaScript(context);
        return;
    }

    if (FBTrace.DBG_STACK)
        FBTrace.sysout("javascripttool currentFrame ", frame);

    JavaScriptTool.Turn.currentFrame = frame;
    panel.onStartDebugging(frame);
};

JavaScriptTool.onStopDebugging = function(context)
{
    var panel = context.getPanel("script", true);
    // Then we are looking at the Script panel.
    if (panel && panel === Firebug.chrome.getSelectedPanel())
    {
        // unhighlight and remove toolbar-status line
        panel.showNoStackFrame();
    }

    if (panel)
        panel.onStopDebugging();

    delete JavaScriptTool.Turn.currentFrame;
};

JavaScriptTool.onCompilationUnit = function(context, url, kind)
{
     var compilationUnit = new CompilationUnit(url, context);

     compilationUnit.kind = kind;

     context.compilationUnits[url] = compilationUnit;

     if (FBTrace.DBG_COMPILATION_UNITS)
     {
         FBTrace.sysout("JavaScriptTool.onCompilationUnit "+url+" added to "+context.getName(),
             compilationUnit);
     }
};

JavaScriptTool.initialize = function()
{
    if (FBTrace.DBG_INITIALIZE)
        FBTrace.sysout("JavaScriptTool initialize");

    // This is how we get events.
    Firebug.connection.addListener(JavaScriptTool);
};

JavaScriptTool.shutdown = function()
{
    // This is how we get events.
    Firebug.connection.removeListener(JavaScriptTool);
};

// ********************************************************************************************* //
// Registration

Firebug.registerModule(JavaScriptTool);

return JavaScriptTool;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/bti/inProcess/webApp",
[
],
function webAppFactory() {

// ********************************************************************************************* //

// WebApp: unit of related browsing contexts.
// http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#groupings-of-browsing-contexts
var WebApp = function(win)
{
    this.topMostWindow = win;
};

/**
 * The Window of the top-level browsing context, aka 'top'
 * http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#top-level-browsing-context
 */
WebApp.prototype =
{
    getTopMostWindow: function()
    {
        return this.topMostWindow;
    }
};

// ********************************************************************************************* //
// Registration

return WebApp;

// ********************************************************************************************* //
});/* See license.txt for terms of usage */

define("firebug/chrome/activableModule",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/array",
    "firebug/chrome/module"
],
function(Firebug, FBTrace, Obj, Arr, Module) {

"use strict";

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// Implementation

/**
 * @module Should be used by modules (Firebug specific task controllers) that supports
 * activation. An example of such 'activable' module can be the debugger module
 * {@link Firebug.Debugger}, which can be disabled in order to avoid performance
 * penalties (in cases where the user doesn't need a debugger for the moment).
 */
var ActivableModule = Obj.extend(Module,
/** @lends ActivableModule */
{
    /**
     * Every activable module is disabled by default waiting for on a panel
     * that wants to have it enabled (and display provided data). The rule is
     * if there is no panel (view) the module is disabled.
     */
    enabled: false,

    /**
     * List of observers (typically panels). If there is at least one observer registered
     * The module becomes active.
     */
    observers: null,

    /**
     * List of dependent modules.
     */
    dependents: null,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function()
    {
        Module.initialize.apply(this, arguments);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Observers (dependencies)

    hasObservers: function()
    {
        return this.observers ? this.observers.length > 0 : false;
    },

    addObserver: function(observer)
    {
        if (!this.observers)
            this.observers = [];

        if (this.observers.indexOf(observer) === -1)
        {
            this.observers.push(observer);
            this.onObserverChange(observer);  // targeted, not dispatched.
        }
        // else no-op
    },

    removeObserver: function(observer)
    {
        if (!this.observers)
            return;

        if (this.observers.indexOf(observer) !== -1)
        {
            Arr.remove(this.observers, observer);
            this.onObserverChange(observer);  // targeted, not dispatched
        }
        // else no-op
    },

    /**
     * This method is called if an observer (e.g. {@link Panel}) is added or removed.
     * The module should decide about activation/deactivation upon existence of at least one
     * observer.
     */
    onObserverChange: function(observer)
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug Activation

    onSuspendingFirebug: function()
    {
        // Called before any suspend actions. First caller to return true aborts suspend.
    },

    onSuspendFirebug: function()
    {
        // When the number of activeContexts decreases to zero. Modules should remove
        // listeners, disable function that takes resources
    },

    onResumeFirebug: function()
    {
        // When the number of activeContexts increases from zero. Modules should undo the
        // work done in onSuspendFirebug
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module enable/disable APIs.

    isEnabled: function()
    {
        return this.hasObservers();
    },

    isAlwaysEnabled: function()
    {
        return this.hasObservers();
    }
});

// ********************************************************************************************* //
// Registration

// xxxHonza: backward compatibility
Firebug.ActivableModule = ActivableModule;

return ActivableModule;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/activablePanel",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/options",
    "firebug/chrome/panel",
],
function(Firebug, FBTrace, Obj, Options, Panel) {

"use strict";

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// Implementation

/**
 * @panel This object represents a panel with two states: enabled/disabled. Such support
 * is important for panel that represents performance penalties and it's useful for the
 * user to have the option to disable them.
 *
 * All methods in this object are used on the prototype object (they represent class methods)
 * and so, |this| points to the panel's prototype and *not* to the panel instance.
 */
var ActivablePanel = Obj.extend(Panel,
/** @lends ActivablePanel */
{
    activable: true,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    isActivable: function()
    {
        return this.activable;
    },

    isEnabled: function()
    {
        if (!this.isActivable())
            return true;

        if (!this.name)
            return false;

        return Options.get(this.name + ".enableSites");
    },

    setEnabled: function(enable)
    {
        if (!this.name || !this.activable)
            return;

        Options.set(this.name + ".enableSites", enable);
    },

    /**
     * Called when an instance of this panel type is enabled or disabled. Again notice that
     * this is a class method and so, panel instance variables (like e.g. context) are
     * not accessible from this method.
     * @param {Object} enable Set to true if this panel type is now enabled.
     */
    onActivationChanged: function(enable)
    {
        // TODO: Use ActivableModule.addObserver to express dependencies on modules.
    },
});

// ********************************************************************************************* //
// Registration

// xxxHonza: backward compatibility
Firebug.ActivablePanel = ActivablePanel;

return ActivablePanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/activation",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/locale",
    "firebug/lib/url",
    "firebug/chrome/tabWatcher",
    "firebug/chrome/annotations",
    "firebug/chrome/firefox",
],
function(Module, Obj, Firebug, Locale, Url, TabWatcher, Annotations, Firefox) {

"use strict";

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //

/**
 * @module Implements Firebug activation logic.
 *
 * 1) Part of the logic is based on annotation service (see components/firebug-annotations.js)
 *    in order to remember whether Firebug is activated for given site or not.
 *    If there is "firebugged.showFirebug" annotation for a given site Firebug is activated.
 *    If there is "firebugged.closed" annotation for a given site Firebug is not activated.
 *
 * 2) Other part is based on extensions.firebug.allPagesActivation option. This option
 *    can be set to the following values:
 *    none: The option isn't used (default value)
 *    on:   Firebug is activated for all URLs.
 *    off:  Firebug is never activated.
 *
 *    This logic has higher priority over the URL annotations.
 *    If "off" options is selected, all existing URL annotations are removed.
 */
Firebug.Activation = Obj.extend(Module,
{
    dispatchName: "activation",

    // called once
    initializeUI: function()
    {
        Module.initializeUI.apply(this, arguments);

        TabWatcher.initializeUI();
        TabWatcher.addListener(this);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        TabWatcher.removeListener(this);
    },

    // true if the Places annotation the URI "firebugged"
    shouldCreateContext: function(browser, url, userCommands)
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("shouldCreateContext allPagesActivation " +
                Firebug.allPagesActivation);

        if (Firebug.allPagesActivation == "on")
            return true;

        // This condition has been introduced to disable Firebug for about:blank
        // which caused issue 1483 to fail. However, there are cases when users
        // want to inspect even system pages (such as about:blank) and don't want
        // Firebug UI to be automatically hidden (see issue 5632).
        // Since issue 1483 doesn't fail anymore, the condition is removed.
        //if (Firebug.filterSystemURLs && Url.isSystemURL(url))
        //    return false;

        if (userCommands)
            return true;

        // document.open on a Firebugged page
        if (browser && browser.showFirebug && url.substr(0, 8) === "wyciwyg:")
            return true;

        try
        {
            var uri = this.convertToURIKey(url, Firebug.activateSameOrigin);
            if (!uri)
                return false;

            var hasAnnotation = Annotations.pageHasAnnotation(uri);

            if (FBTrace.DBG_ACTIVATION)
            {
                FBTrace.sysout("shouldCreateContext hasAnnotation " + hasAnnotation +
                    " for " + uri.spec + " in " +
                    (browser ? browser.contentWindow.location : "no browser") +
                    " using activateSameOrigin: " + Firebug.activateSameOrigin);
            }

            // Annotated, so return the value.
            if (hasAnnotation)
                return this.checkAnnotation(browser, uri);

            // Then Firebug.TabWatcher found a connection.
            if (browser.FirebugLink)
            {
                var dst = browser.FirebugLink.dst;
                var dstURI = this.convertToURIKey(dst.spec, Firebug.activateSameOrigin);

                if (FBTrace.DBG_ACTIVATION)
                {
                    FBTrace.sysout("shouldCreateContext found FirebugLink pointing to " +
                        dstURI.spec, browser.FirebugLink);
                }

                // And it matches us now.
                if (dstURI && dstURI.equals(uri))
                {
                    var srcURI = this.convertToURIKey(browser.FirebugLink.src.spec,
                        Firebug.activateSameOrigin);

                    if (srcURI)
                    {
                        if (FBTrace.DBG_ACTIVATION)
                        {
                            FBTrace.sysout("shouldCreateContext found FirebugLink pointing from " +
                                srcURI.spec, browser.FirebugLink);
                        }

                        // And it's on the same domain.
                        if (srcURI.schemeIs("file") || (dstURI.host == srcURI.host))
                        {
                            hasAnnotation = Annotations.pageHasAnnotation(srcURI);
                            // And the source page was annotated.
                            if (hasAnnotation)
                            {
                                var srcShow = this.checkAnnotation(browser, srcURI);
                                // And the source annotation said show it.
                                if (srcShow)
                                {
                                    // So we show dst as well.
                                    this.watchBrowser(browser);
                                }
                                return srcShow;
                            }
                        }
                    }
                }
                else
                {
                    if (FBTrace.DBG_ACTIVATION)
                        FBTrace.sysout("shouldCreateContext FirebugLink does not match " +
                            uri.spec, browser.FirebugLink);
                }
            }
            else if (browser.contentWindow.opener)
            {
                var openerContext = Firebug.TabWatcher.getContextByWindow(
                    browser.contentWindow.opener);

                if (FBTrace.DBG_ACTIVATION)
                    FBTrace.sysout("shouldCreateContext opener found, has " +
                        (openerContext ? "a " : "no ") + " context: " +
                        browser.contentWindow.opener.location);

                if (openerContext)
                {
                    // popup windows of Firebugged windows are Firebugged
                    return true;
                }
            }

            // don't createContext
            return false;
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("pageHasAnnotation FAILS for url: " + url + " which gave uri " +
                    (uri ? uri.spec : "null"), exc);
            }
        }
    },

    shouldShowContext: function(context)
    {
        return this.shouldCreateContext(context.browser, context.getWindowLocation().toString());
    },

    // Firebug is opened in the browser.
    watchBrowser: function(browser)
    {
        try
        {
            var annotation = "firebugged.showFirebug";
            this.setPageAnnotation(browser.currentURI.spec, annotation);
        }
        catch (e)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("activation.watchBrowser; EXCEPTION " + e, e);
        }
    },

    // Firebug closes in the browser.
    unwatchBrowser: function(browser, userCommands)
    {
        var uri = browser.currentURI.spec;
        // Then mark to not open virally.
        if (userCommands)
        {
            this.setPageAnnotation(uri, "firebugged.closed");
        }
        else
        {
            // unmark this URI
            this.removePageAnnotation(uri);
        }
    },

    clearAnnotations: function()
    {
        Annotations.clear();
        Annotations.flush();

        Firebug.connection.dispatch("onClearAnnotations", []);
    },

    // Process the URL to canonicalize it. This needs not be reversible.
    convertToURIKey: function(url, sameOrigin)
    {
        // Remove the fragment. It shouldn't have any impact on the activation.
        url = url.replace(/#.*/, "");

        var uri = Url.makeURI(Url.normalizeURL(url));

        if (Firebug.filterSystemURLs && Url.isSystemURL(url))
            return uri;

        // avoid exceptions
        if (url == "about:blank")
            return uri;

        if (uri && sameOrigin)
        {
            try
            {
                // Returns the string before the path (such as "scheme://user:password@host:port").
                var prePath = uri.prePath;
                var shortURI = Url.makeURI(prePath);
                if (!shortURI)
                    return uri;

                // Annoying "about" URIs throw if .host is accessed
                if (shortURI.scheme === "about")
                    return shortURI;

                if (shortURI.scheme === "file")
                    return shortURI;

                return shortURI;

                // This makes a.co.uk -> co.uk, mail.cn.mozilla.com -> cn.mozilla.com and 
                // blog.getfirebug.com -> getfirebug.com, which is wrong. See issue 2202.)
                /*
                var host = shortURI.host;
                if (host)
                {
                    // Slice the subdomain (if any) from the URL so that activateSameOrigin works
                    // for domains (including TLD domains). So we want:
                    // 1) www.google.com -> google.com
                    // 2) www.stuff.co.nz -> stuff.co.nz
                    // 3) getfirebug.com -> getfirebug.com
                    var levels = host.split('.');
                    if (levels.length > 2)
                        levels = levels.slice(1);
                    shortURI.host = levels.join('.');
                    return shortURI;
                }
                */
            }
            catch (exc)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("activation.convertToURIKey returning full URI, " +
                        "activateSameOrigin FAILS for shortURI " + shortURI + " because: " + exc,
                        exc);

                return uri;
            }
        }

        return uri;
    },

    checkAnnotation: function(browser, uri)
    {
        var annotation = Annotations.getPageAnnotation(uri);

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("shouldCreateContext read back annotation " + annotation +
                " for uri " + uri.spec);

        // Then the user closed Firebug on this page last time.
        if ((Firebug.allPagesActivation != "on") && (annotation.indexOf("closed") > 0))
        {
            // annotated as 'closed', don't create
            return false;
        }
        else
        {
            // annotated, createContext
            return true;
        }
    },

    setPageAnnotation: function(currentURI, annotation)
    {
        var uri = this.convertToURIKey(currentURI, Firebug.activateSameOrigin);
        if (uri)
            Annotations.setPageAnnotation(uri, annotation);

        if (FBTrace.DBG_ACTIVATION || FBTrace.DBG_ANNOTATION)
            FBTrace.sysout("setPageAnnotation currentURI " + currentURI + " becomes URI key "+
                (uri ? uri.spec : "ERROR"));

        if (Firebug.activateSameOrigin)
        {
            uri = this.convertToURIKey(currentURI, false);
            if (uri)
                Annotations.setPageAnnotation(uri, annotation);

            if (FBTrace.DBG_ACTIVATION || FBTrace.DBG_ANNOTATION)
                FBTrace.sysout("setPageAnnotation with activeSameOrigin currentURI " +
                    currentURI.spec + " becomes URI key " + (uri ? uri.spec : "ERROR"));
        }
    },

    removePageAnnotation: function(currentURI)
    {
        var uri = this.convertToURIKey(currentURI, Firebug.activateSameOrigin);
        if (uri)
            Annotations.removePageAnnotation(uri);

        if (Firebug.activateSameOrigin)
        {
            uri = this.convertToURIKey(currentURI, false);
            if (uri)
                Annotations.removePageAnnotation(uri);
        }

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("Firebug.Activation.unwatchBrowser untagged "+uri.spec);
    },

    // Stops at the first fn(uri) that returns a true value.
    iterateAnnotations: function(fn)
    {
        var annotations = Annotations.getAnnotations(this.annotationName);
        for (var uri in annotations)
        {
            var rc = fn(uri, annotations[uri]);
            if (rc)
                return rc;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Options

    /**
     * After all options (and annotations) have been reset make sure to set
     * a new annotation for the current URL.
     * The annotation will ensure Firebug to be visible after refresh.
     */
    afterResetAllOptions: function()
    {
        // Only reset the annotation if Firebug is active for the current URL.
        if (!Firebug.currentContext)
            return;

        var currentURI = Firefox.getCurrentURI();
        var annotation = "firebugged.showFirebug";

        this.setPageAnnotation(currentURI.spec, annotation);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.Activation);

return Firebug.Activation;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/annotations",
[
    "firebug/chrome/module",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/chrome/privacy",
],
function(Module, FBTrace, Obj, Privacy) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

var dirService = Cc["@mozilla.org/file/directory_service;1"].getService(Ci.nsIProperties);

// ********************************************************************************************* //
// Annotation

/**
 * @class Represents an internal Firebug annotation service. This service is used to
 * annotate sites with an info whether Firebug should be activated for them or not.
 */
var Annotations = Obj.extend(Module,
{
    annotations: [],

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    initialize: function()
    {
        // Get annotation file stored within the profile directory.
        this.file = dirService.get("ProfD", Ci.nsIFile);
        this.file.append("firebug");
        this.file.append("annotations.json");

        // Load annotations.
        this.loadAnnotations();

        Privacy.addListener(this);
    },

    shutdown: function()
    {
        this.flush();

        Privacy.removeListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Public Methods

    setPageAnnotation: function(uri, value)
    {
        if (FBTrace.DBG_ANNOTATIONS)
            FBTrace.sysout("Annotations.setPageAnnotation; " + value + ", " + uri.spec);

        this.annotations[uri.spec] = value;
    },

    getPageAnnotation: function(uri)
    {
        return this.annotations[uri.spec];
    },

    pageHasAnnotation: function(uri)
    {
        return this.annotations[uri.spec] ? true : false;
    },

    removePageAnnotation: function(uri)
    {
        if (FBTrace.DBG_ANNOTATIONS)
            FBTrace.sysout("Annotations.removePageAnnotation; " + uri.spec);

        delete this.annotations[uri.spec];
    },

    getAnnotations: function()
    {
        return this.annotations;
    },

    clear: function()
    {
        this.annotations = [];
    },

    flush: function(force)
    {
        // Do not store anything if private-browsing mode is on.
        if (!force && Privacy.isPrivateBrowsing())
            return;

        try
        {
            // Initialize output stream.
            var outputStream = Cc["@mozilla.org/network/file-output-stream;1"]
                .createInstance(Ci.nsIFileOutputStream);
            // write, create, truncate
            // see https://developer.mozilla.org/en-US/docs/PR_Open#Parameters
            outputStream.init(this.file, 0x02 | 0x08 | 0x20, 0666, 0);

            // Convert data to JSON.
            var arr = [];
            for (var uri in this.annotations)
            {
                arr.push({
                    uri: uri,
                    value: this.annotations[uri]
                });
            }

            var jsonString = JSON.stringify(arr);

            // Store annotations
            outputStream.write(jsonString, jsonString.length);
            outputStream.close();

            if (FBTrace.DBG_ANNOTATIONS)
                FBTrace.sysout("Annotations.loadAnnotations; Annotations stored to " +
                    this.file.path, jsonString);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS || FBTrace.DBG_ANNOTATIONS)
                FBTrace.sysout("Annotations.flush; EXCEPTION", err);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Internals

    // Persistence
    loadAnnotations: function()
    {
        try
        {
            this.clear();

            if (!this.file.exists())
            {
                this.file.create(Ci.nsIFile.NORMAL_FILE_TYPE, 0666);
                if (FBTrace.DBG_ANNOTATIONS)
                    FBTrace.sysout("Annotations.loadAnnotations; Annotations file created " +
                        this.file.path);
                return;
            }

            var inputStream = Cc["@mozilla.org/network/file-input-stream;1"]
                .createInstance(Ci.nsIFileInputStream);
            var cstream = Cc["@mozilla.org/intl/converter-input-stream;1"]
                .createInstance(Ci.nsIConverterInputStream);

            // loadAnnotations input stream
            // read, create
            inputStream.init(this.file, 0x01 | 0x08, 0666, 0);
            cstream.init(inputStream, "UTF-8", 0, 0);

            // Load annotations
            var json = "";
            var data = {};
            while (cstream.readString(-1, data) != 0)
                json += data.value;

            if (!json.length)
                return;

            var arr = JSON.parse(json);
            if (!arr)
                return;

            // convert to map for faster lookup
            for (var i=0; i<arr.length; i++)
                this.annotations[arr[i].uri] = arr[i].value;

            if (FBTrace.DBG_ANNOTATIONS)
                FBTrace.sysout("Annotations.loadAnnotations; Annotations loaded from " +
                    this.file.path, arr);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS || FBTrace.DBG_ANNOTATIONS)
                FBTrace.sysout("Annotations.loadAnnotations; EXCEPTION", err);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Privacy

    onPrivateBrowsingChange: function(enabled)
    {
        if (enabled)
        {
            this.flush(true);
            this.clear();
        }
        else
        {
            this.loadAnnotations();
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Options

    resetAllOptions: function()
    {
        // "Reset all options" removes all annotations even if the browser window
        // is currently in private mode.
        this.clear();
        this.flush(true);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.Annotations = Annotations;

Firebug.registerModule(Annotations);

return Annotations;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/balloonNote",
[
    "firebug/lib/domplate"
],
function(Domplate) {

"use strict";

// ********************************************************************************************* //
// Constants

Firebug.BalloonNote = function(doc, object)
{
    this.initialize(doc, object);
};

var {domplate, DIV, SPAN, TAG} = Domplate;

Firebug.BalloonNote.prototype = domplate(
{
    tag:
        DIV({"class": "balloon", onclick: "$onClick"},
            DIV({"class": "balloonTop1"},
                DIV({"class": "balloonTop2"})
            ),
            DIV({"class": "balloonInner1"},
                DIV({"class": "balloonInner2"},
                    DIV({"class": "balloonInner3"},
                        DIV({"class": "balloonInner4"},
                            SPAN({"class": "balloonCloseButton closeButton",
                                onclick: "$onCloseAction"}),
                            DIV({"class": "balloonContent"},
                                TAG("$cause|getContentTag", {cause: "$cause"})
                            )
                        )
                    )
                )
            ),
            DIV({"class": "balloonBottom1"},
                DIV({"class": "balloonBottom2"})
            )
        ),

    getContentTag: function(object)
    {
        return DIV(object.message);
    },

    onCloseAction: function()
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    initialize: function(doc, object)
    {
        // xxxHonza: TODO: this object should implement the whole show/hide logic
        // move from Firebug.BreakNotification
    }
});

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

/**
 * The 'context' in this file is always 'Firebug.currentContext'
 */
define("firebug/chrome/chrome",
[
    "firebug/lib/object",
    "firebug/chrome/firefox",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/system",
    "firebug/chrome/menu",
    "firebug/chrome/toolbar",
    "firebug/lib/url",
    "firebug/lib/locale",
    "firebug/lib/string",
    "firebug/lib/events",
    "firebug/js/fbs",
    "firebug/chrome/window",
    "firebug/lib/options"
],
function chromeFactory(Obj, Firefox, Dom, Css, System, Menu, Toolbar, Url, Locale, String,
    Events, FBS, Win, Options) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const nsIWebNavigation = Ci.nsIWebNavigation;

const wm = Cc["@mozilla.org/appshell/window-mediator;1"].getService(Ci.nsIWindowMediator);

const LOAD_FLAGS_BYPASS_PROXY = nsIWebNavigation.LOAD_FLAGS_BYPASS_PROXY;
const LOAD_FLAGS_BYPASS_CACHE = nsIWebNavigation.LOAD_FLAGS_BYPASS_CACHE;
const LOAD_FLAGS_NONE = nsIWebNavigation.LOAD_FLAGS_NONE;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// URLs used in the Firebug Menu and several other places
const firebugURLs =
{
    main: "https://getfirebug.com",
    help: "https://getfirebug.com/help",
    FAQ: "https://getfirebug.com/wiki/index.php/FAQ",
    docs: "https://getfirebug.com/docs.html",
    keyboard: "https://getfirebug.com/wiki/index.php/Keyboard_and_Mouse_Shortcuts",
    discuss: "https://groups.google.com/forum/#!forum/firebug",
    issues: "http://code.google.com/p/fbug/issues/list?can=1",
    donate: "https://getfirebug.com/getinvolved",
    extensions: "https://getfirebug.com/wiki/index.php/Firebug_Extensions",
    issue5110: "http://code.google.com/p/fbug/issues/detail?id=5110"
};

const statusCropSize = 20;

// ********************************************************************************************* //

// factory is global in module loading window
var ChromeFactory =
{

// chrome is created in caller window.
createFirebugChrome: function(win)
{
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Private

    var panelSplitter, sidePanelDeck, panelBar1, panelBar2;

var FirebugChrome =
{
    // TODO: remove this property, add getters for location, title, focusedElement, setter popup
    dispatchName: "FirebugChrome",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    /**
     * Called by panelBarWaiter when XUL panelBar(s) (main and side) are constructed
     * (i.e. the constructor of panelBar binding is executed twice) and when all Firebug
     * modules + extension modules (if any) are loaded.
     */
    initialize: function()
    {
        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("chrome.initialize;");

        this.window = win;

        panelSplitter = this.getElementById("fbPanelSplitter");
        sidePanelDeck = this.getElementById("fbSidePanelDeck");
        panelBar1 = this.getElementById("fbPanelBar1");
        panelBar2 = this.getElementById("fbPanelBar2");

        // Firebug has not been initialized yet
        if (!Firebug.isInitialized)
            Firebug.initialize(this);

        // FBL should be available at this moment.
        if (FBTrace.sysout && (!FBL || !FBL.initialize))
        {
            FBTrace.sysout("Firebug is broken, FBL incomplete, if the last function is QI, " +
                "check lib.js:", FBL);
        }

        var browser1Complete = false;
        var browser2Complete = false;

        if (panelBar1)
        {
            var browser1 = panelBar1.browser;
            browser1Complete = browser1.complete;

            if (!browser1Complete)
                Events.addEventListener(browser1, "load", browser1Loaded, true);

            browser1.droppedLinkHandler = function()
            {
                return false;
            };

            if (FBTrace.DBG_INITIALIZE)
                FBTrace.sysout("chrome.browser1.complete; " + browser1Complete);
        }

        if (panelBar2)
        {
            var browser2 = panelBar2.browser;
            browser2Complete = browser2.complete;

            if (!browser2Complete)
                Events.addEventListener(browser2, "load", browser2Loaded, true);

            browser2.droppedLinkHandler = function()
            {
                return false;
            };

            if (FBTrace.DBG_INITIALIZE)
                FBTrace.sysout("chrome.browser2.complete; " + browser2Complete);
        }

        Events.addEventListener(win, "blur", onBlur, true);

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("chrome.initialized in " + win.location + " with " +
                (panelBar1 ? panelBar1.browser.ownerDocument.documentURI : "no panel bar"), win);

        // At this point both panelBars can be loaded already, since the src is specified
        // in firebugOverlay.xul (asynchronously loaded). If yes, start up the initialization
        // sequence now.
        if (browser1Complete && browser2Complete)
        {
            setTimeout(function()
            {
                // chrome bound into this scope
                FirebugChrome.initializeUI();
            });
        }
    },

    /**
     * Called when the UI is ready to be initialized, once the panel browsers are loaded.
     */
    initializeUI: function()
    {
        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("chrome.initializeUI;");

        // listen for panel updates
        Firebug.registerUIListener(this);

        try
        {
            var cmdPopupBrowser = this.getElementById("fbCommandPopupBrowser");

            this.applyTextSize(Firebug.textSize);

            var doc1 = panelBar1.browser.contentDocument;
            Events.addEventListener(doc1, "mouseover", onPanelMouseOver, false);
            Events.addEventListener(doc1, "mouseout", onPanelMouseOut, false);
            Events.addEventListener(doc1, "mousedown", onPanelMouseDown, false);
            Events.addEventListener(doc1, "mouseup", onPanelMouseUp, false);
            Events.addEventListener(doc1, "click", onPanelClick, false);
            Events.addEventListener(panelBar1, "selectingPanel", onSelectingPanel, false);
            Events.addEventListener(panelBar1, "DOMMouseScroll", onMouseScroll, false);

            var doc2 = panelBar2.browser.contentDocument;
            Events.addEventListener(doc2, "mouseover", onPanelMouseOver, false);
            Events.addEventListener(doc2, "mouseout", onPanelMouseOut, false);
            Events.addEventListener(doc2, "click", onPanelClick, false);
            Events.addEventListener(doc2, "mousedown", onPanelMouseDown, false);
            Events.addEventListener(doc2, "mouseup", onPanelMouseUp, false);
            Events.addEventListener(panelBar2, "selectPanel", onSelectedSidePanel, false);

            var doc3 = cmdPopupBrowser.contentDocument;
            Events.addEventListener(doc3, "mouseover", onPanelMouseOver, false);
            Events.addEventListener(doc3,"mouseout", onPanelMouseOut, false);
            Events.addEventListener(doc3, "mousedown", onPanelMouseDown, false);
            Events.addEventListener(doc3, "click", onPanelClick, false);

            var mainTabBox = panelBar1.ownerDocument.getElementById("fbPanelBar1-tabBox");
            Events.addEventListener(mainTabBox, "mousedown", onMainTabBoxMouseDown, false);

            // The side panel bar doesn't care about this event. It must, however,
            // prevent it from bubbling now that we allow the side panel bar to be
            // *inside* the main panel bar.
            Events.addEventListener(panelBar2, "selectingPanel", stopBubble, false);

            var locationList = this.getElementById("fbLocationList");
            Events.addEventListener(locationList, "selectObject", onSelectLocation, false);

            this.updatePanelBar1(Firebug.panelTypes);

            // Internationalize Firebug UI before firing initializeUI
            // (so putting version into Firebug About menu operates with correct label)
            Firebug.internationalizeUI(win.document);
            Firebug.internationalizeUI(top.document);

            // xxxHonza: Is there any reason why we don't distribute "initializeUI"?
            // event to modules?
            Firebug.initializeUI();

            // Append all registered stylesheets into Firebug UI
            for (var i=0; i<Firebug.stylesheets.length; i++)
            {
                var uri = Firebug.stylesheets[i];
                this.appendStylesheet(uri);
            }

            if (FBTrace.DBG_INITIALIZE)
                FBTrace.sysout("chrome.initializeUI; Custom stylesheet appended " +
                    Firebug.stylesheets.length, Firebug.stylesheets);

            // Fire event for window event listeners
            Firebug.sendLoadEvent();
        }
        catch (exc)
        {
            fatalError("chrome.initializeUI ERROR "+exc, exc);
        }
    },

    shutdown: function()
    {
        var doc1 = panelBar1.browser.contentDocument;
        Events.removeEventListener(doc1, "mouseover", onPanelMouseOver, false);
        Events.removeEventListener(doc1, "mouseout", onPanelMouseOut, false);
        Events.removeEventListener(doc1, "mousedown", onPanelMouseDown, false);
        Events.removeEventListener(doc1, "mouseup", onPanelMouseUp, false);
        Events.removeEventListener(doc1, "click", onPanelClick, false);
        Events.removeEventListener(panelBar1, "selectingPanel", onSelectingPanel, false);
        Events.removeEventListener(panelBar1, "DOMMouseScroll", onMouseScroll, false);

        var doc2 = panelBar2.browser.contentDocument;
        Events.removeEventListener(doc2, "mouseover", onPanelMouseOver, false);
        Events.removeEventListener(doc2, "mouseout", onPanelMouseOut, false);
        Events.removeEventListener(doc2, "mousedown", onPanelMouseDown, false);
        Events.removeEventListener(doc2, "mouseup", onPanelMouseUp, false);
        Events.removeEventListener(doc2, "click", onPanelClick, false);
        Events.removeEventListener(panelBar2, "selectPanel", onSelectedSidePanel, false);
        Events.removeEventListener(panelBar2, "selectingPanel", stopBubble, false);

        var cmdPopupBrowser = this.getElementById("fbCommandPopupBrowser");
        var doc3 = cmdPopupBrowser.contentDocument;
        Events.removeEventListener(doc3, "mouseover", onPanelMouseOver, false);
        Events.removeEventListener(doc3, "mouseout", onPanelMouseOut, false);
        Events.removeEventListener(doc3, "mousedown", onPanelMouseDown, false);
        Events.removeEventListener(doc3, "click", onPanelClick, false);

        var mainTabBox = panelBar1.ownerDocument.getElementById("fbPanelBar1-tabBox");
        Events.removeEventListener(mainTabBox, "mousedown", onMainTabBoxMouseDown, false);

        var locationList = this.getElementById("fbLocationList");
        Events.removeEventListener(locationList, "selectObject", onSelectLocation, false);

        Events.removeEventListener(win, "blur", onBlur, true);

        Firebug.unregisterUIListener(this);

        Firebug.shutdown();

        if (FBTrace.DBG_EVENTLISTENERS)
        {
            var info = [];
            var listeners = Firebug.Events.getRegisteredListeners();
            for (var i=0; i<listeners.length; i++)
            {
                var listener = listeners[i];
                info.push({
                    parentId: listener.parentId,
                    evendId: listener.eventId,
                    capturing: listener.capturing,
                    stack: listener.stack,
                });
            }

            FBTrace.sysout("firebug.shutdownFirebug; listeners: " + info.length, info);
        }

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("chrome.shutdown; Done for " + win.location);
    },

    /**
     * Checks if the Firebug window has the focus (is the most recent window)
     */
    hasFocus: function()
    {
        try
        {
            // If the ID of the active element is related to Firebug, it must have the focus
            var windowID = wm.getMostRecentWindow(null).document.activeElement.id;
            return ["firebug", "fbMainContainer"].indexOf(windowID) !== -1;
        }
        catch(ex)
        {
            return false;
        }
    },

    appendStylesheet: function(uri)
    {
        var cmdPopupBrowser = this.getElementById("fbCommandPopupBrowser");

        var doc1 = panelBar1.browser.contentDocument;
        var doc2 = panelBar2.browser.contentDocument;
        var doc3 = cmdPopupBrowser.contentDocument;

        Css.appendStylesheet(doc1, uri);
        Css.appendStylesheet(doc2, uri);
        Css.appendStylesheet(doc3, uri);

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("chrome.appendStylesheet; " + uri);
    },

    updateOption: function(name, value)
    {
        if (panelBar1 && panelBar1.selectedPanel)
            panelBar1.selectedPanel.updateOption(name, value);

        if (panelBar2 && panelBar2.selectedPanel)
            panelBar2.selectedPanel.updateOption(name, value);

        if (name == "textSize")
            this.applyTextSize(value);

        if (name == "omitObjectPathStack")
            this.obeyOmitObjectPathStack(value);

        if (name == "viewPanelOrient")
            this.updateOrient(value);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    disableOff: function(collapse)
    {
        // disable/enable this button in the Firebug.chrome window
        Dom.collapse(FirebugChrome.$("fbCloseButton"), collapse);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getPanelDocument: function(panelType)
    {
        var cmdPopup = this.getElementById("fbCommandPopup");
        var cmdPopupBrowser = this.getElementById("fbCommandPopupBrowser");

        // Command Line Popup can be displayed for all the other panels
        // (except for the Console panel)
        // XXXjjb, xxxHonza, xxxsz: this should be somehow better, more generic and extensible,
        // e.g. by asking each panel if it supports the Command Line Popup
        var consolePanelType = Firebug.getPanelType("console");
        if (consolePanelType == panelType)
        {
            if (!Dom.isCollapsed(cmdPopup))
                return cmdPopupBrowser.contentDocument;
        }

        // Standard panel and side panel documents.
        if (!panelType.prototype.parentPanel)
            return panelBar1.browser.contentDocument;
        else
            return panelBar2.browser.contentDocument;
    },

    getPanelBrowser: function(panel)
    {
        if (!panel.parentPanel)
            return panelBar1.browser;
        else
            return panelBar2.browser;
    },

    savePanels: function()
    {
        var path = this.writePanels(panelBar1.browser.contentDocument);
        if (FBTrace.DBG_PANELS)
            FBTrace.sysout("Wrote panels to "+path+"\n");
    },

    writePanels: function(doc)
    {
        var serializer = new XMLSerializer();
        var foStream = Components.classes["@mozilla.org/network/file-output-stream;1"]
               .createInstance(Components.interfaces.nsIFileOutputStream);
        var file = Components.classes["@mozilla.org/file/directory_service;1"]
           .getService(Components.interfaces.nsIProperties)
           .get("TmpD", Components.interfaces.nsIFile);

        // extensions sub-directory
        file.append("firebug");
        file.append("panelSave.html");
        file.createUnique(Components.interfaces.nsIFile.NORMAL_FILE_TYPE, 0666);
        // write, create, truncate
        foStream.init(file, 0x02 | 0x08 | 0x20, 0664, 0);
        // remember, doc is the DOM tree
        serializer.serializeToStream(doc, foStream, "");
        foStream.close();
        return file.path;
    },

    // part of initializeUI
    updatePanelBar1: function(panelTypes)
    {
        var mainPanelTypes = [];
        for (var i = 0; i < panelTypes.length; ++i)
        {
            var panelType = panelTypes[i];
            if (!panelType.prototype.parentPanel && !panelType.hidden)
                mainPanelTypes.push(panelType);
        }
        panelBar1.updatePanels(mainPanelTypes);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getName: function()
    {
        return win ? win.location.href : null;
    },

    close: function()
    {
        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("chrome.close closing window "+win.location);
        win.close();
    },

    focus: function()
    {
        win.focus();
        panelBar1.browser.contentWindow.focus();
    },

    isFocused: function()
    {
        return wm.getMostRecentWindow(null) == win;
    },

    focusWatch: function(context)
    {
        if (Firebug.isDetached())
            Firebug.chrome.focus();
        else
            Firebug.toggleBar(true);

        Firebug.chrome.selectPanel("script");

        var watchPanel = context.getPanel("watches", true);
        if (watchPanel)
        {
            watchPanel.editNewWatch();
        }
    },

    isOpen: function()
    {
        return !(FirebugChrome.$("fbContentBox").collapsed);
    },

    toggleOpen: function(shouldShow)
    {
        var contentBox = Firebug.chrome.$("fbContentBox");
        contentBox.setAttribute("collapsed", !shouldShow);

        if (!this.inDetachedScope)
        {
            Dom.collapse(Firefox.getElementById('fbMainFrame'), !shouldShow);

            var contentSplitter = Firefox.getElementById('fbContentSplitter');
            if (contentSplitter)
                contentSplitter.setAttribute("collapsed", !shouldShow);
        }

        if (shouldShow && !this.positionInitialzed)
        {
            this.positionInitialzed = true;
            if (Firebug.framePosition != "detached" && Firebug.framePosition != "bottom")
            {
                // null only updates frame position without side effects
                this.setPosition();
            }
        }
    },

    onDetach: function()
    {
        if(!Firebug.currentContext)
            Firebug.toggleBar(true);
        else
            Firebug.showBar(true);
    },

    onUndetach: function()
    {
        Dom.collapse(Firebug.chrome.$('fbResumeBox'), true);
        Dom.collapse(Firebug.chrome.$("fbContentBox"), false);
    },

    // only called when detached
    syncResumeBox: function(context)
    {
        var resumeBox = Firebug.chrome.$('fbResumeBox');

        // xxxHonza: Don't focus the Firebug window now. It would bring the detached Firebug window
        // to the top every time the attached Firefox page is refreshed, which is annoying.
        //this.focus();  // bring to users attention

        if (context)
        {
            Firebug.chrome.toggleOpen(true);
            Firebug.chrome.syncPanel();
            Dom.collapse(resumeBox, true);
        }
        else
        {
            Firebug.chrome.toggleOpen(false);
            Dom.collapse(resumeBox, false);

            Firebug.chrome.window.parent.document.title =
                Locale.$STR("Firebug - inactive for current website");
        }
    },

    reload: function(skipCache)
    {
        var reloadFlags = skipCache
            ? LOAD_FLAGS_BYPASS_PROXY | LOAD_FLAGS_BYPASS_CACHE
            : LOAD_FLAGS_NONE;

        // Make sure the selected tab in the attached browser window is refreshed.
        var browser = Firefox.getCurrentBrowser();
        browser.firebugReload = true;
        browser.webNavigation.reload(reloadFlags);

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("chrome.reload; " + skipCache + ", " + browser.currentURI.spec);
    },

    gotoPreviousTab: function()
    {
        if (Firebug.currentContext.previousPanelName)
            this.selectPanel(Firebug.currentContext.previousPanelName);
    },

    gotoSiblingTab : function(goRight)
    {
        if (FirebugChrome.$("fbContentBox").collapsed)
            return;
        var i, currentIndex = newIndex = -1, currentPanel = this.getSelectedPanel(), newPanel;
        var panelTypes = Firebug.getMainPanelTypes(Firebug.currentContext);

        // get the current panel's index (is there a simpler way for this?)
        for (i = 0; i < panelTypes.length; i++)
        {
            if (panelTypes[i].prototype.name === currentPanel.name)
            {
                currentIndex = i;
                break;
            }
        }

        if (currentIndex != -1)
        {
            newIndex = goRight ? (currentIndex == panelTypes.length - 1 ?
                0 : ++currentIndex) : (currentIndex == 0 ? panelTypes.length - 1 : --currentIndex);

            newPanel = panelTypes[newIndex].prototype;
            if (newPanel && newPanel.name)
            {
                this.selectPanel(newPanel.name);
            }
        }
    },

    getNextObject: function(reverse)
    {
        var panel = Firebug.currentContext.getPanel(Firebug.currentContext.panelName);
        if (panel)
        {
            var panelStatus = this.getElementById("fbPanelStatus");
            var item = panelStatus.getItemByObject(panel.selection);
            if (item)
            {
                if (reverse)
                    item = item.previousSibling ? item.previousSibling.previousSibling : null;
                else
                    item = item.nextSibling ? item.nextSibling.nextSibling : null;

                if (item)
                    return item.repObject;
            }
        }
    },

    gotoNextObject: function(reverse)
    {
        var nextObject = this.getNextObject(reverse);
        if (nextObject)
            this.select(nextObject);
        else
            System.beep();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Panels

    /**
     * Set this.location on the current panel or one given by name.
     * The location object should be known to the caller to be of the correct type for the panel,
     * e.g. SourceFile for Script panel
     * @param object location object, null selects default location
     * @param panelName name of the panel to select, null means current panel
     * @param sidePanelName name of the side panel to select
     */
    navigate: function(object, panelName, sidePanelName)
    {
        var panel;
        if (panelName || sidePanelName)
            panel = this.selectPanel(panelName, sidePanelName);
        else
            panel = this.getSelectedPanel();

        if (panel)
            panel.navigate(object);
    },

    /**
     *  Set this.selection by object type analysis, passing the object to all panels to
     *      find the best match
     *  @param object new this.selection object
     *  @param panelName matching panel.name will be used, if its supportsObject returns true
     *  @param sidePanelName default side panel name used, if its supportsObject returns true
     *  @param forceUpdate if true, then (object === this.selection) is ignored and
     *      updateSelection is called
     */
    select: function(object, panelName, sidePanelName, forceUpdate)
    {
        if (FBTrace.DBG_PANELS)
            FBTrace.sysout("chrome.select object:"+object+" panelName:"+panelName+
                " sidePanelName:"+sidePanelName+" forceUpdate:"+forceUpdate+"\n");

        var bestPanelName = getBestPanelName(object, Firebug.currentContext, panelName);

        // allow refresh if needed (last argument)
        var panel = this.selectPanel(bestPanelName, sidePanelName/*, true*/);
        if (panel)
            panel.select(object, forceUpdate);

        // issue 4778
        this.syncLocationList();
    },

    selectPanel: function(panelName, sidePanelName, noRefresh)
    {
        if (panelName && sidePanelName)
            Firebug.currentContext.sidePanelNames[panelName] = sidePanelName;

        // cause panel visibility changes and events
        return panelBar1.selectPanel(panelName, false, noRefresh);
    },

    selectSidePanel: function(panelName)
    {
        return panelBar2.selectPanel(panelName);
    },

    selectSupportingPanel: function(object, context, forceUpdate)
    {
        var bestPanelName = getBestPanelSupportingObject(object, context);
        var panel = this.selectPanel(bestPanelName, false, true);
        if (panel)
            panel.select(object, forceUpdate);
    },

    clearPanels: function()
    {
        panelBar1.hideSelectedPanel();
        panelBar1.selectedPanel = null;
        panelBar2.selectedPanel = null;
    },

    getSelectedPanel: function()
    {
        return panelBar1 ? panelBar1.selectedPanel : null;
    },

    getSelectedSidePanel: function()
    {
        return panelBar2 ? panelBar2.selectedPanel : null;
    },

    switchToPanel: function(context, switchToPanelName)
    {
        // Remember the previous panel and bar state so we can revert if the user cancels.
        this.previousPanelName = context.panelName;
        this.previousSidePanelName = context.sidePanelName;
        this.previouslyCollapsed = FirebugChrome.$("fbContentBox").collapsed;

        // TODO previouslyMinimized
        this.previouslyFocused = Firebug.isDetached() && this.isFocused();

        var switchPanel = this.selectPanel(switchToPanelName);
        if (switchPanel)
            this.previousObject = switchPanel.selection;

        return switchPanel;
    },

    unswitchToPanel: function(context, switchToPanelName, canceled)
    {
        var switchToPanel = context.getPanel(switchToPanelName);

        if (this.previouslyFocused)
            this.focus();

        if (canceled && this.previousPanelName)
        {
            // revert
            if (this.previouslyCollapsed)
                Firebug.showBar(false);

            if (this.previousPanelName == switchToPanelName)
                switchToPanel.select(this.previousObject);
            else
                this.selectPanel(this.previousPanelName, this.previousSidePanelName);
        }
        else
        {
            // else stay on the switchToPanel
            this.selectPanel(switchToPanelName);
            if (switchToPanel.selection)
                this.select(switchToPanel.selection);
            this.getSelectedPanel().panelNode.focus();
        }

        delete this.previousObject;
        delete this.previousPanelName;
        delete this.previousSidePanelName;
        delete this.inspectingChrome;

        return switchToPanel;
    },

    getSelectedPanelURL: function()
    {
        var location = null;
        if (Firebug.currentContext)
        {
            var panel = Firebug.chrome.getSelectedPanel();
            if (panel)
            {
                location = panel.location;
                if (!location && panel.name == "html")
                    location = Firebug.currentContext.window.document.location;

                if (location && (location instanceof Firebug.SourceFile ||
                    location instanceof CSSStyleSheet))
                    location = location.href;
            }
        }

        if (!location)
        {
            var currentURI = Firefox.getCurrentURI();
            if (currentURI)
                location = currentURI.asciiSpec;
        }

        if (!location)
            return;

        location = location.href || location.url || location.toString();
        if (Firebug.filterSystemURLs && Url.isSystemURL(location))
            return;

        return location;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Location interface provider for binding.xml panelFileList

    getLocationProvider: function()
    {
        // a function that returns an object with .getObjectDescription() and .getLocationList()
        return function getSelectedPanelFromCurrentContext()
        {
            // panels provide location, use the selected panel
            return Firebug.chrome.getSelectedPanel();
        };
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Synchronization

    setFirebugContext: function(context)
    {
         // This sets the global value of Firebug.currentContext in the window, that this
         // chrome is compiled into. Note, that for firebug.xul the Firebug object is shared
         // across windows, but not FirebugChrome and Firebug.currentContext.
         Firebug.currentContext = context;

         if (FBTrace.DBG_WINDOWS || FBTrace.DBG_DISPATCH || FBTrace.DBG_ACTIVATION)
             FBTrace.sysout("setFirebugContext "+(Firebug.currentContext?
                Firebug.currentContext.getName():" **> NULL <** ") + " in "+win.location);
    },

    hidePanel: function()
    {
        if (panelBar1.selectedPanel)
            panelBar1.hideSelectedPanel();

        if (panelBar2.selectedPanel)
            panelBar2.hideSelectedPanel();
    },

    syncPanel: function(panelName)
    {
        var context = Firebug.currentContext;

        if (FBTrace.DBG_PANELS)
            FBTrace.sysout("chrome.syncPanel Firebug.currentContext=" +
                (context ? context.getName() : "undefined"));

        var panelStatus = this.getElementById("fbPanelStatus");
        panelStatus.clear();

        if (context)
        {
            if (!panelName)
                panelName = context.panelName? context.panelName : Firebug.defaultPanelName;

            // Make the HTML panel the default panel, which is displayed
            // to the user the very first time.
            if (!panelName || !Firebug.getPanelType(panelName))
                panelName = "html";

            this.syncMainPanels();
            panelBar1.selectPanel(panelName, true);
        }
        else
        {
            panelBar1.selectPanel(null, true);
        }

        if (Firebug.isDetached())
            this.syncTitle();
    },

    syncMainPanels: function()
    {
        if (Firebug.currentContext)
        {
            var panelTypes = Firebug.getMainPanelTypes(Firebug.currentContext);
            panelBar1.updatePanels(panelTypes);

            // Update also BON tab flag (orange background if BON is active)
            // every time the user changes the current tab in Firefox.
            Firebug.Breakpoint.updatePanelTabs(Firebug.currentContext);
        }
    },

    syncSidePanels: function()
    {
        if (FBTrace.DBG_PANELS)
        {
            FBTrace.sysout("chrome.syncSidePanels; main panel: " +
                (panelBar1.selectedPanel ? panelBar1.selectedPanel.name : "no panel") +
                ", side panel: " +
                (panelBar2.selectedPanel ? panelBar2.selectedPanel.name : "no panel"));
        }

        if (!panelBar1.selectedPanel)
            return;

        var panelTypes;
        if (Firebug.currentContext)
        {
            panelTypes = Firebug.getSidePanelTypes(Firebug.currentContext,
                panelBar1.selectedPanel);
            panelBar2.updatePanels(panelTypes);
        }

        if (Firebug.currentContext && Firebug.currentContext.sidePanelNames)
        {
            if (!panelBar2.selectedPanel ||
                (panelBar2.selectedPanel.parentPanel !== panelBar1.selectedPanel.name))
            {
                var sidePanelName = Firebug.currentContext.sidePanelNames[
                    Firebug.currentContext.panelName];
                sidePanelName = getBestSidePanelName(sidePanelName, panelTypes);
                panelBar2.selectPanel(sidePanelName, true);
            }
            else
            {
                // If the context changes, we need to refresh the panel.
                panelBar2.selectPanel(panelBar2.selectedPanel.name, true);
            }
        }
        else
        {
            panelBar2.selectPanel(null);
        }

        if (FBTrace.DBG_PANELS)
            FBTrace.sysout("chrome.syncSidePanels; selected side panel " + panelBar1.selectedPanel);

        sidePanelDeck.selectedPanel = panelBar2;

        Dom.collapse(sidePanelDeck, !panelBar2.selectedPanel);
        Dom.collapse(panelSplitter, !panelBar2.selectedPanel);

        Events.dispatch(Firebug.uiListeners, "updateSidePanels", [panelBar1.selectedPanel]);
    },

    syncTitle: function()
    {
        if (Firebug.currentContext)
        {
            var title = Firebug.currentContext.getTitle();
            win.parent.document.title = Locale.$STRF("WindowTitle", [title]);
        }
        else
        {
            win.parent.document.title = Locale.$STR("Firebug");
        }
    },

    focusLocationList: function()
    {
        var locationList = this.getElementById("fbLocationList");
        locationList.popup.showPopup(locationList, -1, -1, "popup", "bottomleft", "topleft");
    },

    syncLocationList: function()
    {
        var locationButtons = this.getElementById("fbLocationButtons");

        var panel = panelBar1.selectedPanel;
        if (panel && panel.location)
        {
            var locationList = this.getElementById("fbLocationList");
            locationList.location = panel.location;

            Dom.collapse(locationButtons, false);
        }
        else
        {
            Dom.collapse(locationButtons, true);
        }
    },

    clearStatusPath: function()
    {
        var panelStatus = this.getElementById("fbPanelStatus");
        panelStatus.clear();
    },

    syncStatusPath: function()
    {
        var panelStatus = this.getElementById("fbPanelStatus");
        var panelStatusSeparator = this.getElementById("fbStatusSeparator");
        var panel = panelBar1.selectedPanel;

        if (!panel || (panel && !panel.selection))
        {
            panelStatus.clear();
        }
        else
        {
            var path = panel.getObjectPath(panel.selection);
            if (!path || !path.length)
            {
                Dom.hide(panelStatusSeparator, true);
                panelStatus.clear();
            }
            else
            {
                // Update the visibility of the separator. The separator
                // is displayed only if there are some other buttons on the left side.
                // Before showing the status separator let's see whether there are any other
                // buttons on the left.
                var hide = true;
                var sibling = panelStatusSeparator.parentNode.previousSibling;
                while (sibling)
                {
                    if (!Dom.isCollapsed(sibling))
                    {
                        hide = false;
                        break;
                    }
                    sibling = sibling.previousSibling;
                }
                Dom.hide(panelStatusSeparator, hide);

                if (panel.name != panelStatus.lastPanelName)
                    panelStatus.clear();

                panelStatus.lastPanelName = panel.name;

                // If the object already exists in the list, just select it and keep the path.
                var selection = panel.selection;
                var existingItem = panelStatus.getItemByObject(panel.selection);
                if (existingItem)
                {
                    // Update the labels of the status path elements, because it can be,
                    // that the elements changed even when the selected element exists
                    // inside the path (issue 4826)
                    var statusItems = panelStatus.getItems();
                    for (var i = 0; i < statusItems.length; ++i)
                    {
                        var object = Firebug.getRepObject(statusItems[i]);
                        var rep = Firebug.getRep(object, Firebug.currentContext);
                        var objectTitle = rep.getTitle(object, Firebug.currentContext);
                        var title = String.cropMultipleLines(objectTitle, statusCropSize);

                        statusItems[i].label = title;
                    }
                    panelStatus.selectItem(existingItem);
                }
                else
                {
                    panelStatus.clear();

                    for (var i = 0; i < path.length; ++i)
                    {
                        var object = path[i];

                        var rep = Firebug.getRep(object, Firebug.currentContext);
                        var objectTitle = rep.getTitle(object, Firebug.currentContext);

                        var title = String.cropMultipleLines(objectTitle, statusCropSize);
                        panelStatus.addItem(title, object, rep, panel.statusSeparator);
                    }

                    panelStatus.selectObject(panel.selection);
                    if (FBTrace.DBG_PANELS)
                        FBTrace.sysout("syncStatusPath "+path.length+" items ", path);
                }
            }
        }
    },

    toggleOrient: function(preferredValue)
    {
        var value = Options.get("viewPanelOrient");
        if (value == preferredValue)
            return;

        Options.togglePref("viewPanelOrient");
    },

    updateOrient: function(value)
    {
        var panelPane = FirebugChrome.$("fbPanelPane");
        if (!panelPane)
            return;

        var newOrient = value ? "vertical" : "horizontal";
        if (panelPane.orient == newOrient)
            return;

        panelSplitter.orient = panelPane.orient = newOrient;
    },

    setPosition: function(pos)
    {
        if (Firebug.framePosition == pos)
            return;

        if (pos)
        {
            if (Firebug.getSuspended())
                Firebug.toggleBar();
        }
        else
        {
            pos = Firebug.framePosition;
        }

        if (pos == "detached")
        {
            Firebug.toggleDetachBar(true, true);
            return;
        }

        if (Firebug.isDetached())
            Firebug.toggleDetachBar(false, true);

        pos && this.syncPositionPref(pos);

        var vertical = pos == "top" || pos == "bottom";
        var after = pos == "bottom" || pos == "right";

        var document = window.parent.document;
        var container = document.getElementById(vertical ? "appcontent" : "browser");

        var splitter = Firefox.getElementById("fbContentSplitter");
        splitter.setAttribute("orient", vertical ? "vertical" : "horizontal");
        splitter.setAttribute("dir", after ? "" : "reverse");
        container.insertBefore(splitter, after ? null: container.firstChild);

        var frame = document.getElementById("fbMainFrame");

        var newFrame = frame.cloneNode(true);
        var newBrowser = newFrame.querySelector("#fbMainContainer");
        var oldBrowser = frame.querySelector("#fbMainContainer");

        newBrowser.removeAttribute("src");
        container.insertBefore(newFrame, after ? null: container.firstChild);

        this.swapBrowsers(oldBrowser, newBrowser);
        this.browser = newBrowser;

        frame.parentNode.removeChild(frame);
        this.framePosition = pos;
    },

    syncPositionPref: function(pos)
    {
        if (!pos)
        {
            if (Firebug.isDetached())
                pos = "detached";
            else
                pos = this.framePosition || 'bottom';
        }

        Firebug.Options.set("framePosition", pos);
        return Firebug.framePosition = pos;
    },

    swapBrowsers: function(oldBrowser, newBrowser)
    {
        var oldDoc = oldBrowser.contentDocument;
        // Panels remember the top window, for which they were first opened.
        // So we need to destroy their views.
        var styleSheet = oldDoc.styleSheets[0];
        var rulePos = styleSheet.cssRules.length;
        styleSheet.insertRule(
            "panel{display:-moz-box!important; visibility:collapse!important;}", rulePos);

        // We need to deal with inner frames first since swapFrameLoaders
        // doesn't work for type="chrome" browser containing type="content" browsers
        var frames = oldDoc.querySelectorAll("browser[type*=content], iframe[type*=content]");
        var tmpFrames = [], placeholders = [];

        var topDoc = oldBrowser.ownerDocument;
        var temp = topDoc.createElement("box");
        topDoc.documentElement.appendChild(temp);

        var swapDocShells = function(a, b)
        {
            // important! must touch browser.contentDocument to initialize it
            a.contentDocument == b.contentDocument;
            if (a.nodeName == "iframe")
                a.QueryInterface(Ci.nsIFrameLoaderOwner).swapFrameLoaders(b);
            else
                a.swapDocShells(b);
        };

        for (var i = frames.length - 1; i >= 0; i--)
        {
            placeholders[i] = document.createElement("placeholder");
            tmpFrames[i] = frames[i].cloneNode(true);
            tmpFrames[i].removeAttribute("src");
            frames[i].removeAttribute("src");
            temp.appendChild(tmpFrames[i]);
        }

        for (var i = tmpFrames.length - 1; i >= 0; i--)
        {
            swapDocShells(tmpFrames[i], frames[i]);
            frames[i].parentNode.replaceChild(placeholders[i], frames[i]);
        }

        swapDocShells(oldBrowser, newBrowser);

        for (var i = placeholders.length - 1; i >= 0; i--)
            placeholders[i].parentNode.replaceChild(frames[i], placeholders[i]);

        for (var i = frames.length - 1; i >= 0; i--)
            swapDocShells(tmpFrames[i], frames[i]);

        temp.parentNode.removeChild(temp);

        styleSheet.deleteRule(rulePos);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Global Attributes

    getGlobalAttribute: function(id, name)
    {
        var elt = FirebugChrome.$(id);
        return elt.getAttribute(name);
    },

    setGlobalAttribute: function(id, name, value)
    {
        var elt = FirebugChrome.$(id);
        if (elt)
        {
            if (value == null)
                elt.removeAttribute(name);
            else
                elt.setAttribute(name, value);
        }

        if (Firebug.externalChrome)
            Firebug.externalChrome.setGlobalAttribute(id, name, value);
    },

    setChromeDocumentAttribute: function(id, name, value)
    {
        // call as Firebug.chrome.setChromeDocumentAttribute() to set attributes
        // in another window
        var elt = FirebugChrome.$(id);
        if (elt)
            elt.setAttribute(name, value);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    keyCodeListen: function(key, filter, listener, capture)
    {
        if (!filter)
            filter = Events.noKeyModifiers;

        var keyCode = KeyEvent["DOM_VK_"+key];

        function fn(event)
        {
            if (event.keyCode == keyCode && (!filter || filter(event)))
            {
                listener();
                Events.cancelEvent(event);
            }
        }

        Events.addEventListener(win, "keypress", fn, capture);

        return [fn, capture];
    },

    keyListen: function(ch, filter, listener, capture)
    {
        if (!filter)
            filter = Events.noKeyModifiers;

        var charCode = ch.charCodeAt(0);

        function fn(event)
        {
            if (event.charCode == charCode && (!filter || filter(event)))
            {
                listener();
                Events.cancelEvent(event);
            }
        }

        Events.addEventListener(win, "keypress", fn, capture);

        return [fn, capture];
    },

    keyIgnore: function(listener)
    {
        Events.removeEventListener(win, "keypress", listener[0], listener[1]);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    $: function(id)
    {
        return this.getElementById(id);
    },

    getElementById: function(id)
    {
        // The document we close over, not the global.
        return win.document.getElementById(id);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    applyTextSize: function(value)
    {
        if (!panelBar1)
            return;

        var zoom = Firebug.Options.getZoomByTextSize(value);
        var zoomString = (zoom * 100) + "%";

        // scale the aspect relative to 11pt Lucida Grande
        // xxxsz: The magic number 0.547 should be replaced some logic retrieving this value.
        var fontSizeAdjust = zoom * 0.547;
        var contentBox = Firebug.chrome.$("fbContentBox");
        contentBox.style.fontSizeAdjust = fontSizeAdjust;

        //panelBar1.browser.contentDocument.documentElement.style.fontSizeAdjust = fontSizeAdjust;
        //panelBar2.browser.contentDocument.documentElement.style.fontSizeAdjust = fontSizeAdjust;

        panelBar1.browser.markupDocumentViewer.textZoom = zoom;
        panelBar2.browser.markupDocumentViewer.textZoom = zoom;

        var cmdPopupBrowser = this.getElementById("fbCommandPopupBrowser");
        cmdPopupBrowser.markupDocumentViewer.textZoom = zoom;

        var box = Firebug.chrome.$("fbCommandBox");
        box.style.fontSizeAdjust = fontSizeAdjust;
        if (Firebug.CommandLine)
        {
            Firebug.CommandLine.getSingleRowCommandLine().style.fontSizeAdjust = fontSizeAdjust;
            Firebug.chrome.$("fbCommandLineCompletion").style.fontSizeAdjust = fontSizeAdjust;
            Firebug.chrome.$("fbCommandLineCompletionList").style.fontSizeAdjust = fontSizeAdjust;

            Firebug.CommandEditor.fontSizeAdjust(fontSizeAdjust);
        }

        Firebug.dispatchToPanels("onTextSizeChange", [zoom, fontSizeAdjust]);
    },

    obeyOmitObjectPathStack: function(value)
    {
        var panelStatus = this.getElementById("fbPanelStatus");
        // The element does not exist immediately at start-up.
        if (!panelStatus)
            return;
        Dom.hide(panelStatus, (value ? true : false));
    },

    getPanelStatusElements: function()
    {
        return this.getElementById("fbPanelStatus");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Event Listeners uilisteners  or "panelListeners"

    onPanelNavigate: function(object, panel)
    {
        this.syncLocationList();
    },

    onObjectSelected: function(object, panel)
    {
        if (panel == panelBar1.selectedPanel)
        {
            this.syncStatusPath();

            var sidePanel = panelBar2.selectedPanel;
            if (sidePanel)
                sidePanel.select(object);
        }
    },

    onObjectChanged: function(object, panel)
    {
        if (panel == panelBar1.selectedPanel)
        {
            this.syncStatusPath();

            var sidePanel = panelBar2.selectedPanel;
            if (sidePanel)
                sidePanel.refresh();
        }
    },

    // called on setTimeout() after sourceBox viewport has been repainted
    onApplyDecorator: function(sourceBox)
    {
    },

    // called on scrollTo() passing in the selected line
    onViewportChange: function(sourceLink)
    {
    },

    // called when the Firebug UI comes up in browser
    showUI: function(browser, context)
    {
    },

    // called when the Firebug UI comes down; context may be null
    hideUI: function(browser, context)
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onMenuShowing: function(popup)
    {
        var detachFirebug = Dom.getElementsByAttribute(popup, "id", "menu_firebug_detachFirebug")[0];
        if (detachFirebug)
        {
            detachFirebug.setAttribute("label", (Firebug.isDetached() ?
                Locale.$STR("firebug.AttachFirebug") : Locale.$STR("firebug.DetachFirebug")));
        }

        var toggleFirebug = Dom.getElementsByAttribute(popup, "id", "menu_firebug_toggleFirebug")[0];
        if (toggleFirebug)
        {
            var fbContentBox = FirebugChrome.$("fbContentBox");
            var collapsed = fbContentBox.getAttribute("collapsed");
            if (collapsed == "true")
            {
                toggleFirebug.setAttribute("label", Locale.$STR("inBrowser"));
                toggleFirebug.setAttribute("tooltiptext", Locale.$STR("inBrowser"));
            }
            else
            {
              toggleFirebug.setAttribute("label", Locale.$STR("firebug.menu.Minimize_Firebug"));
              toggleFirebug.setAttribute("tooltiptext", Locale.$STR("firebug.menu.tip.Minimize_Firebug"));
            }

            // If Firebug is detached, hide the menu. ('Open Firebug' shortcut doesn't hide
            // but just focuses the external window)
            if (Firebug.isDetached())
                toggleFirebug.setAttribute("collapsed", (collapsed == "true" ? "false" : "true"));
        }
    },

    onOptionsShowing: function(popup)
    {
        for (var child = popup.firstChild; child; child = child.nextSibling)
        {
            if (child.localName == "menuitem")
            {
                var option = child.getAttribute("option");
                if (option)
                {
                    var checked = false;
                    if (option == "profiling")
                        checked = FBS.profiling;
                    else
                        checked = Firebug.Options.get(option);

                    child.setAttribute("checked", checked);
                }
            }
        }
    },

    onToggleOption: function(menuitem)
    {
        var option = menuitem.getAttribute("option");
        var checked = menuitem.getAttribute("checked") == "true";

        Firebug.Options.set(option, checked);
    },

    onContextShowing: function(event)
    {
        // xxxHonza: This context menu support can be used even in a separate window, which
        // doesn't contain the Firebug UI (panels).
        //if (!panelBar1.selectedPanel)
        //    return false;

        var popup = event.target;
        if (popup.id != "fbContextMenu")
            return;

        var target = win.document.popupNode;
        var panel = target ? Firebug.getElementPanel(target) : null;

        // The event must be on our chrome not inside the panel.
        if (!panel)
            panel = panelBar1 ? panelBar1.selectedPanel : null;

        Dom.eraseNode(popup);

        // Make sure the Copy action is only available if there is actually something
        // selected in the panel.
        var sel = target.ownerDocument.defaultView.getSelection();
        if (!this.contextMenuObject &&
            !FirebugChrome.$("cmd_copy").getAttribute("disabled") &&
            !sel.isCollapsed)
        {
            var menuitem = Menu.createMenuItem(popup, {label: "Copy"});
            menuitem.setAttribute("command", "cmd_copy");
        }

        var object;
        if (this.contextMenuObject)
            object = this.contextMenuObject;
        else if (target && target.ownerDocument == document)
            object = Firebug.getRepObject(target);
        else if (target && panel)
            object = panel.getPopupObject(target);
        else if (target)
            // xxxHonza: What about a node from a different document? Is that OK?
            object = Firebug.getRepObject(target);

        this.contextMenuObject = null;

        var rep = Firebug.getRep(object, Firebug.currentContext);
        var realObject = rep ? rep.getRealObject(object, Firebug.currentContext) : null;
        var realRep = realObject ? Firebug.getRep(realObject, Firebug.currentContext) : null;

        if (FBTrace.DBG_MENU)
        {
            FBTrace.sysout("chrome.onContextShowing object:"+object+", rep: "+rep+
                ", realObject: "+realObject+", realRep:"+realRep);
        }

        // 1. Add the custom menu items from the realRep
        if (realObject && realRep)
        {
            var items = realRep.getContextMenuItems(realObject, target, Firebug.currentContext);
            if (items)
                Menu.createMenuItems(popup, items);
        }

        // 2. Add the custom menu items from the original rep
        if (object && rep && rep != realRep)
        {
            var items = rep.getContextMenuItems(object, target, Firebug.currentContext);
            if (items)
                Menu.createMenuItems(popup, items);
        }

        // 3. Add the custom menu items from the panel
        if (panel)
        {
            var items = panel.getContextMenuItems(realObject, target);
            if (items)
                Menu.createMenuItems(popup, items);
        }

        // 4. Add the inspect menu items
        if (realObject && rep && rep.inspectable)
        {
            var items = this.getInspectMenuItems(realObject);

            // Separate existing menu items from 'inspect' menu items.
            if (popup.firstChild && items.length > 0)
                Menu.createMenuSeparator(popup);

            Menu.createMenuItems(popup, items);
        }

        // 5. Add menu items from uiListeners
        var items = [];
        Events.dispatch(Firebug.uiListeners, "onContextMenu", [items, object, target,
            Firebug.currentContext, panel, popup]);
        Menu.createMenuItems(popup, items);

        // Make sure there are no unnecessary separators (e.g. at the top or bottom
        // of the popup)
        Menu.optimizeSeparators(popup);

        if (!popup.firstChild)
            return false;
    },

    getInspectMenuItems: function(object)
    {
        var items = [];

        // Domplate (+ support for context menus) can be used even in separate
        // windows when Firebug.currentContext doesn't have to be defined.
        if (!Firebug.currentContext)
            return items;

        for (var i = 0; i < Firebug.panelTypes.length; ++i)
        {
            var panelType = Firebug.panelTypes[i];
            if (!panelType.prototype.parentPanel
                && panelType.prototype.name != Firebug.currentContext.panelName
                && panelSupportsObject(panelType, object, Firebug.currentContext))
            {
                var panelName = panelType.prototype.name;

                var title = Firebug.getPanelTitle(panelType);
                var label = Locale.$STRF("panel.Inspect_In_Panel", [title]);
                var tooltiptext = Locale.$STRF("panel.tip.Inspect_In_Panel", [title]);
                var id = "InspectIn" + panelName + "Panel";

                var command = Obj.bindFixed(this.select, this, object, panelName);
                items.push({label: label, tooltiptext: tooltiptext, command: command, nol10n: true,
                    id: id});
            }
        }

        return items;
    },

    onTooltipShowing: function(event)
    {
        // xxxHonza: This tooltip support can be used even in a separate window, which
        // doesn't contain the Firebug UI (panels).
        //if (!panelBar1.selectedPanel)
        //    return false;

        var tooltip = FirebugChrome.$("fbTooltip");
        var target = win.document.tooltipNode;

        var panel = target ? Firebug.getElementPanel(target) : null;

        var object;

        /* XXXjjb: This causes the Script panel to show the function body over and over.
         * We need to clear it at least, but actually we need to understand why the tooltip
         * should show the context menu object at all. One thing the contextMenuObject supports
         * is peeking at function bodies when stopped at a breakpoint.
         * That case could be supported with clearing the contextMenuObject, but we don't
         * know if that breaks something else. So maybe a popupMenuObject should be set
         * on the context if that is what we want to support.
         * The other complication is that there seems to be another tooltip.
        if (this.contextMenuObject)
        {
            object = this.contextMenuObject;
            FBTrace.sysout("tooltip by contextMenuObject");
        }
        else*/

        if (target && target.ownerDocument == document)
            object = Firebug.getRepObject(target);
        else if (panel)
            object = panel.getTooltipObject(target);

        var rep = object ? Firebug.getRep(object, Firebug.currentContext) : null;
        object = rep ? rep.getRealObject(object, Firebug.currentContext) : null;
        rep = object ? Firebug.getRep(object) : null;

        if (object && rep)
        {
            var label = rep.getTooltip(object, Firebug.currentContext, target);
            if (label)
            {
                tooltip.setAttribute("label", label);
                return true;
            }
        }

        if (Css.hasClass(target, 'noteInToolTip'))
            Css.setClass(tooltip, 'noteInToolTip');
        else
            Css.removeClass(tooltip, 'noteInToolTip');

        if (target && target.hasAttribute("title"))
        {
            tooltip.setAttribute("label", target.getAttribute("title"));
            return true;
        }

        return false;
    },

    openAboutDialog: function()
    {
        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("Firebug.openAboutDialog");

        try
        {
            // Firefox 4.0+ implements a new AddonManager. In case of Firefox 3.6 the module
            // is not available and there is an exception.
            Components.utils["import"]("resource://gre/modules/AddonManager.jsm");
        }
        catch (err)
        {
        }

        if (typeof(AddonManager) != "undefined")
        {
            AddonManager.getAddonByID("firebug@software.joehewitt.com", function(addon)
            {
                openDialog("chrome://mozapps/content/extensions/about.xul", "",
                "chrome,centerscreen,modal", addon);
            });
        }
        else
        {
            var extensionManager = Cc["@mozilla.org/extensions/manager;1"].getService(
                Ci.nsIExtensionManager);

            openDialog("chrome://mozapps/content/extensions/about.xul", "",
                "chrome,centerscreen,modal", "urn:mozilla:item:firebug@software.joehewitt.com",
                extensionManager.datasource);
        }
    },

    breakOnNext: function(context, event)
    {
        // avoid bubbling from associated options
        if (event.target.id != "cmd_firebug_toggleBreakOn")
            return;

        if (!context)
        {
            if (FBTrace.DBG_BP)
                FBTrace.sysout("Firebug chrome: breakOnNext with no context??");
            return;
        }

        var panel = panelBar1.selectedPanel;

        if (FBTrace.DBG_BP)
            FBTrace.sysout("Firebug chrome: breakOnNext for panel " +
                (panel ? panel.name : "NO panel"), panel);

        if (panel && panel.breakable)
            Firebug.Breakpoint.toggleBreakOnNext(panel);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    visitWebsite: function(which, arg)
    {
        var url = firebugURLs[which];
        if (url)
        {
            if (arg)
                url += arg;

            Win.openNewTab(url);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Main Toolbar

    appendToolbarButton: function(button, before)
    {
        var toolbar = FirebugChrome.$("fbPanelBar1-buttons");
        var element = Toolbar.createToolbarButton(toolbar, button, before);
        element.repObject = button;
    },

    removeToolbarButton: function(button)
    {
        var toolbar = FirebugChrome.$("fbPanelBar1-buttons");
        for (var child = toolbar.firstChild; child; child = child.nextSibling)
        {
            if (child.repObject == button)
            {
                toolbar.removeChild(child);
                break;
            }
        }
    }
};

// ********************************************************************************************* //
// Local Helpers

function panelSupportsObject(panelType, object, context)
{
    if (panelType)
    {
        try {
            // This tends to throw exceptions often because some objects are weird
            return panelType.prototype.supportsObject(object, typeof object, context)
        } catch (exc) {}
    }

    return 0;
}

function getBestPanelName(object, context, panelName)
{
    if (!panelName && context)
        panelName = context.panelName;

    // Check if the panel type of the suggested panel supports the object, and if so, go with it.
    if (panelName)
    {
        var panelType = Firebug.getPanelType(panelName);
        if (panelSupportsObject(panelType, object, context))
            return panelType.prototype.name;
    }

    // The suggested name didn't pan out, so search for the panel type with the
    // most specific level of support.
    return getBestPanelSupportingObject(object, context);
}

function getBestPanelSupportingObject(object, context)
{
    var bestLevel = 0;
    var bestPanel = null;

    for (var i = 0; i < Firebug.panelTypes.length; ++i)
    {
        var panelType = Firebug.panelTypes[i];
        if (!panelType.prototype.parentPanel)
        {
            var level = panelSupportsObject(panelType, object, context);
            if (!bestLevel || (level && (level > bestLevel) ))
            {
                bestLevel = level;
                bestPanel = panelType;
            }

            if (FBTrace.DBG_PANELS)
                FBTrace.sysout("chrome.getBestPanelName panelType: " + panelType.prototype.name +
                    " level: " + level + " bestPanel: " +
                    (bestPanel ? bestPanel.prototype.name : "null") +
                    " bestLevel: " + bestLevel);
        }
    }

    return bestPanel ? bestPanel.prototype.name : null;
}

function getBestSidePanelName(sidePanelName, panelTypes)
{
    if (sidePanelName)
    {
        // Verify, that the suggested panel name is in the acceptable list.
        for (var i = 0; i < panelTypes.length; ++i)
        {
            if (panelTypes[i].prototype.name == sidePanelName)
                return sidePanelName;
        }
    }

    // Default to the first panel type in the list.
    return panelTypes.length ? panelTypes[0].prototype.name : null;
}

// ********************************************************************************************* //
// Event listeners

function browser1Loaded()
{
    if (FBTrace.DBG_INITIALIZE)
        FBTrace.sysout("browse1Loaded\n");

    var browser1 = panelBar1.browser;
    var browser2 = panelBar2.browser;
    Events.removeEventListener(browser1, "load", browser1Loaded, true);

    browser1.contentDocument.title = "Firebug Main Panel";
    browser1.complete = true;

    if (browser1.complete && browser2.complete)
    {
        // initializeUI() is executed asynchronously (solves issue 3442)
        // The problem has been introduced (for an unknown reason) by revision R12210
        setTimeout(function() {
            // chrome bound into this scope
            FirebugChrome.initializeUI();
        });
    }

    if (FBTrace.DBG_INITIALIZE)
        FBTrace.sysout("browse1Loaded complete\n");
}

function browser2Loaded()
{
    if (FBTrace.DBG_INITIALIZE)
        FBTrace.sysout("browse2Loaded\n");

    var browser1 = panelBar1.browser;
    var browser2 = panelBar2.browser;
    Events.removeEventListener(browser2, "load", browser2Loaded, true);

    browser2.contentDocument.title = "Firebug Side Panel";
    browser2.complete = true;

    if (browser1.complete && browser2.complete)
    {
        // See browser1Loaded for more info.
        setTimeout(function() {
            // chrome bound into this scope
            FirebugChrome.initializeUI();
        });
    }

    if (FBTrace.DBG_INITIALIZE)
        FBTrace.sysout("browse2Loaded complete\n");
}

function onBlur(event)
{
    // XXXjjb: this seems like a waste: called continuously to clear possible highlight I guess.
    // XXXhh: Is this really necessary? I disabled it for now as this was preventing me
    // to show highlights on focus
    //Firebug.Inspector.highlightObject(null, Firebug.currentContext);
}

function onSelectLocation(event)
{
    try
    {
        var locationList = FirebugChrome.getElementById("fbLocationList");
        var location = locationList.repObject;

        FirebugChrome.navigate(location);
    }
    catch (err)
    {
        FBTrace.sysout("chrome.onSelectLocation; EXCEPTION " + err, err);
    }
}

function onSelectingPanel(event)
{
    try
    {
        doSelectingPanel(event);
    }
    catch (err)
    {
        FBTrace.sysout("chrome.onSelectingPanel; EXCEPTION " + err, err);
    }
}

function doSelectingPanel(event)
{
    var panel = panelBar1.selectedPanel;
    var panelName = panel ? panel.name : null;

    if (FBTrace.DBG_PANELS)
        FBTrace.sysout("chrome.onSelectingPanel=" + panelName + " Firebug.currentContext=" +
            (Firebug.currentContext ? Firebug.currentContext.getName() : "undefined"));

    if (Firebug.currentContext)
    {
        Firebug.currentContext.previousPanelName = Firebug.currentContext.panelName;
        Firebug.currentContext.panelName = panelName;

        Firebug.currentContext.sidePanelName =
            Firebug.currentContext.sidePanelNames &&
            panelName in Firebug.currentContext.sidePanelNames
            ? Firebug.currentContext.sidePanelNames[panelName]
            : null;
    }

    if (panel)
        panel.navigate(panel.location);

    // Hide all toolbars now. It's a responsibility of the new selected panel to show
    // those toolbars, that are necessary. This avoids the situation when a naughty panel
    // doesn't clean up its toolbars. This must be done before 'showPanel' is dispatched,
    // where the visibility of the BON buttons is managed.
    var toolbar = FirebugChrome.$("fbToolbarInner");
    var child = toolbar.firstChild;
    while (child)
    {
        Dom.collapse(child, true);
        child = child.nextSibling;
    }

    // Those extensions that don't use XUL overlays (i.e. bootstrapped extensions)
    // can provide toolbar buttons throug Firebug APIs.
    var panelToolbar = FirebugChrome.$("fbPanelToolbar");
    Dom.eraseNode(panelToolbar);

    if (panel)
    {
        // get buttons from current panel
        var buttons;
        if (panel.getPanelToolbarButtons)
            buttons = panel.getPanelToolbarButtons();

        if (!buttons)
            buttons = [];

        Events.dispatch(Firebug.uiListeners, "onGetPanelToolbarButtons", [panel, buttons]);

        for (var i=0; i<buttons.length; ++i)
            Toolbar.createToolbarButton(panelToolbar, buttons[i]);

        Dom.collapse(panelToolbar, buttons.length == 0);
    }

    // Calling Firebug.showPanel causes dispatching 'showPanel' to all modules.
    var browser = panel ? panel.context.browser : Firefox.getCurrentBrowser();
    Firebug.showPanel(browser, panel);

    // Synchronize UI around panels. Execute the sync after 'showPanel' so the logic
    // can decide whether to display separators or not.
    // xxxHonza: The command line should be synced here as well.
    Firebug.chrome.syncLocationList();
    Firebug.chrome.syncStatusPath();

    //xxxjjb: unfortunately the Stack side panel depends on the status path (sync after.)
    Firebug.chrome.syncSidePanels();
}

function onMouseScroll(event)
{
    if (Events.isControlAlt(event))
    {
        Events.cancelEvent(event);
        Firebug.Options.changeTextSize(-event.detail);
    }
}

function onSelectedSidePanel(event)
{
    var sidePanel = panelBar2.selectedPanel;
    if (Firebug.currentContext)
    {
        var panelName = Firebug.currentContext.panelName;
        if (panelName)
        {
            var sidePanelName = sidePanel ? sidePanel.name : null;
            Firebug.currentContext.sidePanelNames[panelName] = sidePanelName;
        }
    }

    if (FBTrace.DBG_PANELS)
        FBTrace.sysout("chrome.onSelectedSidePanel name=" +
            (sidePanel ? sidePanel.name : "undefined"));

    var panel = panelBar1.selectedPanel;
    if (panel && sidePanel)
        sidePanel.select(panel.selection);

    var browser = sidePanel ? sidePanel.context.browser : Firefox.getCurrentBrowser();
    // dispatch to modules
    Firebug.showSidePanel(browser, sidePanel);
}

function onPanelMouseOver(event)
{
    var object = Firebug.getRepObject(event.target);
    if (!object)
        return;

    var rep = Firebug.getRep(object, Firebug.currentContext);
    if (rep)
        rep.highlightObject(object, Firebug.currentContext, event.target);
}

function onPanelMouseOut(event)
{
    var object = Firebug.getRepObject(event.target);
    if (!object)
        return;

    var rep = Firebug.getRep(object, Firebug.currentContext);
    if (rep)
        rep.unhighlightObject(object, Firebug.currentContext, event.target);
}

function onPanelClick(event)
{
    var repNode = Firebug.getRepNode(event.target);
    if (repNode)
    {
        var object = repNode.repObject;
        var rep = Firebug.getRep(object, Firebug.currentContext);
        var realObject = rep ? rep.getRealObject(object, Firebug.currentContext) : null;
        var realRep = realObject ? Firebug.getRep(realObject, Firebug.currentContext) : rep;
        if (!realObject)
            realObject = object;

        if (Events.isLeftClick(event))
        {
            if (Css.hasClass(repNode, "objectLink"))
            {
                if (realRep)
                {
                    realRep.inspectObject(realObject, Firebug.currentContext);
                    Events.cancelEvent(event);
                }
            }
        }
    }
}

var lastMouseDownPosition = {x: -1000, y: -1000};
function onPanelMouseDown(event)
{
    if (Events.isLeftClick(event))
    {
        lastMouseDownPosition.x = event.screenX;
        lastMouseDownPosition.y = event.screenY;
    }
    else if (Events.isMiddleClick(event, true) && Events.isControlAlt(event))
    {
        Events.cancelEvent(event);
        Firebug.Options.setTextSize(0);
    }
    else if (Events.isMiddleClick(event) && Firebug.getRepNode(event.target))
    {
        // Prevent auto-scroll when middle-clicking a rep object
        Events.cancelEvent(event);
    }
}

function onPanelMouseUp(event)
{
    if (Events.isLeftClick(event))
    {
        var selection = event.target.ownerDocument.defaultView.getSelection();
        var target = selection.focusNode || event.target;

        if (Dom.getAncestorByClass(selection.focusNode, "editable") ===
            Dom.getAncestorByClass(selection.anchorNode, "editable"))
        {
            var editable = Dom.getAncestorByClass(target, "editable");
            if (editable || Css.hasClass(event.target, "inlineExpander"))
            {
                var selectionData;
                var unselectedRange = event.target.ownerDocument.createRange();
                var selectedRange = selection.getRangeAt(0);
                var referenceElement = editable || event.target;
                unselectedRange.setStart(referenceElement.firstElementChild ||
                    referenceElement, 0);
                unselectedRange.setEnd(selectedRange.startContainer, selectedRange.startOffset);

                if (selectedRange.collapsed)
                {
                    var distance = Math.abs(event.screenX - lastMouseDownPosition.x) +
                        Math.abs(event.screenY - lastMouseDownPosition.y);

                    // If mouse has moved far enough, set selection at that point
                    if (distance > 3 || Css.hasClass(event.target, "inlineExpander"))
                    {
                        selectionData =
                        {
                            start: selectedRange.startOffset,
                            end: selectedRange.endOffset
                        };
                    }
                    // otherwise leave selectionData undefined to select all text
                }
                else
                {
                    var unselectedRangeLength = unselectedRange.toString().length;
                    var selectedRangeLength = selection.getRangeAt(0).toString().length;
                    selectionData =
                    {
                        start: unselectedRangeLength,
                        end: unselectedRangeLength + selectedRangeLength
                    };
                }

                if (editable)
                {
                    Firebug.Editor.startEditing(editable, null, null, selectionData);
                }
                else
                {
                    Firebug.Editor.setSelection(selectionData);
                    selection.removeAllRanges();
                }

                Events.cancelEvent(event);
            }
        }
    }
    else if (Events.isControlClick(event) || Events.isMiddleClick(event))
    {
        var repNode = Firebug.getRepNode(event.target);
        if (!repNode)
            return;

        var object = repNode.repObject;
        var rep = Firebug.getRep(object, Firebug.currentContext);
        var realObject = rep ? rep.getRealObject(object, Firebug.currentContext) : null;
        var realRep = realObject ? Firebug.getRep(realObject, Firebug.currentContext) : rep;
        if (!realObject)
            realObject = object;

        if (!realRep || !realRep.browseObject(realObject, Firebug.currentContext))
        {
            if (rep && !(rep != realRep && rep.browseObject(object, Firebug.currentContext)))
            {
                var panel = Firebug.getElementPanel(event.target);
                if (!panel || !panel.browseObject(realObject))
                    return;
            }
        }
        Events.cancelEvent(event);
    }
}

function onMainTabBoxMouseDown(event)
{
    if (Firebug.isInBrowser())
    {
        var contentSplitter = FirebugChrome.$("fbContentSplitter");
        // TODO: grab the splitter here.
    }
}

function stopBubble(event)
{
    event.stopPropagation();
}

function getRealObject(object)
{
    var rep = Firebug.getRep(object, Firebug.currentContext);
    var realObject = rep ? rep.getRealObject(object, Firebug.currentContext) : null;
    return realObject ? realObject : object;
}

function fatalError(summary, exc)
{
    if (typeof(FBTrace) !== undefined)
        FBTrace.sysout.apply(FBTrace, arguments);

    Components.utils.reportError(summary);

    throw exc;
}

return FirebugChrome;

}  // end of createFirebugChrome(win)
}; // end of var ChromeFactory object

// ********************************************************************************************* //

return ChromeFactory;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/eventSource",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/events",
    "firebug/lib/array",
],
function(Firebug, FBTrace, Events, Arr) {

"use strict";

// ********************************************************************************************* //
// Constants

var TraceError = FBTrace.to("DBG_ERRORS");

// ********************************************************************************************* //
// Implementation

/**
 * Support for listeners registration. This object is also extended by Module,
 * so all modules supports listening automatically. Note that an array of listeners is
 * created for each instance of a module within the initialize method. Thus all derived
 * module classes must ensure that the Module.initialize method is called for the
 * super class.
 */
function EventSource()
{
    // The array is created when the first listeners is added.
    // It can't be created here since derived objects would share
    // the same array.
    this.fbListeners = null;
};

EventSource.prototype =
{
    addListener: function(listener)
    {
        if (!listener)
        {
            TraceError.sysout("firebug.Listener.addListener; ERROR null listener registered.");
            return;
        }

        // Delay the creation until the objects are created so 'this' causes new array
        // for this object (e.g. module, panel, etc.)
        if (!this.fbListeners)
            this.fbListeners = [];

        this.fbListeners.push(listener);
    },

    removeListener: function(listener)
    {
        // if this.fbListeners is null, remove is being called with no add
        Arr.remove(this.fbListeners, listener);
    },

    dispatch: function(eventName, args)
    {
        if (this.fbListeners && this.fbListeners.length > 0)
            Events.dispatch(this.fbListeners, eventName, args);
    },

    dispatch2: function(eventName, args)
    {
        if (this.fbListeners && this.fbListeners.length > 0)
            return Events.dispatch2(this.fbListeners, eventName, args);
    }
};

// ********************************************************************************************* //
// Registration

// xxxHonza: backward compatibility
Firebug.Listener = EventSource;

return EventSource;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/firefox",
[], function() {

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;
var Cc = Components.classes;
var wm = Cc["@mozilla.org/appshell/window-mediator;1"].getService(Ci.nsIWindowMediator);

// ********************************************************************************************* //
// Browser.xul dependent code

function getBrowserDocument()
{
    // TODO: this function is called very frequently, worth optimizing
    try
    {
        var chrome = Firebug.chrome;
        return chrome.inDetachedScope ? chrome.originalBrowser.ownerDocument : top.document;
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("firefox.getBrowserDocument; EXCEPTION " + e, e);
    }
}

// ********************************************************************************************* //
// Browser.xul independent code

var Firefox =
{
    getElementById: function(id)
    {
        return getBrowserDocument().getElementById(id);
    },

    $: function(id)
    {
        return this.getElementById(id);
    },

    getTabBrowser: function()
    {
        if (window.gBrowser)
            return window.gBrowser;

        var tabBrowser = Firefox.getElementById("content");
        if (tabBrowser)
            return tabBrowser;

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("Firefox.getTabBrowser no window.gBrowser in "+window.location);
    },

    getCurrentBrowser: function()
    {
        var tabBrowser = Firefox.getTabBrowser();
        return tabBrowser ? tabBrowser.selectedBrowser : undefined;
    },

    getBrowsers: function()
    {
        var tabBrowser = Firefox.getTabBrowser();
        return tabBrowser ? tabBrowser.browsers : undefined;
    },

    selectTabByWindow: function(win)
    {
        var tabBrowser = Firefox.getTabBrowser();
        if (tabBrowser)
        {
            var index = tabBrowser.getBrowserIndexForDocument(win.document);
            tabBrowser.selectTabAtIndex(index);
        }
    },

    getCurrentURI: function()
    {
        try
        {
            return Firefox.getTabBrowser().currentURI;
        }
        catch (exc)
        {
            return null;
        }
    },

    /**
     * Returns <browser> element for specified content window.
     * @param {Object} win - Content window
     */
    getBrowserForWindow: function(win)
    {
        var tabBrowser = Firefox.getTabBrowser();
        if (tabBrowser && win.document)
            return tabBrowser.getBrowserForDocument(win.document);
    },

    openWindow: function(windowType, url, features, params)
    {
        var win = windowType ? wm.getMostRecentWindow(windowType) : null;
        if (win)
        {
            if ("initWithParams" in win)
                win.initWithParams(params);
            win.focus();
        }
        else
        {
            var winFeatures = "resizable,dialog=no,centerscreen" +
                (features != "" ? ("," + features) : "");
            var parentWindow = (this.instantApply || !window.opener || window.opener.closed) ?
                window : window.opener;

            win = parentWindow.openDialog(url, "_blank", winFeatures, params);
        }
        return win;
    },

    viewSource: function(url, lineNo)
    {
        window.openDialog("chrome://global/content/viewSource.xul", "_blank",
            "all,dialog=no", url, null, null, lineNo);
    },
};

// ********************************************************************************************* //

//XXXjoe This horrible hack works around a focus bug in Firefox which is caused when
//the HTML Validator extension and Firebug are installed.  It causes the keyboard to
//behave erratically when typing, and the only solution I've found is to delay
//the initialization of HTML Validator by overriding this function with a timeout.
//XXXrobc Do we still need this? Does this extension even exist anymore?
//xxxHonza: The extension still exists, but I think we should remove this hack.
try
{
    if (top.hasOwnProperty('TidyBrowser'))
    {
        var prev = TidyBrowser.prototype.updateStatusBar;
        TidyBrowser.prototype.updateStatusBar = function()
        {
            var self = this, args = arguments;
            setTimeout(function()
            {
                prev.apply(self, args);
            });
        };
    }
}
catch (err)
{
    if (FBTrace.DBG_ERRORS)
        FBTrace.sysout("firefox; EXCEPTION HTML Validator collision!", err);
}

// ********************************************************************************************* //
// Registration

return Firefox;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/infotip",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/dom"
],
function(Module, Obj, Firebug, Domplate, Locale, Events, Dom) {

"use strict";

// ********************************************************************************************* //
// Constants

const infoTipMargin = 10;

// ********************************************************************************************* //

var {domplate, DIV} = Domplate;
Firebug.InfoTip = Obj.extend(Module,
{
    dispatchName: "infoTip",
    tags: domplate(
    {
        infoTipTag: DIV({"class": "infoTip"}),
    }),

    initializeBrowser: function(browser)
    {
        browser.onInfoTipMouseOut = Obj.bind(this.onMouseOut, this, browser);
        browser.onInfoTipMouseMove = Obj.bind(this.onMouseMove, this, browser);

        var doc = browser.contentDocument;
        if (!doc)
            return;

        doc.addEventListener("mouseover", browser.onInfoTipMouseMove, true);
        doc.addEventListener("mouseout", browser.onInfoTipMouseOut, true);
        doc.addEventListener("mousemove", browser.onInfoTipMouseMove, true);

        return browser.infoTip = this.tags.infoTipTag.append({}, Dom.getBody(doc));
    },

    uninitializeBrowser: function(browser)
    {
        if (browser.infoTip)
        {
            var doc = browser.contentDocument;
            doc.removeEventListener("mouseover", browser.onInfoTipMouseMove, true);
            doc.removeEventListener("mouseout", browser.onInfoTipMouseOut, true);
            doc.removeEventListener("mousemove", browser.onInfoTipMouseMove, true);

            browser.infoTip.parentNode.removeChild(browser.infoTip);
            delete browser.infoTip;
            delete browser.onInfoTipMouseMove;
        }
    },

    showInfoTip: function(infoTip, panel, target, x, y, rangeParent, rangeOffset)
    {
        if (!Firebug.showInfoTips)
            return;

        var scrollParent = Dom.getOverflowParent(target);
        var scrollX = x + (scrollParent ? scrollParent.scrollLeft : 0);

        var show = panel.showInfoTip(infoTip, target, scrollX, y, rangeParent, rangeOffset);
        if (!show && this.fbListeners)
        {
            show = Events.dispatch2(this.fbListeners, "showInfoTip", [infoTip, target, scrollX, y,
                rangeParent, rangeOffset]);
        }

        if (show)
        {
            var htmlElt = infoTip.ownerDocument.documentElement;
            var panelWidth = htmlElt.clientWidth;
            var panelHeight = htmlElt.clientHeight;

            if (x+infoTip.offsetWidth+infoTipMargin > panelWidth)
            {
                infoTip.style.left = Math.max(0, panelWidth -
                    (infoTip.offsetWidth + infoTipMargin)) + "px";
                infoTip.style.right = "auto";
            }
            else
            {
                infoTip.style.left = (x+infoTipMargin) + "px";
                infoTip.style.right = "auto";
            }

            if (y+infoTip.offsetHeight+infoTipMargin > panelHeight)
            {
                infoTip.style.top = Math.max(0, panelHeight -
                    (infoTip.offsetHeight+infoTipMargin)) + "px";
                infoTip.style.bottom = "auto";
            }
            else
            {
                infoTip.style.top = (y+infoTipMargin) + "px";
                infoTip.style.bottom = "auto";
            }

            if (FBTrace.DBG_INFOTIP)
                FBTrace.sysout("infotip.showInfoTip; top: " + infoTip.style.top +
                    ", left: " + infoTip.style.left + ", bottom: " + infoTip.style.bottom +
                    ", right:" + infoTip.style.right + ", offsetHeight: " + infoTip.offsetHeight +
                    ", offsetWidth: " + infoTip.offsetWidth +
                    ", x: " + x + ", panelWidth: " + panelWidth +
                    ", y: " + y + ", panelHeight: " + panelHeight);

            infoTip.setAttribute("active", "true");
        }
        else
        {
            this.hideInfoTip(infoTip);
        }
    },

    hideInfoTip: function(infoTip)
    {
        if (infoTip)
            infoTip.removeAttribute("active");
    },

    onMouseOut: function(event, browser)
    {
        if (!event.relatedTarget)
            this.hideInfoTip(browser.infoTip);
    },

    onMouseMove: function(event, browser)
    {
        // Ignore if the mouse is moving over the existing info tip.
        if (Dom.getAncestorByClass(event.target, "infoTip"))
            return;

        if (browser.currentPanel)
        {
            var x = event.clientX, y = event.clientY;
            this.showInfoTip(browser.infoTip, browser.currentPanel, event.target, x, y,
                event.rangeParent, event.rangeOffset);
        }
        else
        {
            this.hideInfoTip(browser.infoTip);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    disable: function()
    {
        // XXXjoe For each browser, call uninitializeBrowser
    },

    showPanel: function(browser, panel)
    {
        if (panel)
        {
            var infoTip = panel.panelBrowser.infoTip;
            if (!infoTip)
                infoTip = this.initializeBrowser(panel.panelBrowser);
            this.hideInfoTip(infoTip);
        }

    },

    showSidePanel: function(browser, panel)
    {
        this.showPanel(browser, panel);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.InfoTip);

return Firebug.InfoTip;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/knownIssues",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/options",
    "firebug/lib/dom",
    "firebug/chrome/firefox",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/chrome/reps",
    "firebug/chrome/window",
    "firebug/chrome/panelActivation",
    "firebug/lib/events",
    "firebug/lib/css",
],
function(Firebug, Module, Rep, FBTrace, Obj, Options, Dom, Firefox, Domplate, Locale, FirebugReps,
    Win, PanelActivation, Events, Css) {

"use strict";

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

var {domplate, SPAN, P, DIV, BUTTON, TABLE, TR, TD, TBODY} = Domplate;

var slowJSDBugUrl = "https://bugzilla.mozilla.org/show_bug.cgi?id=815603";

// ********************************************************************************************* //
// Domplate

var slowJsdTag =
    P({"class": "slowJsdMessage disabledPanelDescription",
        style: "margin: 15px 0 15px 0; color: green"}
    );

var slowJsdRep = domplate(Rep,
{
    className: "text",

    tag:
        FirebugReps.OBJECTBOX(
            TABLE(
                TBODY(
                    TR(
                        TD({"valign": "middle"},
                            SPAN({"class": "slowJSD"})
                        ),
                        TD({"valign": "middle", "style": "white-space: nowrap;"},
                            BUTTON({onclick: "$onClick"},
                                Locale.$STR("knownissues.message.slowJSD.GotIt")
                            )
                        )
                    )
                )
            )
        ),

    onClick: function(event)
    {
        Options.set("showSlowJSDMessage", false);

        var row = Dom.getAncestorByClass(event.target, "logRow");
        row.parentNode.removeChild(row);

        Events.cancelEvent(event);
    }
});

// ********************************************************************************************* //

/**
 * This module is responsible for various hacks and workarounds related
 * to known platform issues.
 */
var KnownIssues = Obj.extend(Module,
/** @lends KnownIssues */
{
    dispatchName: "knownIssues",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function(prefDomain, prefNames)
    {
        Module.initialize.apply(this, arguments);

        Firebug.registerUIListener(this);
        PanelActivation.addListener(this);
    },

    shutdown: function()
    {
        Firebug.unregisterUIListener(this);
        PanelActivation.removeListener(this);

        Module.shutdown.apply(this, arguments);
    },

    initContext: function(context)
    {
        Module.initContext.apply(this, arguments);

        // Initialize default value.
        context.showSlowJSDMessage = Options.get("showSlowJSDMessage");

        this.showSlowJSDMessage(context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    showSlowJSDMessage: function(context)
    {
        // Do not display twice for this context
        if (!context || !context.showSlowJSDMessage)
            return;

        // The message is displayed only if the Console panel is enabled.
        if (!PanelActivation.isPanelEnabled(Firebug.getPanelType("console")))
            return;

        // The message is displayed only if the Script panel is enabled.
        if (!PanelActivation.isPanelEnabled(Firebug.getPanelType("script")))
            return;

        var row = Firebug.Console.log({}, context, "warn", slowJsdRep, true);

        // xxxHonza: couldn't we have vertical centering (50%) for all ".logRow" elements?
        row.setAttribute("style", "background-position: 4px 50%;")

        var parentNode = row.getElementsByClassName("slowJSD")[0];
        FirebugReps.Description.render(Locale.$STR("knownissues.message.slowJSD"),
            parentNode, Obj.bindFixed(Win.openNewTab, Win, slowJSDBugUrl));

        context.showSlowJSDMessage = false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Listener

    /**
     * Issue 6821: Tell the user that JSD slows down opening Firebug and tab switching
     */
    showDisabledPanelBox: function(panelName, parentNode)
    {
        if (panelName != "script")
            return;

        var box = parentNode.getElementsByClassName("disabledPanelDescription")[0];
        var message = slowJsdTag.insertAfter({}, box);

        FirebugReps.Description.render(Locale.$STR("knownissues.message.slowJSD"),
            message, Obj.bindFixed(Win.openNewTab, Win, slowJSDBugUrl));
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // PanelActivation Listener

    activationChanged: function(panelType, enable)
    {
        this.showSlowJSDMessage(Firebug.currentContext);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(KnownIssues);

return KnownIssues;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/measureBox",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/css",
],
function(Firebug, FBTrace, Css) {

"use strict";

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// Implementation

/**
 * MeasureBox
 * To get pixels size.width and size.height:
 *
 * <ul>
 *   <li>this.startMeasuring(view);</li>
 *   <li>var size = this.measureText(lineNoCharsSpacer);</li>
 *   <li>this.stopMeasuring();</li>
 * </ul>
 */
var MeasureBox =
/** @lends MeasureBox */
{
    startMeasuring: function(target)
    {
        if (!this.measureBox)
        {
            this.measureBox = target.ownerDocument.createElement("span");
            this.measureBox.className = "measureBox";
        }

        Css.copyTextStyles(target, this.measureBox);

        target.ownerDocument.body.appendChild(this.measureBox);
    },

    getMeasuringElement: function()
    {
        return this.measureBox;
    },

    measureText: function(value)
    {
        this.measureBox.textContent = value || "m";

        return {
            width: this.measureBox.offsetWidth,
            height: this.measureBox.offsetHeight - 1
        };
    },

    measureInputText: function(value)
    {
        if (!value)
            value = "m";

        if (!Firebug.showTextNodesWithWhitespace)
            value = value.replace(/\t/g, "mmmmmm").replace(/\ /g, "m");

        this.measureBox.textContent = value;

        return {
            width: this.measureBox.offsetWidth,
            height: this.measureBox.offsetHeight - 1
        };
    },

    getBox: function(target)
    {
        var style = this.measureBox.ownerDocument.defaultView.getComputedStyle(this.measureBox, "");
        var box = Css.getBoxFromStyles(style, this.measureBox);
        return box;
    },

    stopMeasuring: function()
    {
        this.measureBox.parentNode.removeChild(this.measureBox);
    }
};

// ********************************************************************************************* //
// Registration

// xxxHonza: backward compatibility
Firebug.MeasureBox = MeasureBox;

return MeasureBox;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/menu",
[
    "firebug/lib/trace",
    "firebug/lib/locale",
    "firebug/lib/options",
    "firebug/lib/css",
    "firebug/lib/deprecated",
    "firebug/lib/system",
],
function(FBTrace, Locale, Options, Css, Deprecated, System) {

"use strict";

// ********************************************************************************************* //
// Constants

var Menu = {};

// ********************************************************************************************* //

Menu.createMenu = function(popup, item)
{
    if (typeof item == "string")
    {
        return Deprecated.deprecated("The function's header changed to "+
            "createMenu(popup, item)",
            Menu.createMenu, [popup, {label: item}])();
    }

    var menu = popup.ownerDocument.createElement("menu");
    popup.appendChild(menu);

    Menu.setItemIntoElement(menu, item);

    this.createMenuPopup(menu, item);

    return menu;
};

Menu.createMenuPopup = function(parent, item)
{
    var menuPopup = parent.ownerDocument.createElement("menupopup");
    parent.appendChild(menuPopup);

    if (item.items)
    {
        for (var i = 0, len = item.items.length; i < len; ++i)
            Menu.createMenuItem(menuPopup, item.items[i]);
    }

    return menuPopup;
}

// Menu.createMenuItems(popup, items[, before])
Menu.createMenuItems = function(popup, items, before)
{
    for (var i=0; i<items.length; i++)
    {
        var item = items[i];

        // Override existing items to avoid duplicates.
        var existingItem = popup.querySelector("#" + item.id);
        if (existingItem)
        {
            Menu.createMenuItem(popup, item, existingItem);
            popup.removeChild(existingItem);
            continue;
        }

        Menu.createMenuItem(popup, item, before);
    }
};

Menu.createMenuItem = function(popup, item, before)
{
    if ((typeof(item) == "string" && item == "-") || item.label == "-")
        return Menu.createMenuSeparator(popup, item, before);

    var menuitem;

    if (item.items)
        menuitem = Menu.createMenu(popup, item);
    else
        menuitem = popup.ownerDocument.createElement("menuitem");

    Menu.setItemIntoElement(menuitem, item);

    if (before)
        popup.insertBefore(menuitem, before);
    else
        popup.appendChild(menuitem);

    return menuitem;
};

Menu.setItemIntoElement = function(element, item)
{
    var label = item.nol10n ? item.label : Locale.$STR(item.label);

    element.setAttribute("label", label);

    if (item.id)
        element.setAttribute("id", item.id);

    if (item.type)
        element.setAttribute("type", item.type);

    // Avoid closing the popup menu if a preference has been changed.
    // This allows to quickly change more options.
    if (item.type == "checkbox" && !item.closemenu)
        element.setAttribute("closemenu", "none");

    if (item.disabled)
        element.setAttribute("disabled", "true");

    if (item.image)
    {
        element.setAttribute("class", "menuitem-iconic");
        element.setAttribute("image", item.image);
    }

    if (item.command)
        element.addEventListener("command", item.command, false);

    if (item.commandID)
        element.setAttribute("command", item.commandID);

    if (item.option)
        element.setAttribute("option", item.option);

    if (item.tooltiptext)
    {
        var tooltiptext = item.nol10n ? item.tooltiptext : Locale.$STR(item.tooltiptext);
        element.setAttribute("tooltiptext", tooltiptext);
    }

    if (item.className)
        Css.setClass(element, item.className);

    if (item.acceltext)
        element.setAttribute("acceltext", item.acceltext);
    else if (item.key)
        element.setAttribute("key", item.key);

    if (item.name)
        element.setAttribute("name", item.name);

    if (item.checked)
        element.setAttribute("checked", "true");

    return element;
};

Menu.createMenuHeader = function(popup, item)
{
    var header = popup.ownerDocument.createElement("label");
    header.setAttribute("class", "menuHeader");

    var label = item.nol10n ? item.label : Locale.$STR(item.label);

    header.setAttribute("value", label);

    popup.appendChild(header);
    return header;
};

Menu.createMenuSeparator = function(popup, item, before)
{
    if (item instanceof Node)
    {
        return Deprecated.deprecated("The function's header changed to "+
            "createMenuSeparator(popup, item, before)",
            Menu.createMenuSeparator, [popup, null, before])();
    }

    if (!popup.firstChild)
        return;

    if (FBTrace.DBG_MENU)
        FBTrace.sysout("createMenuSeparator", {popup: popup, item: item, before: before});

    var menuItem = popup.ownerDocument.createElement("menuseparator");
    if (typeof item == "object" && item.id)
        menuItem.setAttribute("id", item.id);

    if (before)
        popup.insertBefore(menuItem, before);
    else
        popup.appendChild(menuItem);

    return menuItem;
};

/**
 * Create an option menu item definition. This method is usually used in methods like:
 * {@link Panel.getOptionsMenuItems} or {@link Panel.getContextMenuItems}.
 *
 * @param {String} label Name of the string from *.properties file.
 * @param {String} option Name of the associated option.
 * @param {String, Optional} tooltiptext Optional name of the string from *.properties file
 *      that should be used as a tooltip for the menu.
 */
Menu.optionMenu = function(label, option, tooltiptext)
{
    return {
        label: label,
        type: "checkbox",
        checked: Options.get(option),
        option: option,
        tooltiptext: tooltiptext,
        command: function() {
            return Options.togglePref(option);
        }
    };
};

/**
 * Remove unnecessary separators (at the top or at the bottom of the menu).
 */
Menu.optimizeSeparators = function(popup)
{
    while (popup.firstChild && popup.firstChild.tagName == "menuseparator")
        popup.removeChild(popup.firstChild);

    while (popup.lastChild && popup.lastChild.tagName == "menuseparator")
        popup.removeChild(popup.lastChild);

    // xxxHonza: We should also check double-separators
};

// ********************************************************************************************* //
// Registration

return Menu;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/module",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/chrome/eventSource",
],
function(Firebug, FBTrace, Obj, EventSource) {

"use strict";

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// Implementation

/**
 * @module Base class for all modules. Every derived module object must be registered using
 * <code>Firebug.registerModule</code> method. There is always one instance of a module object
 * per browser window.
 */
var Module = Obj.extend(new EventSource(),
/** @lends Module */
{
    /**
     * Called by Firebug when Firefox window is opened.
     */
    initialize: function()
    {
    },

    /**
     * Called when the UI is ready for context creation.
     * Used by chromebug; normally FrameProgressListener events trigger UI synchronization,
     * this event allows sync without progress events.
     */
    initializeUI: function(detachArgs)
    {
    },

    /**
     * Called by Firebug when Firefox window is closed.
     */
    shutdown: function()
    {
    },

    /**
     * Called when a new context is created but before the page is loaded.
     */
    initContext: function(context, persistedState)
    {
    },

    /**
     * Called when a context is destroyed. Module may store info on persistedState
     * for reloaded pages.
     */
    destroyContext: function(context, persistedState)
    {
    },

    /**
     * Called when attaching to a window (top-level or frame).
     */
    watchWindow: function(context, win)
    {
    },

    /**
     * Called when unwatching a window (top-level or frame).
     */
    unwatchWindow: function(context, win)
    {
    },

    // Called when a FF tab is create or activated (user changes FF tab)
    // Called after context is created or with context == null (to abort?)
    showContext: function(browser, context)
    {
    },

    /**
     * Called after a context's page gets DOMContentLoaded
     */
    loadedContext: function(context)
    {
    },

    /**
     * After 'onSelectingPanel', a panel has been selected but is not yet visible
     * @param browser a tab's browser element
     * @param panel selected panel or null
     */
    showPanel: function(browser, panel)
    {
    },

    showSidePanel: function(browser, sidePanel)
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    updateOption: function(name, value)
    {
    },

    getObjectByURL: function(context, url)
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // intermodule dependency

    // xxxHonza: This should be removed
    // caller needs module. win maybe context.window or iframe in context.window.
    // true means module is ready now, else getting ready
    isReadyElsePreparing: function(context, win)
    {
    },
});

// ********************************************************************************************* //
// Registration

// xxxHonza: backward compatibility.
Firebug.Module = Module;

return Module;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/navigationHistory",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/firebug",
    "firebug/lib/dom",
    "firebug/chrome/menu",
],
function(Module, Obj, Locale, Firebug, Dom, Menu) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const MAX_HISTORY_MENU_ITEMS = 15;

// ********************************************************************************************* //

/**
 * @class Support for back and forward pattern for navigating within Firebug UI (panels).
 */
Firebug.NavigationHistory = Obj.extend(Module,
{
    dispatchName: "navigationHistory",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Extending Module

    initContext: function(context, persistedState)
    {
        Module.initContext.apply(this, arguments);

        // Initialize context members.
        context.navigationHistory = [];
        context.navigationHistoryIndex = 0;

        if (persistedState && persistedState.navigationHistory)
        {
            context.navigationHistory = persistedState.navigationHistory;
            context.navigationHistoryIndex = persistedState.navigationHistoryIndex;
        }
    },

    destroyContext: function(context, persistedState)
    {
        Module.destroyContext.apply(this, arguments);

        if (persistedState)
        {
            persistedState.navigationHistory = context.navigationHistory;
            persistedState.navigationHistoryIndex = context.navigationHistoryIndex;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // History popup menu

    onPopupShowing: function(popup, context)
    {
        var currIndex = this.getCurrentIndex(context);

        if (FBTrace.DBG_HISTORY)
        {
            FBTrace.sysout("history.onPopupShowing; " + currIndex + ", " +
                context.getName(), context);
        }

        Dom.eraseNode(popup);

        var list = this.getHistory(context);

        // Don't display the popup for a single item.
        var count = list.length;
        if (count <= 1)
            return false;

        var maxItems = MAX_HISTORY_MENU_ITEMS;
        var half = Math.floor(maxItems / 2);
        var start = Math.max(currIndex - half, 0);
        var end = Math.min(start == 0 ? maxItems : currIndex + half + 1, count);

        if (end == count)
            start = Math.max(count - maxItems, 0);

        var tooltipBack = Locale.$STR("firebug.history.Go back to this panel");
        var tooltipCurrent = Locale.$STR("firebug.history.Stay on this panel");
        var tooltipForward = Locale.$STR("firebug.history.Go forward to this panel");

        for (var i=end-1; i>=start; i--)
        {
            var historyItem = list[i];
            var panelType = Firebug.getPanelType(historyItem.panelName);
            var label = Firebug.getPanelTitle(panelType);
            if (historyItem.location && historyItem.location.url)
                label += " - " + historyItem.location.url;

            var menuInfo = {
                label: label,
                nol10n: true,
                className: "menuitem-iconic fbURLMenuItem",
            };

            if (i < currIndex)
            {
                menuInfo.className += " navigationHistoryMenuItemBack";
                menuInfo.tooltiptext = tooltipBack;
            }
            else if (i == currIndex)
            {
                menuInfo.type = "radio";
                menuInfo.checked = "true";
                menuInfo.className = "navigationHistoryMenuItemCurrent";
                menuInfo.tooltiptext = tooltipCurrent;
            }
            else
            {
                menuInfo.className += " navigationHistoryMenuItemForward";
                menuInfo.tooltiptext = tooltipForward;
            }

            var menuItem = Menu.createMenuItem(popup, menuInfo);
            menuItem.repObject = location;
            menuItem.setAttribute("index", i);
        }

        return true;
    },

    onHistoryCommand: function(event, context)
    {
        var menuItem = event.target;
        var index = menuItem.getAttribute("index");
        if (!index)
            return false;

        this.gotoHistoryIndex(context, index);
        return true;
    },

    goBack: function(context)
    {
        var currIndex = this.getCurrentIndex(context);

        if (FBTrace.DBG_HISTORY)
            FBTrace.sysout("history.goBack; " + currIndex + ", " + context.getName(), context);

        this.gotoHistoryIndex(context, currIndex - 1);
    },

    goForward: function(context)
    {
        var currIndex = this.getCurrentIndex(context);

        if (FBTrace.DBG_HISTORY)
            FBTrace.sysout("history.goForward; " + currIndex + ", " + context.getName(), context);

        this.gotoHistoryIndex(context, currIndex + 1);
    },

    gotoHistoryIndex: function(context, index)
    {
        var list = this.getHistory(context);
        if (index < 0 || index >= list.length)
            return;

        var historyItem = list[index];

        try
        {
            this.navInProgress = true;
            Firebug.chrome.navigate(historyItem.location, historyItem.panelName);
            context.navigationHistoryIndex = index;
        }
        catch (e)
        {
        }
        finally
        {
            this.navInProgress = false;
        }

        this.updateButtons(context);
    },


    updateButtons: function(context)
    {
        var list = this.getHistory(context);

        var backButton = Firebug.chrome.$("fbNavigateBackButton");
        var forwardButton = Firebug.chrome.$("fbNavigateForwardButton");

        backButton.setAttribute("disabled", "true");
        forwardButton.setAttribute("disabled", "true");

        if (list.length <= 1)
            return;

        var currIndex = this.getCurrentIndex(context);

        if (currIndex > 0)
            backButton.removeAttribute("disabled");

        if (currIndex < list.length-1)
            forwardButton.removeAttribute("disabled");
    },

    getHistory: function(context)
    {
        if (!context.navigationHistory)
            context.navigationHistory = [];

        return context.navigationHistory;
    },

    getCurrentIndex: function(context)
    {
        if (typeof(context.navigationHistoryIndex) == "undefined")
            context.navigationHistoryIndex = 0;

        return context.navigationHistoryIndex;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Listener

    onPanelNavigate: function(location, panel)
    {
        var context = panel.context;
        var currIndex = this.getCurrentIndex(context);

        if (FBTrace.DBG_HISTORY)
            FBTrace.sysout("history.onPanelNavigate; " + currIndex + ", " +
                "Panel: " + (panel ? panel.name : "Unknown Panel") + ", " +
                "Location: " + (location ? location.url : "No Location") + ", " +
                context.getName());

        // The panel must be always there
        if (!panel)
            return;

        // Ignore side panel navigation.
        if (panel.parentPanel)
            return;

        // The user is navigating using the history UI, this action doesn't affect
        // the history list.
        if (this.navInProgress)
            return;

        var list = this.getHistory(context);

        // If the last item in the history is the same bail out.
        var lastHistoryItem = list.length ? list[list.length-1] : null;
        if (lastHistoryItem && lastHistoryItem.panelName == panel.name &&
            lastHistoryItem.location == location)
            return;

        if (lastHistoryItem && lastHistoryItem.location && location &&
            lastHistoryItem.location.url == location.url)
            return;

        // If the panel is the same, bail out.
        var currHistoryItem = list.length ? list[currIndex] : null;
        if (currHistoryItem && currHistoryItem.panelName == panel.name &&
            currHistoryItem.location == location)
            return;

        // Remove forward history.
        list.splice(currIndex+1, list.length-(currIndex+1));

        // New back history record.
        list.push({panelName: panel.name, location: location});
        context.navigationHistoryIndex = list.length-1;

        if (FBTrace.DBG_HISTORY)
            FBTrace.sysout("history.onPanelNavigate; New history record created " + currIndex +
                ", " + panel.name + ", " + (location ? location.url : "No Location"), list);

        // Update back and forward buttons in the UI.
        this.updateButtons(context);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.NavigationHistory);
Firebug.registerUIListener(Firebug.NavigationHistory);

return Firebug.NavigationHistory;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/panelActivation",
[
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/lib/locale",
    "firebug/lib/domplate",
    "firebug/lib/xpcom",
    "firebug/lib/url",
    "firebug/lib/dom",
    "firebug/lib/options",
],
function(Module, Rep, Obj, Firebug, Firefox, Locale, Domplate, Xpcom, Url, Dom, Options) {

"use strict";

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

var prefs = Xpcom.CCSV("@mozilla.org/preferences-service;1", "nsIPrefBranch");
var prompts = Xpcom.CCSV("@mozilla.org/embedcomp/prompt-service;1", "nsIPromptService");

var {domplate, DIV, H1, SPAN, P, A} = Domplate;

// ********************************************************************************************* //
// Panel Activation Implementation

/**
 * @module Implements Panel activation logic. A Firebug panel can support activation in order
 * to avoid performance penalties in cases when panel's features are not necessary at the moment.
 * Such panel must be derived from {@link ActivablePanel} and appropriate activable
 * module from {@link ActivableModule}
 */
Firebug.PanelActivation = Obj.extend(Module,
/** @lends Firebug.PanelActivation */
{
    dispatchName: "panelActivation",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    initialize: function()
    {
        prefs.addObserver(Options.getPrefDomain(), this, false);
        Firebug.connection.addListener(this);
    },

    initializeUI: function()
    {
        // The "off" option is removed so make sure to convert previous value
        // into "none" if necessary.
        if (Firebug.allPagesActivation == "off")
            Firebug.allPagesActivation = "none";

        // Update option menu item.
        this.updateAllPagesActivation();
    },

    shutdown: function()
    {
        prefs.removeObserver(Options.getPrefDomain(), this, false);
        Firebug.connection.removeListener(this);
    },

    showPanel: function(browser, panel)
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("PanelActivation.showPanel; " + (panel ? panel.name : "null panel"));

        // Panel toolbar is not displayed for disabled panels.
        var chrome = Firebug.chrome;
        Dom.collapse(chrome.$("fbToolbar"), !panel);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    activatePanelTypes: function(panelTypes)
    {
        for (var i = 0; i < panelTypes.length; i++)
        {
            var panelType = panelTypes[i];
            if (!this.isPanelActivable(panelType))
                continue;

            if (this.isPanelEnabled(panelType))
                panelType.prototype.onActivationChanged(true);
        }
    },

    deactivatePanelTypes: function(panelTypes)
    {
        for (var i = 0; i < panelTypes.length; i++)
        {
            var panelType = panelTypes[i];
            if (!this.isPanelActivable(panelType))
                continue;

            if (this.isPanelEnabled(panelType))
                panelType.prototype.onActivationChanged(false);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    isPanelActivable: function(panelType)
    {
        return panelType.prototype.activable ? true : false;
    },

    isPanelEnabled: function(panelType)
    {
        if (typeof(panelType) == "string")
            panelType = Firebug.getPanelType("script");

        if (!this.isPanelActivable(panelType))
            return true;

        // Panel "class" object is used to decide whether a panel is disabled
        // or not (i.e.: isEnabled is a static method of Panel)
        return panelType ? panelType.prototype.isEnabled() : false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Enable & disable methods.

    enablePanel: function(panelType)
    {
        this.setPanelState(panelType, true);
    },

    disablePanel: function(panelType)
    {
        this.setPanelState(panelType, false);
    },

    enableAllPanels: function()
    {
        for (var i = 0; i < Firebug.panelTypes.length; i++)
        {
            var panelType = Firebug.panelTypes[i];
            this.setPanelState(panelType, true);
        }
    },

    disableAllPanels: function()
    {
        for (var i = 0; i < Firebug.panelTypes.length; i++)
        {
            var panelType = Firebug.panelTypes[i];
            this.setPanelState(panelType, false);
        }
    },

    setPanelState: function(panelType, enable)
    {
        if (panelType && panelType.prototype.setEnabled)
            panelType.prototype.setEnabled(enable);

        this.updateTab(panelType);
    },

    updateTab: function(panelType)
    {
        var panelName = panelType.prototype.name;
        var panelBar = Firebug.chrome.$("fbPanelBar1");
        var tab = panelBar.updateTab(panelType);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Observer activation changes (preference)

    /**
     * Observer for activation preferences changes.
     */
    observe: function(subject, topic, data)
    {
        if (topic != "nsPref:changed")
            return;

        if (data.indexOf(".enableSites") == -1)
            return;

        var parts = data.split(".");
        if (parts.length != 4)
            return;

        try
        {
            var panelName = parts[2];
            var panelType = Firebug.getPanelType(panelName);
            if (panelType)
            {
                var enable = Options.get(panelName + ".enableSites");
                this.onActivationChanged(panelType, enable);
            }
        }
        catch (e)
        {
            if (FBTrace.DBG_ACTIVATION || FBTrace.DBG_ERRORS)
                FBTrace.sysout("PanelActivation.observe; EXCEPTION " + e, e);
        }
    },

    onActivationChanged: function(panelType, enable)
    {
        if (!enable)
        {
            // Iterate all contexts and destroy all instances of the specified panel.
            var self = this;
            Firebug.connection.eachContext(function(context) {
                context.destroyPanel(panelType, context.persistedState);
            });
        }

        panelType.prototype.onActivationChanged(enable);

        this.dispatch("activationChanged", [panelType, enable]);

        Firebug.chrome.$("fbPanelBar1").updateTab(panelType);
        Firebug.chrome.syncPanel();
    },

    // respond to event
    onClearAnnotations: function()
    {
        Firebug.closeFirebug(true);  // and we turn off as it now cannot be enabled
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI commands

    clearAnnotations: function(force)
    {
        // If 'force' is set to true, ignore preference and skip the confirmation dialog.
        // Note that the argument is used by automated tests.
        var skipConfirmation = (typeof(force) == "boolean" && force === true);
        if (skipConfirmation)
        {
            Firebug.connection.clearAnnotations();
            return;
        }

        // Show the confirmation dialog only if the preference/user says so.
        var clearConfirmationPref = "clearAnnotationsConfirmation";
        if (Options.get(clearConfirmationPref))
        {
            var check = {value: false};
            var flags = prompts.BUTTON_POS_0 * prompts.BUTTON_TITLE_YES +
            prompts.BUTTON_POS_1 * prompts.BUTTON_TITLE_NO;

            if (!prompts.confirmEx(Firebug.chrome.window, Locale.$STR("Firebug"),
                Locale.$STR("annotations.confirm.clear"), flags, "", "", "",
                Locale.$STR("Do_not_show_this_message_again"), check) == 0)
            {
                return;
            }

            Options.set(clearConfirmationPref, !check.value);
        }

        Firebug.connection.clearAnnotations();
    },

    toggleAll: function(state)
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("Firebug.toggleAll("+state+") with allPagesActivation: " +
                Firebug.allPagesActivation);

        if (state == "on")
        {
            if (Firebug.allPagesActivation == state) // then we were armed
                Firebug.allPagesActivation = "none";
            else
                this.allOn();
        }
        else
        {
            Firebug.allPagesActivation = "none";
        }

        Options.set("allPagesActivation", Firebug.allPagesActivation);
        this.updateAllPagesActivation();
    },

    updateOption: function(name, value)
    {
        if (name == "allPagesActivation")
            this.updateAllPagesActivation();
    },

    updateAllPagesActivation: function()
    {
        // don't show Off button if we are always on
        var allOn = Firebug.allPagesActivation == "on";
        Firebug.chrome.disableOff(allOn);

        Firebug.StartButton.resetTooltip();
    },

    allOn: function()
    {
        Firebug.allPagesActivation = "on";  // In future we always create contexts,
        Firebug.toggleBar(true);  // and we turn on for the current page
    }
});

// ********************************************************************************************* //
// Disabled Panel Box

/**
 * @domplate This template renders default content for disabled panels.
 */
Firebug.DisabledPanelBox = domplate(Rep,
/** @lends Firebug.DisabledPanelBox */
{
    tag:
        DIV({"class": "disabledPanelBox"},
            H1({"class": "disabledPanelHead"},
                SPAN("$pageTitle")
            ),
            P({"class": "disabledPanelDescription", style: "margin-top: 15px;"},
                Locale.$STR("moduleManager.desc3"),
                SPAN("&nbsp;"),
                SPAN({"class": "descImage descImage-$panelName"})
            ),
            A({"class": "objectLink", onclick: "$onEnable"},
                Locale.$STR("moduleManager.Enable")
            )
            /* need something here that pushes down any thing appended to the panel */
        ),

    onEnable: function(event)
    {
        var view = event.target.ownerDocument.defaultView;
        var isMainPanel = (view.name == "fbPanelBar1-browser");
        var panelBar = Firebug.chrome.$(isMainPanel ? "fbPanelBar1" : "fbPanelBar2");

        var panelType = panelBar.selectedTab.panelType;
        if (panelType.prototype.setEnabled)
        {
            panelType.prototype.setEnabled(true);
            panelBar.updateTab(panelType);
        }
        else
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("panelActivation.onEnable; panel is not activable: " +
                    Firebug.getPanelTitle(panelType));
            }
        }
    },

    /**
     * Show default content saying that this panel type (specified by name) is disabled.
     * The parent node is specified in panel.html file.
     */
    show: function(browser, panelName)
    {
        if (!panelName)
            return;

        var panel = Firebug.getPanelType(panelName);
        var panelTitle = Firebug.getPanelTitle(panel);
        var args = {
            pageTitle: Locale.$STRF("moduleManager.title", [panelTitle]),
            panelName: panelName
        };

        var parentNode = this.getParentNode(browser);
        this.tag.replace(args, parentNode, this);
        parentNode.removeAttribute("collapsed");

        // Dispatch an event to UI listeners, so the box can be customized.
        Firebug.dispatch(Firebug.uiListeners, "showDisabledPanelBox",
            [panelName, parentNode]);
    },

    /**
     * Hide currently displayed default content.
     */
    hide: function(browser)
    {
        var parentNode = this.getParentNode(browser);

        // xxxHonza: I am seeing null parentNode when Firebug initializes
        // Could it be because the panel.html can sometimes take more time to load?
        if (!parentNode)
            return;

        Dom.clearNode(parentNode);
        parentNode.setAttribute("collapsed", true);
    },

    getParentNode: function(browser)
    {
        var doc = browser.contentDocument;
        return doc.documentElement.querySelector(".disabledPanelNode");
    },
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.PanelActivation);

return Firebug.PanelActivation;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/panel",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/css",
    "firebug/lib/options",
    "firebug/lib/dom",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/chrome/eventSource",
    "firebug/chrome/searchBox",
],
function(Firebug, FBTrace, Obj, Css, Options, Dom, Events, Wrapper, EventSource, SearchBox) {

"use strict";

// ********************************************************************************************* //
// Constants

var Trace = FBTrace.to("DBG_PANELS");
var TraceError = FBTrace.to("DBG_ERRORS");

// ********************************************************************************************* //
// Implementation

/**
 * @panel Base class for all panels. Every derived panel must define a constructor and
 * register with <code>Firebug.registerPanel</code> method. An instance of the panel
 * object is created by the framework for each browser tab where Firebug is activated.
 */
var Panel = Obj.extend(new EventSource(),
/** @lends Panel */
{
    searchable: false,    // supports search
    editable: true,       // clicking on contents in the panel will invoke the inline editor,
                          // e.g. the CSS Style panel or HTML panel.
    breakable: false,     // if true, supports break-on-next (the pause button functionality)
    order: 2147483647,    // relative position of the panel (or a side panel)
    statusSeparator: "<", // the character used to separate items on the panel status (aka
                          // breadcrumbs) in the tool bar, e.g. ">"  in the DOM panel
    enableA11y: false,    // true if the panel wants to participate in A11y accessibility support.
    deriveA11yFrom: null, // Name of the panel that uses the same a11y logic.
    inspectable: false,   // true to support inspecting elements inside this panel

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function(context, doc)
    {
        if (!context.browser)
        {
            TraceError.sysout("attempt to create panel with dud context!");
            return false;
        }

        this.context = context;
        this.document = doc;

        this.panelNode = doc.createElement("div");
        this.panelNode.ownerPanel = this;

        Css.setClass(this.panelNode, "panelNode panelNode-" + this.name + " contextUID=" +
            context.uid);

        // Load persistent content if any.
        var persistedState = Firebug.getPanelState(this);
        if (persistedState)
        {
            this.persistContent = persistedState.persistContent;
            if (this.persistContent && persistedState.panelNode)
                this.loadPersistedContent(persistedState);
        }

        // The default value for 'Persist' is set only the first time.
        if (typeof(this.persistContent) == "undefined")
            this.persistContent = Options.get(this.name + ".defaultPersist");

        doc.body.appendChild(this.panelNode);

        // Update panel's tab in case the break-on-next (BON) is active.
        var shouldBreak = this.shouldBreakOnNext();

        // xxxHonza: import the right module
        Firebug.Breakpoint.updatePanelTab(this, shouldBreak);

        Trace.sysout("firebug.initialize panelNode for " + this.name);

        this.initializeNode(this.panelNode);
    },

    destroy: function(state) // Panel may store info on state
    {
        Trace.sysout("firebug.destroy panelNode for " + this.name);

        state.persistContent = this.persistContent;

        if (this.panelNode)
        {
            if (this.persistContent)
                this.savePersistedContent(state);

            delete this.panelNode.ownerPanel;
        }

        this.destroyNode();

        // xxxHonza: not exactly sure why, but it helps when testing memory-leaks.
        // Note that the selection can point to a document (in case of the HTML panel).
        // Perhaps it breaks a cycle (page -> Firebug -> page)?
        this.selection = null;
        delete this.panelBrowser;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Persistence

    savePersistedContent: function(state)
    {
        state.panelNode = this.panelNode;
    },

    loadPersistedContent: function(persistedState)
    {
        // move the nodes from the persistedState to the panel
        while (persistedState.panelNode.firstChild)
            this.panelNode.appendChild(persistedState.panelNode.firstChild);

        Dom.scrollToBottom(this.panelNode);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Life Cycle

    /**
     * Called when a panel in one XUL window is about to disappear to later reappear in
     * another XUL window.
     */
    detach: function(oldChrome, newChrome)
    {
    },

    // This is how a panel in one window reappears in another window; lazily called
    reattach: function(doc)
    {
        this.document = doc;

        if (this.panelNode)
        {
            var scrollTop = this.panelNode.scrollTop;
            this.panelNode = doc.adoptNode(this.panelNode, true);
            this.panelNode.ownerPanel = this;
            doc.body.appendChild(this.panelNode);
            this.panelNode.scrollTop = scrollTop;
        }
    },

    // Called at the end of module.initialize; addEventListener-s here
    initializeNode: function(panelNode)
    {
        Events.dispatch(this.fbListeners, "onInitializeNode", [this]);
    },

    // removeEventListener-s here.
    destroyNode: function()
    {
        Events.dispatch(this.fbListeners, "onDestroyNode", [this]);
    },

    show: function(state)  // persistedPanelState plus non-persisted hide() values
    {
    },

    hide: function(state)  // store info on state for next show.
    {
    },

    watchWindow: function(context, win)
    {
    },

    unwatchWindow: function(context, win)
    {
    },

    loadWindow: function(context, win)
    {
    },

    updateOption: function(name, value)
    {
    },

    /**
     * Called after chrome.applyTextSize
     * @param zoom: ratio of current size to normal size, e.g. 1.5
     */
    onTextSizeChange: function(zoom)
    {

    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Toolbar

    showToolbarButtons: function(buttonsId, show)
    {
        try
        {
            var buttons = Firebug.chrome.$(buttonsId);
            Dom.collapse(buttons, !show);
        }
        catch (exc)
        {
            TraceError.sysout("panel.showToolbarButtons; FAILS " + exc, exc);
        }
    },

    onGetPanelToolbarButtons: function(panel, items)
    {
        return [];
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Returns a number indicating the view's ability to inspect the object.
     *
     * Zero means not supported, and higher numbers indicate specificity.
     */
    supportsObject: function(object, type)
    {
        return 0;
    },

    // beyond type testing, is this object selectable?
    hasObject: function(object)
    {
        return false;
    },

    navigate: function(object)
    {
        // Get default location object if none is specified.
        if (!object)
            object = this.getDefaultLocation();

        // Make sure the location is *not* undefined.
        if (!object)
            object = null;

        // We should be extra careful when dealing with the |location| object (include
        // converting it to string).
        // There might be cases where the object is removed from the page (e.g. a stylesheet
        // that is currently displayed in the CSS panel) and the panel location not updated.
        //
        // This might happen because of optimization, where background panels do not observe
        // changes on the page (e.g. using a Mutation Observer).
        //
        // The object is a dead wrapper in such moments firing an exception anytime
        // its properties or methods are accessed.
        // So just pass the object back to the panel, which must do proper checking.
        if (!this.location || (object != this.location))
        {
            Trace.sysout("Panel.navigate; " + this.name);

            this.location = object;
            this.updateLocation(object);

            Events.dispatch(Firebug.uiListeners, "onPanelNavigate", [object, this]);
        }
        else
        {
            Trace.sysout("Panel.navigate; Skipped for panel " + this.name);
        }
    },

    /**
     * The location object has been changed, the panel should update it view
     *
     * @param object a location, must be one of getLocationList() returns
     *  if  getDefaultLocation() can return null, then updateLocation must handle it here.
     */
    updateLocation: function(object)
    {
    },

    select: function(object, forceUpdate)
    {
        if (!object)
            object = this.getDefaultSelection();

        Trace.sysout("firebug.select " + this.name + " forceUpdate: " + forceUpdate + " " +
            object + ((object == this.selection) ? "==" : "!=") + this.selection);

        if (forceUpdate || object != this.selection)
        {
            this.selection = object;
            this.updateSelection(object);

            Events.dispatch(Firebug.uiListeners, "onObjectSelected", [object, this]);
        }
    },

    /**
     * Firebug wants to show an object to the user and this panel has the best supportsObject()
     * result for the object. If the panel displays a container for objects of this type,
     * it should set this.selectedObject = object
     */
    updateSelection: function(object)
    {
    },

    /**
     * Redisplay the panel based on the current location and selection
     */
    refresh: function()
    {
        if (this.location)
            this.updateLocation(this.location);
        else if (this.selection)
            this.updateSelection(this.selection);
    },

    markChange: function(skipSelf)
    {
        if (this.dependents)
        {
            if (skipSelf)
            {
                for (var i = 0; i < this.dependents.length; i++)
                {
                    var panelName = this.dependents[i];
                    if (panelName != this.name)
                        this.context.invalidatePanels(panelName);
                }
            }
            else
            {
                this.context.invalidatePanels.apply(this.context, this.dependents);
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Inspector

    /**
     * Called by the framework when the user starts inspecting. Inspecting must be enabled
     * for the panel (panel.inspectable == true)
     */
    startInspecting: function()
    {
    },

    /**
     * Called by the framework when inspecting is in progress and the user moves the mouse over
     * a new page element. Inspecting must be enabled for the panel (panel.inspectable == true).
     * This method is called in a timeout to avoid performance penalties when the user moves
     * the mouse over the page elements too fast.
     *
     * @param {Element} node The page element being inspected
     * @returns {Boolean} Returns true if the node should be selected within the panel using
     *      the default panel selection mechanism (i.e. by calling panel.select(node) method).
     */
    inspectNode: function(node)
    {
        return true;
    },

    /**
     * Called by the framework when the user stops inspecting. Inspecting must be enabled
     * for the panel (panel.inspectable == true)
     *
     * @param {Element} node The last page element inspected
     * @param {Boolean} canceled Set to true if inspecting has been canceled
     *          by pressing the escape key.
     */
    stopInspecting: function(node, canceled)
    {
    },

    /**
     * Called by the framework when inspecting is in progress. Allows to inspect
     * only nodes that are supported by the panel. Derived panels can provide effective
     * algorithms to provide these nodes.
     * @param {Element} node Currently inspected page element.
     */
    getInspectNode: function(node)
    {
        while (node)
        {
            if (this.supportsObject(node, typeof node))
                return node;
            node = node.parentNode;
        }
        return null;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Called by search in the case something was found.
     * This will highlight the given node for a specific time-span. There's only one node
     * highlighted at a time.
     *
     * @param {Node} Node to highlight
     */
    highlightNode: function(node)
    {
        if (this.highlightedNode)
            Css.cancelClassTimed(this.highlightedNode, "jumpHighlight", this.context);

        this.highlightedNode = node;

        if (node)
            Css.setClassTimed(node, "jumpHighlight", this.context);
    },

    /**
     * Called by the framework when panel search is used.
     * This is responsible for finding and highlighting search matches.
     *
     * @param {String} text String to search for
     * @param {Boolean} reverse Indicates, if search is reversed
     * @returns {Boolean} true, if search matched, otherwise false
     */
    search: function(text, reverse)
    {
    },

    /**
     * Retrieves the search options that this modules supports.
     * This is used by the search UI to present the proper options.
     */
    getSearchOptionsMenuItems: function()
    {
        return [
            SearchBox.searchOptionMenu("search.Case Sensitive", "searchCaseSensitive",
                "search.tip.Case_Sensitive")
        ];
    },

    /**
     * Navigates to the next document whose match parameter returns true.
     */
    navigateToNextDocument: function(match, reverse)
    {
        // This is an approximation of the UI that is displayed by the location
        // selector. This should be close enough, although it may be better
        // to simply generate the sorted list within the module, rather than
        // sorting within the UI.
        var self = this;
        function compare(a, b)
        {
            var locA = self.getObjectDescription(a);
            var locB = self.getObjectDescription(b);

            if (locA.path > locB.path)
                return 1;
            if (locA.path < locB.path)
                return -1;
            if (locA.name > locB.name)
                return 1;
            if (locA.name < locB.name)
                return -1;

            return 0;
        }

        var allLocs = this.getLocationList().sort(compare);
        for (var curPos = 0; curPos < allLocs.length && allLocs[curPos] != this.location; curPos++);

        function transformIndex(index)
        {
            if (reverse)
            {
                // For the reverse case we need to implement wrap around.
                var intermediate = curPos - index - 1;
                return (intermediate < 0 ? allLocs.length : 0) + intermediate;
            }
            else
            {
                return (curPos + index + 1) % allLocs.length;
            }
        };

        for (var next = 0; next < allLocs.length - 1; next++)
        {
            var object = allLocs[transformIndex(next)];

            if (match(object))
            {
                this.navigate(object);
                return object;
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Options menu item
     * @typedef {Object} OptionsMenuItem
     * @property {String} label - Label of the item
     * @property {String} tooltiptext - Tooltip text of the item
     * @property {Boolean} nol10n - If true, the label and tooltiptext won't be translated
     * @property {String} type - Type of the menu item
     * @property {Boolean} checked - If true, the item is checked
     * @property {Function} command - Command, which is executed when the item is clicked
     */

    /**
     * Called when "Options" clicked. Return array of
     *
     * @returns {OptionsMenuItem[]} Generated menu items
     */
    getOptionsMenuItems: function()
    {
        return null;
    },

    /**
     * Called by chrome.onContextMenu to build the context menu when this panel has focus.
     * See also FirebugRep for a similar function also called by onContextMenu
     * Extensions may monkey patch and chain off this call
     *
     * @param object: the 'realObject', a model value, e.g. a DOM property
     * @param target: the HTML element clicked on.
     * @returns an array of menu items.
     */
    getContextMenuItems: function(object, target)
    {
        return [];
    },

    getBreakOnMenuItems: function()
    {
        return [];
    },

    getEditor: function(target, value)
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getDefaultSelection: function()
    {
        return null;
    },

    browseObject: function(object)
    {
    },

    getPopupObject: function(target)
    {
        return Firebug.getRepObject(target);
    },

    getTooltipObject: function(target)
    {
        return Firebug.getRepObject(target);
    },

    showInfoTip: function(infoTip, x, y)
    {

    },

    getObjectPath: function(object)
    {
        return null;
    },

    /**
     * An array of objects that can be passed to getObjectLocation.
     * The list of things a panel can show, e.g. sourceFiles.
     * Only shown if panel.location is defined and supportsObject is true
     */
    getLocationList: function()
    {
        return null;
    },

    getDefaultLocation: function()
    {
        return null;
    },

    getObjectLocation: function(object)
    {
        return "";
    },

    /**
     * URL parts
     * @typedef {Object} URLParts
     * @property {String} path - Group/category label
     * @property {String} name - Item label
     */

    /**
     * Text for the location list menu e.g. Script panel source file list
     *
     * @returns {URLParts} Object description
     */
    getObjectDescription: function(object)
    {
        var url = this.getObjectLocation(object);
        return Url.splitURLBase(url);
    },

    /**
     *  UI signal that a tab needs attention, e.g. Script panel is currently stopped on a breakpoint
     *  @param {Boolean} show If true, highlighting is turned on
     */
    highlight: function(show)
    {
        var tab = this.getTab();
        if (!tab)
            return;

        if (show)
            tab.setAttribute("highlight", "true");
        else
            tab.removeAttribute("highlight");
    },

    getTab: function()
    {
        return Firebug.getPanelTab(this.name);
    },

    /**
     * If the panel supports source viewing, then return a SourceLink, else null
     *
     * @param target an element from the panel under the mouse
     * @param object the realObject under the mouse
     */
    getSourceLink: function(target, object)
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Support for Break On Next

    /**
     * Called by the framework to see if the panel currently supports BON
     */
    supportsBreakOnNext: function()
    {
        return this.breakable;  // most panels just use this flag
    },

    /**
     * Called by the framework when the user clicks on the Break On Next button.
     *
     * @param {Boolean} armed Set to true if the Break On Next feature is
     * to be armed for action and set to false if the Break On Next should be disarmed.
     * If 'armed' is true, then the next call to shouldBreakOnNext should be |true|.
     */
    breakOnNext: function(armed)
    {
    },

    /**
     * Called when a panel is selected/displayed. The method should return true
     * if the Break On Next feature is currently armed for this panel.
     */
    shouldBreakOnNext: function()
    {
        return false;
    },

    /**
     * Returns labels for Break On Next tooltip (one for enabled and one for disabled state).
     *
     * @param {Boolean} enabled Set to true if the Break On Next feature is
     * currently activated for this panel.
     */
    getBreakOnNextTooltip: function(enabled)
    {
        return null;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Selected Object

    /**
     * Define getter for the |selection| property. This way we can always check if the current
     * selected object is valid and reset if necessary.
     */
    get selection()
    {
        try
        {
            if (this._selection && Wrapper.isDeadWrapper(this._selection))
                this._selection = null;
        }
        catch (err)
        {
            this._selection = null;
        }

        return this._selection;
    },

    set selection(val)
    {
        this._selection = val;
    }
});

// ********************************************************************************************* //
// Registration

// xxxHonza: backward compatibility.
Firebug.Panel = Panel;

return Panel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/panelNotification",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/chrome/window",
    "firebug/lib/css",
    "firebug/lib/dom",
],
function(Firebug, FBTrace, Domplate, Locale, Win, Css, Dom) {

"use strict";

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

var {domplate, DIV, TABLE, TBODY, TR, TD, SPAN, BUTTON} = Domplate;

// ********************************************************************************************* //
// Implementation

var PanelNotification = domplate(
{
    tag:
        TABLE({"class": "panelNotification", cellpadding: 0, cellspacing: 0},
            TBODY(
                TR({"class": "panelNotificationRow"},
                    TD({"class": "panelNotificationCol"},
                        SPAN({"class": "panelNotificationMessage"},
                            "$message"
                        )
                    ),
                    TD({"class": "panelSeparatorCol"}),
                    TD({"class": "panelNotificationCol"},
                        BUTTON({"class": "panelNotificationButton",
                            title: "$buttonTooltip",
                            onclick: "$onPreferences"},
                            "$buttonLabel"
                        )
                    )
                )
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onPreferences: function(event)
    {
        var table = Dom.getAncestorByClass(event.target, "panelNotification");
        Win.openNewTab("about:config?filter=" + table.config.prefName);
    },

    // xxxHonza: this API should be a little more generic
    updateCounter: function(row)
    {
        var container = Dom.getAncestorByClass(row, "panelNotificationBox");
        if (container)
            Css.removeClass(container, "collapsed");

        // Update info within the limit row.
        var message = row.getElementsByClassName("panelNotificationMessage").item(0);
        message.firstChild.nodeValue = Locale.$STRP("plural.Limit_Exceeded2",
            [row.config.totalCount]);
    },

    render: function(parent, config)
    {
        // Set default values
        config.buttonTooltip = config.buttonTooltip || null;
        config.buttonLabel = config.buttonLabel || Locale.$STR("LimitPrefs");
        config.message = config.message || Locale.$STRP("plural.Limit_Exceeded2", [0]);

        var element = this.tag.append(config, parent, this);
        element.config = config;
        return element;
    }
});

// ********************************************************************************************* //
// Registration

return PanelNotification;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/plugin",
[
    "firebug/chrome/panel",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/trace/debug",
],
function(Panel, Obj, Firebug, Debug) {

// ********************************************************************************************* //
// This is a panel implemented as its own browser with its own URL

Firebug.PluginPanel = function() {};

Firebug.PluginPanel.prototype = Obj.extend(Panel,
{
    createBrowser: function()
    {
        var doc = Firebug.chrome.window.document;
        this.browser = doc.createElement("browser");
        this.browser.addEventListener("DOMContentLoaded", this.browserReady, false);
        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("plugin.createBrowser DOMContentLoaded addEventListener\n");
        this.browser.className = "pluginBrowser";
        this.browser.setAttribute("src", this.url);  // see tabContext.createPanelType
    },

    destroyBrowser: function()
    {
        if (this.browser)
        {
            this.browser.parentNode.removeChild(this.browser);
            delete this.browser;
            if (FBTrace.DBG_INITIALIZE)
                FBTrace.sysout("plugin.destroyBrowser \n");
        }
    },

    browserReady: function()
    {
        this.browser.removeEventListener("DOMContentLoaded", this.browserReady, false);

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("plugin.browserReady DOMContentLoaded addEventListener");

        this.innerPanel = this.browser.contentWindow.FirebugPanel; // XXXjjb ?
        if (this.visible)
        {
            if (this.innerPanel)
                innerCall(this.innerPanel, "initialize", [this.context.window]);
            this.updateSelection(this.selection);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    initialize: function()
    {
        this.browserReady = Obj.bindFixed(this.browserReady, this);
        Panel.initialize.apply(this, arguments);
    },

    destroy: function(state)
    {
        this.destroyBrowser();
        Panel.destroy.apply(this, arguments);
    },

    show: function(state)
    {
        if (!this.browser)
            this.createBrowser();
    },

    hide: function()
    {
    },

    supportsObject: function(object, type)
    {
        if (this.innerPanel)
            return innerCall(this.innerPanel, "supportsObject", [object, type]);
        else
            return 0;
    },

    updateSelection: function(object)
    {
        if (!this.innerPanel)
            return;

        innerCall(this.innerPanel, "select", [object]);
    },

    getObjectPath: function(object)
    {
    },

    getDefaultSelection: function()
    {
    },

    updateOption: function(name, value)
    {
    },

    getOptionsMenuItems: function()
    {
    },

    getContextMenuItems: function(object, target)
    {
    },

    getEditor: function(target, value)
    {
    }
});

// ********************************************************************************************* //

function innerCall(innerPanel, name, args)
{
    try
    {
        innerPanel[name].apply(innerPanel, args);
    }
    catch (exc)
    {
        Debug.ERROR(exc);
    }
}

// ********************************************************************************************* //
// Registration

return Firebug.PluginPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/privacy",
[
    "firebug/chrome/module",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/array",
    "firebug/lib/events",
],
function(Module, FBTrace, Obj, Arr, Events) {

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;
var Cu = Components.utils;

try
{
    Cu["import"]("resource://gre/modules/PrivateBrowsingUtils.jsm");
}
catch (err)
{
}

// ********************************************************************************************* //

/**
 * No data should be written if Firefox is set to privatebrowsing.
 * don't forget to check it before access (issue 2923).
 * 
 * xxxHonza: as soon as Fx 22 is the min for Firebug most of the methods can be removed.
 * The most important one will be the isPrivateBrowsing
 */
var Privacy = Obj.extend(Module,
{
    initialize: function()
    {
        if (this.observerService)
            return;

        this.observerService = Cc["@mozilla.org/observer-service;1"]
            .getService(Ci.nsIObserverService);

        this.observerService.addObserver(this, "private-browsing", false);

        this.update();
    },

    shutdown: function()
    {
        this.observerService.removeObserver(this, "private-browsing");
    },

    update: function(data)
    {
        try
        {
            // xxxHonza: this component has been removed in Firefox 22
            // https://bugzilla.mozilla.org/show_bug.cgi?id=845063
            var pbs = Cc["@mozilla.org/privatebrowsing;1"]
                .getService(Ci.nsIPrivateBrowsingService);

            this.privateBrowsingEnabled = pbs.privateBrowsingEnabled;

            Events.dispatch(this.fbListeners, "onPrivateBrowsingChange",
                [this.privateBrowsingEnabled]);

            if (FBTrace.DBG_ACTIVATION)
                FBTrace.sysout("Privacy.update " + this.isPrivateBrowsing());
        }
        catch (e)
        {
            // nsIPrivateBrowsingService has been removed since Fx 22 so, don't display
            // the error message.
            //if (FBTrace.DBG_ERRORS)
            //    FBTrace.sysout("Privacy.update EXCEPTION " + e, e);
        }
    },

    observe: function (subject, topic, data)
    {
        if (topic == "private-browsing")
            Privacy.update(data);
    },

    isPrivateBrowsing: function()
    {
        try
        {
            // First check existence of the new PB API. Get firebugFrame.xul and check
            // private mode (it's the same as for the top parent window).
            if (typeof PrivateBrowsingUtils != "undefined")
                return PrivateBrowsingUtils.isWindowPrivate(Firebug.chrome.window);
        }
        catch (e)
        {
        }

        // OK, use nsIPrivateBrowsingService, it should still exist and the following
        // property should be properly initialized in update() method
        return this.privateBrowsingEnabled;
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Privacy);

return Privacy;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/rep",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/locale",
    "firebug/lib/string",
    "firebug/lib/domplate",
    "firebug/html/inspector",
],
function(Firebug, FBTrace, Locale, Str, Domplate, Inspector) {

"use strict";

// ********************************************************************************************* //
// Constants

var TraceError = FBTrace.to("DBG_ERRORS");

// ********************************************************************************************* //
// Implementation

var Rep = Domplate.domplate(
{
    className: "",
    inspectable: true,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsObject: function(object, type)
    {
        return false;
    },

    highlightObject: function(object, context)
    {
        var realObject = this.getRealObject(object, context);
        if (realObject)
            Inspector.highlightObject(realObject, context);
    },

    unhighlightObject: function(object, context)
    {
        Inspector.highlightObject(null);
    },

    inspectObject: function(object, context)
    {
        Firebug.chrome.select(object);
    },

    browseObject: function(object, context)
    {
    },

    persistObject: function(object, context)
    {
    },

    getRealObject: function(object, context)
    {
        return object;
    },

    getTitle: function(object)
    {
        if (!object)
        {
            TraceError.sysout("Rep.getTitle; ERROR No object provided");
            return "null object";
        }

        try
        {
            if (object.constructor && typeof(object.constructor) == 'function')
            {
                var ctorName = object.constructor.name;

                // xxxsz: Objects with 'Object' as constructor name should also be shown.
                // See issue 6148.
                if (ctorName)
                    return ctorName;
            }
        }
        catch (e)
        {
            TraceError.sysout("rep.getTitle; EXCEPTION " + e, e);
        }

        var label = Str.safeToString(object); // e.g. [object XPCWrappedNative [object foo]]

        const re =/\[object ([^\]]*)/;
        var m = re.exec(label);
        var n = null;
        if (m)
            n = re.exec(m[1]);  // e.g. XPCWrappedNative [object foo

        if (n)
            return n[1];  // e.g. foo
        else
            return m ? m[1] : label;
    },

    showInfoTip: function(infoTip, target, x, y)
    {
        return false;
    },

    getTooltip: function(object)
    {
        return null;
    },

    /**
     * Called by chrome.onContextMenu to build the context menu when the underlying object
     * has this rep. See also Panel for a similar function also called by onContextMenu
     * Extensions may monkey patch and chain off this call
     *
     * @param object: the 'realObject', a model value, e.g. a DOM property
     * @param target: the HTML element clicked on.
     * @param context: the context, probably Firebug.currentContext
     * @return an array of menu items.
     */
    getContextMenuItems: function(object, target, context)
    {
        return [];
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Convenience for Domplate templates

    STR: function(name)
    {
        return Locale.$STR(name);
    },

    cropString: function(text)
    {
        return Str.cropString(text);
    },

    cropMultipleLines: function(text, limit)
    {
        return Str.cropMultipleLines(text, limit);
    },

    toLowerCase: function(text)
    {
        return text ? text.toLowerCase() : text;
    },

    plural: function(n)
    {
        return n == 1 ? "" : "s";
    }
});

// ********************************************************************************************* //
// Registration

// xxxHonza: backward compatibility
Firebug.Rep = Rep;

return Rep;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/reps",
[
    "firebug/lib/object",
    "firebug/lib/array",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/chrome/firefox",
    "firebug/lib/xpcom",
    "firebug/lib/locale",
    "firebug/html/htmlLib",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/lib/options",
    "firebug/lib/url",
    "firebug/js/sourceLink",
    "firebug/js/stackFrame",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/chrome/window",
    "firebug/lib/system",
    "firebug/lib/xpath",
    "firebug/lib/string",
    "firebug/lib/xml",
    "firebug/dom/toggleBranch",
    "firebug/console/closureInspector",
    "firebug/chrome/menu",
    "arch/compilationunit",
    "firebug/net/netUtils",
    "firebug/chrome/panelActivation",
    "firebug/chrome/rep",
    "firebug/html/inspector",
],
function(Obj, Arr, Firebug, Domplate, Firefox, Xpcom, Locale, HTMLLib, Events, Wrapper, Options,
    Url, SourceLink, StackFrame, Css, Dom, Win, System, Xpath, Str, Xml, ToggleBranch,
    ClosureInspector, Menu, CompilationUnit, NetUtils, PanelActivation, Rep, Inspector) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, TAG, DIV, SPAN, TR, P, UL, LI, PRE, A} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;

// xxxHonza: the only global should be Firebug object.
var FirebugReps = window.FirebugReps = {};

try
{
    // xxxHonza: RJS
    var FBS = {};
    Components.utils["import"]("resource://firebug/firebug-service.js", FBS);
    var jsd = Cc["@mozilla.org/js/jsd/debugger-service;1"].getService(Ci.jsdIDebuggerService);
}
catch (err)
{
}

// ********************************************************************************************* //
// Common Tags

var OBJECTBOX = FirebugReps.OBJECTBOX =
    SPAN({"class": "objectBox objectBox-$className", role: "presentation"});

var PREOBJECTBOX =
    PRE({"class": "objectBox inline objectBox-$className", role: "presentation"});

var OBJECTBLOCK = FirebugReps.OBJECTBLOCK =
    DIV({"class": "objectBox objectBox-$className focusRow subLogRow", role: "listitem"});

var OBJECTLINK = FirebugReps.OBJECTLINK =
    A({
        "class": "objectLink objectLink-$className a11yFocus",
        _repObject: "$object"
    });

// ********************************************************************************************* //

FirebugReps.Undefined = domplate(Rep,
{
    tag: OBJECTBOX("undefined"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "undefined",

    supportsObject: function(object, type)
    {
        return type == "undefined";
    }
});

// ********************************************************************************************* //

FirebugReps.Null = domplate(Rep,
{
    tag: OBJECTBOX("null"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "null",

    supportsObject: function(object, type)
    {
        return object == null;
    }
});

// ********************************************************************************************* //

FirebugReps.Hint = domplate(Rep,
{
    tag: OBJECTBOX("$object"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "hint",
});

// ********************************************************************************************* //

FirebugReps.Nada = domplate(Rep,
{
    tag: SPAN(""),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "nada"
});

// ********************************************************************************************* //

FirebugReps.Number = domplate(Rep,
{
    tag: OBJECTBOX({"_repObject": "$object"}, "$object"),
    tinyTag: OBJECTBOX("$object"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "number",

    supportsObject: function(object, type)
    {
        return type == "boolean" || type == "number";
    }
});

// ********************************************************************************************* //

// To support copying strings with multiple spaces, tabs, newlines etc. correctly
// we are unfortunately required by Firefox to use a <pre> tag (bug 116083).
// Don't do that with all OBJECTBOX's though - it inserts newlines *everywhere*.
// (See issues 3816, 6130.)
// XXX: This would look much nicer with support for IF in domplate.
var reSpecialWhitespace = /  |[\t\n]/;
FirebugReps.SpecialWhitespaceString = domplate(Rep,
{
    tag: PREOBJECTBOX({"_repObject": "$object"}, "&quot;$object&quot;"),

    shortTag: OBJECTBOX({"_repObject": "$object"}, "&quot;$object|cropMultipleLines&quot;"),
    tinyTag: OBJECTBOX("&quot;$object|cropMultipleLines&quot;"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "string",

    supportsObject: function(object, type)
    {
        return (type == "string" && reSpecialWhitespace.test(object));
    }
});

FirebugReps.String = domplate(Rep,
{
    tag: OBJECTBOX({"_repObject": "$object"}, "&quot;$object&quot;"),

    shortTag: OBJECTBOX({"_repObject": "$object"}, "&quot;$object|cropMultipleLines&quot;"),
    tinyTag: OBJECTBOX("&quot;$object|cropMultipleLines&quot;"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "string",

    supportsObject: function(object, type)
    {
        return type == "string";
    }
});

// ********************************************************************************************* //

FirebugReps.Text = domplate(Rep,
{
    tag: OBJECTBOX("$object"),

    // Refer to SpecialWhitespaceString above.
    specialWhitespaceTag: PREOBJECTBOX("$object"),

    shortTag: OBJECTBOX("$object|cropMultipleLines"),

    getWhitespaceCorrectedTag: function(str)
    {
        return reSpecialWhitespace.test(str) ? this.specialWhitespaceTag : this.tag;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "text"
});

// ********************************************************************************************* //

FirebugReps.Caption = domplate(Rep,
{
    tag: SPAN({"class": "caption"}, "$object")
});

// ********************************************************************************************* //

FirebugReps.Warning = domplate(Rep,
{
    tag: DIV({"class": "warning focusRow", role: "listitem"}, "$object|STR")
});

// ********************************************************************************************* //

FirebugReps.Func = domplate(Rep,
{
    tag:
        OBJECTLINK("$object|summarizeFunction"),

    summarizeFunction: function(fn)
    {
        var fnText = Str.safeToString(fn);
        var namedFn = /^function ([^(]+\([^)]*\))/.exec(fnText);
        var anonFn = /^function \(/.test(fnText);
        var displayName = fn.displayName;

        return namedFn ? namedFn[1] : (displayName ? displayName + "()" :
            (anonFn ? "function()" : fnText));
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    copySource: function(fn)
    {
        if (fn && typeof (fn['toSource']) == 'function')
            System.copyToClipboard(fn.toSource());
    },

    monitor: function(fn, monitored)
    {
        if (monitored)
            Firebug.Debugger.unmonitorFunction(fn,  "monitor");
        else
            Firebug.Debugger.monitorFunction(fn, "monitor");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "function",

    supportsObject: function(object, type)
    {
        return type == "function";
    },

    inspectObject: function(fn, context)
    {
        var sourceLink = Firebug.SourceFile.findSourceForFunction(fn, context);
        if (sourceLink)
            Firebug.chrome.select(sourceLink);

        if (FBTrace.DBG_FUNCTION_NAMES)
            FBTrace.sysout("reps.function.inspectObject selected sourceLink is ", sourceLink);
    },

    getTooltip: function(fn, context)
    {
        var script = Firebug.SourceFile.findScriptForFunctionInContext(context, fn);
        if (script)
        {
            return Locale.$STRF("Line", [Url.normalizeURL(script.fileName),
                script.baseLineNumber]);
        }
        else
        {
            if (fn.toString)
                return fn.toString();
        }
    },

    getTitle: function(fn, context)
    {
        var name = fn.name ? fn.name : "function";
        return name + "()";
    },

    getContextMenuItems: function(fn, target, context, script)
    {
        if (!script)
            script = Firebug.SourceFile.findScriptForFunctionInContext(context, fn);
        if (!script)
            return;

        var scriptInfo = Firebug.SourceFile.getSourceFileAndLineByScript(context, script);
        var monitored = scriptInfo ? FBS.fbs.isMonitored(scriptInfo.sourceFile.href,
            scriptInfo.lineNo) : false;

        var self = this;
        var name = script ? StackFrame.getFunctionName(script, context) : fn.name;
        return [
            {
                label: Locale.$STRF("ShowCallsInConsole", [name]),
                tooltiptext: Locale.$STRF("dom.tip.Log_Calls_To_Function", [name]),
                nol10n: true,
                type: "checkbox",
                checked: monitored,
                command: function()
                {
                    var checked = this.hasAttribute("checked");
                    self.monitor(fn, !checked);
                }
            },
            "-",
            {
                label: "CopySource",
                tooltiptext: "dom.tip.Copy_Source",
                command: Obj.bindFixed(this.copySource, this, fn)
            }
        ];
    }
});

// ********************************************************************************************* //

FirebugReps.Obj = domplate(Rep,
{
    tag:
        OBJECTLINK(
            SPAN({"class": "objectTitle"}, "$object|getTitle "),
            SPAN({"class": "objectLeftBrace", role: "presentation"}, "{"),
            FOR("prop", "$object|shortPropIterator",
                " $prop.name",
                SPAN({"class": "objectEqual", role: "presentation"}, "$prop.equal"),
                TAG("$prop.tag", {object: "$prop.object"}),
                SPAN({"class": "objectComma", role: "presentation"}, "$prop.delim")
            ),
            SPAN({"class": "objectRightBrace"}, "}")
        ),

    shortTag:
        OBJECTLINK(
            SPAN({"class": "objectTitle"}, "$object|getTitle "),
            SPAN({"class": "objectLeftBrace", role: "presentation"}, "{"),
            FOR("prop", "$object|shortPropIterator",
                " $prop.name",
                SPAN({"class": "objectEqual", role: "presentation"}, "$prop.equal"),
                TAG("$prop.tag", {object: "$prop.object"}),
                SPAN({"class": "objectComma", role: "presentation"}, "$prop.delim")
            ),
            SPAN({"class": "objectRightBrace"}, "}")
        ),

    titleTag:
        SPAN({"class": "objectTitle"}, "$object|getTitleTag"),

    getTitleTag: function(object)
    {
        var title;
        if (typeof(object) == "string")
            title = object;
        else
            title = this.getTitle(object);

        if (title == "Object")
            title = "{...}";

        return title;
    },

    longPropIterator: function (object)
    {
        return this.propIterator(object, 100);
    },

    shortPropIterator: function (object)
    {
        return this.propIterator(object, Options.get("ObjectShortIteratorMax"));
    },

    propIterator: function (object, max)
    {
        function isInterestingProp(t, value)
        {
            return (t == "boolean" || t == "number" || (t == "string" && value) ||
                (t == "object" && value && value.toString));
        };

        // Object members with non-empty values are preferred since it gives the
        // user a better overview of the object.
        var props = [];
        this.getProps(props, object, max, isInterestingProp);

        if (props.length <= max)
        {
            // There are not enough props yet (or at least, not enough props to
            // be able to know whether we should print "more..." or not).
            // Let's display also empty members and functions.
            this.getProps(props, object, max, function(t, value)
            {
                return !isInterestingProp(t, value);
            });
        }

        if (props.length > max)
        {
            props[props.length-1] = {
                object: Locale.$STR("firebug.reps.more") + "...",
                tag: FirebugReps.Caption.tag,
                name: "",
                equal: "",
                delim: ""
            };
        }
        else if (props.length > 0)
        {
            props[props.length-1].delim = '';
        }

        return props;
    },

    getProps: function (props, object, max, filter)
    {
        max = max || 3;
        if (!object)
            return [];

        var len = 0;

        try
        {
            for (var name in object)
            {
                if (props.length > max)
                    return;

                var value;
                try
                {
                    value = object[name];
                }
                catch (exc)
                {
                    continue;
                }

                var t = typeof(value);
                if (filter(t, value))
                {
                    var rep = Firebug.getRep(value);
                    var tag = rep.tinyTag || rep.shortTag || rep.tag;
                    if ((t == "object" || t == "function") && value)
                    {
                        value = rep.getTitle(value);
                        if (rep.titleTag)
                            tag = rep.titleTag;
                        else
                            tag = FirebugReps.Obj.titleTag;
                    }

                    props.push({tag: tag, name: name, object: value, equal: "=", delim: ", "});
                }
            }
        }
        catch (exc)
        {
            // Sometimes we get exceptions when trying to read from certain objects, like
            // StorageList, but don't let that gum up the works
            // XXXjjb also History.previous fails because object is a web-page object
            // which does not have permission to read the history
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "object",

    supportsObject: function(object, type)
    {
        return true;
    }
});

// ********************************************************************************************* //
// Reference

/**
 * A placeholder used instead of cycle reference within arrays.
 * @param {Object} target The original referenced object
 */
FirebugReps.ReferenceObj = function(target)
{
    this.target = target;
};

/**
 * Rep for cycle reference in an array.
 */
FirebugReps.Reference = domplate(Rep,
{
    tag:
        OBJECTLINK({_repObject: "$object"},
            SPAN({title: "$object|getTooltip"},
                "[...]")
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "Reference",

    supportsObject: function(object, type)
    {
        return (object instanceof FirebugReps.ReferenceObj);
    },

    getTooltip: function(object)
    {
        return Locale.$STR("firebug.reps.reference");
    },

    getRealObject: function(object)
    {
        return object.target;
    },
});

// ********************************************************************************************* //

FirebugReps.ArrBase = domplate(FirebugReps.Obj,
{
    className: "array",
    toggles: new ToggleBranch.ToggleBranch(),

    titleTag:
        SPAN({"class": "objectTitle"}, "$object|getTitleTag"),

    getTitle: function(object, context)
    {
        return "[" + object.length + "]";
    },

    supportsObject: function(object, type)
    {
        return this.isArray(object);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    longArrayIterator: function(array)
    {
        return this.arrayIterator(array, 300);
    },

    shortArrayIterator: function(array)
    {
        return this.arrayIterator(array, Options.get("ObjectShortIteratorMax"));
    },

    arrayIterator: function(array, max)
    {
        var items = [];
        for (var i = 0; i < array.length && i <= max; ++i)
        {
            try
            {
                var delim = (i == array.length-1 ? "" : ", ");
                var value = array[i];

                // Cycle detected
                if (value === array)
                    value = new FirebugReps.ReferenceObj(value);

                var rep = Firebug.getRep(value);
                var tag = rep.shortTag || rep.tag;
                items.push({object: value, tag: tag, delim: delim});
            }
            catch (exc)
            {
                var rep = Firebug.getRep(exc);
                var tag = rep.shortTag || rep.tag;

                items.push({object: exc, tag: tag, delim: delim});
            }
        }

        if (array.length > max + 1)
        {
            items[max] = {
                object: (array.length-max) + " " + Locale.$STR("firebug.reps.more") + "...",
                tag: FirebugReps.Caption.tag,
                delim: ""
            };
        }

        return items;
    },

    getItemIndex: function(child)
    {
        var arrayIndex = 0;
        for (child = child.previousSibling; child; child = child.previousSibling)
        {
            if (child.repObject)
                ++arrayIndex;
        }
        return arrayIndex;
    },

    /**
     * Returns true if the passed object is an array with additional (custom) properties,
     * otherwise returns false. Custom properties should be displayed in extra expandable
     * section.
     *
     * Example array with a custom property.
     * var arr = [0, 1];
     * arr.myProp = "Hello";
     *
     * @param {Array} array The array object.
     */
    hasSpecialProperties: function(array)
    {
        function isInteger(x)
        {
            var y = parseInt(x, 10);
            if (isNaN(y))
                return false;
           return x === y.toString();
        }

        var n = 0;
        var props = Object.getOwnPropertyNames(array);
        for (var i=0; i<props.length; i++)
        {
            var p = props[i];

            // Valid indexes are skipped
            if (isInteger(p))
                continue;

            // Ignore standard 'length' property, anything else is custom.
            if (p != "length")
                return true;
        }

        return false;
    },

    onToggleProperties: function(event)
    {
        var target = event.originalTarget;
        if (Css.hasClass(target, "objectBox-array"))
        {
            Events.cancelEvent(event);

            Css.toggleClass(target, "opened");

            var propBox = target.getElementsByClassName("arrayProperties").item(0);
            if (Css.hasClass(target, "opened"))
            {
                Firebug.DOMPanel.DirTable.tag.replace(
                    {object: target.repObject, toggles: this.toggles}, propBox);
            }
            else
            {
                Dom.clearNode(propBox);
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    highlightObject: function(object, context, target)
    {
        // Highlighting huge amount of elements on the page can cause serious performance
        // problems (see issue 4736). So, avoid highlighting if the number of elements in
        // the array exceeds specified limit.
        var arr = this.getRealObject(object, context);
        var limit = Options.get("multiHighlightLimit");
        if (!arr || (limit > 0 && arr.length > limit))
        {
            if (Css.hasClass(target, "arrayLeftBracket") ||
                Css.hasClass(target, "arrayRightBracket"))
            {
                var tooltip = Locale.$STRF("console.multiHighlightLimitExceeded", [limit]);
                target.setAttribute("title", tooltip);
            }

            // Do not highlight, a tooltip will be displayed instead.
            return;
        }

        target.removeAttribute("title");

        // Highlight multiple elements on the page.
        Inspector.highlightObject(arr, context);
    },

    isArray: function(obj)
    {
        return false;
    }
});

// ********************************************************************************************* //

FirebugReps.Arr = domplate(FirebugReps.ArrBase,
{
    tag:
        OBJECTBOX({_repObject: "$object",
            $hasTwisty: "$object|hasSpecialProperties",
            onclick: "$onToggleProperties"},
            A({"class": "objectLink", onclick: "$onClickBracket"},
                SPAN({"class": "arrayLeftBracket", role: "presentation"}, "[")
            ),
            FOR("item", "$object|longArrayIterator",
                TAG("$item.tag", {object: "$item.object"}),
                SPAN({"class": "arrayComma", role: "presentation"}, "$item.delim")
            ),
            A({"class": "objectLink", onclick: "$onClickBracket"},
                SPAN({"class": "arrayRightBracket", role: "presentation"}, "]")
            ),
            SPAN({"class": "arrayProperties", role: "group"})
        ),

    shortTag:
        OBJECTBOX({_repObject: "$object",
            $hasTwisty: "$object|hasSpecialProperties",
            onclick: "$onToggleProperties"},
            SPAN({"class": "arrayLeftBracket", role: "presentation"}, "["),
            FOR("item", "$object|shortArrayIterator",
                TAG("$item.tag", {object: "$item.object"}),
                SPAN({"class": "arrayComma", role: "presentation"}, "$item.delim")
            ),
            SPAN({"class": "arrayRightBracket"}, "]"),
            SPAN({"class": "arrayProperties", role: "group"})
        ),

    onClickBracket: function(event)
    {
        var obj = Firebug.getRepObject(event.target);
        Firebug.chrome.select(obj);
    },

    isArray: function(obj)
    {
        return Array.isArray(obj) || Object.prototype.toString.call(obj) === "[object Arguments]";
    }
});

// ********************************************************************************************* //

/**
 * Any arrayish object that is not directly Array type (e.g. HTMLCollection, NodeList, etc.)
 */
FirebugReps.ArrayLikeObject = domplate(FirebugReps.ArrBase,
{
    tag:
        OBJECTBOX({_repObject: "$object",
            $hasTwisty: "$object|hasSpecialProperties",
            onclick: "$onToggleProperties"},
            A({"class": "objectTitle objectLink", onclick: "$onClickTitle"},
                "$object|getTitle"
            ),
            SPAN({"class": "arrayLeftBracket", role: "presentation"}, "["),
            FOR("item", "$object|longArrayIterator",
                TAG("$item.tag", {object: "$item.object"}),
                SPAN({"class": "arrayComma", role: "presentation"}, "$item.delim")
            ),
            SPAN({"class": "arrayRightBracket", role: "presentation"}, "]"),
            SPAN({"class": "arrayProperties", role: "group"})
        ),

    shortTag:
        OBJECTBOX({_repObject: "$object",
            $hasTwisty: "$object|hasSpecialProperties",
            onclick: "$onToggleProperties"},
            A({"class": "objectTitle objectLink", onclick: "$onClickTitle"},
                "$object|getTitle"
            ),
            SPAN({"class": "arrayLeftBracket", role: "presentation"}, "["),
            FOR("item", "$object|shortArrayIterator",
                TAG("$item.tag", {object: "$item.object"}),
                SPAN({"class": "arrayComma", role: "presentation"}, "$item.delim")
            ),
            SPAN({"class": "arrayRightBracket"}, "]"),
            SPAN({"class": "arrayProperties", role: "group"})
        ),

    onClickTitle: function(event)
    {
        var obj = Firebug.getRepObject(event.target);
        Firebug.chrome.select(obj);
    },

    getTitle: function(obj, context)
    {
        const re = /\[object ([^\]]*)/;
        var label = Object.prototype.toString.call(obj);
        var m = re.exec(label);
        return (m ? m[1] : label);
    },

    isArray: function(obj)
    {
        return Arr.isArrayLike(obj);
    }
});

// ********************************************************************************************* //

FirebugReps.Property = domplate(Rep,
{
    supportsObject: function(object, type)
    {
        return object instanceof FirebugReps.PropertyObj;
    },

    getRealObject: function(prop, context)
    {
        return prop.object[prop.name];
    },

    getTitle: function(prop, context)
    {
        return prop.name;
    }
});

// ********************************************************************************************* //

FirebugReps.PropertyObj = function(object, name)
{
    this.object = object;
    this.name = name;

    this.getObject = function()
    {
        return object[name];
    };
};

// ********************************************************************************************* //

FirebugReps.NetFile = domplate(FirebugReps.Obj,
{
    supportsObject: function(object, type)
    {
        if (typeof(Firebug.NetFile) == "undefined")
            return false;

        return object instanceof Firebug.NetFile;
    },

    browseObject: function(file, context)
    {
        Win.openNewTab(file.href);
        return true;
    },

    getRealObject: function(file, context)
    {
        return NetUtils.getRealObject(file, context);
    }
});

// ********************************************************************************************* //

FirebugReps.Element = domplate(Rep,
{
    className: "element",

    tag:
        OBJECTLINK(
            "&lt;",
            SPAN({"class": "nodeTag"}, "$object|getLocalName"),
            FOR("attr", "$object|attrIterator",
                "&nbsp;$attr.localName=&quot;",
                SPAN({"class": "nodeValue"}, "$attr|getAttrValue"),
                "&quot;"
            ),
            "&gt;"
         ),

    shortTag:
        OBJECTLINK(
            SPAN({"class": "$object|getVisible"},
                SPAN({"class": "selectorTag"}, "$object|getSelectorTag"),
                SPAN({"class": "selectorId"}, "$object|getSelectorId"),
                SPAN({"class": "selectorClass"}, "$object|getSelectorClasses"),
                TAG("$object|getValueTag", {object: "$object"})
            )
         ),

    // Generic template for various element values
    valueTag:
        SPAN({"class": "selectorValue"}, "$object|getValue"),

    // Template for <input> element with a single value coming from attribute.
    singleInputTag:
        SPAN(
            SPAN("&nbsp;"),
            SPAN({"class": "selectorValue"},
                Locale.$STR("firebug.reps.element.attribute_value") + " = "
            ),
            SPAN({"class": "attributeValue inputValue"},
                TAG(FirebugReps.String.tag, {object: "$object|getValueFromAttribute"})
            )
        ),

    // Template for <input> element with two different values (attribute and property)
    multipleInputTag:
        SPAN(
            SPAN("&nbsp;"),
            SPAN({"class": "selectorValue"},
                Locale.$STR("firebug.reps.element.property_value") + " = "
            ),
            SPAN({"class": "propertyValue inputValue"},
                TAG(FirebugReps.String.tag, {object: "$object|getValueFromProperty"})
            ),
            SPAN("&nbsp;"),
            SPAN({"class": "selectorValue"},
                Locale.$STR("firebug.reps.element.attribute_value") + " = "
            ),
            SPAN({"class": "attributeValue inputValue"},
                TAG(FirebugReps.String.tag, {object: "$object|getValueFromAttribute"})
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getValueTag: function(elt)
    {
        // Use proprietary template for <input> elements that can have two
        // different values. One coming from attribute 'value' and one coming
        // from property 'value'.
        if (elt instanceof window.HTMLInputElement)
        {
            var attrValue = elt.getAttribute("value");
            var propValue = elt.value;

            if (attrValue != propValue)
                return this.multipleInputTag;
            else
                return this.singleInputTag;
        }

        return this.valueTag;
    },

    getValueFromAttribute: function(elt)
    {
        var limit = Options.get("stringCropLength");
        var value = elt.getAttribute("value");
        return Str.cropString(value, limit);
    },

    getValueFromProperty: function(elt)
    {
        var limit = Options.get("stringCropLength");
        return Str.cropString(elt.value, limit);
    },

    getValue: function(elt)
    {
        var value;

        if (elt instanceof window.HTMLImageElement)
            value = Url.getFileName(elt.getAttribute("src"));
        else if (elt instanceof window.HTMLAnchorElement)
            value = Url.getFileName(elt.getAttribute("href"));
        else if (elt instanceof window.HTMLInputElement)
            value = elt.getAttribute("value");
        else if (elt instanceof window.HTMLFormElement)
            value = Url.getFileName(elt.getAttribute("action"));
        else if (elt instanceof window.HTMLScriptElement)
            value = Url.getFileName(elt.getAttribute("src"));

        return value ? " " + Str.cropMultipleLines(value, 20) : "";
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getLocalName: function(object)
    {
        try
        {
            return Xml.getLocalName(object);
        }
        catch (err)
        {
            return "";
        }
    },

    getNodeName: function(object)
    {
        try
        {
            return Xml.getNodeName(object);
        }
        catch (err)
        {
            return "";
        }
    },

    getAttrValue: function(attr)
    {
        var limit = Firebug.displayedAttributeValueLimit;
        return (limit > 0) ? Str.cropString(attr.value, limit) : attr.value;
    },

    getVisible: function(elt)
    {
        return Xml.isVisible(elt) ? "" : "selectorHidden";
    },

    getSelectorTag: function(elt)
    {
        return this.getLocalName(elt);
    },

    getSelectorId: function(elt)
    {
        try
        {
            return elt.id ? ("#" + elt.id) : "";
        }
        catch (e)
        {
            return "";
        }
    },

    getSelectorClasses: function(elt)
    {
        try
        {
            var selectorClasses = "";
            for (var i=0, len=elt.classList.length; i<len; ++i)
                selectorClasses += "." + elt.classList[i];
            return selectorClasses;
        }
        catch (err)
        {
            return "";
        }
    },

    attrIterator: function(elt)
    {
        var attrs = [];
        var idAttr, classAttr;
        if (elt.attributes)
        {
            for (var i = 0; i < elt.attributes.length; ++i)
            {
                var attr = elt.attributes[i];
                if (attr.localName.indexOf("-moz-math") != -1)
                    continue;
                if (attr.localName.indexOf("firebug-") != -1)
                    continue;
                else if (attr.localName == "id")
                    idAttr = attr;
                else if (attr.localName == "class")
                    classAttr = attr;
                else
                    attrs.push(attr);
            }
        }

        // Make sure 'id' and 'class' attributes are displayed first.
        if (classAttr)
            attrs.splice(0, 0, classAttr);
        if (idAttr)
            attrs.splice(0, 0, idAttr);

        return attrs;
    },

    shortAttrIterator: function(elt)
    {
        // Short version returns only 'id' and 'class' attributes.
        var attrs = [];
        if (elt.attributes)
        {
            for (var i = 0; i < elt.attributes.length; ++i)
            {
                var attr = elt.attributes[i];
                if (attr.localName == "id" || attr.localName == "class")
                    attrs.push(attr);
            }
        }
        return attrs;
    },

    getHidden: function(elt)
    {
        return Xml.isVisible(elt) ? "" : "nodeHidden";
    },

    getXPath: function(elt)
    {
        return Xpath.getElementTreeXPath(elt);
    },

    getNodeTextGroups: function(element)
    {
        var text =  element.textContent;
        if (!Firebug.showFullTextNodes)
        {
            text = Str.cropString(text,50);
        }

        var escapeGroups=[];

        if (Firebug.showTextNodesWithWhitespace)
            escapeGroups.push({
                "group": "whitespace",
                "class": "nodeWhiteSpace",
                "extra": {
                    "\t": "_Tab",
                    "\n": "_Para",
                    " " : "_Space"
                }
            });

        if (Firebug.entityDisplay != "symbols")
            escapeGroups.push({
                "group": "text",
                "class": "nodeTextEntity",
                "extra": {}
            });

        if (escapeGroups.length)
            return Str.escapeGroupsForEntities(text, escapeGroups, Options.get("entityDisplay"));
        else
            return [{str:text, "class": "", extra: ""}];
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    copyHTML: function(elt)
    {
        var html = Xml.getElementHTML(elt);
        System.copyToClipboard(html);
    },

    copyInnerHTML: function(elt)
    {
        System.copyToClipboard(elt.innerHTML);
    },

    copyXPath: function(elt)
    {
        var xpath = Xpath.getElementXPath(elt);
        System.copyToClipboard(xpath);
    },

    copyCSSPath: function(elt)
    {
        var csspath = Css.getElementCSSPath(elt);
        System.copyToClipboard(csspath);
    },

    paste: function(elt, clipboardContent, mode)
    {
        if (elt instanceof window.HTMLElement)
            return this.pasteHTML.apply(this, arguments);
        else
            return this.pasteXML.apply(this, arguments);
    },

    pasteHTML: function(elt, clipboardContent, mode)
    {
        if (mode === "replaceInner")
            elt.innerHTML = clipboardContent;
        else if (mode === "replaceOuter")
            elt.outerHTML = clipboardContent;
        else
            elt.insertAdjacentHTML(mode, clipboardContent);
    },

    pasteXML: function(elt, clipboardContent, mode)
    {
        var contextNode, parentNode = elt.parentNode;
        if (["beforeBegin", "afterEnd", "replaceOuter"].indexOf(mode) >= 0)
            contextNode = parentNode;
        else
            contextNode = elt;

        var pastedElements = Dom.markupToDocFragment(clipboardContent, contextNode);
        switch (mode)
        {
            case "beforeBegin":
                parentNode.insertBefore(pastedElements, elt);
                break;
            case "afterBegin":
                elt.insertBefore(pastedElements, elt.firstChild);
                break;
            case "beforeEnd":
                elt.appendChild(pastedElements);
                break;
            case "afterEnd":
                Dom.insertAfter(pastedElements, elt);
                break;
            case "replaceInner":
                Dom.eraseNode(elt);
                elt.appendChild(pastedElements);
                break;
            case "replaceOuter":
                parentNode.replaceChild(pastedElements, elt);
                break;
        }
    },

    persistor: function(context, xpath)
    {
        var elts = xpath
            ? Xpath.getElementsByXPath(context.window.document, xpath)
            : null;

        return elts && elts.length ? elts[0] : null;
    },

    reloadFrame: function(frame)
    {
        frame.contentDocument.location.reload();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsObject: function(object, type)
    {
        return object instanceof window.Element;
    },

    browseObject: function(elt, context)
    {
        var tag = elt.localName.toLowerCase();
        if (tag == "script" || tag == "img" || tag == "iframe" || tag == "frame")
            Win.openNewTab(elt.src);
        else if (tag == "link" || tag == "a")
            Win.openNewTab(elt.href);

        return true;
    },

    ignoreTarget: function(target)
    {
        // XXX: Temporary fix for issue 5577.
        var repNode = target && Firebug.getRepNode(target);
        return (repNode && repNode.classList.contains("cssRule"));
    },

    highlightObject: function(object, context, target)
    {
        if (this.ignoreTarget(target))
            return;

        Inspector.highlightObject(object, context);
    },

    persistObject: function(elt, context)
    {
        var xpath = Xpath.getElementXPath(elt);

        return Obj.bind(this.persistor, window.top, xpath);
    },

    getTitle: function(element, context)
    {
        return Css.getElementCSSSelector(element);
    },

    getTooltip: function(elt, context, target)
    {
        // If the mouse cursor hovers over cropped value of an input element
        // display the full value in the tooltip.
        if (Css.hasClass(target, "objectBox-string"))
        {
            var inputValue = Dom.getAncestorByClass(target, "inputValue");
            if (inputValue)
            {
                var limit = Options.get("stringCropLength");
                var value;
                if (Css.hasClass(inputValue, "attributeValue"))
                    value = elt.getAttribute("value");
                else if (Css.hasClass(inputValue, "propertyValue"))
                    value = elt.value;

                if (value && value.length > limit)
                    return value;
            }
        }

        // Don't show a tooltip when hovering an element (see issue 6706)
        return "";
    },

    getContextMenuItems: function(elt, target, context)
    {
        if (this.ignoreTarget(target))
            return;

        var type;
        var items = [];
        var clipboardContent = System.getStringDataFromClipboard();
        var isEltRoot = (elt === elt.ownerDocument.documentElement);

        if (Xml.isElementHTMLOrXHTML(elt))
            type = "HTML";
        else if (Xml.isElementMathML(elt))
            type = "MathML";
        else if (Xml.isElementSVG(elt))
            type = "SVG";
        else if (Xml.isElementXUL(elt))
            type = "XUL";
        else
            type = "XML";

        items.push(
        {
            label: Locale.$STRF("html.Copy_Node", [type]),
            tooltiptext: Locale.$STRF("html.tip.Copy_Node", [type]),
            command: Obj.bindFixed(this.copyHTML, this, elt)
        });

        if (Xml.isElementHTMLOrXHTML(elt))
        {
            items.push(
            {
                label: "CopyInnerHTML",
                tooltiptext: "html.tip.Copy_innerHTML",
                command: Obj.bindFixed(this.copyInnerHTML, this, elt)
            });
        }

        items = items.concat([
            {
                label: "CopyXPath",
                tooltiptext: "html.tip.Copy_XPath",
                id: "fbCopyXPath",
                command: Obj.bindFixed(this.copyXPath, this, elt)
            },
            {
                label: "Copy_CSS_Path",
                tooltiptext: "html.tip.Copy_CSS_Path",
                id: "fbCopyCSSPath",
                command: Obj.bindFixed(this.copyCSSPath, this, elt)
            },
            {
                label: Locale.$STRF("html.menu.Paste", [type]),
                tooltiptext: Locale.$STRF("html.tip.Paste", [type]),
                disabled: !clipboardContent,
                id: "fbPaste",
                items: [
                    {
                        label: "html.menu.Paste_Replace_Content",
                        tooltiptext: "html.tip.Paste_Replace_Content",
                        id: "fbPasteReplaceInner",
                        command: Obj.bindFixed(this.paste, this, elt, clipboardContent,
                            "replaceInner")
                    },
                    {
                        label: "html.menu.Paste_Replace_Node",
                        tooltiptext: "html.tip.Paste_Replace_Node",
                        id: "fbPasteReplaceOuter",
                        disabled: isEltRoot,
                        command: Obj.bindFixed(this.paste, this, elt, clipboardContent,
                            "replaceOuter")
                    },
                    {
                        label: "html.menu.Paste_AsFirstChild",
                        tooltiptext: "html.tip.Paste_AsFirstChild",
                        id: "fbPasteFirstChild",
                        command: Obj.bindFixed(this.paste, this, elt, clipboardContent,
                            "afterBegin")
                    },
                    {
                        label: "html.menu.Paste_AsLastChild",
                        tooltiptext: "html.tip.Paste_AsLastChild",
                        id: "fbPasteLastChild",
                        command: Obj.bindFixed(this.paste, this, elt, clipboardContent, "beforeEnd")
                    },
                    {
                        label: "html.menu.Paste_Before",
                        tooltiptext: "html.tip.Paste_Before",
                        id: "fbPasteBefore",
                        disabled: isEltRoot,
                        command: Obj.bindFixed(this.paste, this, elt, clipboardContent,
                            "beforeBegin")
                    },
                    {
                        label: "html.menu.Paste_After",
                        tooltiptext: "html.tip.Paste_After",
                        id: "fbPasteAfter",
                        disabled: isEltRoot,
                        command: Obj.bindFixed(this.paste, this, elt, clipboardContent, "afterEnd")
                    }
                ]
            }
        ]);

        var tag = elt.localName.toLowerCase();
        if (tag == "script" || tag == "link" || tag == "a" || tag == "img" || tag == "iframe" ||
            tag == "frame")
        {
            items = items.concat([
                "-",
                {
                    label: "OpenInTab",
                    tooltiptext: "firebug.tip.Open_In_Tab",
                    command: Obj.bindFixed(this.browseObject, this, elt, context)
                }
            ]);
        }

        if (tag == "iframe" || tag == "frame")
        {
            items = items.concat([
                {
                    label: "html.menu.Reload_Frame",
                    tooltiptext: "html.menu.tip.Reload_Frame",
                    command: Obj.bindFixed(this.reloadFrame, this, elt)
                }
            ]);
        }

        items = items.concat([
            "-",
            {
                label: "ScrollIntoView",
                tooltiptext: "html.tip.Scroll_Into_View",
                id: "fbScrollIntoView",
                command: Obj.bindFixed(elt.scrollIntoView, elt)
            }
        ]);

        return items;
    }
});

// ********************************************************************************************* //

FirebugReps.TextNode = domplate(Rep,
{
    tag:
        OBJECTLINK(
            "&lt;",
            SPAN({"class": "nodeTag"}, "TextNode"),
            "&nbsp;textContent=&quot;",
            SPAN({"class": "nodeValue"}, "$object.textContent|cropMultipleLines"),
            "&quot;",
            "&gt;"
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "textNode",

    inspectObject: function(node, context)
    {
        // Text nodes have two displays in HTML panel, inline and distinct
        // node. We need to examine which case we are dealing with in order to
        // select the proper object.
        if (HTMLLib.hasNoElementChildren(node.parentNode))
        {
            node = node.parentNode;
        }

        Firebug.chrome.select(node, "html", "domSide");
    },

    supportsObject: function(object, type)
    {
        return object instanceof window.Text;
    },

    getTitle: function(win, context)
    {
        return "textNode";
    }
});

// ********************************************************************************************* //

FirebugReps.RegExp = domplate(Rep,
{
    tag:
        OBJECTLINK(
            SPAN({"class": "objectTitle"}, "$object|getTitle"),
            SPAN("&nbsp;"),
            SPAN({"class": "regexpSource"}, "$object|getSource")
        ),

    className: "regexp",

    supportsObject: function(object, type)
    {
        return Object.prototype.toString.call(object) === "[object RegExp]";
    },

    getSource: function(object)
    {
        var source = "/" + object.source + "/";
        source += object.ignoreCase ? "i" : "";
        source += object.global ? "g" : "";
        source += object.multiline ? "m" : "";
        return source;
    }
});

// ********************************************************************************************* //

FirebugReps.Document = domplate(Rep,
{
    tag:
        OBJECTLINK("Document ", SPAN({"class": "objectPropValue"}, "$object|getLocation")),

    getLocation: function(doc)
    {
        return doc.location ? Url.getFileName(doc.location.href) : "";
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "object",

    supportsObject: function(object, type)
    {
        return object instanceof window.Document;
    },

    browseObject: function(doc, context)
    {
        Win.openNewTab(doc.location.href);
        return true;
    },

    persistObject: function(doc, context)
    {
        return this.persistor;
    },

    persistor: function(context)
    {
        return context.window.document;
    },

    getTitle: function(win, context)
    {
        return "document";
    },

    getTooltip: function(doc)
    {
        return doc.location.href;
    }
});

// ********************************************************************************************* //

FirebugReps.StyleSheet = domplate(Rep,
{
    tag:
        OBJECTLINK("StyleSheet ", SPAN({"class": "objectPropValue"}, "$object|getLocation")),

    getLocation: function(styleSheet)
    {
        return Url.getFileName(styleSheet.href);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    copyURL: function(styleSheet)
    {
        var url = Css.getURLForStyleSheet(styleSheet);
        if (url)
            System.copyToClipboard(url);

        if (FBTrace.DBG_ERRORS && !url)
            FBTrace.sysout("reps.StyleSheet.copyURL; ERROR no URL", styleSheet);
    },

    openInTab: function(styleSheet)
    {
        var url = Css.getURLForStyleSheet(styleSheet);
        if (url)
            Win.openNewTab(url);

        if (FBTrace.DBG_ERRORS && !url)
            FBTrace.sysout("reps.StyleSheet.openInTab; ERROR no URL", styleSheet);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "object",

    supportsObject: function(object, type)
    {
        return object instanceof window.CSSStyleSheet;
    },

    browseObject: function(styleSheet, context)
    {
        Win.openNewTab(styleSheet.href);
        return true;
    },

    persistObject: function(styleSheet, context)
    {
        return Obj.bind(this.persistor, top, styleSheet.href);
    },

    getTooltip: function(styleSheet)
    {
        return styleSheet.href;
    },

    getContextMenuItems: function(styleSheet, target, context)
    {
        return [
            {
                label: "CopyLocation",
                tooltiptext: "clipboard.tip.Copy_Location",
                command: Obj.bindFixed(this.copyURL, this, styleSheet)
            },
            "-",
            {
                label: "OpenInTab",
                tooltiptext: "firebug.tip.Open_In_Tab",
                command: Obj.bindFixed(this.openInTab, this, styleSheet)
            }
        ];
    },

    persistor: function(context, href)
    {
        return Css.getStyleSheetByHref(href, context);
    }
});

// ********************************************************************************************* //

FirebugReps.CSSRule = domplate(Rep,
{
    tag:
        OBJECTLINK("$object|getType ", SPAN({"class": "objectPropValue"}, "$object|getDescription")),

    getType: function(rule)
    {
        if (rule instanceof window.CSSStyleRule)
        {
            return "CSSStyleRule";
        }
        else if (window.CSSSupportsRule && rule instanceof window.CSSSupportsRule)
        {
            return "CSSSupportsRule";
        }
        else if ((window.CSSDocumentRule && rule instanceof window.CSSDocumentRule) ||
            (window.CSSMozDocumentRule && rule instanceof window.CSSMozDocumentRule))
        {
            return "CSSDocumentRule";
        }
        else if (rule instanceof window.CSSFontFaceRule)
        {
            return "CSSFontFaceRule";
        }
        else if (rule instanceof window.CSSImportRule)
        {
            return "CSSImportRule";
        }
        else if (rule instanceof window.CSSMediaRule)
        {
            return "CSSMediaRule";
        }
        else if (rule instanceof window.CSSCharsetRule)
        {
            return "CSSCharsetRule";
        }
        else if ((window.CSSKeyframesRule && rule instanceof window.CSSKeyframesRule) ||
            rule instanceof window.MozCSSKeyframesRule)
        {
            return "CSSKeyframesRule";
        }
        else if ((window.CSSKeyframeRule && rule instanceof window.CSSKeyframeRule) ||
            rule instanceof window.MozCSSKeyframeRule)
        {
            return "CSSKeyframeRule";
        }
        else if (window.CSSPageRule && rule instanceof window.CSSPageRule)
        {
        	return "CSSPageRule";
        }
        else if (rule instanceof window.CSSNameSpaceRule)
        {
            return "CSSNameSpaceRule";
        }

        return "CSSRule";
    },

    getDescription: function(rule)
    {
        if (rule instanceof window.CSSStyleRule)
        {
            return rule.selectorText;
        }
        else if (window.CSSSupportsRule && rule instanceof window.CSSSupportsRule)
        {
            return rule.conditionText;
        }
        else if ((window.CSSDocumentRule && rule instanceof window.CSSDocumentRule) ||
            (window.CSSMozDocumentRule && rule instanceof window.CSSMozDocumentRule))
        {
            return rule.conditionText;
        }
        else if (rule instanceof window.CSSFontFaceRule)
        {
            return rule.style.getPropertyValue("font-family");
        }
        else if (rule instanceof window.CSSImportRule)
        {
            return Url.getFileName(rule.href);
        }
        else if (rule instanceof window.CSSMediaRule)
        {
            return rule.media.mediaText;
        }
        else if (rule instanceof window.CSSCharsetRule)
        {
            return rule.encoding;
        }
        else if ((window.CSSKeyframesRule && rule instanceof window.CSSKeyframesRule) ||
            rule instanceof window.MozCSSKeyframesRule)
        {
            return rule.name;
        }
        else if ((window.CSSKeyframeRule && rule instanceof window.CSSKeyframeRule) ||
            rule instanceof window.MozCSSKeyframeRule)
        {
            return rule.keyText;
        }
        else if (window.CSSPageRule && rule instanceof window.CSSPageRule)
        {
        	return rule.selectorText || "";
        }
        else if (rule instanceof window.CSSNameSpaceRule)
        {
            var reNamespace = /^@namespace (.+ )?url\("(.*?)"\);$/;
            var namespace = rule.cssText.match(reNamespace);
            var prefix = namespace[1] || "";
            var name = namespace[2];
            return prefix + name;
        }

        return "";
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "object",

    supportsObject: function(object, type)
    {
        return object instanceof window.CSSRule;
    },

    getTooltip: function(rule)
    {
        if (rule instanceof CSSFontFaceRule)
            return Css.extractURLs(rule.style.getPropertyValue("src")).join(", ");
        else if (rule instanceof window.CSSImportRule)
            return rule.href;

        return "";
    }
});

// ********************************************************************************************* //

FirebugReps.Window = domplate(Rep,
{
    tag:
        OBJECTLINK("$object|getWindowTitle ",
            SPAN({"class": "objectPropValue"},
                "$object|getLocation"
            )
        ),

    getLocation: function(win)
    {
        try
        {
            return (win && win.location && !win.closed) ? Url.getFileName(win.location.href) : "";
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("reps.Window window closed? "+exc, exc);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "object",

    supportsObject: function(object, type)
    {
        return object instanceof window.Window;
    },

    browseObject: function(win, context)
    {
        Win.openNewTab(win.location.href);
        return true;
    },

    persistObject: function(win, context)
    {
        return this.persistor;
    },

    persistor: function(context)
    {
        return context.window;
    },

    getTitle: function(win, context)
    {
        return "window";
    },

    getWindowTitle: function(win)
    {
        if (Firebug.viewChrome)
        {
            if (win.toString().indexOf('XrayWrapper') !== -1)
                return "XrayWrapper[Window]";
        }
        return "Window";
    },

    getTooltip: function(win)
    {
        if (win && !win.closed)
            return win.location.href;
    }
});

// ********************************************************************************************* //

FirebugReps.Event = domplate(Rep,
{
    className: "event",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    tag:
        TAG("$copyEventTag", {object: "$object|copyEvent"}),

    copyEventTag:
        OBJECTLINK("$object|summarizeEvent"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    summarizeEvent: function(event)
    {
        var info = [event.type, " "];

        var eventFamily = Events.getEventFamily(event.type);
        if (eventFamily == "mouse")
            info.push("clientX=", event.clientX, ", clientY=", event.clientY);
        else if (eventFamily == "key")
            info.push("charCode=", event.charCode, ", keyCode=", event.keyCode);
        else if (event.type == "message")
            info.push("origin=", event.origin, ", data=", event.data);

        return info.join("");
    },

    copyEvent: function(event)
    {
        return new Dom.EventCopy(event);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsObject: function(object, type)
    {
        return object instanceof window.Event || object instanceof Dom.EventCopy;
    },

    getTitle: function(event, context)
    {
        return "Event " + event.type;
    }
});

// ********************************************************************************************* //

FirebugReps.SourceLink = domplate(Rep,
{
    tag:
        OBJECTLINK(
            {$collapsed: "$object|hideSourceLink"},
            DIV("$object|getSourceLinkTitle"),
            DIV({$systemLink: "$object|isSystemLink"}, "$object|getSystemFlagTitle")),

    isSystemLink: function(sourceLink)
    {
        return sourceLink && Url.isSystemURL(sourceLink.href);
    },

    hideSourceLink: function(sourceLink)
    {
        try
        {
            return (sourceLink && sourceLink.href && sourceLink.href.indexOf) ?
                (sourceLink.href.indexOf("XPCSafeJSObjectWrapper") != -1) : true;
        }
        catch (e)
        {
            // xxxHonza: I see "Security error" code: "1000" nsresult:
            // "0x805303e8 (NS_ERROR_DOM_SECURITY_ERR)"
            // when accessing globalStorage property of a page.
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("reps.hideSourceLink; EXCEPTION " + sourceLink + ", " + e, e);
        }

        return true;
    },

    getSourceLinkTitle: function(sourceLink)
    {
        if (!sourceLink || !sourceLink.href || typeof(sourceLink.href) !== 'string')
            return "";

        try
        {
            // XXX This is wrong for at least data: URLs. E.g. evaluating
            // "%2f" in the command line shows as "/".
            var fileName = sourceLink.href;
            fileName = Url.getFileName(fileName);
            fileName = decodeURIComponent(fileName);
        }
        catch(exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("reps.getSourceLinkTitle decodeURIComponent fails for \'" +
                    sourceLink.href + "\': " + exc, exc);
        }

        var maxWidth = Firebug.sourceLinkLabelWidth;
        if (maxWidth > 0)
            fileName = Str.cropString(fileName, maxWidth);

        if (sourceLink.instance)
        {
            return Locale.$STRF("InstanceLine", [fileName, sourceLink.instance + 1,
                sourceLink.line]);
        }
        else if (sourceLink.line && typeof(sourceLink.col) != "undefined")
        {
            return Locale.$STRF("LineAndCol", [fileName, sourceLink.line, sourceLink.col]);
        }
        else if (sourceLink.line)
        {
            return Locale.$STRF("Line", [fileName, sourceLink.line]);
        }
        else
        {
            return fileName;
        }
    },

    getSystemFlagTitle: function(sourceLink)
    {
        if (this.isSystemLink(sourceLink))
            return Locale.$STRF("SystemItem", [""]);
        else
            return "";
    },

    copyLink: function(sourceLink)
    {
        System.copyToClipboard(sourceLink.href);
    },

    openInTab: function(sourceLink)
    {
        Win.openNewTab(sourceLink.href);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "sourceLink",

    supportsObject: function(object, type)
    {
        return object instanceof SourceLink.SourceLink;
    },

    getTooltip: function(sourceLink)
    {
        var text;
        try
        {
            text = decodeURI(sourceLink.href);
        }
        catch(exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("reps.getTooltip decodeURI fails for " + sourceLink.href, exc);
        }

        text = unescape(sourceLink.href);

        var lines = Str.splitLines(text);
        if (lines.length < 10)
            return text;

        lines.splice(10);
        return lines.join("") + "...";
    },

    inspectObject: function(sourceLink, context)
    {
        if (sourceLink.type == "js")
        {
            var scriptFile = Firebug.SourceFile.getSourceFileByHref(sourceLink.href, context);
            if (scriptFile)
                return Firebug.chrome.select(sourceLink);
        }
        else if (sourceLink.type == "css")
        {
            // If an object is defined, treat it as the highest priority for
            // inspect actions
            if (sourceLink.object) {
                Firebug.chrome.select(sourceLink.object);
                return;
            }

            var stylesheet = Css.getStyleSheetByHref(sourceLink.href, context);
            if (stylesheet)
            {
                var ownerNode = stylesheet.ownerNode;
                if (ownerNode)
                {
                    Firebug.chrome.select(sourceLink, "html");
                    return;
                }

                var panel = context.getPanel("stylesheet");
                if (panel && panel.getRuleByLine(stylesheet, sourceLink.line))
                    return Firebug.chrome.select(sourceLink);
            }
        }
        else if (sourceLink.type == "net")
        {
            return Firebug.chrome.select(sourceLink);
        }

        // Fallback is to just open the view-source window on the file
        Firefox.viewSource(sourceLink.href, sourceLink.line);
    },

    browseObject: function(sourceLink, context)
    {
        Win.openNewTab(sourceLink.href);
        return true;
    },

    getContextMenuItems: function(sourceLink, target, context)
    {
        return [
            {
                label: "CopyLocation",
                tooltiptext: "clipboard.tip.Copy_Location",
                command: Obj.bindFixed(this.copyLink, this, sourceLink)
            },
            "-",
            {
                label: "OpenInTab",
                tooltiptext: "firebug.tip.Open_In_Tab",
                command: Obj.bindFixed(this.openInTab, this, sourceLink)
            }
        ];
    }
});

// ********************************************************************************************* //

FirebugReps.CompilationUnit = domplate(FirebugReps.SourceLink,
{
    tag:
        OBJECTLINK({$collapsed: "$object|hideSourceLink"}, "$object|getSourceLinkTitle"),

    persistor: function(context, href)
    {
        return context.getCompilationUnit(href);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "CompilationUnit",
    inspectable: false,

    supportsObject: function(object, type)
    {
       return (object instanceof CompilationUnit) ? 2 : 0;
    },

    persistObject: function(compilationUnit)
    {
        var href = compilationUnit.getURL();
        return Obj.bind(this.persistor, top, href);
    },

    browseObject: function(sourceLink, context)
    {
    },

    getTooltip: function(compilationUnit)
    {
        return compilationUnit.getURL();
    }
});

// ********************************************************************************************* //

// XXXjjb Since the repObject is fn the stack does not have correct line numbers
FirebugReps.StackFrame = domplate(Rep,
{
    tag:
        OBJECTBLOCK({$hasTwisty: "$object|hasArguments", _repObject: "$object",
            onclick: "$onToggleArguments"},
            SPAN({"class":"stackFrameMarker"}, ""),
            A({"class": "objectLink a11yFocus", _repObject: "$object"}, "$object|getCallName"),
            SPAN("("),
            SPAN({"class": "arguments"},
                FOR("arg", "$object|argIterator",
                    SPAN({"class": "argName"}, "$arg.name"),
                    SPAN("="),
                    TAG("$arg.tag", {object: "$arg.value"}),
                    SPAN({"class": "arrayComma"}, "$arg.delim")
                )
            ),
            SPAN(")"),
            SPAN({"class": "objectLink-sourceLink objectLink a11yFocus",
                _repObject: "$object|getSourceLink",
                role: "link"},
                "$object|getSourceLinkTitle"),
            DIV({"class": "argList"})
        ),

    argList:
        DIV({"class": "argListBox", onclick: "$onSelectFrame"},
            FOR("arg", "$object|argIterator",
                DIV({"class": "argBox"},
                    SPAN({"class": "argName"}, "$arg.name"),
                    SPAN("&nbsp;=&nbsp;"),
                    TAG("$arg.tag", {object: "$arg.value"})
                )
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getTitle: function(frame)
    {
        return frame.getFunctionName();
    },

    hasArguments: function(frame)
    {
        return frame.args.length;
    },

    getCallName: function(frame)
    {
        return frame.getFunctionName();
    },

    getSourceLinkTitle: function(frame)
    {
        var fileName = Url.getFileName(frame.href);

        var maxWidth = Firebug.sourceLinkLabelWidth;
        if (maxWidth > 0)
            var fileName = Str.cropString(fileName, maxWidth);

        return Locale.$STRF("Line", [fileName, frame.line]);
    },

    argIterator: function(frame)
    {
        if (!frame.args)
            return [];

        var items = [];

        for (var i = 0; i < frame.args.length; ++i)
        {
            var arg = frame.args[i];

            if (!arg)
                break;

            if (arg.hasOwnProperty('value')) // then we got these from jsd
            {
                var rep = Firebug.getRep(arg.value);
                var tag = rep.shortTag ? rep.shortTag : rep.tag;

                var delim = (i == frame.args.length-1 ? "" : ", ");

                items.push({name: arg.name, value: arg.value, tag: tag, delim: delim});
            }
            else if (arg.hasOwnProperty('name'))
            {
                items.push({name: arg.name, delim: delim});
            }
            else  // eg from Error object
            {
                var delim = (i == frame.args.length-1 ? "" : ", ");
                var rep = Firebug.getRep(arg);
                var tag = rep.shortTag ? rep.shortTag : rep.tag;

                items.push({value: arg, tag: tag, delim: delim});
            }

            if (FBTrace.DBG_DOMPLATE)
                FBTrace.sysout("reps.stackframe args[" + i + "]: " + arg.name + " = " +
                    arg.value, {arg: arg, item: items[items.length - 1]});
        }

        return items;
    },

    getSourceLink: function(stackFrame)
    {
        var sourceLink = new SourceLink.SourceLink(stackFrame.href, stackFrame.line, "js");
        return sourceLink;
    },

    onToggleArguments: function(event)
    {
        this.toggleArguments(event.originalTarget);
    },

    toggleArguments: function(target)
    {
        if (Css.hasClass(target, "objectBox-stackFrame"))
        {
            if (Css.hasClass(target, "opened"))
                this.collapseArguments(target);
            else
                this.expandArguments(target);
        }
    },

    collapseArguments: function(target)
    {
        if (!Css.hasClass(target, "opened"))
            return;

        Css.toggleClass(target, "opened");

        var argList = target.getElementsByClassName("argList").item(0);
        Dom.clearNode(argList);
    },

    expandArguments: function(target)
    {
        if (Css.hasClass(target, "opened"))
            return;

        var frame = target.repObject;
        if (!this.hasArguments(frame))
            return;

        Css.toggleClass(target, "opened");

        var argList = target.getElementsByClassName("argList").item(0);
        this.argList.replace({object: frame}, argList);
    },

    onSelectFrame: function(event)
    {
        var target = event.currentTarget;
        if (Css.hasClass(target, "argListBox"))
        {
            var stackFrame = Dom.getAncestorByClass(target, "objectBox-stackFrame");
            var panel = Firebug.getElementPanel(target);
            this.inspectObject(stackFrame.repObject, panel.context);
            Events.cancelEvent(event);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Rep

    className: "stackFrame",

    supportsObject: function(object, type)
    {
        return object instanceof StackFrame.StackFrame;
    },

    inspectObject: function(stackFrame, context)
    {
        if (context.stopped)
            Firebug.chrome.select(stackFrame);
        else
            Firebug.chrome.select(this.getSourceLink(stackFrame));
    },

    getTooltip: function(stackFrame, context)
    {
        return Locale.$STRF("Line", [stackFrame.href, stackFrame.line]);
    }
});

// ********************************************************************************************* //

FirebugReps.StackTrace = domplate(Rep,
{
    tag:
        DIV({role : "group", "aria-label" : Locale.$STR("aria.labels.stack trace")},
            FOR("frame", "$object.frames|frameIterator",
                TAG(FirebugReps.StackFrame.tag, {object: "$frame"})
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "stackTrace",

    supportsObject: function(object, type)
    {
        return object instanceof StackFrame.StackTrace;
    },

    frameIterator: function(frames)
    {
        // Skip Firebug internal frames.
        // xxxHonza: this is another place where we peel off stack frames.
        var result = [];
        for (var i=0; frames && i<frames.length; i++)
        {
            var frame = frames[i];
            var sf = frame.sourceFile;
            if ((sf && sf.href && Str.hasPrefix(sf.href, "chrome")) ||
                (frame.fn === "_firebugRerun") ||
                (frame.fn === "jsdbug_NoScriptFunctionName") ||
                (frame.fn === "(debugger)"))
            {
                continue;
            }

            result.push(frames[i]);
        }
        return result;
    }
});

// ********************************************************************************************* //

// xxxsz: Is this code still in use?
FirebugReps.Assert = domplate(Rep,
{
    tag:
        DIV(
            DIV({"class": "errorTitle"}),
            DIV({"class": "assertDescription"})
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "assert",

    inspectObject: function(error, context)
    {
        var sourceLink = this.getSourceLink(error);
        Firebug.chrome.select(sourceLink);
    },

    getContextMenuItems: function(error, target, context)
    {
        var breakOnThisError = this.hasErrorBreak(error);

        return [
            {
                label: "CopyError",
                tooltiptext: "console.tip.Copy_Error",
                command: Obj.bindFixed(this.copyError, this, error)
            },
            "-",
            {
                label: "BreakOnThisError",
                tooltiptext: "console.menu.tip.Break_On_This_Error",
                type: "checkbox",
                checked: breakOnThisError,
                command: Obj.bindFixed(this.breakOnThisError, this, error, context)
            },
            Menu.optionMenu("BreakOnAllErrors", "breakOnErrors",
                "console.menu.tip.Break_On_All_Errors")
        ];
    }
});

// ********************************************************************************************* //

FirebugReps.SourceText = domplate(Rep,
{
    tag:
        DIV(
            FOR("line", "$object|lineIterator",
                DIV({"class": "sourceRow", role : "presentation"},
                    SPAN({"class": "sourceLine", role : "presentation"}, "$line.lineNo"),
                    SPAN({"class": "sourceRowText", role : "presentation"}, "$line.text")
                )
            )
        ),

    lineIterator: function(sourceText)
    {
        var maxLineNoChars = (sourceText.lines.length + "").length;
        var list = [];

        for (var i = 0; i < sourceText.lines.length; ++i)
        {
            // Make sure all line numbers are the same width (with a fixed-width font)
            var lineNo = (i+1) + "";
            while (lineNo.length < maxLineNoChars)
                lineNo = " " + lineNo;

            list.push({lineNo: lineNo, text: sourceText.lines[i]});
        }

        return list;
    },

    getHTML: function(sourceText)
    {
        return getSourceLineRange(sourceText, 1, sourceText.lines.length);
    }
});

//********************************************************************************************** //

FirebugReps.nsIDOMHistory = domplate(Rep,
{
    tag:
        OBJECTBOX({onclick: "$showHistory", _repObject: "$object"},
            OBJECTLINK("$object|summarizeHistory")
        ),

    className: "nsIDOMHistory",

    summarizeHistory: function(history)
    {
        try
        {
            var items = history.length;
            return Locale.$STRP("firebug.reps.historyEntries", [items]);
        }
        catch (exc)
        {
            return "object does not support history (nsIDOMHistory)";
        }
    },

    showHistory: function(event)
    {
        try
        {
            var history = event.currentTarget.repObject;
            history.length;  // if this throws, then unsupported
            Firebug.chrome.select(history);
        }
        catch (exc)
        {
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsObject: function(object, type)
    {
        return (object instanceof Ci.nsIDOMHistory);
    }
});

// ********************************************************************************************* //

FirebugReps.ApplicationCache = domplate(Rep,
{
    tag:
        OBJECTLINK("$object|summarizeCache"),

    summarizeCache: function(applicationCache)
    {
        try
        {
            return applicationCache.mozItems.length + " items in offline cache";
        }
        catch(exc)
        {
            return "https://bugzilla.mozilla.org/show_bug.cgi?id=422264";
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "applicationCache",

    supportsObject: function(object, type)
    {
        if (Ci.nsIDOMOfflineResourceList)
            return (object instanceof Ci.nsIDOMOfflineResourceList);
    }
});

// ********************************************************************************************* //

FirebugReps.Storage = domplate(Rep,
{
    tag:
        OBJECTLINK(
            SPAN({"class": "storageTitle"}, "$object|summarize "),
            FOR("prop", "$object|longPropIterator",
                "$prop.name",
                SPAN({"class": "objectEqual", role: "presentation"}, "$prop.equal"),
                TAG("$prop.tag", {object: "$prop.object"}),
                SPAN({"class": "objectComma", role: "presentation"}, "$prop.delim")
            )
        ),

    shortTag:
        OBJECTLINK(
            SPAN({"class": "storageTitle"}, "$object|summarize "),
            FOR("prop", "$object|shortPropIterator",
                "$prop.name",
                SPAN({"class": "objectEqual", role: "presentation"}, "$prop.equal"),
                TAG("$prop.tag", {object: "$prop.object"}),
                SPAN({"class": "objectComma", role: "presentation"}, "$prop.delim")
            )
        ),

    summarize: function(storage)
    {
        return Locale.$STRP("firebug.storage.totalItems", [storage.length]);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "Storage",

    supportsObject: function(object, type)
    {
        return (object instanceof window.Storage);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Iterator

    longPropIterator: function(object)
    {
        return this.propIterator(object, 100);
    },

    shortPropIterator: function(object)
    {
        return this.propIterator(object, Options.get("ObjectShortIteratorMax"));
    },

    propIterator: function(storage, max)
    {
        // Extract names/values and pass them through to the standard propIterator.
        var obj = Object.create(null);
        for (var i = 0, len = storage.length; i < len; i++)
        {
            var name = storage.key(i);
            obj[name] = storage.getItem(name);
        }
        return FirebugReps.Obj.propIterator(obj, max);
    }
});

// ********************************************************************************************* //

FirebugReps.XPathResult = domplate(FirebugReps.Arr,
{
    className: "array xPathResult",
    toggles: new ToggleBranch.ToggleBranch(),

    tag:
        SPAN(FirebugReps.Arr.tag),

    shortTag:
        SPAN(FirebugReps.Arr.shortTag),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    hasSpecialProperties: function(array)
    {
        // xxxHonza: fix for test console/api/log-xpathresult
        // FirebugReps.Arr.hasSpecialProperties iterates object properties
        // (using Object.getOwnPropertyNames), but misses 'constructor' if the property
        // is not explicitely accessed before. Any explanation for such behavior?
        // (btw. it was actually accessed, but order of 'supportsObject' calls changed when
        // 'Exception' rep moved into its own module, see issue: 6606)
        var ctor = array && array.constructor;
        return FirebugReps.Arr.hasSpecialProperties.apply(this, arguments);
    },

    supportsObject: function(xpathresult, type)
    {
        return (xpathresult instanceof window.XPathResult);
    },

    arrayIterator: function(xpathresult, max)
    {
        var items = [];
        for (var i=0; i<xpathresult.snapshotLength && i<=max; i++)
        {
            var value = xpathresult.snapshotItem(i);
            var rep = Firebug.getRep(value);
            var tag = rep.shortTag || rep.tag;
            var delim = (i == xpathresult.snapshotLength-1 ? "" : ", ");

            items.push({object: value, tag: tag, delim: delim});
        }

        if (xpathresult.snapshotLength > max + 1)
        {
            items[max] = {
                object: (xpathresult.snapshotLength-max) + " " +
                    Locale.$STR("firebug.reps.more") + "...",
                tag: FirebugReps.Caption.tag,
                delim: ""
            };
        }

        return items;
    },
});

// ********************************************************************************************* //

FirebugReps.Description = domplate(Rep,
{
    className: "Description",

    // Use SPAN to make sure the description is nicely inserted into existing text inline.
    tag:
        SPAN({"class": "descriptionBox", onclick: "$onClickLink"}),

    render: function(text, parentNode, listener)
    {
        var params = {};
        params.onClickLink = function(event)
        {
            // Only clicks on links are passed to the original listener.
            var localName = event.target.localName;
            if (listener && localName && localName.toLowerCase() == "a")
                listener(event);
        };

        var rootNode = this.tag.replace(params, parentNode, this);

        var parser = Xpcom.CCIN("@mozilla.org/xmlextras/domparser;1", "nsIDOMParser");
        var doc = parser.parseFromString("<div>" + text + "</div>", "text/xml");
        var root = doc.documentElement;

        // Error handling
        var nsURI = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
        if (root.namespaceURI == nsURI && root.nodeName == "parsererror")
        {
            FBTrace.sysout("reps.Description; parse ERROR " + root.firstChild.nodeValue, root);

            return FirebugReps.Warning.tag.replace({object: "css.EmptyElementCSS"},
                parentNode, FirebugReps.Warning);
        }

        // Nodes from external documents need to be imported.
        root = rootNode.ownerDocument.importNode(root, true);

        rootNode.appendChild(root);
        return rootNode;
    }
});

// ********************************************************************************************* //

FirebugReps.Attr = domplate(Rep,
{
    tag:
        OBJECTLINK(
            SPAN(
                SPAN({"class": "attrTitle"}, "$object|getTitle"),
                SPAN({"class": "attrEqual"}, "="),
                TAG("$object|getValueTag", {object: "$object.value"})
            )
        ),

    getTitle: function(attr)
    {
        return attr.name;
    },

    getValueTag: function(object)
    {
        return Firebug.getRep(object.value).tag;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "Attr",

    supportsObject: function(object, type)
    {
        return (object instanceof window.Attr);
    },
});

// ********************************************************************************************* //

FirebugReps.Date = domplate(Rep,
{
    tag:
        OBJECTLINK(
            SPAN({"class": "objectTitle"}, "$object|getTitle "),
            SPAN({"class": "objectLeftBrace", role: "presentation"}, "{"),
            SPAN({"class": "attrEqual"}, "$object|getValue"),
            SPAN({"class": "objectRightBrace"}, "}")
        ),

    getValue: function(object)
    {
        return object.toString();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "Date",

    supportsObject: function(object, type)
    {
        return object && object.constructor && object.constructor.name == "Date";
    },
});

// ********************************************************************************************* //

FirebugReps.NamedNodeMap = domplate(Rep,
{
    tag:
        OBJECTLINK(
            SPAN({"class": "arrayLeftBracket", role: "presentation"}, "["),
            FOR("prop", "$object|longPropIterator",
                SPAN({"class": "nodeName"}, "$prop.name"),
                SPAN({"class": "objectEqual", role: "presentation"}, "$prop.equal"),
                TAG("$prop.tag", {object: "$prop.object"}),
                SPAN({"class": "objectComma", role: "presentation"}, "$prop.delim")
            ),
            SPAN({"class": "arrayRightBracket", role: "presentation"}, "]")
        ),

    shortTag:
        OBJECTLINK(
            SPAN({"class": "arrayLeftBracket", role: "presentation"}, "["),
            FOR("prop", "$object|shortPropIterator",
                SPAN({"class": "nodeName"}, "$prop.name"),
                SPAN({"class": "objectEqual", role: "presentation"}, "$prop.equal"),
                TAG("$prop.tag", {object: "$prop.object"}),
                SPAN({"class": "objectComma", role: "presentation"}, "$prop.delim")
            ),
            SPAN({"class": "arrayRightBracket", role: "presentation"}, "]")
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "NamedNodeMap",

    supportsObject: function(object, type)
    {
        // NamedNodeMap is no more since Fx 22 - see https://bugzilla.mozilla.org/show_bug.cgi?id=847195.
        // The temporary Attr-only replacement is MozNamedAttrMap.
        return (object instanceof (window.NamedNodeMap || window.MozNamedAttrMap));
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Iterator

    longPropIterator: function(object)
    {
        return this.propIterator(object, 100);
    },

    shortPropIterator: function(object)
    {
        return this.propIterator(object, Options.get("ObjectShortIteratorMax"));
    },

    propIterator: function (object, max)
    {
        max = max || 3;

        var props = [];
        for (var i=0; i<object.length && i<max; i++)
        {
            var item = object.item(i);
            var name = item.name;
            var value = item.value;

            var rep = Firebug.getRep(value);
            var tag = rep.tag;

            props.push({tag: tag, name: name, object: value, equal: "=", delim: ", "});
        }

        if (object.length > max)
        {
            var index = max - 1, more = object.length - max + 1;
            if (index < 1)
            {
                index = 1;
                more++;
            }
            props[index] = {
                object: more + " " + Locale.$STR("firebug.reps.more") + "...",
                tag: FirebugReps.Caption.tag,
                name: "",
                equal: "",
                delim: ""
            };
        }
        else if (props.length > 0)
        {
            props[props.length-1].delim = "";
        }

        return props;
    },
});

//********************************************************************************************** //

FirebugReps.ClosureScope = domplate(Rep,
{
    tag: OBJECTBOX({_repObject: "$object"}, "$object|getTitle"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "scope",
    inspectable: false,

    getTitle: function(object)
    {
        var type = ClosureInspector.getScopeTypeFromWrapper(object);
        if (type === "declarative")
            return Locale.$STR("firebug.reps.declarativeScope");
        if (type === "object")
            return Locale.$STR("firebug.reps.objectScope");
        if (type === "with")
            return Locale.$STR("firebug.reps.withScope");
        return "<unknown scope \"" + type + "\">"; // shouldn't happen
    },

    supportsObject: function(object, type)
    {
        return ClosureInspector.isScopeWrapper(object);
    }
});

// ********************************************************************************************* //

FirebugReps.OptimizedAway = domplate(Rep,
{
    tag: OBJECTBOX({_repObject: "$object"}, "$object|getTitle"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "optimizedAway",

    getTitle: function(object)
    {
        return Locale.$STR("firebug.reps.optimizedAway");
    },

    supportsObject: function(object, type)
    {
        return ClosureInspector.isOptimizedAway(object);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerRep(
    FirebugReps.Undefined,
    FirebugReps.Null,
    FirebugReps.Number,
    FirebugReps.SpecialWhitespaceString,
    FirebugReps.String,
    FirebugReps.nsIDOMHistory, // make this early to avoid exceptions
    FirebugReps.ApplicationCache, // this also
    FirebugReps.RegExp,
    FirebugReps.Window,
    FirebugReps.Element,
    FirebugReps.TextNode,
    FirebugReps.Document,
    FirebugReps.StyleSheet,
    FirebugReps.CSSRule,
    FirebugReps.Event,
    FirebugReps.SourceLink,
    FirebugReps.CompilationUnit,
    FirebugReps.StackTrace,
    FirebugReps.StackFrame,
    FirebugReps.NetFile,
    FirebugReps.Property,
    FirebugReps.Arr,
    FirebugReps.ArrayLikeObject,
    FirebugReps.XPathResult,
    FirebugReps.Storage,
    FirebugReps.Attr,
    FirebugReps.Date,
    FirebugReps.NamedNodeMap,
    FirebugReps.Reference,
    FirebugReps.ClosureScope,
    FirebugReps.OptimizedAway
);

Firebug.setDefaultReps(FirebugReps.Func, FirebugReps.Obj);

return Firebug.Reps = FirebugReps;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/searchBox",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/css",
    "firebug/lib/search",
    "firebug/lib/system",
    "firebug/lib/string",
    "firebug/lib/locale",
    "firebug/lib/options"
],
function(Module, Obj, Firebug, Css, Search, System, Str, Locale, Options) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const searchDelay = 150;

// ********************************************************************************************* //

/**
 * @module Implements basic search box functionality. The box is displayed on the right side
 * of the Firebug's toolbar. Specific search capabilities depends on the current panel
 * and implemented in <code>panel.search</code> method. The search-box is automatically
 * available for panels that have <code>searchable<code> property set to true (set to
 * false by default).
 */
Firebug.Search = Obj.extend(Module,
{
    dispatchName: "search",

    onSearchCommand: function(document)
    {
        var el = document.activeElement;
        var id = el.id;
        var doSearch = true;

        if (id == "fbPanelBar1-browser" || id == "fbPanelBar2-browser")
        {
            var sel = el.contentWindow.getSelection().toString();
            if (!sel)
            {
                var input = el.contentDocument.activeElement;
                if (input instanceof Ci.nsIDOMNSEditableElement)
                {
                    sel = input.QueryInterface(Ci.nsIDOMNSEditableElement).
                        editor.selection.toString();
                }
                else
                {
                    doSearch = false;
                }
            }

            if (doSearch)
                this.search(sel, Firebug.currentContext);
        }

        this.focus();
    },

    search: function(text, context)
    {
        var searchBox = Firebug.chrome.$("fbSearchBox");
        searchBox.value = text;
        this.update(context);
    },

    searchNext: function(context)
    {
        return this.update(context, true, false);
    },

    searchPrev: function(context)
    {
        return this.update(context, true, true);
    },

    displayOnly: function(text, context)
    {
        var searchBox = Firebug.chrome.$("fbSearchBox");

        if (text && text.length > 0)
            Css.setClass(searchBox, "fbSearchBox-attention");
        else
            Css.removeClass(searchBox, "fbSearchBox-attention");

        searchBox.value = text;
    },

    focus: function(context)
    {
        if (Firebug.isDetached())
            Firebug.chrome.focus();
        else
            Firebug.toggleBar(true);

        var searchBox = Firebug.chrome.$("fbSearchBox");
        searchBox.focus();
        searchBox.select();
    },

    update: function(context, immediate, reverse)
    {
        var panel = Firebug.chrome.getSelectedPanel();
        if (!panel || !panel.searchable)
            return;

        var searchBox = Firebug.chrome.$("fbSearchBox");
        var panelNode = panel.panelNode;

        var value = searchBox.value;

        this.addToHistory(value);

        // This sucks, but the find service won't match nodes that are invisible, so we
        // have to make sure to make them all visible unless the user is appending to the
        // last string, in which case it's ok to just search the set of visible nodes
        if (!panel.searchText || value == panel.searchText ||
            !Str.hasPrefix(value, panel.searchText))
        {
            Css.removeClass(panelNode, "searching");
        }

        if (Firebug.Search.isCaseSensitive(value))
            Css.setClass(searchBox, "fbSearchBox-autoSensitive");
        else
            Css.removeClass(searchBox, "fbSearchBox-autoSensitive");

        if (FBTrace.DBG_SEARCH)
        {
            FBTrace.sysout("search Firebug.Search.isAutoSensitive(value): " +
                Firebug.Search.isAutoSensitive(value) + " for " + value, searchBox);
        }

        // Cancel the previous search to keep typing smooth
        clearTimeout(panelNode.searchTimeout);

        if (immediate)
        {
            var found = panel.search(value, reverse);
            panel.searchText = value;
            if (!found && value)
               this.onNotFound();

            if (value)
            {
                // Hides all nodes that didn't pass the filter
                Css.setClass(panelNode, "searching");
            }
            else
            {
                // Makes all nodes visible again
                Css.removeClass(panelNode, "searching");
            }

            return found;
        }
        else
        {
            var sBox = this;
            // After a delay, perform the search
            panelNode.searchTimeout = setTimeout(function()
            {
                var found = panel.search(value, reverse);
                panel.searchText = value;
                if (!found && value)
                {
                    var shouldIgnore = panel.shouldIgnoreIntermediateSearchFailure;
                    if (shouldIgnore && shouldIgnore.call(panel, value))
                        found = true;
                    else
                        sBox.onNotFound();
                }

                if (value)
                {
                    // Hides all nodes that didn't pass the filter
                    Css.setClass(panelNode, "searching");
                }
                else
                {
                    // Makes all nodes visible again
                    Css.removeClass(panelNode, "searching");
                }

                searchBox.status = (found ? "found" : "notfound");
                sBox.setPlaceholder();

                if (FBTrace.DBG_SEARCH)
                    FBTrace.sysout("search " + searchBox.status + " " + value);

            }, searchDelay);
        }
    },

    onNotFound: function()
    {
        if (this.status != "notfound")
            System.beep();
    },

    isCaseSensitive: function(text)
    {
        return !!Options.get("searchCaseSensitive") || this.isAutoSensitive(text);
    },

    isAutoSensitive: function(text)
    {
        return (text.toLowerCase() !== text);
    },

    getTestingRegex: function(text)
    {
        var caseSensitive = Firebug.Search.isCaseSensitive(text);

        try
        {
            if (Options.get("searchUseRegularExpression"))
                return new RegExp(text, caseSensitive ? "g" : "gi");
            else
                return new Search.LiteralRegExp(text, false, caseSensitive);
        }
        catch (err)
        {
            // The user entered an invalid regex. Duck type the regex object
            // to support literal searches when an invalid regex is entered
            return new Search.LiteralRegExp(text, false, caseSensitive);
        }
    },

    searchOptionMenu: function(label, option, tooltiptext)
    {
        return {
            label: label,
            tooltiptext: tooltiptext,
            checked: Options.get(option),
            option: option,
            command: Obj.bindFixed(this.onToggleSearchOption, this, option)
        };
    },

    onToggleSearchOption: function(option)
    {
        Options.togglePref(option);

        // Make sure the "Case Sensitive || Case Insensitive" label is updated.
        this.update();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // History

    history: [""],

    addToHistory: function(val)
    {
        var history = this.history;

        if (!history[0] || Str.hasPrefix(val, history[0]))
            history[0] = val;
        else if (Str.hasPrefix(history[0], val))
            return;
        else
            history.unshift(val);
    },

    cycleHistory: function(dir)
    {
        var history = this.history;
        if (dir > 0)
            history.unshift(history.pop());
        else
            history.push(history.shift());

        return history[0];
    },

    setPlaceholder: function()
    {
        var panel = Firebug.chrome.getSelectedPanel();
        if (!panel)
            return;

        var searchBox = Firebug.chrome.$("fbSearchBox");
        if (panel.searchPlaceholder)
        {
            searchBox.placeholder = Locale.$STR(panel.searchPlaceholder);
        }
        else
        {
            var panelType = Firebug.getPanelType(panel.name);
            var title = Firebug.getPanelTitle(panelType);
            searchBox.placeholder = Locale.$STRF("search.Placeholder", [title]);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    internationalizeUI: function()
    {
        var sensitive = Firebug.chrome.$("fbSearchBoxIsSensitive");
        sensitive.value = Locale.$STR("search.Case_Sensitive");
        sensitive.setAttribute("tooltiptext", Locale.$STR("search.tip.Case_Sensitive"));

        var notSensitive = Firebug.chrome.$("fbSearchBoxIsNotSensitive");
        notSensitive.value = Locale.$STR("search.Case_Insensitive");
        notSensitive.setAttribute("tooltiptext", Locale.$STR("search.tip.Case_Insensitive"));
    },

    shutdown: function()
    {
    },

    showPanel: function(browser, panel)
    {
        // Manage visibility of the search-box according to the searchable flag.
        var searchBox = Firebug.chrome.$("fbSearchBox");
        searchBox.status = "noSearch";
        Css.removeClass(searchBox, "fbSearchBox-attention");
        Css.removeClass(searchBox, "fbSearchBox-autoSensitive");

        if (panel)
        {
            searchBox.collapsed = !panel.searchable;
            searchBox.updateOptions(panel.getSearchOptionsMenuItems());
        }
        else
        {
            searchBox.collapsed = false;
        }

        this.setPlaceholder();
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.Search);

return Firebug.Search;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/shortcuts",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/firefox/customizeShortcuts",
],
function(Module, Obj, Firebug, Firefox, CustomizeShortcuts) {

// ********************************************************************************************* //
// Constants

Components.utils.import("resource://gre/modules/Services.jsm");

var KeyEvent = window.KeyEvent;

// ********************************************************************************************* //

/**
 * ShortcutsModel object implements keyboard shortcuts logic.
 */
Firebug.ShortcutsModel = Obj.extend(Module,
{
    dispatchName: "shortcuts",

    initializeUI: function()
    {
        if (FBTrace.DBG_SHORTCUTS)
            FBTrace.sysout("shortcuts.initializeUI; Shortcuts module initialization.");

        this.initShortcuts();
    },

    initShortcuts: function()
    {
        var branch = Services.prefs.getBranch("extensions.firebug.key.shortcut.");
        var shortcutNames = branch.getChildList("", {});

        // We need to touch keyset to apply keychanges without restart
        this.keysets = [];
        this.disabledKeyElements = [];
        shortcutNames.forEach(this.initShortcut, this);

        this.keysets.forEach(function(keyset) {
            keyset.parentNode.insertBefore(keyset, keyset.nextSibling);
        });

        for (var i=0; i<this.disabledKeyElements.length; i++)
        {
            var elem = this.disabledKeyElements[i];
            elem.removeAttribute("disabled");
        }

        this.keysets = this.disabledKeyElements = null;
    },

    initShortcut: function(element, index, array)
    {
        var branch = Services.prefs.getBranch("extensions.firebug.key.");
        var shortcut = branch.getCharPref("shortcut." + element);
        var tokens = shortcut.split(" ");
        var key = tokens.pop();
        var modifiers = tokens.join(",");

        var keyElem = document.getElementById("key_firebug_" + element);
        if (!keyElem)
        {
            // If key is not defined in xul, add it
            keyElem = document.createElement("key");
            keyElem.className = "fbOnlyKey";
            keyElem.id = "key_firebug_" + element;
            keyElem.command = "cmd_firebug_" + element;
            document.getElementById("mainKeyset").appendChild(keyElem);
        }

        // invalidAttr needed in case default shortcut uses key rather than keycode
        var attr = "key";
        var invalidAttr = "key";

        // Choose between key or keycode attribute
        if (key.length <= 1)
        {
            invalidAttr = "keycode";
        }
        else if (KeyEvent["DOM_"+key])
        {
            attr = "keycode";
        }
        else
        {
            // Only set valid keycodes
            return;
        }

        keyElem.setAttribute("modifiers", modifiers);
        keyElem.setAttribute(attr, key);
        keyElem.removeAttribute(invalidAttr);

        if (this.keysets.indexOf(keyElem.parentNode) == -1)
            this.keysets.push(keyElem.parentNode);

        // Modify shortcut for global key, if it exists
        var keyElem = Firefox.getElementById("key_firebug_" + element);
        if (!keyElem)
            return;

        if (FBTrace.DBG_SHORTCUTS)
        {
            FBTrace.sysout("Firebug.ShortcutsModel.initShortcut; global shortcut",
                {key: key, modifiers: modifiers});
        }

        // Disable existing global shortcuts
        var selector = "key[" + attr + "='" + key + "'][modifiers='" + modifiers + "']"
            + ":not([id='key_firebug_" + element + "']):not([disabled='true'])";

        var existingKeyElements = keyElem.ownerDocument.querySelectorAll(selector);
        for (var i=existingKeyElements.length-1; i>=0; i--)
        {
            var existingKeyElement = existingKeyElements[i];
            existingKeyElement.setAttribute("disabled", "true");
            this.disabledKeyElements.push(existingKeyElement);
        }

        keyElem.setAttribute("modifiers", modifiers);
        keyElem.setAttribute(attr, key);
        keyElem.removeAttribute(invalidAttr);

        if (this.keysets.indexOf(keyElem.parentNode) == -1)
            this.keysets.push(keyElem.parentNode);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Commands

    customizeShortcuts: function()
    {
        // Open the "customize shortcuts" dialog.
        window.openDialog("chrome://firebug/content/firefox/customizeShortcuts.xul", "",
            "chrome,centerscreen,dialog,modal,resizable=yes", new CustomizeShortcuts());
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.ShortcutsModel);

return Firebug.ShortcutsModel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/tabContext",
[
    "firebug/lib/object",
    "arch/compilationunit",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/chrome/window",
    "firebug/lib/css",
    "firebug/chrome/plugin",
],
function(Obj, CompilationUnit, Events, Url, Win, Css) {

// ********************************************************************************************* //
// Constants

const throttleTimeWindow = 200;
const throttleMessageLimit = 30;
const throttleInterval = 30;
const throttleFlushCount = 20;
const refreshDelay = 300;

// ********************************************************************************************* //

Firebug.TabContext = function(win, browser, chrome, persistedState)
{
    this.window = win;
    this.browser = browser;
    this.persistedState = persistedState;

    this.name = Url.normalizeURL(this.getWindowLocation().toString());

    this.windows = [];
    this.panelMap = {};
    this.sidePanelNames = {};

    this.compilationUnits = {};
    this.sourceFileByTag = {}; // mozilla only

    // New nsITraceableChannel interface (introduced in FF3.0.4) makes possible
    // to re-implement source-cache so that it solves the double-load problem.
    // Anyway, keep the previous cache implementation for backward compatibility
    // (with Firefox 3.0.3 and lower)
    if (Components.interfaces.nsITraceableChannel)
        this.sourceCache = new Firebug.TabCache(this);
    else
        this.sourceCache = new Firebug.SourceCache(this);

    this.global = win;  // used by chromebug

    // -- Back end support --
    this.sourceFileMap = {};  // backend
};

Firebug.TabContext.prototype =
{
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Browser Tools Interface BrowserContext

    getCompilationUnit: function(url)
    {
        return this.compilationUnits[url];
    },

    getAllCompilationUnits: function()
    {
        return Firebug.SourceFile.mapAsArray(this.compilationUnits);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getWindowLocation: function()
    {
        return Win.safeGetWindowLocation(this.window);
    },

    getTitle: function()
    {
        if (this.window && this.window.document)
            return this.window.document.title;
        else
            return "";
    },

    getName: function()
    {
        if (!this.name || this.name === "about:blank")
        {
            var url = this.getWindowLocation().toString();
            if (Url.isDataURL(url))
            {
                var props = Url.splitDataURL(url);
                if (props.fileName)
                    this.name = "data url from "+props.fileName;
            }
            else
            {
                this.name = Url.normalizeURL(url);
                if (this.name === "about:blank" && this.window.frameElement)
                    this.name += " in "+Css.getElementCSSSelector(this.window.frameElement);
            }
        }
        return this.name;
    },

    getGlobalScope: function()
    {
        return this.window;
    },

    addSourceFile: function(sourceFile)
    {
        if (!this.sourceFileMap)
        {
            FBTrace.sysout("tabContext.addSourceFile; ERROR no source map!");
            return;
        }

        this.sourceFileMap[sourceFile.href] = sourceFile;
        sourceFile.context = this;

        this.addTags(sourceFile);

        var kind = CompilationUnit.SCRIPT_TAG;
        if (sourceFile.compilation_unit_type == "event")
            kind = CompilationUnit.BROWSER_GENERATED;

        if (sourceFile.compilation_unit_type == "eval")
            kind = CompilationUnit.EVAL;

        var url = sourceFile.href;
        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("onCompilationUnit " + url, [this, url, kind] );

        Firebug.connection.dispatch("onCompilationUnit", [this, url, kind]);

        // HACKs
        var compilationUnit = this.getCompilationUnit(url);
        if (!compilationUnit)
        {
            if (FBTrace.DBG_COMPILATION_UNITS || FBTrace.DBG_ERRORS)
                FBTrace.sysout("tabContext.addSourceFile; ERROR Unknown URL: " + url,
                    this.compilationUnits);
            return;
        }

        compilationUnit.sourceFile = sourceFile;

        compilationUnit.getSourceLines(-1, -1, function onLines(compilationUnit,
            firstLineNumber, lastLineNumber, lines)
        {
            Firebug.connection.dispatch("onSourceLines", arguments);

            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("onSourceLines "+compilationUnit.getURL() + " " + lines.length +
                    " lines", compilationUnit);
        });
    },

    removeSourceFile: function(sourceFile)
    {
        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("tabContext.removeSourceFile " + sourceFile.href + " in context " +
                sourceFile.context.getName());

        delete this.sourceFileMap[sourceFile.href];
        delete sourceFile.context;

        // ?? Firebug.onSourceFileDestroyed(this, sourceFile);
    },

    addTags: function(sourceFile)
    {
        if (sourceFile.outerScript)
            this.sourceFileByTag[sourceFile.outerScript.tag] = sourceFile;

        for (var innerTag in sourceFile.innerScripts)
            this.sourceFileByTag[innerTag] = sourceFile;
    },

    getSourceFileByTag: function(tag)
    {
        return this.sourceFileByTag[tag];
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    // backward compat
    get chrome()
    {
        return Firebug.chrome;
    },

    getCurrentGlobal: function()
    {
        return this.stoppedGlobal || this.baseWindow || this.window;
    },

    destroy: function(state)
    {
        // All existing timeouts need to be cleared
        if (this.timeouts)
        {
            for (var timeout in this.timeouts)
                clearTimeout(timeout);
        }

        // Also all waiting intervals must be cleared.
        if (this.intervals)
        {
            for (var timeout in this.intervals)
                clearInterval(timeout);
        }

        if (this.throttleTimeout)
            clearTimeout(this.throttleTimeout);

        // All existing DOM listeners need to be cleared. Note that context is destroyed
        // when the top level window is unloaded. However, some listeners can be registered
        // to iframes (documents), which can be already unloaded at this point.
        // Removing listeners from such 'unloaded' documents (or window) can throw
        // "TypeError: can't access dead object"
        // We should avoid these exceptions (even if they are not representing memory leaks)
        this.unregisterAllListeners();

        state.panelState = {};

        // Inherit panelStates that have not been restored yet
        if (this.persistedState)
        {
            for (var panelName in this.persistedState.panelState)
                state.panelState[panelName] = this.persistedState.panelState[panelName];
        }

        // Destroy all panels in this context.
        for (var panelName in this.panelMap)
        {
            var panelType = Firebug.getPanelType(panelName);
            this.destroyPanel(panelType, state);
        }

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("tabContext.destroy " + this.getName() + " set state ", state);
    },

    getPanelType: function(panelName)
    {
        // Get "global" panelType, registered using Firebug.registerPanel
        var panelType = Firebug.getPanelType(panelName);

        // The panelType can be "local", available only within the context.
        if (!panelType && this.panelTypeMap && this.panelTypeMap.hasOwnProperty(panelName))
            panelType = this.panelTypeMap[panelName];

        if (panelType && !panelType.prototype)
        {
            FBTrace.sysout("tabContext.getPanel no prototype " + panelType, panelType);
            return null;
        }

        return panelType || null;
    },

    getPanel: function(panelName, noCreate)
    {
        var panelType = this.getPanelType(panelName);
        if (!panelType)
            return null;

        // Create instance of the panelType only if it's enabled.
        var enabled = panelType.prototype.isEnabled ? panelType.prototype.isEnabled() : true;
        if (enabled)
            return this.getPanelByType(panelType, noCreate);

        return null;
    },

    isPanelEnabled: function(panelName)
    {
        var panelType = this.getPanelType(panelName);
        if (!panelType)
            return false;
        return (!panelType.prototype.isEnabled || panelType.prototype.isEnabled());
    },

    getPanelByType: function(panelType, noCreate)
    {
        if (!panelType || !this.panelMap)
            return null;

        var panelName = panelType.prototype.name;
        if ( this.panelMap.hasOwnProperty(panelName) )
            return this.panelMap[panelName];
        else if (!noCreate)
            return this.createPanel(panelType);
    },

    eachPanelInContext: function(callback)
    {
        for (var panelName in this.panelMap)
        {
            if (this.panelMap.hasOwnProperty(panelName))
            {
                var panel = this.panelMap[panelName];
                var rc = callback(panel);
                if (rc)
                    return rc;
            }
        }
    },

    createPanel: function(panelType)
    {
        // Instantiate a panel object. This is why panels are defined by prototype inheritance
        var panel = new panelType();
        this.panelMap[panel.name] = panel;

        if (FBTrace.DBG_PANELS)
            FBTrace.sysout("tabContext.createPanel; Panel created: " + panel.name, panel);

        Events.dispatch(Firebug.modules, "onCreatePanel", [this, panel, panelType]);

        // Initialize panel and associate with a document.
        if (panel.parentPanel)
        {
            // then this new panel is a side panel
            panel.mainPanel = this.panelMap[panel.parentPanel];
            if (panel.mainPanel)
            {
                // then our panel map is consistent
                // wire the side panel to get UI events from the main panel
                panel.mainPanel.addListener(panel);
            }
            else
            {
                // then our panel map is broken, maybe by an extension failure.
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("tabContext.createPanel panel.mainPanel missing " +
                        panel.name + " from " + panel.parentPanel.name);
            }
        }

        var doc = this.chrome.getPanelDocument(panelType);
        panel.initialize(this, doc);

        return panel;
    },

    destroyPanel: function(panelType, state)
    {
        var panelName = panelType.prototype.name;
        var panel = this.panelMap[panelName];
        if (!panel)
            return;

        // Create an object to persist state, re-using old one if it was never restored
        var panelState = panelName in state.panelState ? state.panelState[panelName] : {};
        state.panelState[panelName] = panelState;

        try
        {
            // Destroy the panel and allow it to persist extra info to the state object
            var dontRemove = panel.destroy(panelState);
            delete this.panelMap[panelName];

            if (dontRemove)
                return;
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("tabContext.destroy FAILS (" + panelName + ") " + exc, exc);

            // the destroy failed, don't keep the bad state
            delete state.panelState[panelName];
        }

        // Remove the panel node from the DOM and so delete its content.
        var panelNode = panel.panelNode;
        if (panelNode && panelNode.parentNode)
            panelNode.parentNode.removeChild(panelNode);
    },

    removePanel: function(panelType, state)
    {
        var panelName = panelType.prototype.name;
        if (!this.panelMap.hasOwnProperty(panelName))
            return null;

        state.panelState = {};

        this.destroyPanel(panelType, state);
    },

    // allows a panel from one context to be used in other contexts.
    setPanel: function(panelName, panel)
    {
        if (panel)
            this.panelMap[panelName] = panel;
        else
            delete this.panelMap[panelName];
    },

    invalidatePanels: function()
    {
        if (!this.invalidPanels)
            this.invalidPanels = {};

        for (var i = 0; i < arguments.length; ++i)
        {
            var panelName = arguments[i];
            var panel = this.getPanel(panelName, true);
            if (panel && !panel.noRefresh)
                this.invalidPanels[panelName] = 1;
        }

        if (this.refreshTimeout)
        {
            this.clearTimeout(this.refreshTimeout);
            delete this.refreshTimeout;
        }

        this.refreshTimeout = this.setTimeout(Obj.bindFixed(function()
        {
            var invalids = [];

            for (var panelName in this.invalidPanels)
            {
                var panel = this.getPanel(panelName, true);
                if (panel)
                {
                    if (panel.visible && !panel.editing)
                        panel.refresh();
                    else
                        panel.needsRefresh = true;

                    // If the panel is being edited, we'll keep trying to
                    // refresh it until editing is done
                    if (panel.editing)
                        invalids.push(panelName);
                }
            }

            delete this.invalidPanels;
            delete this.refreshTimeout;

            // Keep looping until every tab is valid
            if (invalids.length)
                this.invalidatePanels.apply(this, invalids);

        }, this), refreshDelay);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Timeouts and Intervals

    setTimeout: function(fn, delay)
    {
        if (setTimeout == this.setTimeout)
            throw new Error("setTimeout recursion");

        // we're using a sandboxed setTimeout function
        var timeout = setTimeout(fn, delay);

        if (!this.timeouts)
            this.timeouts = {};

        this.timeouts[timeout] = 1;

        return timeout;
    },

    clearTimeout: function(timeout)
    {
        // we're using a sandboxed clearTimeout function
        clearTimeout(timeout);

        if (this.timeouts)
            delete this.timeouts[timeout];
    },

    setInterval: function(fn, delay)
    {
        // we're using a sandboxed setInterval function
        var timeout = setInterval(fn, delay);

        if (!this.intervals)
            this.intervals = {};

        this.intervals[timeout] = 1;

        return timeout;
    },

    clearInterval: function(timeout)
    {
        // we're using a sandboxed clearInterval function
        clearInterval(timeout);

        if (this.intervals)
            delete this.intervals[timeout];
    },

    delay: function(message, object)
    {
        this.throttle(message, object, null, true);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    // queue the call |object.message(arg)| or just delay it if forceDelay
    throttle: function(message, object, args, forceDelay)
    {
        if (!this.throttleInit)
        {
            this.throttleBuildup = 0;
            this.throttleQueue = [];
            this.throttleTimeout = 0;
            this.lastMessageTime = 0;
            this.throttleInit = true;
        }

        if (!forceDelay)
        {
            if (!Firebug.throttleMessages)
            {
                message.apply(object, args);
                return false;
            }

            // Count how many messages have been logged during the throttle period
            var logTime = Date.now();
            if (logTime - this.lastMessageTime < throttleTimeWindow)
                ++this.throttleBuildup;
            else
                this.throttleBuildup = 0;

            this.lastMessageTime = logTime;

            // If the throttle limit has been passed, enqueue the message to be
            // logged later on a timer, otherwise just execute it now
            if (!this.throttleQueue.length && this.throttleBuildup <= throttleMessageLimit)
            {
                try
                {
                    message.apply(object, args);
                }
                catch (e)
                {
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("tabContext.throttle; EXCEPTION " + e, e);
                }

                return false;
            }
        }

        this.throttleQueue.push(message, object, args);

        if (this.throttleTimeout)
            this.clearTimeout(this.throttleTimeout);

        var self = this;
        this.throttleTimeout =
            this.setTimeout(function() { self.flushThrottleQueue(); }, throttleInterval);

        return true;
    },

    flushThrottleQueue: function()
    {
        var queue = this.throttleQueue;

        if (!queue[0])
            FBTrace.sysout("tabContext.flushThrottleQueue no queue[0]", queue);

        var max = throttleFlushCount * 3;
        if (max > queue.length)
            max = queue.length;

        for (var i = 0; i < max; i += 3)
        {
            try
            {
                queue[i].apply(queue[i+1], queue[i+2]);
            }
            catch (e)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("tabContext.flushThrottleQueue; EXCEPTION " + e, e);
            }
        }

        queue.splice(0, throttleFlushCount*3);

        if (queue.length)
        {
            var self = this;
            this.throttleTimeout =
                this.setTimeout(function f() { self.flushThrottleQueue(); }, throttleInterval);
        }
        else
        {
            this.throttleTimeout = 0;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Event Listeners

    addEventListener: function(parent, eventId, listener, capturing)
    {
        if (!this.listeners)
            this.listeners = [];

        for (var i=0; i<this.listeners.length; i++)
        {
            var l = this.listeners[i];
            if (l.parent == parent && l.eventId == eventId && l.listener == listener &&
                l.capturing == capturing)
            {
                // Listener already registered!
                return;
            }
        }

        parent.addEventListener(eventId, listener, capturing);

        this.listeners.push({
            parent: parent,
            eventId: eventId,
            listener: listener,
            capturing: capturing,
        });
    },

    removeEventListener: function(parent, eventId, listener, capturing)
    {
        parent.removeEventListener(eventId, listener, capturing);

        if (!this.listeners)
            this.listeners = [];

        for (var i=0; i<this.listeners.length; i++)
        {
            var l = this.listeners[i];
            if (l.parent == parent && l.eventId == eventId && l.listener == listener &&
                l.capturing == capturing)
            {
                this.listeners.splice(i, 1);
                break;
            }
        }
    },

    /**
     * Executed by the framework when the context is about to be destroyed.
     */
    unregisterAllListeners: function()
    {
        if (!this.listeners)
            return;

        for (var i=0; i<this.listeners.length; i++)
        {
            var l = this.listeners[i];

            try
            {
                l.parent.removeEventListener(l.eventId, l.listener, l.capturing);
            }
            catch (e)
            {
                if (FBTrace.DBG_ERRORS)
                {
                    FBTrace.sysout("tabContext.unregisterAllListeners; (" + l.eventId +
                        ") " + e, e);
                }
            }
        }

        this.listeners = null;
    }
};

// ********************************************************************************************* //
// Registration

return Firebug.TabContext;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/tableRep",
[
    "firebug/firebug",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/array",
    "firebug/chrome/reps",
],
function(Firebug, Rep, FBTrace, Domplate, Locale, Dom, Css, Arr, FirebugReps) {

"use strict";

// ********************************************************************************************* //
// Resources

// http://www.softwareishard.com/blog/firebug/tabular-logs-in-firebug/

// ********************************************************************************************* //
// Constants

var {domplate, DIV, TABLE, THEAD, TR, FOR, TH, TBODY, TD, TAG} = Domplate;

// Tracing
var Trace = FBTrace.to("DBG_TABLEREP");
var TraceError = FBTrace.to("DBG_ERRORS");

// ********************************************************************************************* //

/**
 * @domplate The template is used to generate tabular UI for generic data/objects. Tables are
 * typically logged into the Console panel through console.table() API, but the UI can be
 * used within other panels too. Various complex as well as simple generic objects and arrays
 * are supported.
 */
var TableRep = domplate(Rep,
/** @lends TableRep */
{
    className: "table",
    tableClassName: "dataTable",
    groupable: false,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Domplate

    tag:
        DIV({"class": "dataTableSizer", "tabindex": "-1" },
            TABLE({"class": "$tableClassName", cellspacing: 0, cellpadding: 0, width: "100%",
                "role": "grid"},
                THEAD({"class": "dataTableThead", "role": "presentation"},
                    TR({"class": "headerRow focusRow dataTableRow subFocusRow", "role": "row",
                        onclick: "$onClickHeader"},
                        FOR("column", "$object.columns",
                            TH({"class": "headerCell a11yFocus", "role": "columnheader",
                                $alphaValue: "$column.alphaValue"},
                                DIV({"class": "headerCellBox"},
                                    "$column.label"
                                )
                            )
                        )
                    )
                ),
                TBODY({"class": "dataTableTbody", "role": "presentation"},
                    FOR("row", "$object.data|getRows",
                        TR({"class": "focusRow dataTableRow subFocusRow", "role": "row"},
                            FOR("column", "$row|getColumns",
                                TD({"class": "a11yFocus dataTableCell", "role": "gridcell"},
                                    TAG("$column|getValueTag", {object: "$column"})
                                )
                            )
                        )
                    )
                )
            )
        ),

    getValueTag: function(object)
    {
        var rep = Firebug.getRep(object);
        return rep.shortTag || rep.tag;
    },

    getRows: function(data)
    {
        var props = this.getProps(data);
        if (!props.length)
            return [];
        return props;
    },

    getColumns: function(row)
    {
        if (typeof(row) != "object")
            return [row];

        var cols = [];
        var value = null;
        for (var i=0; i<this.columns.length; i++)
        {
            var prop = this.columns[i].property;

            // Object property is not set for this column, so display entire
            // row-value in the cell. This can happen in cases where a generic
            // object is logged using table layout. In such case there is one
            // column (no property associated) and each row represents a member
            // of the object.
            if (typeof prop == "undefined")
            {
                value = row;
            }
            else if (typeof row[prop] == "undefined")
            {
                var props = (typeof(prop) == "string") ? prop.split(".") : [prop];

                value = row;
                for (var p in props)
                    value = (value && value[props[p]]) || undefined;
            }
            else
            {
                value = row[prop];
            }

            cols.push(value);
        }

        Trace.sysout("tableRep.getColumns", {cols: cols, row: row});

        return cols;
    },

    getProps: function(obj)
    {
        if (typeof(obj) != "object")
            return [obj];

        Trace.sysout("tableRep.getProps", obj);

        var tabularData = this.isTabularData(obj);

        if (Array.isArray(obj) && !tabularData)
        {
            // An array with no child objects (i.e. not tabular data),
            // use two columns (name, value)
            return getArrayProps(obj);
        }
        else if (Array.isArray(obj))
        {
            // Array with inner objects (i.e. tabular data), columns are
            // generated according to props in the first object (i.e. first row).
            return Arr.cloneArray(obj);
        }
        else if (obj instanceof window.Storage)
        {
            // Special case for Storage. It uses different way to iterate over all items.
            // Logged as generic array (two columns: name value)
            return getStorageProps(obj);
        }
        else if (!tabularData)
        {
            // Generic object, use two columns (prop names, prop values) to display it.
            return getObjectProps(obj);
        }

        // Typically map of objects (or object with object properties, i.e. tabular data),
        // columns generated according to the first property object (aka first row). 
        var arr = [];
        for (var p in obj)
        {
            var value = obj[p];
            if (this.domFilter(value, p))
                arr.push(value);
        }

        return arr;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Sorting

    onClickHeader: function(event)
    {
        var table = Dom.getAncestorByClass(event.target, "dataTable");
        var header = Dom.getAncestorByClass(event.target, "headerCell");
        if (!header)
            return;

        var numerical = !Css.hasClass(header, "alphaValue");

        var colIndex = 0;
        for (header = header.previousSibling; header; header = header.previousSibling)
            ++colIndex;

        this.sort(table, colIndex, numerical);
    },

    sort: function(table, colIndex, numerical)
    {
        var tbody = Dom.getChildByClass(table, "dataTableTbody");
        var thead = Dom.getChildByClass(table, "dataTableThead");

        var values = [];
        for (var row = tbody.childNodes[0]; row; row = row.nextSibling)
        {
            var cell = row.childNodes[colIndex];
            var value = numerical ? parseFloat(cell.textContent) : cell.textContent;

            // Use the original textContent if the parsing failed.
            value = value || cell.textContent;

            values.push({row: row, value: value});
        }

        values.sort(function(a, b) { return a.value < b.value ? -1 : 1; });

        var headerRow = thead.firstChild;
        var headerSorted = Dom.getChildByClass(headerRow, "headerSorted");
        Css.removeClass(headerSorted, "headerSorted");
        if (headerSorted)
            headerSorted.removeAttribute("aria-sort");

        var header = headerRow.childNodes[colIndex];
        Css.setClass(header, "headerSorted");

        if (!header.sorted || header.sorted == 1)
        {
            Css.removeClass(header, "sortedDescending");
            Css.setClass(header, "sortedAscending");
            header.setAttribute("aria-sort", "ascending");

            header.sorted = -1;

            for (var i = 0; i < values.length; i++)
                tbody.appendChild(values[i].row);
        }
        else
        {
            Css.removeClass(header, "sortedAscending");
            Css.setClass(header, "sortedDescending");
            header.setAttribute("aria-sort", "descending");

            header.sorted = 1;

            for (var i = values.length-1; i >= 0; i--)
                tbody.appendChild(values[i].row);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Console logging

    log: function(data, cols, context, object)
    {
        // No arguments passed into console.table method, bail out for now,
        // but some error message could be displayed in the future.
        if (!data)
            return;

        var columns = this.computeColumns(data, cols);

        // Don't limit strings in the table. It should be mostly ok. In case of
        // complaints we need an option.
        var prevValue = Firebug.stringCropLength;
        Firebug.stringCropLength = -1;

        try
        {
            this.columns = columns;

            var obj = object || {};
            obj.data = data;
            obj.columns = columns;

            var row = Firebug.Console.log(obj, context, "table", this, true);

            // Set vertical height for scroll bar.
            var tBody = row.querySelector(".dataTableTbody");
            var maxHeight = Firebug.tabularLogMaxHeight;
            if (maxHeight > 0 && tBody.clientHeight > maxHeight)
                tBody.style.height = maxHeight + "px";
        }
        catch (err)
        {
            TraceError.sysout("consoleInjector.table; EXCEPTION " + err, err);
        }
        finally
        {
            Firebug.stringCropLength = prevValue;
            delete this.columns;
        }
    },

    computeColumns: function(data, cols)
    {
        // Get header info from passed argument (can be null).
        var columns = [];
        for (var i=0; cols && i<cols.length; i++)
        {
            var col = cols[i];
            var prop = (typeof(col.property) != "undefined") ? col.property : col;
            var label = (typeof(col.label) != "undefined") ? col.label : prop;

            columns.push({
                property: prop,
                label: label,
                alphaValue: true
            });
        }

        // Generate header info from the data dynamically.
        if (!columns.length)
            columns = this.getHeaderColumns(data);

        Trace.sysout("tableRep.computeColumns; columns:", columns);

        return columns;
    },

    getFirstRow: function(data)
    {
        // Get the first row in the object.
        var firstRow = null;
        for (var p in data)
            return data[p];
    },

    isTabularData: function(data)
    {
        var firstRow = this.getFirstRow(data);

        // If the first property of given object is *not* an object we don't probably
        // deal with a table structured data. In this case we assume that it's a generic
        // object and the table will have two columns: object-properties and object-values.
        return (typeof(firstRow) == "object");
    },

    /**
     * Analyze data and return dynamically created list of columns.
     * @param {Object} data
     */
    getHeaderColumns: function(data)
    {
        var firstRow = this.getFirstRow(data);

        // Generic objects (with no tabular structure) are displayed as two column table:
        // property names and property values. 
        if (typeof(firstRow) != "object")
        {
            Trace.sysout("tableRep.getHeaderColumns; Create columns for generic object");

            return [
                {label: Locale.$STR("firebug.reps.table.ObjectProperties"), property: "name"},
                {label: Locale.$STR("firebug.reps.table.ObjectValues"), property: "value"}
            ];
        }

        // Put together a column property, label and type (type for default sorting logic).
        var header = [];
        for (var p in firstRow)
        {
            var value = firstRow[p];
            if (!this.domFilter(value, p))
                continue;

            header.push({
                property: p,
                label: p,
                alphaValue: (typeof(value) != "number")
            });
        }

        return header;
    },

    /**
     * Filtering based on options set in the DOM panel.
     * @param {Object} value - a property value under inspection.
     * @param {String} name - name of the property.
     * @returns true if the value should be displayed, otherwise false.
     */
    domFilter: function(object, name)
    {
        if (typeof(object) == "function")
        {
            if (Dom.isDOMMember(object, name) && !Firebug.showDOMFuncs)
                return false;
            else if (!Firebug.showUserFuncs)
                return false;
        }
        else
        {
            if (Dom.isDOMMember(object, name) && !Firebug.showDOMProps)
                return false;
            else if (Dom.isDOMConstant(object, name) && !Firebug.showDOMConstants)
                return false;
            else if (!Firebug.showUserProps)
                return false;
        }

        return true;
    },
});

// ********************************************************************************************* //
// Get Properties Helpers

function Property(name, value)
{
    this.name = name;
    this.value = value;
}

function getStorageProps(storage)
{
    var result = [];
    for (var i = 0, len = storage.length; i < len; i++)
    {
        var name = storage.key(i);
        result.push(new Property(name, storage.getItem(name)));
    }
    return result;
}

function getArrayProps(arr)
{
    var result = [];
    for (var i = 0; i < arr.length; i++)
        result.push(new Property(i, arr[i]));
    return result;
}

function getObjectProps(obj)
{
    var result = [];
    for (var p in obj)
        result.push(new Property(p, obj[p]));
    return result;
}

// ********************************************************************************************* //
// Registration

// Backward compatibility.
FirebugReps.Table = TableRep;

return TableRep;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/tabWatcher",
[
    "firebug/chrome/eventSource",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/lib/xpcom",
    "firebug/net/requestObserver",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/lib/http",
    "firebug/chrome/window",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/trace/debug",
    "firebug/trace/traceListener",
    "firebug/trace/traceModule",
    "firebug/chrome/tabContext",
],
function(EventSource, Obj, Firebug, Firefox, Xpcom, HttpRequestObserver, Events, Url, Http, Win,
    Str, Arr, Debug, TraceListener, TraceModule) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const nsIWebNavigation = Ci.nsIWebNavigation;
const nsIWebProgressListener = Ci.nsIWebProgressListener;
const nsIWebProgress = Ci.nsIWebProgress;
const nsISupportsWeakReference = Ci.nsISupportsWeakReference;
const nsISupports = Ci.nsISupports;
const nsIURI = Ci.nsIURI;

const NOTIFY_STATE_DOCUMENT = nsIWebProgress.NOTIFY_STATE_DOCUMENT;

const STATE_IS_WINDOW = nsIWebProgressListener.STATE_IS_WINDOW;
const STATE_IS_DOCUMENT = nsIWebProgressListener.STATE_IS_DOCUMENT;
const STATE_IS_REQUEST = nsIWebProgressListener.STATE_IS_REQUEST;

const STATE_START = nsIWebProgressListener.STATE_START;
const STATE_STOP = nsIWebProgressListener.STATE_STOP;
const STATE_TRANSFERRING = nsIWebProgressListener.STATE_TRANSFERRING;

const STOP_ALL = nsIWebNavigation.STOP_ALL;

const dummyURI = "about:layout-dummy-request";
const aboutBlank = "about:blank";

// ********************************************************************************************* //
// Globals

var contexts = [];

var showContextTimeout = 200;

// ********************************************************************************************* //

/**
 * @object TabWatcher object is responsible for monitoring page load/unload events
 * and triggering proper Firebug UI refresh by firing events. This object is also
 * responsible for creation of a context object that contains meta-data about currently
 * debugged page.
 */
Firebug.TabWatcher = Obj.extend(new EventSource(),
/** @lends Firebug.TabWatcher */
{
    // Store contexts where they can be accessed externally
    contexts: contexts,

    initialize: function()
    {
        this.traceListener = new TraceListener("->", "DBG_WINDOWS", true);
        TraceModule.addListener(this.traceListener);

        HttpRequestObserver.addObserver(TabWatcherHttpObserver, "firebug-http-event", false);
    },

    initializeUI: function()
    {
        var tabBrowser = Firefox.getElementById("content");

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("-> tabWatcher initializeUI "+tabBrowser);

        if (tabBrowser)
            tabBrowser.addProgressListener(TabProgressListener);
    },

    destroy: function()
    {
        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher destroy");

        this.shuttingDown = true;

        HttpRequestObserver.removeObserver(TabWatcherHttpObserver, "firebug-http-event");

        var tabBrowser = Firefox.getElementById("content");
        if (tabBrowser)
        {
            try
            {
                // Exception thrown: tabBrowser.removeProgressListener is not a function
                // when Firebug is in detached state and the origin browser window is closed.
                tabBrowser.removeProgressListener(TabProgressListener);
            }
            catch (e)
            {
                FBTrace.sysout("tabWatcher.destroy; EXCEPTION " + e, e);
            }

            var browsers = Firefox.getBrowsers();
            for (var i = 0; i < browsers.length; ++i)
            {
                var browser = browsers[i];
                this.unwatchTopWindow(browser.contentWindow);
                unregisterFrameListener(browser);
            }
        }

        TraceModule.removeListener(this.traceListener);

        var listeners = TabWatcherUnloader.listeners;
        if (listeners.length > 0)
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("-> tabWatcher.destroy; ERROR unregistered listeners! (" +
                    listeners.length + ")", listeners);
            }

            TabWatcherUnloader.unregisterAll();
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Called when tabBrowser browsers get a new location OR when we get a explicit user op
     * to open Firebug.
     * Attaches to a top-level window. Creates context unless we just re-activated on an
     * existing context.
     */
    watchTopWindow: function(win, uri, userCommands)
    {
        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher.watchTopWindow for: " +
                (uri instanceof nsIURI?uri.spec:uri) + ", tab: " +
                Win.getWindowProxyIdForWindow(win));

        if (!win)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("-> tabWatcher.watchTopWindow should not have a null window!");
            return false;
        }

        // Do not use Firefox.getCurrentBrowser(); since the current tab can be already
        // different from what is passed into this function (see issue 4681)
        // Can be also null, if the window is just closing.
        var selectedBrowser = Win.getBrowserByWindow(win);

        var context = this.getContextByWindow(win);
        if (context) // then we've looked at this window before in this FF session...
        {
            if (FBTrace.DBG_ACTIVATION)
                FBTrace.sysout("-> tabWatcher.watchTopWindow context exists "+context.getName());

            if (!this.shouldShowContext(context))
            {
                // ...but now it is not wanted.
                if (context.browser)
                    delete context.browser.showFirebug;
                this.unwatchContext(win, context);

                return;  // did not create a context
            }

            // Special case for about:blank (see issue 5120)
            // HTML panel's edit mode can cause onStateChange changes and context
            // recreation.
            if (context.loaded && context == Firebug.currentContext &&
                context.getName() == "about:blank")
            {
                FBTrace.sysout("tabWatcher.watchTopWindow; page already watched");
                return;
            }
        }
        else // then we've not looked this window in this session
        {
            // decide whether this window will be debugged or not
            var url = (uri instanceof nsIURI) ? uri.spec : uri;
            if (!this.shouldCreateContext(selectedBrowser, url, userCommands))
            {
                if (FBTrace.DBG_ACTIVATION)
                    FBTrace.sysout("-> tabWatcher will not create context ");

                delete selectedBrowser.showFirebug;
                this.watchContext(win, null);

                return false;  // we did not create a context
            }

            var browser = this.getBrowserByWindow(win);

            context = this.createContext(win, browser, Firebug.getContextType());
        }

        if (win instanceof Ci.nsIDOMWindow && win.parent == win && context)
        {
            // xxxHonza: This place can be called multiple times for one window, so
            // make sure event listeners are not registered twice.
            // There should be a better way to find out whether the listeners are actually
            // registered for the window.
            context.removeEventListener(win, "pageshow", onLoadWindowContent,
                onLoadWindowContent.capturing);
            context.removeEventListener(win, "DOMContentLoaded", onLoadWindowContent,
                onLoadWindowContent.capturing);

            // Re-register again since it could have been done too soon before.
            context.addEventListener(win, "pageshow", onLoadWindowContent,
                onLoadWindowContent.capturing);
            context.addEventListener(win, "DOMContentLoaded", onLoadWindowContent,
                onLoadWindowContent.capturing);

            if (FBTrace.DBG_WINDOWS)
                FBTrace.sysout("-> tabWatcher.watchTopWindow addEventListener for pageshow, " +
                    "DomContentLoaded " + Win.safeGetWindowLocation(win));
        }

        // Dispatch watchWindow for the outer most DOM window
        this.watchWindow(win, context);

        // This is one of two places that loaded is set. The other is in watchLoadedTopWindow
        if (context && !context.loaded)
        {
            context.loaded = !context.browser.webProgress.isLoadingDocument;

            // If the loaded flag is set, the proper event should be dispatched.
            if (context.loaded)
                Events.dispatch(this.fbListeners, "loadedContext", [context]);

            if (FBTrace.DBG_WINDOWS)
                FBTrace.sysout("-> tabWatcher context " +
                    (context.loaded ? '*** LOADED ***' : 'isLoadingDocument') +
                    " in watchTopWindow, id: "+context.uid+", uri: "+
                    (uri instanceof nsIURI ? uri.spec : uri));
        }

        if (context && !context.loaded && !context.showContextTimeout)
        {
            this.rushShowContextTimeout(win, context, 20);
        }
        else
        {
            if (FBTrace.DBG_WINDOWS)
                FBTrace.sysout("-> watchTopWindow context.loaded:" + context.loaded + " for " +
                    context.getName());

            this.rushShowContext(win, context);
        }

        return context;  // we did create or find a context
    },

    rushShowContextTimeout: function(win, context, tryAgain)
    {
        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> rushShowContextTimeout: tryAgain: " + tryAgain);

        // still loading, we want to showContext one time but not too aggressively
        var handler = Obj.bindFixed(function delayShowContext()
        {
            if (FBTrace.DBG_WINDOWS)
                FBTrace.sysout("-> watchTopWindow delayShowContext id:" +
                    context.showContextTimeout, context);

            if (context.browser && context.browser.webProgress.isLoadingDocument && --tryAgain > 0)
            {
                this.rushShowContextTimeout(win, context, tryAgain);
                return;
            }

            // Sometimes context.window is not defined, especially when running tests.
            if (context.window)
            {
                this.rushShowContext(win, context);  // calls showContext
            }
            else
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("tabWatcher watchTopWindow no context.window " +
                        (context.browser? context.browser.currentURI.spec :
                        " and no context.browser"));
            }
        }, this);

        context.showContextTimeout = window.setTimeout(handler, showContextTimeout);
    },

    rushShowContext: function(win, context)
    {
        // then the timeout even has not run, we'll not need it after all.
        if (context.showContextTimeout)
            clearTimeout(context.showContextTimeout);
        delete context.showContextTimeout;

        // Call showContext only for currently active tab.
        var currentURI = Firefox.getCurrentURI();
        if (!currentURI || currentURI.spec != context.browser.currentURI.spec)
        {
            if (FBTrace.DBG_WINDOWS)
            {
                FBTrace.sysout("-> rushShowContext: Do not show context as it's not " +
                    "the active tab: " + context.browser.currentURI.spec);
            }
            return;
        }

        this.watchContext(win, context);  // calls showContext
    },

    // Listeners decide to show or not
    shouldShowContext: function(context)
    {
        if (Events.dispatch2(this.fbListeners, "shouldShowContext", [context]))
            return true;
        else
            return false;
    },

    // Listeners given force-in and veto on URIs/Window.
    shouldCreateContext: function(browser, url, userCommands)
    {
        // called when win has no context, answers the question: create one, true or false?

        if (!this.fbListeners)
            return userCommands;

        // Do not Create if any Listener says true to shouldNotCreateContext
        if (Events.dispatch2(this.fbListeners, "shouldNotCreateContext",
            [browser, url, userCommands]))
        {
            if (FBTrace.DBG_ACTIVATION)
                FBTrace.sysout("-> shouldNotCreateContext vetos create context for: " + url);
            return false;
        }

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("-> shouldCreateContext FBLISTENERS", this.fbListeners);

        // Create if any listener says true to showCreateContext
        if (Events.dispatch2(this.fbListeners, "shouldCreateContext",
            [browser, url, userCommands]))
        {
             if (FBTrace.DBG_ACTIVATION)
                 FBTrace.sysout("-> shouldCreateContext with user: "+userCommands+
                    " one listener says yes to "+ url, this.fbListeners);
            return true;
        }

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("-> shouldCreateContext with user: "+userCommands +
                " no opinion for: "+ url);

        // create if user said so and no one else has an opinion.
        return userCommands;
    },

    createContext: function(win, browser, contextType)
    {
        // If the page is reloaded, store the persisted state from the previous
        // page on the new context
        var persistedState = browser.persistedState;
        delete browser.persistedState;
        var location = Win.safeGetWindowLocation(win).toString();
        //if (!persistedState || persistedState.location != location)
        //    persistedState = null;

        // xxxHonza, xxxJJB: web application detection. Based on domain check.
        var prevDomain = persistedState ? Url.getDomain(persistedState.location) : null;
        var domain = Url.getDomain(location);
        // Remove this, see 3484
        //if (!persistedState || prevDomain != domain)
        //    persistedState = null;

        // The proper instance of Firebug.chrome object (different for detached Firebug and
        // accessible as Firebug.chrome property) must be used for the context object.
        // (the global context object Firebug.currentContext is also different for
        // detached Firebug).
        var context = new contextType(win, browser, Firebug.chrome, persistedState);
        contexts.push(context);

        context.uid =  Obj.getUniqueId();

        browser.showFirebug = true; // this is the only place we should set showFirebug.

        if (FBTrace.DBG_WINDOWS || FBTrace.DBG_ACTIVATION)
        {
            FBTrace.sysout("-> tabWatcher *** INIT *** context, id: " + context.uid +
                ", " + context.getName() + " browser " + browser.currentURI.spec +
                " Firebug.chrome.window: " + Firebug.chrome.window.location +
                " context.window: " + Win.safeGetWindowLocation(context.window));
        }

        Events.dispatch(this.fbListeners, "initContext", [context, persistedState]);

        return context;
    },

    /**
     * Called once the document within a tab is completely loaded.
     */
    watchLoadedTopWindow: function(win)
    {
        var isSystem = Url.isSystemPage(win);

        var context = this.getContextByWindow(win);
        if (context && !context.window)
        {
            if (FBTrace.DBG_WINDOWS)
                FBTrace.sysout("-> tabWatcher.watchLoadedTopWindow bailing !!!, context.window: " +
                    context.window + ", isSystem: " + isSystem);

            this.unwatchTopWindow(win);
            this.watchContext(win, null, isSystem);
            return;
        }

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> watchLoadedTopWindow context: " +
                (context ? (context.uid + ", loaded=" + context.loaded) : "undefined")+
                ", " + Win.safeGetWindowLocation(win));

        if (context && !context.loaded)
        {
            context.loaded = true;

            if (FBTrace.DBG_WINDOWS)
                FBTrace.sysout("-> Context *** LOADED *** in watchLoadedTopWindow, id: " +
                    context.uid + ", uri: " + Win.safeGetWindowLocation(win));

            Events.dispatch(this.fbListeners, "loadedContext", [context]);

            // DOMContentLoaded arrived. Whether or not we did showContext at 400ms, do it now.
            this.rushShowContext(win, context);
        }
    },

    /**
     * Attaches to a window that may be either top-level or a frame within the page.
     */
    watchWindow: function(win, context, skipCompletedDocuments)
    {
        if (!context)
            context = this.getContextByWindow(Win.getRootWindow(win));

        var location = Win.safeGetWindowLocation(win);

        // For every window we watch, prepare for unwatch. It's OK if this is called
        // more times (see 2695).
        if (context)
            TabWatcherUnloader.registerWindow(win);

        try
        {
            // If the documents is already completed do not register the window
            // it should be registered already at this point
            // This condition avoids situation when "about:document-onload-blocker"
            // and STATE_START is fired for a window, which is consequently never
            // firing "unload" and so, stays registered within context.windows
            // See issue 5582 (comment #4)
            if (skipCompletedDocuments && win.document.readyState == "complete")
                return;
        }
        catch (err)
        {
        }

        // Unfortunately, dummy requests that trigger the call to watchWindow
        // are called several times, so we have to avoid dispatching watchWindow
        // more than once
        if (context && context.windows.indexOf(win) == -1)
        {
            context.windows.push(win);

            if (FBTrace.DBG_WINDOWS)
            {
                FBTrace.sysout("-> tabWatcher.watchWindow; " + Win.safeGetWindowLocation(win) +
                    " [" + Win.getWindowId(win).toString() + "] " + context.windows.length +
                    " - " + win.document.readyState);
            }

            Events.dispatch(this.fbListeners, "watchWindow", [context, win]);

            if (FBTrace.DBG_WINDOWS)
            {
                FBTrace.sysout("-> watchWindow for: " + location + ", context: " + context.uid);

                if (context)
                {
                    for (var i = 0; i < context.windows.length; i++)
                        FBTrace.sysout("context: " + context.uid + ", window in context: " +
                            context.windows[i].location.href);
                }
            }

            context.addEventListener(win, "load", onLoadWindow, false);
        }
    },

    /**
     * Detaches from a top-level window. Destroys context
     * Called when windows are closed, or user closes firebug
     */
    unwatchTopWindow: function(win)
    {
        var context = this.getContextByWindow(win);
        if (FBTrace.DBG_WINDOWS)
        {
            FBTrace.sysout("-> tabWatcher.unwatchTopWindow for: " +
                (context ? context.getWindowLocation() : "NULL Context") +
                ", context: " + context);
        }

        this.unwatchContext(win, context);

        // Make sure all listeners ('unload' and 'pagehide') are removed.
        Win.iterateWindows(win, function(win)
        {
            TabWatcherUnloader.unregisterWindow(win);
        });

        // we might later allow extensions to reject unwatch
        return true;
    },

    /**
     * Detaches from a window, top-level or frame (interior)
     */
    unwatchWindow: function(win)
    {
        var context = this.getContextByWindow(win);

        if (!context)
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("unwatchWindow: ERROR no context for win " +
                    Win.safeGetWindowLocation(win));
            }
            return;
        }

        var index = context.windows.indexOf(win);
        if (FBTrace.DBG_WINDOWS)
        {
            FBTrace.sysout("-> tabWatcher.unwatchWindow; " + Win.safeGetWindowLocation(win) +
                " [" + Win.getWindowId(win).toString() + "] " + context.windows.length +
                " - " + win.document.readyState);
        }

        if (index != -1)
        {
            context.windows.splice(index, 1);
            Events.dispatch(this.fbListeners, "unwatchWindow", [context, win]);
        }
    },

    /**
     * Attaches to the window inside a browser because of user-activation
     * returns false if no context was created by the attach attempt, eg extension rejected page
     */
    watchBrowser: function(browser)
    {
        if (FBTrace.DBG_WINDOWS)
        {
            var uri = Http.safeGetURI(browser);
            FBTrace.sysout("-> tabWatcher.watchBrowser for: " +
                (uri instanceof nsIURI?uri.spec:uri));
        }

        registerFrameListener(browser);

        var shouldDispatch = this.watchTopWindow(browser.contentWindow,
            Http.safeGetURI(browser), true);
        if (shouldDispatch)
        {
            Events.dispatch(this.fbListeners, "watchBrowser", [browser]);
            return true;
        }

        return false;
    },

    /**
     * User closes Firebug
     */
    unwatchBrowser: function(browser, userCommands)
    {
        if (FBTrace.DBG_WINDOWS)
        {
            var uri = Http.safeGetURI(browser);
            FBTrace.sysout("-> tabWatcher.unwatchBrowser for: " +
                (uri instanceof nsIURI ? uri.spec : uri) + " user commands: " + userCommands +
                (browser ? "" : "NULL BROWSER"));
        }

        if (!browser)
            return;

        delete browser.showFirebug;

        unregisterFrameListener(browser);

        var shouldDispatch = this.unwatchTopWindow(browser.contentWindow);

        if (shouldDispatch)
        {
            Events.dispatch(this.fbListeners, "unwatchBrowser", [browser, userCommands]);
            return true;
        }
        return false;
    },

    // called when tabs change in firefox
    watchContext: function(win, context, isSystem)
    {
        if (this.shuttingDown)
            return;

        var browser = context ? context.browser : this.getBrowserByWindow(win);
        if (browser)
            browser.isSystemPage = isSystem;

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher context *** SHOW *** (watchContext), id: " +
                (context?context.uid:"null")+", uri: "+win.location.href);

        // context is null if we don't want to debug this browser
        Events.dispatch(this.fbListeners, "showContext", [browser, context]);
    },

    unwatchContext: function(win, context)
    {
        if (!context)
        {
            var browser = this.getBrowserByWindow(win);
            if (browser)
            {
                browser.persistedState = {};
                delete browser.showFirebug;

                // context is null if we don't want to debug this browser
                Events.dispatch(this.fbListeners, "showContext", [browser, null]);
            }

            Events.dispatch(this.fbListeners, "destroyContext",
                [null, (browser ? browser.persistedState : null), browser]);
            return;
        }

        var persistedState = {location: context.getWindowLocation()};
        context.browser.persistedState = persistedState;  // store our state on FF browser elt

        Win.iterateWindows(context.window, function(win)
        {
            Events.dispatch(Firebug.TabWatcher.fbListeners, "unwatchWindow", [context, win]);
        });

        Events.dispatch(this.fbListeners, "destroyContext", [context, persistedState, context.browser]);

        if (FBTrace.DBG_WINDOWS || FBTrace.DBG_ACTIVATION)
        {
            FBTrace.sysout("-> tabWatcher.unwatchContext *** DESTROY *** context " + context.uid +
                " for: " + (context.window && !context.window.closed?context.window.location :
                "no window or closed ") + " aborted: " + context.aborted);
        }

        context.destroy(persistedState);

        // Remove context from the list of contexts.
        Arr.remove(contexts, context);

        for (var name in context)
            delete context[name];

        // unwatchContext can be called on an unload event after another tab is selected
        var currentBrowser = Firefox.getCurrentBrowser();
        if (!currentBrowser.showFirebug)
        {
            // context is null if we don't want to debug this browser
            Events.dispatch(this.fbListeners, "showContext", [currentBrowser, null]);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getContextByWindow: function(winIn)
    {
        if (!winIn)
            return;

        var rootWindow = Win.getRootWindow(winIn);

        if (FBTrace.DBG_ROOT_WINDOW) // too much output to use INITIALIZE
            FBTrace.sysout("winIn: "+Win.safeGetWindowLocation(winIn).substr(0,50)+
                " rootWindow: "+Win.safeGetWindowLocation(rootWindow));

        if (rootWindow)
        {
            for (var i = 0; i < contexts.length; ++i)
            {
                var context = contexts[i];
                if (context.window == rootWindow)
                    return context;
            }
        }
    },

    getContextBySandbox: function(sandbox)
    {
        for (var i = 0; i < contexts.length; ++i)
        {
            var context = contexts[i];
            if (context.sandboxes)
            {
                for (var iframe = 0; iframe < context.sandboxes.length; iframe++)
                {
                    if (context.sandboxes[iframe] == sandbox)
                        return context;
                }
            }
        }
        return null;
    },

    getContextByGlobal: function(global)
    {
        return this.getContextByWindow(global) || this.getContextBySandbox(global);
    },

    // deprecated, use Win.getBrowserByWindow
    getBrowserByWindow: function(win)
    {
        if (this.shuttingDown)
            return null;

        var browsers = Firefox.getBrowsers();
        for (var i = 0; i < browsers.length; ++i)
        {
            var browser = browsers[i];
            if (browser.contentWindow == win)
            {
                registerFrameListener(browser); // Yikes side effect!
                return browser;
            }
        }

        return null;
    },

    iterateContexts: function(fn)
    {
        for (var i = 0; i < contexts.length; ++i)
        {
            var rc = fn(contexts[i]);
            if (rc)
                return rc;
        }
    },

    // Called by script panel, not sure where this belongs.
    reloadPageFromMemory: function(context)
    {
        if (!context)
            context = Firebug.currentContext;

        if (context.browser)
            context.browser.reloadWithFlags(Ci.nsIWebNavigation.LOAD_FLAGS_CHARSET_CHANGE);
        else
            context.window.location.reload();
    },
});

// ********************************************************************************************* //

var TabWatcherUnloader =
{
    listeners: [],

    registerWindow: function(win)
    {
        var root = (win.parent == win);
        var eventName = (root && (win.location.href !== "about:blank")) ? "pagehide" : "unload";
        var listener = Obj.bind(root ? this.onPageHide : this.onUnload, this);
        Events.addEventListener(win, eventName, listener, false);

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher.registerWindow; addEventListener for " + eventName+
                " on " + Win.safeGetWindowLocation(win));

        this.listeners.push({
            window: win,
            listener: listener,
            eventName: eventName
        });
    },

    unregisterWindow: function(win)
    {
        var newListeners = [];
        for (var i=0; i<this.listeners.length; i++)
        {
            var listener = this.listeners[i];
            if (listener.window != win)
            {
                newListeners.push(listener);
            }
            else
            {
                Events.removeEventListener(win, listener.eventName, listener.listener, false);

                if (FBTrace.DBG_WINDOWS)
                    FBTrace.sysout("-> tabWatcher.unregisterWindow; removeEventListener for " +
                        listener.eventName + " on " + Win.safeGetWindowLocation(win));
            }
        }
        this.listeners = newListeners;
    },

    unregisterAll: function()
    {
        for (var i=0; i<this.listeners.length; i++)
        {
            var listener = this.listeners[i];
            Events.removeEventListener(listener.win, listener.eventName, listener.listener, false);
        }

        this.listeners = [];
    },

    onPageHide: function(event)
    {
        var win = event.currentTarget;
        this.unregisterWindow(win);

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher.Unloader; PAGE HIDE (" +
                this.listeners.length + ") " + win.location, event);

        onPageHideTopWindow(event);
    },

    onUnload: function(event)
    {
        var win = event.currentTarget;
        this.unregisterWindow(win);

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher.Unloader; PAGE UNLOAD (" +
                this.listeners.length + ") " + win.location, event);

        onUnloadWindow(event);
    },
};

Firebug.TabWatcherUnloader = TabWatcherUnloader;

// ********************************************************************************************* //

var TabProgressListener = Obj.extend(Http.BaseProgressListener,
{
    onLocationChange: function(progress, request, uri)
    {
        // Only watch windows that are their own parent - e.g. not frames
        if (progress.DOMWindow.parent == progress.DOMWindow)
        {
            var srcWindow = Http.getWindowForRequest(request);
            var browser = srcWindow ? Firebug.TabWatcher.getBrowserByWindow(srcWindow) : null;

            if (FBTrace.DBG_WINDOWS || FBTrace.DBG_ACTIVATION)
            {
                var requestFromFirebuggedWindow = browser && browser.showFirebug;
                FBTrace.sysout("-> TabProgressListener.onLocationChange "+
                    progress.DOMWindow.location+" to: "+
                    (uri?uri.spec:"null location")+
                    (requestFromFirebuggedWindow?" from firebugged window":" no firebug"));
            }

            // 1) We don't want to skip about:blank since Firebug UI is not update when
            // switching to about:blank tab, see issue 4040
            //
            // 2) But we also want to skip "about:blank" in case a new tab is opened
            // (new tab is about:blank at the beggining), no context exists and Firebug
            // is suspended for all contexts, see issue5916
            // There is a workaround for this case in {@TabWatchListener.showContext]
            //
            // the onStateChange will deal with this troublesome case
            //if (uri && uri.spec === "about:blank")
            //    return;

            // document.open() was called, the document was cleared.
            if (uri && uri.scheme === "wyciwyg")
                evictTopWindow(progress.DOMWindow, uri);

            if (uri)
                Firebug.TabWatcher.watchTopWindow(progress.DOMWindow, uri);
            else // the location change to a non-uri means we need to hide
                Firebug.TabWatcher.watchContext(progress.DOMWindow, null, true);
        }
    },

    onStateChange: function(progress, request, flag, status)
    {
        if (FBTrace.DBG_WINDOWS)
        {
            var win = progress.DOMWindow;
            FBTrace.sysout("-> TabProgressListener.onStateChanged for: " +
                Http.safeGetRequestName(request) + ", win: " + win.location.href +
                ", content URL: " + (win.document ? win.document.URL : "no content URL") +
                " " + Http.getStateDescription(flag));
        }
    }
});

// ********************************************************************************************* //
// Obsolete

var FrameProgressListener = Obj.extend(Http.BaseProgressListener,
{
    onStateChange: function(progress, request, flag, status)
    {
        if (FBTrace.DBG_WINDOWS)
        {
            var win = progress.DOMWindow;
            FBTrace.sysout("-> FrameProgressListener.onStateChanged for: " +
                Http.safeGetRequestName(request) + ", win: " + win.location.href +
                ", content URL: " + (win.document ? win.document.URL : "no content URL") +
                " " + Http.getStateDescription(flag) + ", " + status);
        }

        if (flag & STATE_IS_REQUEST && flag & STATE_START)
        {
            // We need to get the hook in as soon as the new DOMWindow is created, but before
            // it starts executing any scripts in the page.  After lengthy analysis, it seems
            // that the start of these "dummy" requests is the only state that works.

            var safeName = Http.safeGetRequestName(request);
            if (safeName && ((safeName == dummyURI) || safeName == "about:document-onload-blocker"))
            {
                var win = progress.DOMWindow;
                // Another weird edge case here - when opening a new tab with about:blank,
                // "unload" is dispatched to the document, but onLocationChange is not called
                // again, so we have to call watchTopWindow here

                if (win.parent == win && (win.location.href == "about:blank"))
                {
                    Firebug.TabWatcher.watchTopWindow(win, win.location.href);
                    return;
                }
                else
                {
                    Firebug.TabWatcher.watchWindow(win, null, true);
                }
            }
        }

        // Later I discovered that XHTML documents don't dispatch the dummy requests, so this
        // is our best shot here at hooking them.
        if (flag & STATE_IS_DOCUMENT && flag & STATE_TRANSFERRING)
        {
            Firebug.TabWatcher.watchWindow(progress.DOMWindow);
            return;
        }

    }
});

// Obsolete
// Registers frame listener for specified tab browser.
function registerFrameListener(browser)
{
    if (browser.frameListener)
        return;

    browser.frameListener = FrameProgressListener;  // just a mark saying we've registered. TODO remove!
    browser.addProgressListener(FrameProgressListener);

    if (FBTrace.DBG_WINDOWS)
    {
        var win = browser.contentWindow;
        FBTrace.sysout("-> tabWatcher register FrameProgressListener for: "+
            Win.safeGetWindowLocation(win)+", tab: "+Win.getWindowProxyIdForWindow(win));
    }
}

function unregisterFrameListener(browser)
{
    if (browser.frameListener)
    {
        delete browser.frameListener;
        browser.removeProgressListener(FrameProgressListener);
    }

    if (FBTrace.DBG_WINDOWS)
    {
        var win = browser.contentWindow;
        FBTrace.sysout("-> tabWatcher unregister FrameProgressListener for: "+
            Win.safeGetWindowLocation(win)+", tab: "+Win.getWindowProxyIdForWindow(win));
    }
}

// ********************************************************************************************* //

function getRefererHeader(request)
{
    var http = Xpcom.QI(request, Ci.nsIHttpChannel);
    var referer = null;
    http.visitRequestHeaders({
        visitHeader: function(name, value)
        {
            if (name == 'referer')
                referer = value;
        }
    });
    return referer;
}

// ********************************************************************************************* //

var TabWatcherHttpObserver = Obj.extend(Object,
{
    dispatchName: "TabWatcherHttpObserver",

    // nsIObserver
    observe: function(aSubject, aTopic, aData)
    {
        try
        {
            if (aTopic == "http-on-modify-request")
            {
                aSubject = aSubject.QueryInterface(Ci.nsIHttpChannel);
                this.onModifyRequest(aSubject);
            }
        }
        catch (err)
        {
            Debug.ERROR(err);
        }
    },

    onModifyRequest: function(request)
    {
        var win = Http.getWindowForRequest(request);
        if (win)
            var tabId = Win.getWindowProxyIdForWindow(win);

        // Tab watcher is only interested in tab related requests.
        if (!tabId)
            return;

        // Ignore redirects
        if (request.URI.spec != request.originalURI.spec)
            return;

        // A document request for the specified tab is here. It can be a top window
        // request (win == win.parent) or embedded iframe request.
        if (request.loadFlags & Ci.nsIHttpChannel.LOAD_DOCUMENT_URI)
        {
            if ((FBTrace.DBG_ACTIVATION || FBTrace.DBG_WINDOWS) && win == win.parent)
            {
                FBTrace.sysout("-> tabWatcher Firebug.TabWatcherHttpObserver *** START *** " +
                    "document request for: " + request.URI.spec + " window for request is "+
                    Win.safeGetWindowLocation(win));
            }

            if (win == win.parent)
            {
                // Make sure the frame listener is registered for top level window, so
                // we can get all onStateChange events and init context for all opened tabs.
                var browser = Firebug.TabWatcher.getBrowserByWindow(win);

                if (!browser)
                    return;

                delete browser.FirebugLink;

                // then this page is opened in new tab or window
                if (Win.safeGetWindowLocation(win).toString() == "about:blank")
                {
                    var referer = getRefererHeader(request);
                    if (referer)
                    {
                        try
                        {
                            var srcURI = Url.makeURI(referer);
                            browser.FirebugLink = {src: srcURI, dst: request.URI};
                        }
                        catch(e)
                        {
                            if (FBTrace.DBG_ERRORS)
                                FBTrace.sysout("tabWatcher.onModifyRequest failed to make URI from "+
                                    referer+" because "+exc, exc);
                        }
                    }
                }
                else
                {
                    // Here we know the source of the request is 'win'. For viral activation
                    // and web app tracking
                    browser.FirebugLink = {src: browser.currentURI, dst: request.URI};
                }
                if (FBTrace.DBG_ACTIVATION && browser.FirebugLink)
                    FBTrace.sysout("tabWatcher.onModifyRequest created FirebugLink from "+
                        browser.FirebugLink.src.spec + " to "+browser.FirebugLink.dst.spec);
            }
        }
    },

    QueryInterface : function (aIID)
    {
        if (aIID.equals(Ci.nsIObserver) ||
            aIID.equals(Ci.nsISupportsWeakReference) ||
            aIID.equals(Ci.nsISupports))
        {
            return this;
        }

        throw Components.results.NS_NOINTERFACE;
    }
});

// ********************************************************************************************* //
// Local Helpers

function onPageHideTopWindow(event)
{
    var win = event.currentTarget;  // we set the handler on a window
    var doc = event.target; // the pagehide is sent to the document.
    if (doc.defaultView != win)
        return; // ignore page hides on interior windows

    if (FBTrace.DBG_WINDOWS)
        FBTrace.sysout("-> tabWatcher pagehide event.currentTarget "+
            Win.safeGetWindowLocation(win), event);

    // http://developer.mozilla.org/en/docs/Using_Firefox_1.5_caching#pagehide_event
    // then the page is cached and there cannot be an unload handler
    if (event.persisted || Win.safeGetWindowLocation(win) === aboutBlank)
    {
        //  see Bug 484710 -  add pageIgnore event for pages that are ejected from the bfcache
        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher onPageHideTopWindow for: " +
                Win.safeGetWindowLocation(win));

        Firebug.TabWatcher.unwatchTopWindow(win);
    }
    else
    {
        // Page is not cached, there may be an unload
        Events.addEventListener(win, "unload", onUnloadTopWindow, true);

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher onPageHideTopWindow set unload handler " +
                Win.safeGetWindowLocation(win));
    }
}

function evictTopWindow(win, uri)
{
    if (FBTrace.DBG_WINDOWS)
        FBTrace.sysout("-> tabWatcher evictTopWindow win "+Win.safeGetWindowLocation(win) +
            " uri "+uri.spec);

    Firebug.TabWatcher.unwatchTopWindow(win);
}

function onUnloadTopWindow(event)
{
    var win = event.currentTarget;
    Events.removeEventListener(win, "unload", onUnloadTopWindow, true);

    if (FBTrace.DBG_WINDOWS)
        FBTrace.sysout("-> tabWatcher onUnloadTopWindow for: " + Win.safeGetWindowLocation(win) +
            " typeof: " + typeof(win));

    Firebug.TabWatcher.unwatchTopWindow(win);
}

function onLoadWindowContent(event)
{
    if (FBTrace.DBG_WINDOWS)
        FBTrace.sysout("-> tabWatcher.onLoadWindowContent event.type: " + event.type);

    var win = event.currentTarget;
    try
    {
        Events.removeEventListener(win, "pageshow", onLoadWindowContent,
            onLoadWindowContent.capturing);

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher.onLoadWindowContent pageshow removeEventListener " +
                Win.safeGetWindowLocation(win));
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("-> tabWatcher.onLoadWindowContent removeEventListener pageshow fails",
                exc);
    }

    try
    {
        Events.removeEventListener(win, "DOMContentLoaded", onLoadWindowContent,
            onLoadWindowContent.capturing);

        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher.onLoadWindowContent DOMContentLoaded " +
                "removeEventListener " + Win.safeGetWindowLocation(win));
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("-> tabWatcher.onLoadWindowContent removeEventListener " +
                "DOMContentLoaded fails", exc);
    }

    // Signal that we got the onLoadWindowContent event. This prevents the
    // FrameProgressListener from sending it.
    var context = Firebug.TabWatcher.getContextByWindow(win);
    if (context)
        context.onLoadWindowContent = true;

    try
    {
        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("-> tabWatcher.onLoadWindowContent:" +
                Win.safeGetWindowLocation(win), win);

        Firebug.TabWatcher.watchLoadedTopWindow(win);
    }
    catch(exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("-> tabWatchter onLoadWindowContent FAILS: "+exc, exc);
    }
}

onLoadWindowContent.capturing = false;

function onUnloadWindow(event)
{
    var win = event.currentTarget;
    var eventType = "unload";

    if (FBTrace.DBG_WINDOWS)
    {
        FBTrace.sysout("-> tabWatcher.onUnloadWindow for: " + Win.safeGetWindowLocation(win) +
            " removeEventListener: "+ eventType);
    }

    Firebug.TabWatcher.unwatchWindow(win);
}

// ********************************************************************************************* //

function onLoadWindow(event)
{
    var win = event.currentTarget;

    Events.removeEventListener(win, "load", onLoadWindow, false);

    var context = Firebug.TabWatcher.getContextByWindow(win);
    if (!context)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("-> onLoadWindow: ERROR No context for loaded window!");
        return;
    }

    Events.dispatch(Firebug.TabWatcher.fbListeners, "loadWindow", [context, win]);
}

// ********************************************************************************************* //

window.__defineGetter__("TabWatcher", function deprecatedTabWatcher()
{
    if (FBTrace.DBG_ERRORS)
        FBTrace.sysout("deprecated TabWatcher global accessed");

    return Firebug.TabWatcher;
});

// ********************************************************************************************* //
// Registration

return Firebug.TabWatcher;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/toggleSidePanels",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/lib/trace",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/lib/css",
],
function(Firebug, Module, Obj, FBTrace, Dom, Options, Css) {

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// ToggleSidePanels Implementation

/**
 * @module Implements 'Toggle Side Panels' feature that is available on panel's toolbar.
 * Visibility of the side-panel-area is panel specific. So, if the user hides it e.g. for
 * the HTML panel it applies to the HTML panel only.
 *
 * Visibility is toggled by 'fbToggleSidePanels' button that is created
 * in firebugOverlay.xul
 *
 * Visibility is persisted across Firefox restarts and stored in preferences. All Firebug
 * side panels are visible by default. Preference names are generated according to the
 * main panel name |panel.name|. For example, the HTML panel is using:
 * extensions.firebug.htmlHideSidePanels (false by default or non existing)
 *
 * Side panels visibility is updated upon 'updateSidePanels' event fired to all
 * UI listeners by Firebug chrome object.
 */
var ToggleSidePanels = Obj.extend(Module,
/** @lends ToggleSidePanels */
{
    dispatchName: "ToggleSidePanels",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        // Register as a listener for 'updateSidePanels' event. 
        Firebug.registerUIListener(this);

        // Register a command handler dynamically, so we don't have to
        // expose this object into the firebugOverlay.xul scope.
        var button = Firebug.chrome.$("fbToggleSidePanels");
        button.addEventListener("command", this.toggle.bind(this), false);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        Firebug.unregisterUIListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Listener

    updateSidePanels: function(panel)
    {
        // If no current panel bail out (the current panel can be disabled i.e. null).
        if (!panel)
            return;

        var context = panel.context;

        // Get list of side panels for the current main panel.
        var selectedPanel = Firebug.chrome.getSelectedPanel();
        var panelTypes = Firebug.getSidePanelTypes(context, selectedPanel);

        // Hide the toggle-side-panels button if there are no side panels
        // for the current main panel.
        var hasSidePanels = (panelTypes.length > 0);
        var box = Firebug.chrome.$("fbToggleSidePanelsBox");
        Dom.collapse(box, !hasSidePanels);

        if (!hasSidePanels)
            return;

        var prefName = this.getPanelPrefName(panel);
        var currentlyVisible = this.isVisible();

        // True preference value means hide the side panels.
        var shouldBeVisible = !Options.get(prefName);

        // Update visibility of the side area.
        if (currentlyVisible != shouldBeVisible)
            this.toggle();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // State

    getPanelPrefName: function(panel)
    {
        // Return preference name for given panel object.
        return panel.name + "HideSidePanels";
    },

    isVisible: function()
    {
        var splitter = Firebug.chrome.$("fbPanelSplitter");
        return !Dom.isCollapsed(splitter);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // XUL Command

    /**
     * Executed when the user presses 'fbToggleSidePanels' button on panel's toolbar.
     *
     * @event XULCommandEvent
     */
    toggle: function(event)
    {
        var splitter = Firebug.chrome.$("fbPanelSplitter");
        var panelDeck = Firebug.chrome.$("fbSidePanelDeck");

        // Get the current state (e.g. if the side panel area is visible it'll be hidden)
        var hide = this.isVisible();

        // Update UI
        Dom.collapse(splitter, hide);
        Dom.collapse(panelDeck, hide);

        // Update preferences
        var selectedPanel = Firebug.chrome.getSelectedPanel();
        var prefName = this.getPanelPrefName(selectedPanel);
        Options.set(prefName, hide);

        // Update button style (its image is changing according to the current state).
        var button = Firebug.chrome.$("fbToggleSidePanels");
        if (hide)
            Css.setClass(button, "closed");
        else
            Css.removeClass(button, "closed");
    },
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(ToggleSidePanels);

return ToggleSidePanels;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/toolbar",
[
    "firebug/lib/trace",
    "firebug/lib/locale",
    "firebug/lib/options",
    "firebug/lib/css",
    "firebug/chrome/menu"
],
function(FBTrace, Locale, Options, Css, Menu) {

// ********************************************************************************************* //
// Constants

var Toolbar = {};

// ********************************************************************************************* //
// Implementation

Toolbar.createToolbarButton = function(toolbar, button, before)
{
    if (typeof(button) == "string" && button.charAt(0) == "-")
        return Toolbar.createToolbarSeparator(toolbar, before);

    var toolbarButton = toolbar.ownerDocument.createElement("toolbarbutton");

    Toolbar.setItemIntoElement(toolbarButton, button);

    if (before)
        toolbar.insertBefore(toolbarButton, before);
    else
        toolbar.appendChild(toolbarButton);

    return toolbarButton;
};

Toolbar.setItemIntoElement = function(element, item)
{
    if (item.label)
    {
        var label = item.nol10n ? item.label : Locale.$STR(item.label);
        element.setAttribute("label", label);
    }

    if (item.id)
        element.setAttribute("id", item.id);

    if (item.type)
        element.setAttribute("type", item.type);

    if (item.checked)
        element.setAttribute("checked", "true");

    if (item.disabled)
        element.setAttribute("disabled", "true");

    if (item.image)
        element.setAttribute("image", item.image);

    if (item.command)
        element.addEventListener("command", item.command, false);

    if (item.commandID)
        element.setAttribute("command", item.commandID);

    if (item.option)
        element.setAttribute("option", item.option);

    if (item.tooltiptext)
    {
        var tooltiptext = item.nol10n ? item.tooltiptext : Locale.$STR(item.tooltiptext);
        element.setAttribute("tooltiptext", tooltiptext);
    }

    if (item.className)
        Css.setClass(element, item.className);

    if (item.key)
        element.setAttribute("accesskey", item.key);

    if (item.name)
        element.setAttribute("name", item.name);

    if (item.items)
        Menu.createMenuPopup(element, item);

    return element;
};

Toolbar.createToolbarSeparator = function(toolbar, before)
{
    if (!toolbar.firstChild)
        return;

    var separator = toolbar.ownerDocument.createElement("toolbarseparator");
    if (before)
        toolbar.insertBefore(separator, before);
    else
        toolbar.appendChild(separator);

    return separator;
};

// ********************************************************************************************* //
// Registration

return Toolbar;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/chrome/window",
[
    "firebug/lib/trace",
    "firebug/lib/http",
    "firebug/chrome/firefox"
],
function(FBTrace, Http, Firefox) {

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;
var Cc = Components.classes;

var wm = Cc["@mozilla.org/appshell/window-mediator;1"].getService(Ci.nsIWindowMediator);

var Win = {};

var window = {};     // these declarations exist to cause errors if we accidently
var document = {};   // reference these globals

// ********************************************************************************************* //
// Crossbrowser API

Win.getWindowProxyIdForWindow = function(win)
{
    if (!win)
        return null;

    var id = Win.getWindowId(win).outerWindowID;

    // xxxJJB, xxxHonza: the id is often null, what could be the problem?
    // jjb: My guess: just another Mozilla bug
    if (!id)
        return Win.getTabIdForWindow(win);

    return id;
};

Win.getTabForWindow = function(aWindow)
{
    aWindow = Win.getRootWindow(aWindow);

    var tabBrowser = Firefox.getTabBrowser();
    if (!aWindow || !tabBrowser || !tabBrowser.getBrowserIndexForDocument)
    {
        if (FBTrace.DBG_WINDOWS)
            FBTrace.sysout("getTabForWindow FAIL aWindow: "+aWindow+" tabBrowser: "+tabBrowser, tabBrowser);
        return null;
    }

    try
    {
        var targetDoc = aWindow.document;

        var tab = null;
        var targetBrowserIndex = tabBrowser.getBrowserIndexForDocument(targetDoc);
        if (targetBrowserIndex != -1)
        {
            tab = tabBrowser.tabContainer.childNodes[targetBrowserIndex];
            return tab;
        }
    }
    catch (ex)
    {
    }

    return null;
};

Win.getTabIdForWindow = function(win)
{
    var tab = Win.getTabForWindow(win);
    return tab ? tab.linkedPanel : null;
};

// ********************************************************************************************* //
// Window iteration

Win.iterateWindows = function(win, handler)
{
    if (!win || !win.document)
        return;

    handler(win);

    if (win == top || !win.frames)
        return; // XXXjjb hack for chromeBug

    for (var i = 0; i < win.frames.length; ++i)
    {
        var subWin = win.frames[i];
        if (subWin != win)
            Win.iterateWindows(subWin, handler);
    }
};

Win.getRootWindow = function(win)
{
    for (; win; win = win.parent)
    {
        if (!win.parent || win == win.parent)
            return win;

        // When checking the 'win.parent' type we need to use the target
        // type from the same scope. i.e. from win.parent
        // Iframes from different domains can use different Window type than
        // the top level window.
        if (!(win.parent instanceof win.parent.Window))
            return win;
    }

    return null;
};

// ********************************************************************************************* //
// Firefox browsing

Win.openNewTab = function(url, postText)
{
    if (!url)
        return;

    var postData = null;
    if (postText)
    {
        var stringStream = Http.getInputStreamFromString(postText);
        postData = Cc["@mozilla.org/network/mime-input-stream;1"].createInstance(Ci.nsIMIMEInputStream);
        postData.addHeader("Content-Type", "application/x-www-form-urlencoded");
        postData.addContentLength = true;
        postData.setData(stringStream);
    }

    var tabBrowser = Firefox.getTabBrowser();
    if (!tabBrowser)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("window.openNewTab; ERROR No tabBrowser!");
        return;
    }

    return tabBrowser.selectedTab = tabBrowser.addTab(url, null, null, postData);
};

// Iterate over all opened firefox windows of the given type. If the callback returns true
// the iteration is stopped.
Win.iterateBrowserWindows = function(windowType, callback)
{
    var windowList = wm.getZOrderDOMWindowEnumerator(windowType, true);
    if (!windowList.hasMoreElements())
        windowList = wm.getEnumerator(windowType);

    while (windowList.hasMoreElements())
    {
        if (callback(windowList.getNext()))
            return true;
    }

    return false;
};

Win.iterateBrowserTabs = function(browserWindow, callback)
{
    var tabBrowser = browserWindow.getBrowser();
    var numTabs = tabBrowser.browsers.length;

    for(var index=0; index<numTabs; index++)
    {
        var currentBrowser = tabBrowser.getBrowserAtIndex(index);
        if (callback(tabBrowser.mTabs[index], currentBrowser))
            return true;
    }

    return false;
};


Win.getBrowserByWindow = function(win)
{
    var browsers = Firefox.getBrowsers();
    for (var i = 0; i < browsers.length; ++i)
    {
        var browser = browsers[i];
        if (browser.contentWindow === win)
            return browser;
    }

    return null;
};

// ********************************************************************************************* //

Win.getWindowId = function(win)
{
    var util = win.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils);
    var outerWindowID = null;
    var innerWindowID = "(none)";

    try
    {
        outerWindowID = util.outerWindowID;
        innerWindowID = util.currentInnerWindowID;
    }
    catch(exc)
    {
        // no - op
    }

    return {
        outer: outerWindowID,
        inner: innerWindowID,
        toString: function() {
            return this.outer+"."+this.inner;
        }
    };
};

Win.safeGetWindowLocation = function(window)
{
    try
    {
        if (window)
        {
            if (window.closed)
                return "(window.closed)";
            if ("location" in window)
                return window.location+"";
            else
                return "(no window.location)";
        }
        else
            return "(no context.window)";
    }
    catch (exc)
    {
        if (FBTrace.DBG_WINDOWS || FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("TabContext.getWindowLocation failed "+exc, exc);
            FBTrace.sysout("TabContext.getWindowLocation failed window:", window);
        }

        return "(getWindowLocation: "+exc+")";
    }
};

// ********************************************************************************************* //

return Win;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/autoCompleter",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/lib/dom",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/console/closureInspector",
    "firebug/console/commandLineExposed",
    "firebug/editor/editor",
    "firebug/editor/inlineEditor",
],
function(Obj, Firebug, Domplate, Locale, Events, Wrapper, Dom, Str, Arr, ClosureInspector,
    CommandLineExposed, Editor, InlineEditor) {

"use strict";

// ********************************************************************************************* //
// Constants

var kwActions = ["throw", "return", "in", "instanceof", "delete", "new",
                   "typeof", "void", "yield"];
var kwAll = ["break", "case", "catch", "const", "continue", "debugger",
  "default", "delete", "do", "else", "false", "finally", "for", "function",
  "get", "if", "in", "instanceof", "let", "new", "null", "return", "set",
  "switch", "this", "throw", "true", "try", "typeof", "var", "void", "while",
  "with", "yield"];
var reOpenBracket = /[\[\(\{]/;
var reCloseBracket = /[\]\)\}]/;
var reJSChar = /[a-zA-Z0-9$_]/;
var reLiteralExpr = /^[ "0-9,]*$/;

var measureCache = {};

// ********************************************************************************************* //
// JavaScript auto-completion

function JSAutoCompleter(textBox, completionBox, options)
{
    var popupSize = 40;

    this.textBox = textBox;
    this.options = options;

    this.completionBox = completionBox;
    this.popupTop = this.popupBottom = null;

    this.completionBase = {
        pre: null,
        expr: null,
        forceShowPopup: false,
        candidates: [],
        hiddenCandidates: []
    };
    this.completions = null;

    this.revertValue = null;

    this.showCompletionPopup = options.showCompletionPopup;
    this.completionPopup = options.completionPopup;
    this.selectedPopupElement = null;

    /**
     * If a completion was just performed, revert it. Otherwise do nothing.
     * Returns true iff the completion was reverted.
     */
    this.revert = function(context)
    {
        if (this.revertValue === null)
            return false;

        this.textBox.value = this.revertValue;
        var len = this.textBox.value.length;
        setCursorToEOL(this.textBox);

        this.complete(context);
        return true;
    };

    /**
     * Hide completions temporarily, so they show up again on the next key press.
     */
    this.hide = function()
    {
        this.completionBase = {
            pre: null,
            expr: null,
            forceShowPopup: false,
            candidates: [],
            hiddenCandidates: []
        };
        this.completions = null;

        this.showCompletions(false);
    };

    /**
     * Completely reset the auto-completer.
     */
    this.reset = function()
    {
        this.hide();
        this.revertValue = null;
    };

    /**
     * Hide completions for this expression (/completion base). Appending further
     * characters to the variable name will not make completions appear, but
     * adding, say, a semicolon and typing something else will.
     */
    this.hideForExpression = function()
    {
        this.completionBase.candidates = [];
        this.completionBase.hiddenCandidates = [];
        this.completions = null;

        this.showCompletions(false);
    };

    /**
     * Check whether it would be acceptable for the return key to evaluate the
     * expression instead of completing things.
     */
    this.acceptReturn = function()
    {
        if (!this.completions)
            return true;

        if (this.getCompletionValue() === this.textBox.value)
        {
            // The user wouldn't see a difference if we completed. This can
            // happen for example if you type 'alert' and press enter,
            // regardless of whether or not there exist other completions.
            return true;
        }

        return false;
    };

    /**
     * Show completions for the current contents of the text box. Either this or
     * hide() must be called when the contents change.
     */
    this.complete = function(context, force)
    {
        this.revertValue = null;
        var offset = this.textBox.selectionStart;
        if (this.createCandidates(context, this.textBox.value, offset, force))
            this.showCompletions(false);
        else
            this.hide();
    };

    /**
     * Update the completion base and create completion candidates for the
     * current value of the text box.
     */
    this.createCandidates = function(context, value, offset, force)
    {
        if (offset !== value.length)
            return false;

        // Create a simplified expression by redacting contents/normalizing
        // delimiters of strings and regexes, to make parsing easier.
        // Give up if the syntax is too weird.
        var svalue = simplifyExpr(value);
        if (svalue === null)
            return false;

        if (killCompletions(svalue, value, force))
            return false;

        // Find the expression to be completed.
        var parseStart = getExpressionOffset(svalue);
        var parsed = value.substr(parseStart);
        var sparsed = svalue.substr(parseStart);

        // Find which part of it represents the property access.
        var propertyStart = getPropertyOffset(sparsed);
        var prop = parsed.substring(propertyStart);
        var spreExpr = sparsed.substr(0, propertyStart);
        var preExpr = parsed.substr(0, propertyStart);

        var spreParsed = svalue.substr(0, parseStart);
        var preParsed = value.substr(0, parseStart);

        if (FBTrace.DBG_COMMANDLINE)
        {
            var sep = (parsed.indexOf("|") > -1) ? "^" : "|";
            FBTrace.sysout("Completing: " + preParsed + sep + preExpr + sep + prop);
        }

        var prevCompletions = this.completions;

        // We only need to calculate a new candidate list if the expression has changed.
        if (preExpr !== this.completionBase.expr || preParsed !== this.completionBase.pre)
        {
            var evalOptions = {
                includeCommandLineAPI: options.includeCommandLineAPI,
                includeCurrentScope: options.includeCurrentScope
            };
            if (!preExpr)
            {
                // Add names of variables declared previously in the typed code.
                evalOptions.additionalCompletions = getNewlyDeclaredNames(spreParsed);
            }

            this.completionBase.expr = preExpr;
            this.completionBase.pre = preParsed;
            var ev = autoCompleteEval(context, preExpr, spreExpr,
                preParsed, spreParsed, evalOptions);
            prevCompletions = null;
            this.completionBase.candidates = ev.completions;
            this.completionBase.hiddenCandidates = ev.hiddenCompletions;
            this.completionBase.forceShowPopup = false;
        }

        this.createCompletions(prop, prevCompletions, force);
        return true;
    };

    /**
     * From a valid completion base, create a list of completions (containing
     * those completion candidates that share a (sometimes case-insensitive)
     * prefix with the user's input) and a default completion. The completions
     * for the previous expression (null if none) are used to help with the
     * latter.
     */
    this.createCompletions = function(prefix, prevCompletions, force)
    {
        if (!this.completionBase.expr && !prefix && !force)
        {
            // Don't complete "".
            this.completions = null;
            return;
        }
        if (!this.completionBase.candidates.length && !prefix && !force)
        {
            // Don't complete empty objects -> toString.
            this.completions = null;
            return;
        }

        var valid = [], ciValid = [];
        var clist = [this.completionBase.candidates, this.completionBase.hiddenCandidates];
        var cind = 0;

        var lowPrefix = prefix.toLowerCase();
        var mustMatchFirstLetter = (!this.completionBase.expr && prefix.length > 0);
        while (ciValid.length === 0 && cind < 2)
        {
            var candidates = clist[cind];
            for (var i = 0; i < candidates.length; ++i)
            {
                // Mark a candidate as matching if it matches the prefix case-
                // insensitively, and shares its upper-case characters. The
                // exception to this is that for global completions, the first
                // character must match exactly (see issue 6030).
                var cand = candidates[i], name = cand.name;
                if (!Str.hasPrefix(name.toLowerCase(), lowPrefix))
                    continue;

                if (mustMatchFirstLetter && name.charAt(0) !== prefix.charAt(0))
                    continue;

                var fail = false;
                for (var j = 0; j < prefix.length; ++j)
                {
                    var ch = prefix.charAt(j);
                    if (ch !== ch.toLowerCase() && ch !== name.charAt(j))
                    {
                        fail = true;
                        break;
                    }
                }
                if (!fail)
                {
                    ciValid.push(cand);
                    if (Str.hasPrefix(name, prefix))
                        valid.push(cand);
                }
            }
            ++cind;
        }

        if (ciValid.length > 0)
        {
            // If possible, default to a candidate matching the case by picking
            // a default from 'valid' and correcting its index.
            var hasMatchingCase = (valid.length > 0);

            this.completions = {
                list: (hasMatchingCase ? valid : ciValid),
                prefix: prefix,
                hidePopup: (cind === 2),
                forced: force
            };
            this.completions.index = this.pickDefaultCandidate(prevCompletions);

            if (hasMatchingCase)
            {
                var find = valid[this.completions.index];
                this.completions.list = ciValid;
                this.completions.index = ciValid.indexOf(find);
            }
        }
        else
        {
            this.completions = null;
        }
    };

    /**
     * Choose a default candidate from the list of completions. The first of all
     * shortest completions is currently used for this, except in some very hacky,
     * but useful, special cases.
     */
    this.pickDefaultCandidate = function(prevCompletions)
    {
        var list = this.completions.list.map(function(x)
        {
            return x.name;
        }), ind;

        // If the typed expression is an extension of the previous completion, keep it.
        if (prevCompletions && Str.hasPrefix(this.completions.prefix, prevCompletions.prefix))
        {
            var lastCompletion = prevCompletions.list[prevCompletions.index].name;
            ind = list.indexOf(lastCompletion);
            if (ind !== -1)
                return ind;
        }

        if (!this.completionBase.expr && !this.completions.prefix)
            return list.length - 1;

        // Special-case certain expressions. (But remember to pick prefix-free
        // candidates; otherwise "validVariable<return>" can auto-complete
        // instead of run.)
        var prefixFree = function(name)
        {
            return !list.some(function(x)
            {
                return x.length < name.length && Str.hasPrefix(name, x);
            });
        };
        var special = {
            "": ["document", "console", "frames", "window", "parseInt", "undefined", "navigator",
                "Array", "Math", "Object", "String", "XMLHttpRequest", "Window"],
            "window.": ["console"],
            "location.": ["href"],
            "console.": ["log"],
            "document.": ["getElementById", "addEventListener", "createElement", "documentElement"],
            "Object.prototype.toString.": ["call"]
        };
        if (special.hasOwnProperty(this.completionBase.expr))
        {
            var ar = special[this.completionBase.expr];
            for (var i = 0; i < ar.length; ++i)
            {
                var prop = ar[i];
                if (Str.hasPrefix(prop, this.completions.prefix))
                {
                    // Use 'prop' as a completion, if it exists.
                    ind = list.indexOf(prop);
                    if (ind !== -1 && prefixFree(prop))
                        return ind;
                }
            }
        }

        // 'prototype' is a good default if it exists.
        ind = list.indexOf("prototype");
        if (ind !== -1 && prefixFree("prototype"))
            return ind;

        // Simply pick out the shortest candidate. This works remarkably well.
        ind = 0;
        for (var i = 1; i < list.length; ++i)
        {
            if (list[i].length < list[ind].length)
                ind = i;
        }

        // Avoid some completions in favor of others.
        var replacements = {
            "toSource": "toString",
            "toFixed": "toString",
            "watch": "toString",
            "pattern": "parentNode",
            "getSelection": "getEventListeners",
            "inspect": "include",
            "home": "history"
        };
        if (replacements.hasOwnProperty(list[ind]))
        {
            var ind2 = list.indexOf(replacements[list[ind]]);
            if (ind2 !== -1)
                return ind2;
        }

        return ind;
    };

    /**
     * Go backward or forward by some number of steps in the list of completions.
     * dir is the relative movement in the list (negative for backwards movement).
     */
    this.cycle = function(dir, clamp)
    {
        var ind = this.completions.index + dir;
        if (clamp)
            ind = Math.max(Math.min(ind, this.completions.list.length - 1), 0);
        else if (ind >= this.completions.list.length)
            ind = 0;
        else if (ind < 0)
            ind = this.completions.list.length - 1;
        this.completions.index = ind;
        this.showCompletions(true);
    };

    /**
     * Get the property name that is currently selected as a completion (or
     * null if there is none).
     */
    this.getCurrentCompletion = function()
    {
        return (this.completions ? this.completions.list[this.completions.index].name : null);
    };

    /**
     * See if we have any completions.
     */
    this.hasCompletions = function()
    {
        return !!this.completions;
    };

    /**
     * Get the value the completion box should have for some value of the
     * text box and a selected completion.
     */
    this.getCompletionBoxValue = function()
    {
        var completion = this.getCurrentCompletion();
        if (completion === null)
            return "";
        var userTyped = this.textBox.value;
        var value = this.completionBase.pre + this.completionBase.expr + completion;
        return userTyped + value.substr(userTyped.length);
    };

    /**
     * Update the completion box and popup to be consistent with the current
     * state of the auto-completer. If just cycling, the old scolling state
     * for the popup is preserved.
     */
    this.showCompletions = function(cycling)
    {
        this.completionBox.value = this.getCompletionBoxValue();

        if (this.completions && (this.completionBase.forceShowPopup ||
            (this.completions.list.length > 1 && this.showCompletionPopup &&
             !this.completions.hidePopup)))
        {
            this.popupCandidates(cycling);
        }
        else
        {
            this.closePopup();
        }
    };

    /**
     * Handle a keypress event. Returns true if the auto-completer used up
     * the event and does not want it to propagate further.
     */
    this.handleKeyPress = function(event, context)
    {
        var clearedTabWarning = this.clearTabWarning();

        if (Events.isAlt(event))
            return false;

        if (event.keyCode === KeyEvent.DOM_VK_TAB &&
            !Events.isControl(event) && !Events.isControlShift(event) &&
            this.textBox.value !== "")
        {
            if (this.completions)
            {
                this.acceptCompletion();
                Events.cancelEvent(event);
                return true;
            }
            else if (this.options.tabWarnings)
            {
                if (clearedTabWarning)
                {
                    // Send tab along if the user was warned.
                    return false;
                }

                this.setTabWarning();
                Events.cancelEvent(event);
                return true;
            }
        }
        else if (event.keyCode === KeyEvent.DOM_VK_RETURN && !this.acceptReturn())
        {
            // Completion on return, when one is user-visible.
            this.acceptCompletion();
            Events.cancelEvent(event);
            return true;
        }
        else if (event.keyCode === KeyEvent.DOM_VK_RIGHT && this.completions &&
            this.textBox.selectionStart === this.textBox.value.length)
        {
            // Complete on right arrow at end of line.
            this.acceptCompletion();
            Events.cancelEvent(event);
            return true;
        }
        else if (event.keyCode === KeyEvent.DOM_VK_BACK_SPACE)
        {
            if (this.completions && !this.textBox.value)
            {
                this.hide();
                Events.cancelEvent(event);
                return true;
            }
        }
        else if (event.keyCode === KeyEvent.DOM_VK_ESCAPE)
        {
            if (this.completions)
            {
                if (this.completions.forced)
                    this.hide();
                else
                    this.hideForExpression();
                Events.cancelEvent(event);
                return true;
            }
            else
            {
                // There are no visible completions, but we might still be able to
                // revert a recently performed completion.
                if (this.revert(context))
                {
                    Events.cancelEvent(event);
                    return true;
                }
            }
        }
        else if (event.keyCode === KeyEvent.DOM_VK_UP ||
            event.keyCode === KeyEvent.DOM_VK_DOWN)
        {
            if (this.completions)
            {
                this.cycle(event.keyCode === KeyEvent.DOM_VK_UP ? -1 : 1, false);
                Events.cancelEvent(event);
                return true;
            }
        }
        else if (event.keyCode === KeyEvent.DOM_VK_PAGE_UP ||
            event.keyCode === KeyEvent.DOM_VK_PAGE_DOWN)
        {
            if (this.completions)
            {
                this.pageCycle(event.keyCode === KeyEvent.DOM_VK_PAGE_UP ? -1 : 1);
                Events.cancelEvent(event);
                return true;
            }
        }
        else if (event.keyCode === KeyEvent.DOM_VK_HOME ||
            event.keyCode === KeyEvent.DOM_VK_END)
        {
            if (this.isPopupOpen())
            {
                this.topCycle(event.keyCode === KeyEvent.DOM_VK_HOME ? -1 : 1);
                Events.cancelEvent(event);
                return true;
            }
        }
        return false;
    };

    /**
     * Handle a keydown event.
     */
    this.handleKeyDown = function(event, context)
    {
        if (event.keyCode === KeyEvent.DOM_VK_ESCAPE && this.completions)
        {
            // Close the completion popup on escape in keydown, so that the popup
            // does not close itself and prevent event propagation on keypress.
            // (Unless the popup is only open due to Ctrl+Space on a non-empty
            // command line, in which case that's precisely what we want.)
            if (!this.forceShowPopup || this.completions.forced)
                this.closePopup();
        }
        else if (event.keyCode === KeyEvent.DOM_VK_SPACE && Events.isControl(event))
        {
            if (!this.completions)
            {
                // If completions have been hidden, show them again.
                this.hide();
                this.complete(context);
            }

            if (this.completions && !this.isPopupOpen())
            {
                // Force-show the completion popup.
                this.completionBase.forceShowPopup = true;
                this.popupCandidates(false);
            }
        }
    };

    this.clearTabWarning = function()
    {
        if (this.tabWarning)
        {
            this.completionBox.value = "";
            delete this.tabWarning;
            return true;
        }
        return false;
    };

    this.setTabWarning = function()
    {
        this.completionBox.value = this.textBox.value + "    " +
            Locale.$STR("firebug.completion.empty");

        this.tabWarning = true;
    };

    /**
     * Get what should be completed to; this is only vaguely related to what is
     * shown in the completion box.
     */
    this.getCompletionValue = function()
    {
        var property = this.getCurrentCompletion();
        var preParsed = this.completionBase.pre, preExpr = this.completionBase.expr;
        var res = preParsed + preExpr + property;

        // Don't adjust index completions.
        if (/^\[['"]$/.test(preExpr.slice(-2)))
            return res;

        if (!isValidProperty(property))
        {
            // The property name is actually invalid in free form, so replace
            // it with array syntax.

            if (preExpr)
            {
                res = preParsed + preExpr.slice(0, -1);
            }
            else
            {
                // Global variable access - assume the variable is a member of 'window'.
                res = preParsed + "window";
            }
            res += '["' + Str.escapeJS(property) + '"]';
        }
        return res;
    };

    /**
     * Accept the current completion into the text box.
     */
    this.acceptCompletion = function()
    {
        var completion = this.getCompletionValue();
        var originalValue = this.textBox.value;
        this.textBox.value = completion;
        setCursorToEOL(this.textBox);

        this.hide();
        this.revertValue = originalValue;
    };

    this.pageCycle = function(dir)
    {
        var length = this.completions.list.length, selIndex = this.completions.index;

        if (!this.isPopupOpen())
        {
            // When no popup is open, cycle by a fixed amount and stop at edges.
            this.cycle(dir * 15, true);
            return;
        }

        var top = this.popupTop, bottom = this.popupBottom;
        if (top === 0 && bottom === length)
        {
            // For a single scroll page, act like home/end.
            this.topCycle(dir);
            return;
        }

        var immediateTarget;
        if (dir === -1)
            immediateTarget = (top === 0 ? top : top + 2);
        else
            immediateTarget = (bottom === length ? bottom: bottom - 2) - 1;
        if ((selIndex - immediateTarget) * dir < 0)
        {
            // The selection has not yet reached the edge target, so jump to it.
            selIndex = immediateTarget;
        }
        else
        {
            // Show the next page.
            if (dir === -1 && top - popupSize <= 0)
                selIndex = 0;
            else if (dir === 1 && bottom + popupSize >= length)
                selIndex = length - 1;
            else
                selIndex = immediateTarget + dir*popupSize;
        }

        this.completions.index = selIndex;
        this.showCompletions(true);
    };

    this.topCycle = function(dir)
    {
        if (dir === -1)
            this.completions.index = 0;
        else
            this.completions.index = this.completions.list.length - 1;
        this.showCompletions(true);
    };

    this.popupCandidates = function(cycling)
    {
        Dom.eraseNode(this.completionPopup);
        this.selectedPopupElement = null;

        var vbox = this.completionPopup.ownerDocument.createElement("vbox");
        vbox.classList.add("fbCommandLineCompletions");
        this.completionPopup.appendChild(vbox);

        var title = this.completionPopup.ownerDocument.
            createElementNS("http://www.w3.org/1999/xhtml", "div");
        title.textContent = Locale.$STR("console.Use Arrow keys, Tab or Enter");
        title.classList.add("fbPopupTitle");
        vbox.appendChild(title);

        var list = this.completions.list, selIndex = this.completions.index;

        if (list.length <= popupSize)
        {
            this.popupTop = 0;
            this.popupBottom = list.length;
        }
        else
        {
            var self = this;
            var setTop = function(val)
            {
                if (val < 0)
                    val = 0;
                self.popupTop = val;
                self.popupBottom = val + popupSize;
                if (self.popupBottom > list.length)
                    setBottom(list.length);
            };
            var setBottom = function(val)
            {
                if (val > list.length)
                    val = list.length;
                self.popupBottom = val;
                self.popupTop = val - popupSize;
                if (self.popupTop < 0)
                    setTop(0);
            };

            if (!cycling)
            {
                // Show the selection at nearly the bottom of the popup, where
                // it is more local.
                setBottom(selIndex + 3);
            }
            else
            {
                // Scroll the popup such that selIndex fits.
                if (selIndex - 2 < this.popupTop)
                    setTop(selIndex - 2);
                else if (selIndex + 3 > this.popupBottom)
                    setBottom(selIndex + 3);
            }
        }

        var separatorInserted = false;

        for (var i = this.popupTop; i < this.popupBottom; i++)
        {
            var prefixLen = this.completions.prefix.length;
            var completion = list[i], name = completion.name;

            var hbox = this.completionPopup.ownerDocument.
                createElementNS("http://www.w3.org/1999/xhtml", "div");
            hbox.completionIndex = i;
            hbox.classList.add("completionLine");
            hbox.classList.add("fbPopupEntry");

            var pre = this.completionPopup.ownerDocument.
                createElementNS("http://www.w3.org/1999/xhtml", "span");
            var preText = this.completionBase.expr + name.substr(0, prefixLen);
            pre.textContent = preText;
            pre.classList.add("userTypedText");

            var post = this.completionPopup.ownerDocument.
                createElementNS("http://www.w3.org/1999/xhtml", "span");
            var postText = name.substr(prefixLen);
            post.textContent = postText;
            post.classList.add("completionText");

            if (i === selIndex)
                this.selectedPopupElement = hbox;

            if (completion.type === CompletionType.API)
            {
                hbox.classList.add("apiCompletion");

                if (!separatorInserted)
                {
                    var separator = this.completionPopup.ownerDocument.
                        createElementNS("http://www.w3.org/1999/xhtml", "div");
                    separator.textContent = Locale.$STR("Firebug Command Line API");
                    separator.classList.add("fbPopupSeparator");
                    vbox.appendChild(separator);

                    separatorInserted = true;
                }
            }

            if (completion.type === CompletionType.API)
                hbox.classList.add("cmd");
            else
                hbox.classList.add("dom");

            hbox.appendChild(pre);
            hbox.appendChild(post);
            vbox.appendChild(hbox);
        }

        if (this.selectedPopupElement)
            this.selectedPopupElement.setAttribute("selected", "true");

        // Open the popup at the pixel position of the start of the completed
        // expression. The text length times the width of a single character,
        // plus apparent padding, is a good enough approximation of this.
        var chWidth = this.getCharWidth(this.completionBase.pre);
        var offsetX = Math.round(this.completionBase.pre.length * chWidth) + 2;

        // xxxHonza: needs to be properly calculated
        offsetX -= 5;

        this.completionPopup.openPopup(this.textBox, "before_start", offsetX, 0, false, false);
    };

    this.getCharWidth = function(text)
    {
        var size = Firebug.textSize;
        if (!measureCache[size])
        {
            var measurer = this.options.popupMeasurer;
            measurer.style.fontSizeAdjust = this.textBox.style.fontSizeAdjust;
            measureCache[size] = measurer.offsetWidth / 60;
        }
        return measureCache[size];
    };

    this.isPopupOpen = function()
    {
        return (this.completionPopup && this.completionPopup.state !== "closed");
    };

    this.closePopup = function()
    {
        if (!this.isPopupOpen())
            return;

        try
        {
            this.completionPopup.hidePopup();
            this.selectedPopupElement = null;
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("JSAutoCompleter.closePopup; EXCEPTION " + err, err);
        }
    };

    this.getCompletionPopupElementFromEvent = function(event)
    {
        var selected = event.target;
        while (selected && selected.localName !== "div")
            selected = selected.parentNode;

        return (selected && typeof selected.completionIndex !== "undefined" ? selected : null);
    };

    this.popupMousedown = function(event)
    {
        var el = this.getCompletionPopupElementFromEvent(event);
        if (!el)
            return;

        if (this.selectedPopupElement)
            this.selectedPopupElement.removeAttribute("selected");

        this.selectedPopupElement = el;
        this.selectedPopupElement.setAttribute("selected", "true");
        this.completions.index = el.completionIndex;
        this.completionBox.value = this.getCompletionBoxValue();
    };

    this.popupScroll = function(event)
    {
        if (event.axis !== event.VERTICAL_AXIS)
            return;
        if (!this.getCompletionPopupElementFromEvent(event))
            return;
        this.cycle(event.detail, true);
    };

    this.popupClick = function(event)
    {
        var el = this.getCompletionPopupElementFromEvent(event);
        if (!el)
            return;

        this.completions.index = el.completionIndex;
        this.acceptCompletion();
    };

    this.popupMousedown = Obj.bind(this.popupMousedown, this);
    this.popupScroll = Obj.bind(this.popupScroll, this);
    this.popupClick = Obj.bind(this.popupClick, this);

    /**
     * A destructor function, to be called when the auto-completer is destroyed.
     */
    this.shutdown = function()
    {
        this.completionBox.value = "";

        if (this.completionPopup)
        {
            Events.removeEventListener(this.completionPopup, "mousedown", this.popupMousedown, true);
            Events.removeEventListener(this.completionPopup, "DOMMouseScroll", this.popupScroll, true);
            Events.removeEventListener(this.completionPopup, "click", this.popupClick, true);
        }
    };

    if (this.completionPopup)
    {
        Events.addEventListener(this.completionPopup, "mousedown", this.popupMousedown, true);
        Events.addEventListener(this.completionPopup, "DOMMouseScroll", this.popupScroll, true);
        Events.addEventListener(this.completionPopup, "click", this.popupClick, true);
    }
};

/**
 * Transform expressions that use .% into more JavaScript-friendly function calls.
 * (This is unrelated to the auto-completer, but autoCompleter.js has so many nice
 * helper functions.)
 */
JSAutoCompleter.transformScopeOperator = function(expr, fname)
{
    var sexpr = simplifyExpr(expr);
    if (!sexpr)
        return expr;
    var search = 0;
    for (;;)
    {
        // Find the next occurrance of .%.
        var end = sexpr.indexOf(".%", search);
        if (end === -1)
            break;

        var start = getExpressionOffset(sexpr, end);
        if (/^-?[0-9]*$/.test(expr.substring(start, end)))
        {
            // False alarm - the operator was actually a number and the modulo operator.
            search = end + 1;
        }
        else
        {
            // Substitute "expr.%prop" with "scopeGetter(expr).prop", or, if used
            // in a "new" expression, "(scopeGetter(expr)).prop" (so that the scope
            // getter isn't used as a constructor). We don't want to use the second
            // thing unconditionally though, because it messes with ASI.
            var newPos = (start === 0 ? -1 : sexpr.lastIndexOf("new", start-1));
            var hasNew = (newPos !== -1 && !/[a-zA-Z0-9_$.]/.test(sexpr.charAt(newPos-1)) &&
                sexpr.substring(newPos + 3, start).trim() === "");
            var subst = function(expr)
            {
                return expr.substr(0, start) + (hasNew ? "(" : "") + fname + "(" +
                    expr.substring(start, end) + ")" + (hasNew ? ")" : "") + "." +
                    expr.substr(end+2);
            };
            expr = subst(expr);
            sexpr = subst(sexpr);

            search = end + fname.length + (hasNew ? 5 : 3); // |(()).| or |().|
        }
    }
    return expr;
};

// ********************************************************************************************* //

/**
 * An (abstract) editor with simple JavaScript auto-completion.
 */
Firebug.JSEditor = function()
{
};

Firebug.JSEditor.prototype = domplate(InlineEditor.prototype,
{
    setupCompleter: function(completionBox, options)
    {
        this.tabNavigation = false;
        this.arrowCompletion = false;
        this.fixedWidth = true;
        this.completionBox = completionBox;

        this.autoCompleter = new EditorJSAutoCompleter(this.input, this.completionBox, options);
    },

    updateLayout: function()
    {
        // Make sure the completion box stays in sync with the input box.
        InlineEditor.prototype.updateLayout.apply(this, arguments);
        this.completionBox.style.width = this.input.style.width;
        this.completionBox.style.height = this.input.style.height;
    },

    destroy: function()
    {
        this.autoCompleter.destroy();
        InlineEditor.prototype.destroy.call(this);
    },

    onKeyPress: function(event)
    {
        var context = this.panel.context;

        if (this.getAutoCompleter().handleKeyPress(event, context))
            return;

        if (event.keyCode === KeyEvent.DOM_VK_TAB ||
            event.keyCode === KeyEvent.DOM_VK_RETURN)
        {
            Editor.stopEditing();
            Events.cancelEvent(event);
        }
    },

    onInput: function()
    {
        var context = this.panel.context;
        this.getAutoCompleter().complete(context);
        Editor.update();
    }
});

function EditorJSAutoCompleter(box, completionBox, options)
{
    var ac = new JSAutoCompleter(box, completionBox, options);

    this.destroy = Obj.bindFixed(ac.shutdown, ac);
    this.reset = Obj.bindFixed(ac.reset, ac);
    this.handleKeyPress = Obj.bind(ac.handleKeyPress, ac);
    this.complete = function(context)
    {
        ac.complete(context);
    };
}

// ********************************************************************************************* //
// Auto-completion helpers

/**
 * Try to find the position at which the expression to be completed starts.
 */
function getExpressionOffset(command, start)
{
    if (typeof start === "undefined")
        start = command.length;

    var bracketCount = 0, instr = false;

    // When completing []-accessed properties, start instead from the last [.
    var lastBr = command.lastIndexOf("[", start);
    if (lastBr !== -1 && /^" *$/.test(command.substring(lastBr+1, start)))
        start = lastBr;

    for (var i = start-1; i >= 0; --i)
    {
        var c = command[i];
        if (reOpenBracket.test(c))
        {
            if (bracketCount)
                --bracketCount;
            else
                break;
        }
        else if (reCloseBracket.test(c))
        {
            var next = command[i + 1];
            if (bracketCount === 0 && next !== "." && next !== "[")
                break;
            else
                ++bracketCount;
        }
        else if (bracketCount === 0)
        {
            if (c === '"') instr = !instr;
            else if (instr || reJSChar.test(c) || c === "." ||
                (c === "%" && command[i-1] === "."))
                ;
            else
                break;
        }
    }
    ++i;

    // The 'new' operator has higher precedence than function calls, so, if
    // present, it should be included if the expression contains a parenthesis.
    var ind = command.indexOf("(", i+1);
    if (i-4 >= 0 && ind !== -1 && ind < start && command.substr(i-4, 4) === "new ")
    {
        i -= 4;
    }

    return i;
}

/**
 * Try to find the position at which the property name of the final property
 * access in an expression starts (for example, 2 in 'a.b').
 */
function getPropertyOffset(expr)
{
    var lastBr = expr.lastIndexOf("[");
    if (lastBr !== -1 && /^" *$/.test(expr.substr(lastBr+1)))
        return lastBr+2;

    var lastDot = expr.lastIndexOf(".");
    if (lastDot !== -1 && expr.charAt(lastDot+1) === "%")
        return lastDot+2;

    return (lastDot === -1 ? 0 : lastDot+1);
}

/**
 * Get the index of the last non-whitespace character in the range [0, from)
 * in str, or -1 if there is none.
 */
function prevNonWs(str, from)
{
    for (var i = from-1; i >= 0; --i)
    {
        if (str.charAt(i) !== " ")
            return i;
    }
    return -1;
}

/**
 * Find the start of a word consisting of characters matching reJSChar, if
 * str[from] is the last character in the word. (This can be used together
 * with prevNonWs to traverse words backwards from a position.)
 */
function prevWord(str, from)
{
    for (var i = from-1; i >= 0; --i)
    {
        if (!reJSChar.test(str.charAt(i)))
            return i+1;
    }
    return 0;
}

/**
 * Check if a position 'pos', marking the start of a property name, is
 * preceded by a function-declaring keyword.
 */
function isFunctionName(expr, pos)
{
    var ind = prevNonWs(expr, pos);
    if (ind === -1 || !reJSChar.test(expr.charAt(ind)))
        return false;
    var word = expr.substring(prevWord(expr, ind), ind+1);
    return (word === "function" || word === "get" || word === "set");
}

function bwFindMatchingParen(expr, from)
{
    var bcount = 1;
    for (var i = from-1; i >= 0; --i)
    {
        if (reCloseBracket.test(expr.charAt(i)))
            ++bcount;
        else if (reOpenBracket.test(expr.charAt(i)))
            if (--bcount === 0)
                return i;
    }
    return -1;
}

/**
 * Check if a '/' at the end of 'expr' would be a regex or a division.
 * May also return null if the expression seems invalid.
 */
function endingDivIsRegex(expr)
{
    var kwCont = ["function", "if", "while", "for", "switch", "catch", "with"];

    var ind = prevNonWs(expr, expr.length);
    var ch = (ind === -1 ? "{" : expr.charAt(ind));
    if (reJSChar.test(ch))
    {
        // Test if the previous word is a keyword usable like 'kw <expr>'.
        // If so, we have a regex, otherwise, we have a division (a variable
        // or literal being divided by something).
        var w = expr.substring(prevWord(expr, ind), ind+1);
        return (kwActions.indexOf(w) !== -1 || w === "do" || w === "else");
    }
    else if (ch === ")")
    {
        // We have a regex in the cases 'if (...) /blah/' and 'function name(...) /blah/'.
        ind = bwFindMatchingParen(expr, ind);
        if (ind === -1)
            return null;
        ind = prevNonWs(expr, ind);
        if (ind === -1)
            return false;
        if (!reJSChar.test(expr.charAt(ind)))
            return false;
        var wind = prevWord(expr, ind);
        if (kwCont.indexOf(expr.substring(wind, ind+1)) !== -1)
            return true;
        return isFunctionName(expr, wind);
    }
    else if (ch === "]")
    {
        return false;
    }
    return true;
}

// Check if a "{" in an expression is an object declaration.
function isObjectDecl(expr, pos)
{
    var ind = prevNonWs(expr, pos);
    if (ind === -1)
        return false;
    var ch = expr.charAt(ind);
    if (ch === ")" || ch === "{" || ch === "}" || ch === ";")
        return false;
    if (!reJSChar.test(ch))
        return true;
    var w = expr.substring(prevWord(expr, ind), ind+1);
    return (kwActions.indexOf(w) !== -1);
}

function isCommaProp(expr, start)
{
    var beg = expr.lastIndexOf(",")+1;
    if (beg < start)
        beg = start;
    while (expr.charAt(beg) === " ")
        ++beg;
    var prop = expr.substr(beg);
    return isValidProperty(prop);
}

function simplifyExpr(expr)
{
    var ret = "", len = expr.length, instr = false, strend, inreg = false, inclass, brackets = [];

    for (var i = 0; i < len; ++i)
    {
        var ch = expr.charAt(i);
        if (instr)
        {
            if (ch === strend)
            {
                ret += '"';
                instr = false;
            }
            else
            {
                if (ch === "\\" && i+1 !== len)
                {
                    ret += " ";
                    ++i;
                }
                ret += " ";
            }
        }
        else if (inreg)
        {
            if (inclass && ch === "]")
                inclass = false;
            else if (!inclass && ch === "[")
                inclass = true;
            else if (!inclass && ch === "/")
            {
                // End of regex, eat regex flags
                inreg = false;
                while (i+1 !== len && reJSChar.test(expr.charAt(i+1)))
                {
                    ret += " ";
                    ++i;
                }
                ret += '"';
            }
            if (inreg)
            {
                if (ch === "\\" && i+1 !== len)
                {
                    ret += " ";
                    ++i;
                }
                ret += " ";
            }
        }
        else
        {
            if (ch === "'" || ch === '"')
            {
                instr = true;
                strend = ch;
                ret += '"';
            }
            else if (ch === "/")
            {
                if (i + 1 < expr.length && /[\/\*]/.test(expr.charAt(i + 1)))
                {
                    var singleLineComment = (expr.charAt(i + 1) === "/");
                    ret += "  ";
                    i += 2;
                    var re = singleLineComment ? /^\n/ : /\*\//;
                    while (i < len && !re.test(expr.substr(i, 2)))
                    {
                        ret += " ";
                        i++;
                    }
                    if (!singleLineComment && i < len)
                    {
                        ret += "  ";
                        i += 2;
                    }
                    i--;
                }
                else
                {
                    var re = endingDivIsRegex(ret);
                    if (re === null)
                        return null;
                    if (re)
                    {
                        inreg = true;
                        ret += '"';
                    }
                    else
                        ret += "/";
                }
            }
            else
            {
                if (reOpenBracket.test(ch))
                    brackets.push(ch);
                else if (reCloseBracket.test(ch))
                {
                    // Check for mismatched brackets
                    if (!brackets.length)
                        return null;
                    var br = brackets.pop();
                    if (br === "(" && ch !== ")")
                        return null;
                    if (br === "[" && ch !== "]")
                        return null;
                    if (br === "{" && ch !== "}")
                        return null;
                }
                ret += ch;
            }
        }
    }

    return ret;
}

// Check if auto-completion should be killed.
function killCompletions(expr, origExpr, force)
{
    if (expr.length === 0)
        return !force;

    if (reJSChar.test(expr[expr.length-1]) ||
            expr.slice(-1) === "." ||
            expr.slice(-2) === ".%")
    {
        // An expression at the end - we're fine.
    }
    else
    {
        var lastBr = expr.lastIndexOf("[");
        if (lastBr !== -1 && /^" *$/.test(expr.substr(lastBr+1)) &&
            origExpr.charAt(lastBr+1) !== "/")
        {
            // Array completions - we're fine.
        }
        else {
            return !force;
        }
    }

    // Check for 'function i'.
    var ind = expr.lastIndexOf(" ");
    if (isValidProperty(expr.substr(ind+1)) && isFunctionName(expr, ind+1))
        return true;

    // Check for '{prop: ..., i'.
    var bwp = bwFindMatchingParen(expr, expr.length);
    if (bwp !== -1 && expr.charAt(bwp) === "{" &&
            isObjectDecl(expr, bwp) && isCommaProp(expr, bwp+1))
    {
        return true;
    }

    // Check for 'var prop..., i'.
    var vind = expr.lastIndexOf("var ");
    if (bwp < vind && isCommaProp(expr, vind+4))
    {
        // Note: This doesn't strictly work, because it kills completions even
        // when we have started a new expression and used the comma operator
        // in it (ie. 'var a; a, i'). This happens very seldom though, so it's
        // not really a problem.
        return true;
    }

    // Check for 'function f(i'.
    while (bwp !== -1 && expr.charAt(bwp) !== "(")
    {
        bwp = bwFindMatchingParen(expr, bwp);
    }
    if (bwp !== -1)
    {
        var ind = prevNonWs(expr, bwp);
        if (ind !== -1 && reJSChar.test(expr.charAt(ind)))
        {
            var stw = prevWord(expr, ind);
            if (expr.substring(stw, ind+1) === "function")
                return true;
            if (isFunctionName(expr, stw))
                return true;
        }
    }
    return false;
}

// Types the autocompletion knows about, some of their non-enumerable properties,
// and the return types of some member functions.

var AutoCompletionKnownTypes = {
    "void": {
        "_fb_ignorePrototype": true
    },
    "Array": {
        "pop": "|void",
        "push": "|void",
        "shift": "|void",
        "unshift": "|void",
        "reverse": "|Array",
        "sort": "|Array",
        "splice": "|Array",
        "concat": "|Array",
        "slice": "|Array",
        "join": "|String",
        "indexOf": "|Number",
        "lastIndexOf": "|Number",
        "filter": "|Array",
        "map": "|Array",
        "reduce": "|void",
        "reduceRight": "|void",
        "every": "|void",
        "forEach": "|void",
        "some": "|void",
        "length": "Number"
    },
    "String": {
        "_fb_contType": "String",
        "split": "|Array",
        "substr": "|String",
        "substring": "|String",
        "charAt": "|String",
        "charCodeAt": "|String",
        "concat": "|String",
        "indexOf": "|Number",
        "lastIndexOf": "|Number",
        "localeCompare": "|Number",
        "match": "|Array",
        "search": "|Number",
        "slice": "|String",
        "replace": "|String",
        "toLowerCase": "|String",
        "toLocaleLowerCase": "|String",
        "toUpperCase": "|String",
        "toLocaleUpperCase": "|String",
        "trim": "|String",
        "length": "Number"
    },
    "RegExp": {
        "test": "|void",
        "exec": "|Array",
        "lastIndex": "Number",
        "ignoreCase": "void",
        "global": "void",
        "multiline": "void",
        "source": "String"
    },
    "Date": {
        "getTime": "|Number",
        "getYear": "|Number",
        "getFullYear": "|Number",
        "getMonth": "|Number",
        "getDate": "|Number",
        "getDay": "|Number",
        "getHours": "|Number",
        "getMinutes": "|Number",
        "getSeconds": "|Number",
        "getMilliseconds": "|Number",
        "getUTCFullYear": "|Number",
        "getUTCMonth": "|Number",
        "getUTCDate": "|Number",
        "getUTCDay": "|Number",
        "getUTCHours": "|Number",
        "getUTCMinutes": "|Number",
        "getUTCSeconds": "|Number",
        "getUTCMilliseconds": "|Number",
        "setTime": "|void",
        "setYear": "|void",
        "setFullYear": "|void",
        "setMonth": "|void",
        "setDate": "|void",
        "setHours": "|void",
        "setMinutes": "|void",
        "setSeconds": "|void",
        "setMilliseconds": "|void",
        "setUTCFullYear": "|void",
        "setUTCMonth": "|void",
        "setUTCDate": "|void",
        "setUTCHours": "|void",
        "setUTCMinutes": "|void",
        "setUTCSeconds": "|void",
        "setUTCMilliseconds": "|void",
        "toUTCString": "|String",
        "toLocaleDateString": "|String",
        "toLocaleTimeString": "|String",
        "toLocaleFormat": "|String",
        "toDateString": "|String",
        "toTimeString": "|String",
        "toISOString": "|String",
        "toGMTString": "|String",
        "toJSON": "|String",
        "toString": "|String",
        "toLocaleString": "|String",
        "getTimezoneOffset": "|Number"
    },
    "Function": {
        "call": "|void",
        "apply": "|void",
        "length": "Number",
        "prototype": "void"
    },
    "HTMLElement": {
        "getElementsByClassName": "|NodeList",
        "getElementsByTagName": "|NodeList",
        "getElementsByTagNameNS": "|NodeList",
        "querySelector": "|HTMLElement",
        "querySelectorAll": "|NodeList",
        "firstChild": "HTMLElement",
        "lastChild": "HTMLElement",
        "firstElementChild": "HTMLElement",
        "lastElementChild": "HTMLElement",
        "parentNode": "HTMLElement",
        "previousSibling": "HTMLElement",
        "nextSibling": "HTMLElement",
        "previousElementSibling": "HTMLElement",
        "nextElementSibling": "HTMLElement",
        "children": "NodeList",
        "childNodes": "NodeList"
    },
    "NodeList": {
        "_fb_contType": "HTMLElement",
        "length": "Number",
        "item": "|HTMLElement",
        "namedItem": "|HTMLElement"
    },
    "Window": {
        "encodeURI": "|String",
        "encodeURIComponent": "|String",
        "decodeURI": "|String",
        "decodeURIComponent": "|String",
        "eval": "|void",
        "parseInt": "|Number",
        "parseFloat": "|Number",
        "isNaN": "|void",
        "isFinite": "|void",
        "NaN": "Number",
        "Math": "Math",
        "undefined": "void",
        "Infinity": "Number"
    },
    "HTMLDocument": {
        "querySelector": "|HTMLElement",
        "querySelectorAll": "|NodeList"
    },
    "Math": {
        "E": "Number",
        "LN2": "Number",
        "LN10": "Number",
        "LOG2E": "Number",
        "LOG10E": "Number",
        "PI": "Number",
        "SQRT1_2": "Number",
        "SQRT2": "Number",
        "abs": "|Number",
        "acos": "|Number",
        "asin": "|Number",
        "atan": "|Number",
        "atan2": "|Number",
        "ceil": "|Number",
        "cos": "|Number",
        "exp": "|Number",
        "floor": "|Number",
        "log": "|Number",
        "max": "|Number",
        "min": "|Number",
        "pow": "|Number",
        "random": "|Number",
        "round": "|Number",
        "sin": "|Number",
        "sqrt": "|Number",
        "tan": "|Number"
    },
    "Number": {
        "valueOf": "|Number",
        "toFixed": "|String",
        "toExponential": "|String",
        "toPrecision": "|String",
        "toLocaleString": "|String",
        "toString": "|String"
    }
};

var LinkType = {
    "PROPERTY": 0,
    "SCOPED_VARS": 1,
    "INDEX": 2,
    "CALL": 3,
    "RETVAL_HEURISTIC": 4
};

function getKnownType(t)
{
    var known = AutoCompletionKnownTypes;
    if (known.hasOwnProperty(t))
        return known[t];
    return null;
}

function getKnownTypeInfo(r)
{
    if (r.charAt(0) === "|")
        return {"val": "Function", "ret": r.substr(1)};
    return {"val": r};
}

function getFakeCompleteKeys(name)
{
    var ret = [], type = getKnownType(name);
    if (!type)
        return ret;
    for (var prop in type) {
        if (prop.substr(0, 4) !== "_fb_")
            ret.push(prop);
    }
    return ret;
}

function eatProp(expr, start)
{
    for (var i = start; i < expr.length; ++i)
        if (!reJSChar.test(expr.charAt(i)))
            break;
    return i;
}

function matchingBracket(expr, start)
{
    var count = 1;
    for (var i = start + 1; i < expr.length; ++i) {
        var ch = expr.charAt(i);
        if (reOpenBracket.test(ch))
            ++count;
        else if (reCloseBracket.test(ch))
            if (!--count)
                return i;
    }
    return -1;
}

function getTypeExtractionExpression(command)
{
    // Return a JavaScript expression for determining the type / [[Class]] of
    // an object given by another JavaScript expression. For DOM nodes, return
    // HTMLElement instead of HTML[node type]Element, for simplicity.
    var ret = "(function() { var v = " + command + "; ";
    ret += "if (window.HTMLElement && v instanceof HTMLElement) return 'HTMLElement'; ";
    ret += "return Object.prototype.toString.call(v).slice(8, -1);})()";
    return ret;
}

/**
 * Compare two property names a and b with a custom sort order. The comparison
 * is lexicographical, but treats _ as higher than other letters in the
 * beginning of the word, so that:
 *  $ < AutoCompleter < add_widget < additive < _ < _priv < __proto__
 * @return -1, 0 or 1 depending on whether (a < b), (a == b) or (a > b).
 */
function comparePropertyNames(lhs, rhs)
{
    var len = Math.min(lhs.length, rhs.length);
    for (var i = 0; i < len; ++i)
    {
        var u1 = (lhs.charAt(i) === "_");
        var u2 = (rhs.charAt(i) === "_");
        if (!u1 && !u2)
            break;
        if (!u1 || !u2)
            return (u1 ? 1 : -1);
    }

    if (lhs < rhs)
        return -1;
    return (lhs === rhs ? 0 : 1);
}

// See autoCompleteEval. This reorders a sorted array to look as if it had been
// sorted by comparePropertyNames.
function reorderPropertyNames(ar)
{
    var buckets = [];
    for (var i = 0; i < ar.length; ++i)
    {
        var s = ar[i];
        if (s.charAt(0) === "_")
        {
            var count = 0, j = 0;
            while (count < s.length && s.charAt(count) === "_")
                ++count;
            --count;
            if (!buckets[count])
                buckets[count] = [];
            buckets[count].push(s);
        }
    }

    if (!buckets.length)
        return ar;

    var res = [];
    for (var i = 0; i < ar.length; ++i)
    {
        if (ar[i].charAt(0) !== "_")
            res.push(ar[i]);
    }
    for (var i = 0; i < buckets.length; ++i)
    {
        var ar2 = buckets[i];
        if (ar2)
            res.push.apply(res, ar2);
    }
    return res;
}

function propertiesToHide(expr, obj)
{
    var ret = [];

    // __{define,lookup}[SG]etter__ appear as own properties on lots of DOM objects.
    ret.push("__defineGetter__", "__defineSetter__",
        "__lookupGetter__", "__lookupSetter__");

    // function.caller/arguments are deprecated and ugly, and don't hold values when
    // evaluated from the command line.
    if (typeof obj === "function")
        ret.push("caller", "arguments");

    if (Object.prototype.toString.call(obj) === "[object String]")
    {
        // Unused, cluttery.
        ret.push("quote", "bold", "italics", "fixed", "fontsize", "fontcolor",
            "link", "anchor", "strike", "small", "big", "blink", "sup", "sub");
    }

    if (expr === "" || expr === "window.")
    {
        // Internal Firefox things.
        ret.push("getInterface", "Components", "XPCNativeWrapper",
            "InstallTrigger", "WindowInternal", "DocumentXBL",
            "startProfiling", "stopProfiling", "pauseProfilers",
            "resumeProfilers", "dumpProfile", "netscape",
            "BoxObject", "BarProp", "BrowserFeedWriter", "ChromeWindow",
            "ElementCSSInlineStyle", "JSWindow", "NSEditableElement",
            "NSRGBAColor", "NSEvent", "NSXPathExpression", "ToString",
            "OpenWindowEventDetail", "Parser", "ParserJS", "Rect",
            "RGBColor", "ROCSSPrimitiveValue", "RequestService",
            "PaintRequest", "PaintRequestList", "WindowUtils",
            "GlobalPropertyInitializer", "GlobalObjectConstructor"
        );

        // Hide ourselves.
        ret.push("_firebug", "__fb_scopedVars");
    }

    // Old and ugly.
    if (expr === "document.")
        ret.push("fgColor", "vlinkColor", "linkColor");
    if (expr === "document.body.")
        ret.push("link", "aLink", "vLink");

    // Rather universal and feel like built-ins.
    ret.push("constructor", "QueryInterface");

    return ret;
}

function setCompletionsFromObject(out, object, context)
{
    // 'object' is a user-level, non-null object.
    try
    {
        var isObjectPrototype = function(obj)
        {
            // Check if an object is "Object.prototype". This isn't as simple
            // as 'obj === context.window.wrappedJSObject.Object.prototype' due
            // to cross-window properties, nor just '!Object.getPrototypeOf(obj)'
            // because of Object.create.
            return !Object.getPrototypeOf(obj) && "hasOwnProperty" in obj;
        };

        var obj = object;
        while (obj !== null)
        {
            var target = (isObjectPrototype(obj) ?
                    out.hiddenCompletions : out.completions);
            if (Array.isArray(obj) && obj.length > 4000)
            {
                // The object is a large array. To avoid RangeErrors from
                // `target.push.apply` and a slow `Object.getOwnPropertyNames`,
                // we just skip this level ("length" is also on the prototype,
                // and numeric property would get hidden later anyway).
            }
            else
            {
                target.push.apply(target, Object.getOwnPropertyNames(obj));
            }
            obj = Object.getPrototypeOf(obj);
        }

        // As a special case, when completing "Object.prototype." no properties
        // should be hidden.
        if (isObjectPrototype(object))
        {
            out.completions = out.hiddenCompletions;
            out.hiddenCompletions = [];
        }
        else
        {
            // Hide a list of well-chosen annoying properties.
            var hide = propertiesToHide(out.spreExpr, object);
            var hideMap = Object.create(null);
            for (var i = 0; i < hide.length; ++i)
                hideMap[hide[i]] = 1;
            var hideRegex = /^XUL[A-Za-z]+$/;

            var newCompletions = [];
            out.completions.forEach(function(prop)
            {
                if (prop in hideMap || hideRegex.test(prop))
                    out.hiddenCompletions.push(prop);
                else
                    newCompletions.push(prop);
            });
            out.completions = newCompletions;
        }

        // Firefox hides __proto__ - add it back.
        if ("__proto__" in object)
            out.hiddenCompletions.push("__proto__");
    }
    catch (exc)
    {
        if (FBTrace.DBG_COMMANDLINE)
            FBTrace.sysout("autoCompleter.setCompletionsFromObject failed", exc);
    }
}

function setCompletionsFromScope(out, object, context)
{
    out.completions = ClosureInspector.getClosureVariablesList(object, context);

    // Hide "arguments"; it almost never holds a value.
    out.completions = Arr.unique(out.completions);
    var ind = out.completions.indexOf("arguments");
    if (ind !== -1)
    {
        out.completions.splice(ind, 1);
        out.hiddenCompletions.push("arguments");
    }
}

function getNewlyDeclaredNames(js)
{
    // XXXsimon: In the future, machinery from issue 5291 could perhaps replace this.
    var re = /\b[a-zA-Z_$][a-zA-Z0-9_$]*\b/g;
    var ar = [], match;
    while ((match = re.exec(js)) !== null)
    {
        if (!/[.%]/.test(js.charAt(match.index - 1)) &&
            js.charAt(re.lastIndex) !== ":" && kwAll.indexOf(match[0]) === -1)
        {
            ar.push(match[0]);
        }
    }
    return ar;
}

function propChainBuildComplete(out, context, tempExpr, result)
{
    if (out.scopeCompletion)
    {
        if (tempExpr.fake)
            return;
        if (typeof result !== "object" && typeof result !== "function")
            return;
        setCompletionsFromScope(out, result, context);
        return;
    }

    var done = function(result)
    {
        if (result == null)
            return;

        if (typeof result !== "object" && typeof result !== "function")
        {
            // To avoid slow completions, convert strings to length 0 (numeric
            // properties are hidden anyway).
            if (typeof result === "string")
                result = "";

            // Convert the primitive into its scope's matching object type.
            result = Wrapper.getContentView(out.window).Object(result);
        }
        setCompletionsFromObject(out, result, context);
    };

    if (tempExpr.fake)
    {
        var name = tempExpr.value.val;
        if (getKnownType(name)._fb_ignorePrototype)
            return;
        var command = name + ".prototype";
        Firebug.CommandLine.evaluate(name + ".prototype", context, context.thisValue, null,
            function found(result, context)
            {
                done(result);
            },
            function failed(result, context) {},
            {noStateChange: true}
        );
    }
    else
    {
        done(result);
    }
}

function evalPropChainStep(step, tempExpr, evalChain, out, context)
{
    if (tempExpr.fake)
    {
        if (step === evalChain.length)
        {
            propChainBuildComplete(out, context, tempExpr);
            return;
        }

        var link = evalChain[step], type = link.type;
        if (type === LinkType.PROPERTY || type === LinkType.INDEX)
        {
            // Use the accessed property if it exists, otherwise abort. It
            // would be possible to continue with a 'real' expression of
            // `tempExpr.value.val`.prototype, but since prototypes seldom
            // contain actual values of things this doesn't work very well.
            var mem = (type === LinkType.INDEX ? "_fb_contType" : link.name);
            var t = getKnownType(tempExpr.value.val);
            if (t.hasOwnProperty(mem))
                tempExpr.value = getKnownTypeInfo(t[mem]);
            else
                return;
        }
        else if (type === LinkType.CALL)
        {
            if (tempExpr.value.ret)
                tempExpr.value = getKnownTypeInfo(tempExpr.value.ret);
            else
                return;
        }
        else
        {
            return;
        }
        evalPropChainStep(step+1, tempExpr, evalChain, out, context);
    }
    else
    {
        var funcCommand = null, link, type;
        while (step !== evalChain.length)
        {
            link = evalChain[step];
            type = link.type;
            if (type === LinkType.PROPERTY)
            {
                tempExpr.thisCommand = tempExpr.command;
                tempExpr.command += "." + link.name;
            }
            else if (type === LinkType.SCOPED_VARS)
            {
                tempExpr.thisCommand = "window";
                tempExpr.command += ".%" + link.name;
            }
            else if (type === LinkType.INDEX)
            {
                tempExpr.thisCommand = "window";
                tempExpr.command += "[" + link.cont + "]";
            }
            else if (type === LinkType.CALL)
            {
                if (link.origCont !== null &&
                     (link.name.substr(0, 3) === "get" ||
                      (link.name.charAt(0) === "$" && link.cont.indexOf(",") === -1)))
                {
                    // Names beginning with get or $ are almost always getters, so
                    // assume we can safely just call it.
                    tempExpr.thisCommand = "window";
                    tempExpr.command += "(" + link.origCont + ")";
                }
                else if (!link.name)
                {
                    // We cannot know about functions without name; try the
                    // heuristic directly.
                    link.type = LinkType.RETVAL_HEURISTIC;
                    evalPropChainStep(step, tempExpr, evalChain, out, context);
                    return;
                }
                else
                {
                    funcCommand = getTypeExtractionExpression(tempExpr.thisCommand);
                    break;
                }
            }
            else if (type === LinkType.RETVAL_HEURISTIC)
            {
                funcCommand = "Function.prototype.toString.call(" + tempExpr.command + ")";
                break;
            }
            ++step;
        }

        var isFunc = (funcCommand !== null), command = (isFunc ? funcCommand : tempExpr.command);
        Firebug.CommandLine.evaluate(command, context, context.thisValue, null,
            function found(result, context)
            {
                if (isFunc)
                {
                    if (type === LinkType.CALL)
                    {
                        if (typeof result !== "string")
                            return;

                        var t = getKnownType(result);
                        if (t && t.hasOwnProperty(link.name))
                        {
                            var propVal = getKnownTypeInfo(t[link.name]);

                            // Make sure the property is a callable function
                            if (!propVal.ret)
                                return;

                            tempExpr.fake = true;
                            tempExpr.value = getKnownTypeInfo(propVal.ret);
                            evalPropChainStep(step+1, tempExpr, evalChain, out, context);
                        }
                        else
                        {
                            // Unknown 'this' type or function name, use
                            // heuristics on the function instead.
                            link.type = LinkType.RETVAL_HEURISTIC;
                            evalPropChainStep(step, tempExpr, evalChain, out, context);
                        }
                    }
                    else if (type === LinkType.RETVAL_HEURISTIC)
                    {
                        if (typeof result !== "string")
                            return;

                        // Perform some crude heuristics for figuring out the
                        // return value of a function based on its contents.
                        // It's certainly not perfect, and it's easily fooled
                        // into giving wrong results,  but it might work in
                        // some common cases.

                        // Check for chaining functions. This is done before
                        // checking for nested functions, because completing
                        // results of member functions containing nested
                        // functions that use 'return this' seems uncommon,
                        // and being wrong is not a huge problem.
                        if (result.indexOf("return this;") !== -1)
                        {
                            tempExpr.command = tempExpr.thisCommand;
                            tempExpr.thisCommand = "window";
                            evalPropChainStep(step+1, tempExpr, evalChain, out, context);
                            return;
                        }

                        // Don't support nested functions.
                        if (result.lastIndexOf("function") !== 0)
                            return;

                        // Check for arrays.
                        if (result.indexOf("return [") !== -1)
                        {
                            tempExpr.fake = true;
                            tempExpr.value = getKnownTypeInfo("Array");
                            evalPropChainStep(step+1, tempExpr, evalChain, out, context);
                            return;
                        }

                        // Check for 'return new Type(...);', and use the
                        // prototype as a pseudo-object for those (since it
                        // is probably not a known type that we can fake).
                        var newPos = result.indexOf("return new ");
                        if (newPos !== -1)
                        {
                            var rest = result.substr(newPos + 11),
                                epos = rest.search(/[^a-zA-Z0-9_$.]/);
                            if (epos !== -1 && /[; \t\n(}]/.test(rest.charAt(epos)))
                            {
                                rest = rest.substring(0, epos);
                                var func = tempExpr.command, expr = rest + ".prototype";
                                tempExpr.command = "(function() { " +
                                    "try { return " + func + ".%" + expr + "; } " +
                                    "catch(e) { return " + expr + "; } " +
                                "})()";
                                evalPropChainStep(step+1, tempExpr, evalChain, out, context);
                                return;
                            }
                        }
                    }
                }
                else
                {
                    propChainBuildComplete(out, context, tempExpr, result);
                }
            },
            function failed(result, context) {},
            {noStateChange: true}
        );
    }
}

function evalPropChain(out, preExpr, origExpr, context)
{
    var evalChain = [], linkStart = 0, len = preExpr.length, lastProp = "";
    var tempExpr = {"fake": false, "command": "window", "thisCommand": "window"};
    while (linkStart !== len)
    {
        var ch = preExpr.charAt(linkStart);
        if (linkStart === 0)
        {
            if (preExpr.substr(0, 4) === "new ")
            {
                var parInd = preExpr.indexOf("(");
                tempExpr.command = preExpr.substring(4, parInd) + ".prototype";
                linkStart = matchingBracket(preExpr, parInd) + 1;
            }
            else if (ch === "[")
            {
                tempExpr.fake = true;
                tempExpr.value = getKnownTypeInfo("Array");
                linkStart = matchingBracket(preExpr, linkStart) + 1;
            }
            else if (ch === '"')
            {
                var isRegex = (origExpr.charAt(0) === "/");
                tempExpr.fake = true;
                tempExpr.value = getKnownTypeInfo(isRegex ? "RegExp" : "String");
                linkStart = preExpr.indexOf('"', 1) + 1;
            }
            else if (!isNaN(ch))
            {
                // The expression is really a decimal number.
                return false;
            }
            else if (reJSChar.test(ch))
            {
                // The expression begins with a regular property name
                var nextLink = eatProp(preExpr, linkStart);
                lastProp = preExpr.substring(linkStart, nextLink);
                linkStart = nextLink;
                tempExpr.command = lastProp;
            }

            // Syntax error (like '.') or a too complicated expression.
            if (linkStart === 0)
                return false;
        }
        else
        {
            if (ch === ".")
            {
                // Property access
                var scope = (preExpr.charAt(linkStart+1) === "%");
                linkStart += (scope ? 2 : 1);
                var nextLink = eatProp(preExpr, linkStart);
                lastProp = preExpr.substring(linkStart, nextLink);
                linkStart = nextLink;
                evalChain.push({
                    "type": (scope ? LinkType.SCOPED_VARS : LinkType.PROPERTY),
                    "name": lastProp
                });
            }
            else if (ch === "(")
            {
                // Function call. Save the function name and the arguments if
                // they are safe to evaluate. Currently literals and single
                // variables not occurring previously on the command line are
                // treated as safe.
                var endCont = matchingBracket(preExpr, linkStart);
                var cont = preExpr.substring(linkStart+1, endCont), origCont = null;
                if (reLiteralExpr.test(cont) || (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(cont) &&
                    preExpr.lastIndexOf(cont, linkStart) === -1))
                {
                    origCont = origExpr.substring(linkStart+1, endCont);
                }
                linkStart = endCont + 1;
                evalChain.push({
                    "type": LinkType.CALL,
                    "name": lastProp,
                    "origCont": origCont,
                    "cont": cont
                });

                lastProp = "";
            }
            else if (ch === "[")
            {
                // Index. Use the supplied index if it is a literal; otherwise
                // it is probably a loop index with a variable not yet defined
                // (like 'for(var i = 0; i < ar.length; ++i) ar[i].prop'), and
                // '0' seems like a reasonably good guess at a valid index.
                var endInd = matchingBracket(preExpr, linkStart);
                var ind = preExpr.substring(linkStart+1, endInd);
                if (reLiteralExpr.test(ind))
                    ind = origExpr.substring(linkStart+1, endInd);
                else
                    ind = "0";
                linkStart = endInd+1;
                evalChain.push({"type": LinkType.INDEX, "cont": ind});
                lastProp = "";
            }
            else
            {
                // Syntax error
                return false;
            }
        }
    }

    evalPropChainStep(0, tempExpr, evalChain, out, context);
    return true;
}


var CompletionType = {
    "NORMAL": 0,
    "API": 1
};

function autoCompleteEval(context, preExpr, spreExpr, preParsed, spreParsed, options)
{
    var out = {
        spreExpr: spreExpr,
        completions: [],
        hiddenCompletions: [],
        window: context.getCurrentGlobal()
    };
    var indexCompletion = false;

    try
    {
        if (spreExpr)
        {
            // Complete member variables of some .-chained expression

            // In case of array indexing, remove the bracket and set a flag to
            // escape completions.
            out.scopeCompletion = false;
            var len = spreExpr.length;
            if (len >= 2 && spreExpr[len-2] === "[" && spreExpr[len-1] === '"')
            {
                indexCompletion = true;
                out.indexQuoteType = preExpr[len-1];
                len -= 2;
            }
            else if (spreExpr.slice(-2) === ".%")
            {
                out.scopeCompletion = true;
                len -= 2;
            }
            else
            {
                len -= 1;
            }
            spreExpr = spreExpr.substr(0, len);
            preExpr = preExpr.substr(0, len);

            if (FBTrace.DBG_COMMANDLINE)
                FBTrace.sysout("commandLine.autoCompleteEval pre:'" + preExpr +
                    "' spre:'" + spreExpr + "'.");

            // Don't auto-complete '.'.
            if (spreExpr === "")
                return out;

            evalPropChain(out, spreExpr, preExpr, context);
        }
        else
        {
            // Complete variables from the local scope

            var contentView = Wrapper.getContentView(out.window);
            if (context.stopped && options.includeCurrentScope)
            {
                out.completions = Firebug.Debugger.getCurrentFrameKeys(context);
            }
            else if (contentView && contentView.Window &&
                contentView.constructor.toString() === contentView.Window.toString())
                // Cross window type pseudo-comparison
            {
                setCompletionsFromObject(out, contentView, context);
            }
            else  // hopefully sandbox in Chromebug
            {
                setCompletionsFromObject(out, context.global, context);
            }
        }

        if (options.additionalCompletions)
            out.completions.push.apply(out.completions, options.additionalCompletions);

        if (indexCompletion)
        {
            // If we are doing index-completions, add "] to everything.
            var convertQuotes = function(x)
            {
                x = (out.indexQuoteType === '"') ? Str.escapeJS(x): Str.escapeSingleQuoteJS(x);
                return x + out.indexQuoteType + "]";
            }

            out.completions = out.completions.map(convertQuotes);
            out.hiddenCompletions = out.hiddenCompletions.map(convertQuotes);
        }
        else if (out.completions.indexOf("length") !== -1 && out.completions.indexOf("0") !== -1)
        {
            // ... otherwise remove numeric keys from array-like things.
            var rePositiveNumber = /^[1-9][0-9]*$/;
            out.completions = out.completions.filter(function(x)
            {
                return !rePositiveNumber.test(x) && x !== "0";
            });
        }

        // Sort the completions, and avoid duplicates.
        // Note: If we make it possible to show both regular and hidden completions
        // at the same time, completions should shadow hiddenCompletions here.
        // XXX Normally we'd just do sortUnique(completions, comparePropertyNames),
        // but JSD makes that slow (issue 6256). Sort and do manual reordering instead.
        out.completions = reorderPropertyNames(Arr.sortUnique(out.completions));
        out.hiddenCompletions = reorderPropertyNames(Arr.sortUnique(out.hiddenCompletions));

        var wrap = function(x)
        {
            return {type: CompletionType.NORMAL, name: x};
        };
        out.completions = out.completions.map(wrap);
        out.hiddenCompletions = out.hiddenCompletions.map(wrap);

        // Add things from the Command Line API, if we are signalled to,
        // and it is not unavailable due to being stopped in the debugger
        // (issue 5321).
        if (!spreExpr && options.includeCommandLineAPI && !context.stopped)
        {
            var global = Wrapper.unwrapObject(out.window);
            CommandLineExposed.getAutoCompletionList().forEach(function(name)
            {
                if (!(name in global))
                    out.completions.push({type: CompletionType.API, name: name});
            });
        }

    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS && FBTrace.DBG_COMMANDLINE)
            FBTrace.sysout("commandLine.autoCompleteEval FAILED", exc);
    }
    return out;
}

var reValidJSToken = /^[A-Za-z_$][A-Za-z_$0-9]*$/;
function isValidProperty(value)
{
    // Use only string props
    if (typeof(value) != "string")
        return false;

    // Use only those props that don't contain unsafe charactes and so need
    // quotation (e.g. object["my prop"] notice the space character).
    // Following expression checks that the name starts with a letter or $_,
    // and there are only letters, numbers or $_ character in the string (no spaces).

    return reValidJSToken.test(value);
}

function setCursorToEOL(input)
{
    // textbox version, https://developer.mozilla.org/en/XUL/Property/inputField
    // input.inputField.setSelectionRange(len, len);
    input.setSelectionRange(input.value.length, input.value.length);
}

// ********************************************************************************************* //
// Registration

Firebug.JSAutoCompleter = JSAutoCompleter;

return JSAutoCompleter;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*global define:1, Components:1, Proxy:1 */

// A note on terminology: here a "closure"/"environment" is generally thought
// of as a container of "scopes".

define("firebug/console/closureInspector",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/wrapper",
    "firebug/debugger/debuggerLib",
],
function(Firebug, FBTrace, Wrapper, DebuggerLib) {
"use strict";

// ********************************************************************************************* //
// Constants

var Cu = Components.utils;

var Trace = FBTrace.to("DBG_COMMANDLINE");

var ScopeProxy = function() {};
var OptimizedAway = Object.create(null);
Object.freeze(OptimizedAway);

// ********************************************************************************************* //

var ClosureInspector =
{
    getVariableOrOptimizedAway: function(scope, name)
    {
        try
        {
            var ret = scope.getVariable(name);
            if (ret !== undefined)
                return ret;

            if (scope.type === "declarative")
            {
                // The variable is either optimized away or actually set to
                // undefined. Optimized-away ones are apparently not settable,
                // so try to detect them by that (it seems rather safe).
                scope.setVariable(name, 0);
                if (scope.getVariable(name) === undefined)
                    return OptimizedAway;
                scope.setVariable(name, undefined);
            }

            return undefined;
        }
        catch (exc)
        {
            // E.g. optimized-away "arguments" can throw "Debugger scope is not live".
            Trace.sysout("ClosureInspector; getVariableOrOptimizedAway caught " +
                "an exception (name = " + name + ")", exc);
            return OptimizedAway;
        }
    },

    isOptimizedAway: function(obj)
    {
        return obj === OptimizedAway;
    },

    isSimple: function(dbgObj)
    {
        return (typeof dbgObj !== "object" || dbgObj === OptimizedAway);
    },

    isScopeInteresting: function(scope)
    {
        return !!scope.parent;
    },

    getFunctionFromObject: function(dbgObj)
    {
        var first = true;
        while (dbgObj)
        {
            var names = dbgObj.getOwnPropertyNames(), pd;

            // "constructor" is boring, use it last
            var ind = names.indexOf("constructor");
            if (ind !== -1)
            {
                names.splice(ind, 1);
                names.push("constructor");
            }

            for (var i = 0; i < names.length; ++i)
            {
                // We assume that the first own property, or the first
                // enumerable property of the prototype (or "constructor"),
                // that is a function with some scope (i.e., it is interpreted,
                // JSScript-backed, and without optimized-away scope) shares
                // this scope with 'dbgObj'.
                // (Since, in the current implementation, Firefox seems to give
                // all functions in a particular scope (except self-contained
                // ones) the same environment, the first is as good as any,
                // and it's probably near the definition of 'dbgObj').

                var name = names[i];
                try
                {
                    pd = dbgObj.getOwnPropertyDescriptor(name);
                }
                catch (e)
                {
                    // getOwnPropertyDescriptor sometimes fails with
                    // "Illegal operation on WrappedNative prototype object",
                    // for instance on [window].proto.gopd("localStorage").
                    continue;
                }
                if (!pd || (!first && !pd.enumerable && name !== "constructor"))
                    continue;

                var toTest = [pd.get, pd.set, pd.value];
                for (var j = 0; j < toTest.length; ++j)
                {
                    var f = toTest[j];
                    if (f && f.environment && this.isScopeInteresting(f.environment))
                        return f;
                }
            }

            if (!first)
                break;
            first = false;
            dbgObj = dbgObj.proto;
        }

        // None found. :(
        return undefined;
    },

    // Within the security context of the (wrapped) window 'win', find a relevant
    // closure for the content object 'obj' (may be from another frame), and, while
    // the debugger is still active, pass it to the specified callback.
    // Throws exceptions on error.
    withEnvironmentForObject: function(win, obj, context, callback)
    {
        if (!obj || !(typeof obj === "object" || typeof obj === "function"))
            throw new TypeError("can't get scope of non-object");

        var objGlobal = Cu.getGlobalForObject(obj);
        if (win !== objGlobal && !(win.document && objGlobal.document &&
            win.document.nodePrincipal.subsumes(objGlobal.document.nodePrincipal)))
        {
            throw new Error("permission denied to access cross origin scope");
        }

        return DebuggerLib.withTemporaryDebugger(context, objGlobal, function(dbgGlobal)
        {
            // Create a view of the object as seen from its own global - 'environment'
            // will not be accessible otherwise.

            var dbgObj = dbgGlobal.makeDebuggeeValue(obj);

            if (obj && typeof obj === "object")
                dbgObj = this.getFunctionFromObject(dbgObj);

            if (!dbgObj || !dbgObj.environment || !this.isScopeInteresting(dbgObj.environment))
                throw new Error("missing closure");

            return callback(dbgObj.environment, dbgGlobal);
        }.bind(this));
    },

    getClosureVariablesList: function(obj, context)
    {
        var ret = [];

        // Avoid 'window' and 'document' getting associated with closures.
        var win = context.getCurrentGlobal();
        if (obj === win || obj === win.document)
            return ret;

        try
        {
            this.withEnvironmentForObject(win, obj, context, function(env)
            {
                for (var scope = env; scope; scope = scope.parent)
                {
                    if (!this.isScopeInteresting(scope))
                        break;

                    // Probably the scope of the bindings for our (or Mozilla's) Command
                    // Line API, which is at the top of the scope chain on objects defined
                    // through the console. Hide it for a nicer display.
                    if (scope.type === "object" && !this.isScopeInteresting(scope.parent) &&
                        scope.getVariable("cd") && scope.getVariable("inspect"))
                    {
                        break;
                    }

                    ret.push.apply(ret, scope.names());
                }
            }.bind(this));
        }
        catch (exc)
        {
            Trace.sysout("ClosureInspector; getClosureVariablesList failed", exc);
        }
        return ret;
    },

    getClosureWrapper: function(obj, win, context)
    {
        // Return a wrapper for its scoped variables.
        var self = this;
        var handler = {};
        handler.getOwnPropertyDescriptor = function(name)
        {
            if (name === "__exposedProps__")
            {
                // Expose mostly everything, rw, through another proxy.
                return {
                    value: Proxy.create({
                        getPropertyDescriptor: function(name)
                        {
                            if (name === "__exposedProps__" || name === "__proto__")
                                return;
                            return {value: "rw", enumerable: true};
                        }
                    })
                };
            }

            return {
                get: function()
                {
                    return self.withEnvironmentForObject(win, obj, context, function(env)
                    {
                        try
                        {
                            var scope = env.find(name);
                            if (!scope)
                                return undefined;
                            var dbgVal = self.getVariableOrOptimizedAway(scope, name);
                            if (self.isSimple(dbgVal))
                                return dbgVal;
                            return DebuggerLib.unwrapDebuggeeValue(dbgVal);
                        }
                        catch (exc)
                        {
                            Trace.sysout("ClosureInspector; failed to return value from getter", exc);
                            return undefined;
                        }
                    });
                },

                set: function(value)
                {
                    self.withEnvironmentForObject(win, obj, context, function(env, dbgGlobal)
                    {
                        var dbgValue = dbgGlobal.makeDebuggeeValue(value);
                        var scope = env.find(name);
                        if (!scope)
                            throw new Error("can't create new closure variable");
                        if (self.getVariableOrOptimizedAway(scope, name) === OptimizedAway)
                            throw new Error("can't set optimized-away closure variable");
                        scope.setVariable(name, dbgValue);
                    });
                }
            };
        };
        handler.getPropertyDescriptor = handler.getOwnPropertyDescriptor;
        handler.delete = function()
        {
            throw new Error("can't delete closure variable");
        };
        // Other traps are syntactically inaccessible, so we don't need to implement them.
        return Proxy.create(handler);
    },

    getScopeWrapper: function(obj, win, context, isScope)
    {
        var makeWrapper = function(scope, dbgGlobal)
        {
            if (!scope || !this.isScopeInteresting(scope))
                return;

            var names = scope.names();

            // Due to bug 822566, we sometimes have to skip over duplicate
            // scopes (see issue 61840).
            if (names.length === 1 && scope.type === "declarative" &&
                scope.parent && scope.parent.type === "declarative")
            {
                var par = scope.parent, parNames = par.names();
                if (parNames.length === 1 && parNames[0] === names[0])
                    scope = par;
            }

            // "arguments" is almost always present and optimized away, so hide it
            // for a nicer display.
            var ind = names.indexOf("arguments");
            if (ind !== -1 && this.getVariableOrOptimizedAway(scope, "arguments") === OptimizedAway)
                names.splice(ind, 1);

            var global = Wrapper.wrapObject(DebuggerLib.unwrapDebuggeeValue(dbgGlobal));
            var scopeDataHolder = Object.create(ScopeProxy.prototype);
            scopeDataHolder.scope = scope;
            scopeDataHolder.scopeType = scope.type;
            scopeDataHolder.global = global;

            var self = this;
            var clone = Object.create(scopeDataHolder);
            names.forEach(function(name)
            {
                var dbgVal = self.getVariableOrOptimizedAway(scope, name);
                Object.defineProperty(clone, name, {
                    get: function() {
                        if (self.isSimple(dbgVal))
                            return dbgVal;
                        return DebuggerLib.unwrapDebuggeeValue(dbgVal);
                    },
                    set: (dbgVal === OptimizedAway ? undefined : function(value) {
                        DebuggerLib.withTemporaryDebugger(context, global, function()
                        {
                            dbgVal = dbgGlobal.makeDebuggeeValue(value);
                            scope.setVariable(name, dbgVal);
                        });
                    }),
                    enumerable: true,
                    configurable: false
                });
            });
            return clone;
        }.bind(this);

        try
        {
            if (isScope)
            {
                var scopeWrapper = Object.getPrototypeOf(obj);
                var scope = scopeWrapper.scope;
                var global = scopeWrapper.global;
                return DebuggerLib.withTemporaryDebugger(context, global, function(dbgGlobal)
                {
                    return makeWrapper(scope.parent, dbgGlobal);
                });
            }
            else
            {
                return this.withEnvironmentForObject(win, obj, context, makeWrapper);
            }
        }
        catch (exc)
        {
            Trace.sysout("ClosureInspector; getScopeWrapper failed", exc);
            return;
        }
    },

    isScopeWrapper: function(obj)
    {
        return obj instanceof ScopeProxy;
    },

    getScopeTypeFromWrapper: function(obj)
    {
        return Object.getPrototypeOf(obj).scopeType;
    },

    withExtendedLanguageSyntax: function(expr, win, context, callback)
    {
        // Temporary FireClosure compatibility.
        if (Firebug.JSAutoCompleter.transformScopeExpr)
            return callback(expr);

        // Note: this is also hard-coded elsewhere.
        var fname = "__fb_scopedVars";

        var newExpr = Firebug.JSAutoCompleter.transformScopeOperator(expr, fname);
        if (expr === newExpr)
            return callback(expr);

        if (Trace.active)
        {
            Trace.sysout("ClosureInspector; transforming expression: `" +
                    expr + "` -> `" + newExpr + "`");
        }

        // Stick the helper function for .%-expressions on the window object.
        // This really belongs on the command line object, but that doesn't
        // work when stopped in the debugger (issue 5321, which depends on
        // integrating JSD2) and we really need this to work there.
        // To avoid leaking capabilities into arbitrary web pages, this is
        // only injected when needed.
        try
        {
            var self = this;
            Object.defineProperty(Wrapper.getContentView(win), fname, {
                value: function(obj)
                {
                    return self.getClosureWrapper(obj, win, context);
                },
                writable: true,
                configurable: true
            });
        }
        catch (exc)
        {
            Trace.sysout("ClosureInspector; failed to inject " + fname, exc);
        }

        var gotDebugger = false;
        try
        {
            return DebuggerLib.withTemporaryDebugger(context, win, function()
            {
                gotDebugger = true;
                return callback(newExpr);
            });
        }
        catch (exc)
        {
            if (gotDebugger)
                throw exc;

            // Wasn't able to activate debugger. :(
            // Rerun the command without debugger, and let it fail in a friendlier way.
            return callback(newExpr);
        }
    }
};

Firebug.ClosureInspector = ClosureInspector;
return ClosureInspector;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/commandEditor",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/events",
    "firebug/chrome/menu",
    "firebug/lib/dom",
    "firebug/lib/locale",
    "firebug/lib/css",
    "firebug/lib/options",
    "firebug/lib/system",
],
function(Module, Obj, Firebug, Events, Menu, Dom, Locale, Css, Options, System) {

"use strict";

// ********************************************************************************************* //
// Constants

var Cu = Components.utils;

var MODE_JAVASCRIPT = "js";
var CONTEXT_MENU = "";
var TEXT_CHANGED = "";

// URL of source-editor.jsm changed in Firefox 27 (introduced in Firefox 8).
var sourceEditorScope = System.importModule([
    "resource:///modules/devtools/sourceeditor/source-editor.jsm",
    "resource:///modules/source-editor.jsm"]);

if (typeof(sourceEditorScope.SourceEditor) != "undefined")
{
    MODE_JAVASCRIPT = sourceEditorScope.SourceEditor.MODES.JAVASCRIPT;
    CONTEXT_MENU = sourceEditorScope.SourceEditor.EVENTS.CONTEXT_MENU;
    TEXT_CHANGED = sourceEditorScope.SourceEditor.EVENTS.TEXT_CHANGED;
}

// ********************************************************************************************* //
// Command Editor

Firebug.CommandEditor = Obj.extend(Module,
{
    dispatchName: "commandEditor",

    editor: null,

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        if (this.editor)
            return;

        // The current implementation of the SourceEditor (based on Orion) doesn't
        // support zooming. So, the TextEditor (based on textarea) can be used
        // by setting extensions.firebug.enableOrion pref to false.
        // See issue 5678
        if (typeof(sourceEditorScope.SourceEditor) != "undefined" && Options.get("enableOrion"))
            this.editor = new sourceEditorScope.SourceEditor();
        else
            this.editor = new TextEditor();

        var config =
        {
            mode: MODE_JAVASCRIPT,
            showLineNumbers: false,
            theme: "chrome://firebug/skin/orion-firebug.css"
        };

        // Custom shortcuts for Orion editor
        config.keys = [{
            action: "firebug-cmdEditor-execute",
            code: KeyEvent.DOM_VK_RETURN,
            accel: true,
            callback: this.onExecute.bind(this),
        },{
            action: "firebug-cmdEditor-escape",
            code: KeyEvent.DOM_VK_ESCAPE,
            callback: this.onEscape.bind(this),
        }];

        // Initialize Orion editor.
        this.parent = document.getElementById("fbCommandEditor");
        this.editor.init(this.parent, config, this.onEditorLoad.bind(this));

        if (FBTrace.DBG_COMMANDEDITOR)
            FBTrace.sysout("commandEditor: SourceEditor initialized");
    },

    shutdown: function()
    {
        if (!this.editor)
            return;

        this.editor.removeEventListener(CONTEXT_MENU, this.onContextMenu);
        this.editor.removeEventListener(TEXT_CHANGED, this.onTextChanged);

        this.editor.destroy();
        this.editor = null;
    },

    /**
     * The load event handler for the source editor. This method does post-load
     * editor initialization.
     */
    onEditorLoad: function()
    {
        // xxxHonza: Context menu support is going to change in SourceEditor
        this.editor.addEventListener(CONTEXT_MENU, this.onContextMenu);
        this.editor.addEventListener(TEXT_CHANGED, this.onTextChanged);

        this.editor.setCaretOffset(this.editor.getCharCount());

        Firebug.chrome.applyTextSize(Firebug.textSize);

        if (FBTrace.DBG_COMMANDEDITOR)
            FBTrace.sysout("commandEditor.onEditorLoad; SourceEditor loaded");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Keyboard shortcuts

    onExecute: function()
    {
        var context = Firebug.currentContext;
        Firebug.CommandLine.update(context);
        Firebug.CommandLine.enter(context);
        return true;
    },

    onEscape: function()
    {
        var context = Firebug.currentContext;
        Firebug.CommandLine.update(context);
        Firebug.CommandLine.cancel(context);
        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Other Events

    onTextChanged: function(event)
    {
        // Ignore changes that are triggered by Firebug's restore logic.
        if (Firebug.CommandEditor.ignoreChanges)
            return;

        var context = Firebug.currentContext;
        Firebug.CommandLine.update(context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Context Menu

    onContextMenu: function(event)
    {
        var popup = document.getElementById("fbCommandEditorPopup");
        Dom.eraseNode(popup);

        var items = Firebug.CommandEditor.getContextMenuItems();
        Menu.createMenuItems(popup, items);

        if (!popup.childNodes.length)
            return;

        popup.openPopupAtScreen(event.screenX, event.screenY, true);
    },

    getContextMenuItems: function()
    {
        var items = [];
        items.push({label: Locale.$STR("Cut"), commandID: "cmd_cut"});
        items.push({label: Locale.$STR("Copy"), commandID: "cmd_copy"});
        items.push({label: Locale.$STR("Paste"), commandID: "cmd_paste"});
        items.push({label: Locale.$STR("Delete"), commandID: "cmd_delete"});
        items.push("-");
        items.push({label: Locale.$STR("SelectAll"), commandID: "cmd_selectAll"});
        return items;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Public API

    setText: function(text)
    {
        try
        {
            // When manually setting the text, ignore the TEXT_CHANGED event.
            this.ignoreChanges = true;

            if (this.editor)
                this.editor.setText(text);
        }
        catch (err)
        {
            // No exception is really expected, we just need the finally clause.
        }
        finally
        {
            this.ignoreChanges = false;
        }
    },

    getText: function()
    {
        if (this.editor)
            return this.editor.getText();
    },

    setSelectionRange: function(start, end)
    {
        if (this.editor)
            this.editor.setSelection(start, end);
    },

    select: function()
    {
        // TODO xxxHonza
    },

    // returns the applicable commands
    getExpression: function()
    {
        if (this.editor)
        {
            if (this.isCollapsed())
                return this.getText();
            else
                return this.editor.getSelectedText();
        }
    },

    isCollapsed: function()
    {
        var selection;
        if (this.editor)
        {
            selection = this.editor.getSelection(); 
            return selection.start === selection.end;
        }
        return true;
    },

    hasFocus: function()
    {
        try
        {
            if (this.editor)
                return this.editor.hasFocus();
        }
        catch (e)
        {
        }
    },

    focus: function()
    {
        if (this.editor)
            this.editor.focus();
    },

    fontSizeAdjust: function(adjust)
    {
        if (!this.editor || !this.editor._view)
            return;

        if (typeof(sourceEditorScope.SourceEditor) != "undefined")
        {
            // See issue 5488
            // var doc = this.editor._view._frame.contentDocument;

            //doc.body.style.fontSizeAdjust = adjust;
        }
        else
        {
            this.editor.textBox.style.fontSizeAdjust = adjust;
        }
    }
});

// ********************************************************************************************* //
// Getters/setters

Firebug.CommandEditor.__defineGetter__("value", function()
{
    return this.getText();
});

Firebug.CommandEditor.__defineSetter__("value", function(val)
{
    this.setText(val);
});

// ********************************************************************************************* //
// Text Editor

/**
 * A simple <textbox> element is used in environments where the Orion SourceEditor is not
 * available (such as SeaMonkey)
 */
function TextEditor() {}
TextEditor.prototype =
{
    init: function(editorElement, config, callback)
    {
        var commandEditorBox = editorElement.parentNode;

        this.textBox = commandEditorBox.ownerDocument.createElement("textbox");
        this.textBox.setAttribute("id", "fbCommandEditor");
        this.textBox.setAttribute("multiline", "true");
        this.textBox.setAttribute("flex", "1");
        this.textBox.setAttribute("newlines", "pasteintact");
        this.textBox.setAttribute("label", "CommandEditor");

        commandEditorBox.replaceChild(this.textBox, editorElement);

        // The original source editor is also loaded asynchronously.
        setTimeout(callback);
    },

    destroy: function()
    {
    },

    addEventListener: function(type, callback)
    {
        if (!type)
            return;

        Events.addEventListener(this.textBox, type, callback, true);
    },

    removeEventListener: function(type, callback)
    {
        if (!type)
            return;

        Events.removeEventListener(this.textBox, type, callback, true);
    },

    setCaretOffset: function(offset)
    {
    },

    getCharCount: function()
    {
        return this.textBox.value ? this.textBox.value.length : 0;
    },

    setText: function(text)
    {
        this.textBox.value = text;
    },

    getText: function()
    {
        return this.textBox.value;
    },

    setSelection: function(start, end)
    {
        this.textBox.setSelectionRange(start, end);
    },

    getSelection: function()
    {
        return {
            start: this.textBox.selectionStart,
            end: this.textBox.selectionEnd
        };
    },

    hasFocus: function()
    {
        return this.textBox.getAttribute("focused") == "true";
    },

    focus: function()
    {
        this.textBox.focus();
    },

    getSelectedText: function()
    {
        var start = this.textBox.selectionStart;
        var end = this.textBox.selectionEnd;

        return this.textBox.value.substring(start, end);
    } 
};

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.CommandEditor);

return Firebug.CommandEditor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/commandHistory",
[
    "firebug/firebug",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/string",
    "firebug/console/autoCompleter"
],
function(Firebug, Events, Wrapper, Css, Dom, Str) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //

Firebug.CommandHistory = function()
{
    const commandHistoryMax = 1000;

    var commandsPopup = Firebug.chrome.$("fbCommandHistory");
    var commands = this.commands = [];
    var commandPointer = 0;
    var commandInsertPointer = -1;

    this.getLastCommand = function()
    {
        var command = commands[commandInsertPointer];
        if (!command)
            return "";

        return command;
    };

    this.appendToHistory = function(command)
    {
        if (commands[commandInsertPointer] != command)
        {
            commandInsertPointer++;
            if (commandInsertPointer >= commandHistoryMax)
                commandInsertPointer = 0;

            commands[commandInsertPointer] = command;
        }

        commandPointer = commandInsertPointer + 1;

        if (Firebug.chrome.$("fbCommandLineHistoryButton").hasAttribute("disabled"))
        {
            Firebug.chrome.$("fbCommandLineHistoryButton").removeAttribute("disabled");
            Firebug.chrome.$("fbCommandEditorHistoryButton").removeAttribute("disabled");

            this.attachListeners();
        }
    };

    this.attachListeners = function()
    {
        Events.addEventListener(commandsPopup, "mouseover", this.onMouseOver, true);
        Events.addEventListener(commandsPopup, "mouseup", this.onMouseUp, true);
        Events.addEventListener(commandsPopup, "popuphidden", this.onPopupHidden, true);
    };

    this.detachListeners = function()
    {
        Events.removeEventListener(commandsPopup, "mouseover", this.onMouseOver, true);
        Events.removeEventListener(commandsPopup, "mouseup", this.onMouseUp, true);
        Events.removeEventListener(commandsPopup, "popuphidden", this.onPopupHidden, true);
    };

    this.cycleCommands = function(context, dir)
    {
        var command;
        var commandLine = Firebug.CommandLine.getCommandLine(context);

        commandPointer += dir;
        if (commandPointer < 0)
            commandPointer = 0;
        else if (commandPointer > commands.length)
            commandPointer = commands.length;

        if (commandPointer < commands.length)
        {
            command = commands[commandPointer];
            if (commandsPopup.state == "open")
            {
                var commandElement = commandsPopup.children[commandPointer];
                this.selectCommand(commandElement);

                Dom.scrollMenupopup(commandsPopup, commandElement);
            }
        }
        else
        {
            command = "";
            this.removeCommandSelection();
        }

        commandLine.value = command;
        Firebug.CommandLine.autoCompleter.hide();
        Firebug.CommandLine.update(context);
        setCursorToEOL(commandLine);
    };

    this.isShown = function()
    {
        return commandsPopup.state == "open";
    };

    this.show = function(element)
    {
        if (this.isShown())
            return this.hide();

        Dom.eraseNode(commandsPopup);

        if(commands.length == 0)
            return;

        var doc = commandsPopup.ownerDocument;

        for (var i = 0; i < commands.length; i++)
        {
            var hbox = doc.createElementNS("http://www.w3.org/1999/xhtml", "div");

            hbox.classList.add("commandHistoryItem");
            var shortExpr = Str.cropString(Str.stripNewLines(commands[i]), 50);
            hbox.textContent = shortExpr;
            hbox.value = i;
            commandsPopup.appendChild(hbox);

            if (i === commandPointer)
                this.selectCommand(hbox);
        }

        commandsPopup.openPopup(element, "before_start", 0, 0, false, false);

        // make sure last element is visible
        setTimeout(Dom.scrollMenupopup, 10, commandsPopup, hbox);
        this.isOpen = true;

        return true;
    };

    this.hide = function()
    {
        commandsPopup.hidePopup();
        this.isOpen = false;
        return true;
    };

    this.toggle = function(element)
    {
        this.isShown() ? this.hide() : this.show(element);
    };

    this.removeCommandSelection = function()
    {
        var selected = commandsPopup.ownerDocument.getElementsByClassName("selected")[0];
        Css.removeClass(selected, "selected");
    };

    this.selectCommand = function(element)
    {
        this.removeCommandSelection();

        Css.setClass(element, "selected");
    };

    this.onMouseOver = function(event)
    {
        var hovered = event.target;

        if (hovered.localName == "vbox")
            return;

        Firebug.CommandLine.commandHistory.selectCommand(hovered);
    };

    this.onMouseUp = function(event)
    {
        var i = event.target.value;
        if (i == undefined)
            return;

        var commandLine = Firebug.CommandLine.getCommandLine(Firebug.currentContext);

        commandLine.value = commands[i];
        commandPointer = event.target.value;

        Firebug.CommandLine.commandHistory.hide();
    };

    this.onPopupHidden = function(event)
    {
        Firebug.chrome.setGlobalAttribute("fbCommandLineHistoryButton", "checked", "false");
        Firebug.chrome.setGlobalAttribute("fbCommandEditorHistoryButton", "checked", "false");
        this.isOpen = false;
    };
};

// ********************************************************************************************* //
// Helpers

//xxxHonza: duplicated in console/autoCompleter.js
function setCursorToEOL(input)
{
    // textbox version, https://developer.mozilla.org/en/XUL/Property/inputField
    // input.inputField.setSelectionRange(len, len);
    input.setSelectionRange(input.value.length, input.value.length);
}

// ********************************************************************************************* //
// Registration

return Firebug.CommandHistory;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*jshint esnext:true, es5:true, curly:false, evil:true*/
/*global Firebug:true, FBTrace:true, define:true */

define("firebug/console/commandLineAPI",
[
    "firebug/lib/xpath",
    "firebug/lib/array",
    "firebug/lib/locale",
    "firebug/lib/system",
    "firebug/lib/wrapper",
],
function(Xpath, Arr, Locale, System, Wrapper) {
"use strict";

// ********************************************************************************************* //
// Command Line API

var CommandLineAPI = {};

/**
 * Gets the command line API for a context.
 *
 * @param {*} context The context
 *
 * @return {*} The command line object
 */
CommandLineAPI.getCommandLineAPI = function(context)
{
    var commands = Object.create(null);

    // returns unwrapped elements from the page
    commands.$ = function(selector, start)
    {
        if (start && start.querySelector && (
            start.nodeType === Node.ELEMENT_NODE ||
            start.nodeType === Node.DOCUMENT_NODE ||
            start.nodeType === Node.DOCUMENT_FRAGMENT_NODE))
        {
            return start.querySelector(selector);
        }

        var result = context.baseWindow.document.querySelector(selector);
        if (result === null && (selector || "")[0] !== "#")
        {
            if (context.baseWindow.document.getElementById(selector))
            {
                // This should be removed in the next minor (non-bugfix) version
                var msg = Locale.$STRF("warning.dollar_change", [selector]);
                Firebug.Console.log(msg, context, "warn");
                result = null;
            }
        }

        return result;
    };

    // returns unwrapped elements from the page
    commands.$$ = function(selector, start)
    {
        var result;

        if (start && start.querySelectorAll && (
            start.nodeType === Node.ELEMENT_NODE ||
            start.nodeType === Node.DOCUMENT_NODE ||
            start.nodeType === Node.DOCUMENT_FRAGMENT_NODE))
        {
            result = start.querySelectorAll(selector);
        }
        else
        {
            result = context.baseWindow.document.querySelectorAll(selector);
        }

        return Arr.cloneArray(result);
    };

    // returns unwrapped elements from the page
    commands.$x = function(xpath, contextNode, resultType)
    {
        var XPathResultType = XPathResult.ANY_TYPE;

        switch (resultType)
        {
            case "number":
                XPathResultType = XPathResult.NUMBER_TYPE;
                break;

            case "string":
                XPathResultType = XPathResult.STRING_TYPE;
                break;

            case "bool":
                XPathResultType = XPathResult.BOOLEAN_TYPE;
                break;

            case "node":
                XPathResultType = XPathResult.FIRST_ORDERED_NODE_TYPE;
                break;

            case "nodes":
                XPathResultType = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
                break;
        }

        var doc = Wrapper.unwrapObject(context.baseWindow.document);
        try
        {
            return Xpath.evaluateXPath(doc, xpath, contextNode, XPathResultType);
        }
        catch(ex)
        {
            throw new Error(ex.message);
        }
    };

    // values from the extension space
    commands.$n = function(index)
    {
        var htmlPanel = context.getPanel("html", true);
        if (!htmlPanel)
            return null;

        if (index < 0 || index >= htmlPanel.inspectorHistory.length)
            return null;

        var node = htmlPanel.inspectorHistory[index];
        if (!node)
            return node;

        return Wrapper.unwrapObject(node);
    };

    commands.cd = function(object)
    {
        if (!(object instanceof window.Window))
            throw new Error("The cd() argument must be a window.");

        if (FBTrace.DBG_COMMANDLINE)
            FBTrace.sysout("commandLine.cd; console ready: " + consoleReady);

        // The window object parameter uses XPCSafeJSObjectWrapper, but we need XrayWrapper.
        // So use Wrapper.wrapObject() to get the XrayWrapper instance of that object.
        // Note: Wrapper.wrapObject always returns the same instance for a given object.
        context.baseWindow = Wrapper.wrapObject(object);

        var format = Locale.$STR("commandline.CurrentWindow") + " %o";
        Firebug.Console.logFormatted([format, context.baseWindow], context, "info");
        return Firebug.Console.getDefaultReturnValue();
    };

    // no web page interaction
    commands.clear = function()
    {
        Firebug.Console.clear(context);
        return Firebug.Console.getDefaultReturnValue();
    };

    // no web page interaction
    commands.inspect = function(obj, panelName)
    {
        Firebug.chrome.select(obj, panelName);
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.keys = function(o)
    {
        // the object is from the page, unwrapped
        return Arr.keys(o);
    };

    commands.values = function(o)
    {
        // the object is from the page, unwrapped
        return Arr.values(o);
    };

    commands.debug = function(fn)
    {
        Firebug.Debugger.monitorFunction(fn, "debug");
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.undebug = function(fn)
    {
        Firebug.Debugger.unmonitorFunction(fn, "debug");
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.monitor = function(fn)
    {
        Firebug.Debugger.monitorFunction(fn, "monitor");
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.unmonitor = function(fn)
    {
        Firebug.Debugger.unmonitorFunction(fn, "monitor");
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.traceAll = function()
    {
        // See issue 6220
        Firebug.Console.log(Locale.$STR("commandline.MethodDisabled"));
        //Firebug.Debugger.traceAll(Firebug.currentContext);
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.untraceAll = function()
    {
        // See issue 6220
        Firebug.Console.log(Locale.$STR("commandline.MethodDisabled"));
        //Firebug.Debugger.untraceAll(Firebug.currentContext);
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.traceCalls = function(/*fn*/)
    {
        // See issue 6220
        Firebug.Console.log(Locale.$STR("commandline.MethodDisabled"));
        //Firebug.Debugger.traceCalls(Firebug.currentContext, fn);
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.untraceCalls = function(/*fn*/)
    {
        // See issue 6220
        Firebug.Console.log(Locale.$STR("commandline.MethodDisabled"));
        //Firebug.Debugger.untraceCalls(Firebug.currentContext, fn);
        return Firebug.Console.getDefaultReturnValue();
    };

    commands.copy = function(x)
    {
        System.copyToClipboard(x);
        return Firebug.Console.getDefaultReturnValue();
    };

    return commands;
};

return CommandLineAPI;

});
/* See license.txt for terms of usage */
/*jshint esnext:true, curly:false, evil:true, forin: false*/
/*global Firebug:true, FBTrace:true, Components:true, define:true */

define("firebug/console/commandLineExposed",
[
    "firebug/lib/wrapper",
    "firebug/debugger/debuggerLib",
    "firebug/lib/object",
    "firebug/console/commandLineAPI",
    "firebug/lib/locale",
],
function(Wrapper, DebuggerLib, Obj, CommandLineAPI, Locale) {

"use strict";

// ********************************************************************************************* //
// Constants

const Cu = Components.utils;

// ********************************************************************************************* //
// Command Line APIs

// List of command line APIs
var commandNames = ["$", "$$", "$n", "$x", "cd", "clear", "inspect", "keys",
    "values", "debug", "undebug", "monitor", "unmonitor", "traceCalls", "untraceCalls",
    "traceAll", "untraceAll", "copy"];

// List of shortcuts for some console methods
var consoleShortcuts = ["dir", "dirxml", "table"];

// List of console variables.
var props = ["$0", "$1", "$2", "$3", "$4"];

// Registered commands, name -> config object.
var userCommands = Object.create(null);

// List of command line APIs to auto-complete, kept equal to the concatenation
// of the above minus trace*.
var completionList = [
    "$", "$$", "$n", "$x", "cd", "clear", "inspect", "keys",
    "values", "debug", "undebug", "monitor", "unmonitor", "copy"
].concat(consoleShortcuts, props);
var unsortedCompletionList = true;

// ********************************************************************************************* //
// Command Line Implementation

/**
 * Returns a command line object (bundled with passed window through closure). The object
 * provides all necessary APIs as described here:
 * http://getfirebug.com/wiki/index.php/Command_Line_API
 *
 * @param {Object} context
 * @param {Object} win
 */
function createFirebugCommandLine(context, win)
{
    var contentView = Wrapper.getContentView(win);
    if (!contentView)
    {
        if (FBTrace.DBG_COMMANDLINE || FBTrace.DBG_ERRORS)
            FBTrace.sysout("createFirebugCommandLine ERROR no contentView " + context.getName());

        return null;
    }

    // The debuggee global.
    var dglobal = DebuggerLib.getDebuggeeGlobal(context, win);

    if (!context.commandLineCache)
        context.commandLineCache = new WeakMap();
    var commandLineCache = context.commandLineCache;

    var commandLine = commandLineCache.get(win.document);
    if (commandLine)
        return copyCommandLine(commandLine, dglobal);

    // The commandLine object.
    commandLine = dglobal.makeDebuggeeValue(Object.create(null));

    var console = Firebug.ConsoleExposed.createFirebugConsole(context, win);
    // The command line API instance.
    var commands = CommandLineAPI.getCommandLineAPI(context);

    // Helpers for command creation.
    function createCommandHandler(command)
    {
        var wrappedCommand = function()
        {
            try
            {
                return command.apply(null, arguments);
            }
            catch(ex)
            {
                throw new Error(ex.message, ex.fileName, ex.lineNumber);
            }
        };
        return dglobal.makeDebuggeeValue(wrappedCommand);
    }

    function createVariableHandler(handler, config)
    {
        var debuggeeObj = {}, object;

        // Callable getters are commands whose syntax are both `command` and `command()`.
        // The help command has this syntax for example.
        if (config.isCallableGetter === true)
            debuggeeObj = function(){ return object.handle(); };

        object = dglobal.makeDebuggeeValue(debuggeeObj);
        object.handle = function()
        {
            try
            {
                return handler(context);
            }
            catch(ex)
            {
                throw new Error(ex.message, ex.fileName, ex.lineNumber);
            }
        };
        return object;
    }

    function createUserCommandHandler(config)
    {
        return function()
        {
            try
            {
                return config.handler.call(null, context, arguments);
            }
            catch(ex)
            {
                throw new Error(ex.message, ex.fileName, ex.lineNumber);
            }
        };
    }

    // Define command line methods.
    for (var commandName in commands)
    {
        var command = commands[commandName];
        commandLine[commandName] = createCommandHandler(command);
    }

    // Register shortcut.
    consoleShortcuts.forEach(function(name)
    {
        var command = console[name].bind(console);
        commandLine[name] = createCommandHandler(command);
    });

    // Register user commands.
    for (var name in userCommands)
    {
        var config = userCommands[name];
        var command = createUserCommandHandler(config, name);
        if (userCommands[name].getter)
            commandLine[name] = createVariableHandler(command, config);
        else
            commandLine[name] = createCommandHandler(command);
    }

    commandLineCache.set(win.document, commandLine);

    // Return a copy so the original one is preserved from changes.
    return copyCommandLine(commandLine, dglobal);
}

// ********************************************************************************************* //
// User Commands

/**
 * Registers a command.
 *
 * @param {string} name The name of the command
 * @param {object} config The configuration. See some examples in commandLineHelp.js 
 *      and commandLineInclude.js
 */
function registerCommand(name, config)
{
    if (commandNames[name] || consoleShortcuts[name] || props[name] || userCommands[name])
    {
        if (FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("firebug.registerCommand; ERROR This command is already " +
                "registered: " + name);
        }

        return false;
    }

    userCommands[name] = config;
    completionList.push(name);
    unsortedCompletionList = true;
    return true;
}

/**
 * Unregisters a command.
 *
 * @param {string} name The name of the command to unregister
 */
function unregisterCommand(name)
{
    if (!userCommands[name])
    {
        if (FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("firebug.unregisterCommand; ERROR This command is not " +
                "registered: " + name);
        }

        return false;
    }

    delete userCommands[name];
    var ind = completionList.indexOf(name);
    if (ind !== -1)
        completionList.splice(ind, 1);
    return true;
}

/**
 * Evaluates an expression in the thread of the webpage, so the Firebug UI is not frozen
 * when the expression calls a function which will be paused.
 *
 *
 * @param {object} context
 * @param {Window} win
 * @param {string} expr The expression (transformed if needed)
 * @param {string} origExpr The expression as typed by the user
 * @param {function} onSuccess The function to trigger in case of success
 * @param {function} onError The function to trigger in case of exception
 * @param {object} [options] The options (see CommandLine.evaluateInGlobal for the details)
 *
 * @see CommandLine.evaluate
 */
function evaluateInPageContext(context, win)
{
    executeInWindowContext(win, evaluate, arguments);
}

/**
 * Evaluates an expression.
 *
 * @param {object} context
 * @param {Window} win
 * @param {string} expr The expression (transformed if needed)
 * @param {string} origExpr The expression as typed by the user
 * @param {function} onSuccess The function to trigger in case of success
 * @param {function} onError The function to trigger in case of exception
 * @param {object} [options] The options (see CommandLine.evaluateInGlobal for the details)
 */
function evaluate(context, win, expr, origExpr, onSuccess, onError, options)
{
    if (!options)
        options = {};

    var result;
    var contentView = Wrapper.getContentView(win);
    var dglobal = DebuggerLib.getDebuggeeGlobal(context, win);
    var resObj;

    if (!options.noCmdLineAPI)
    {
        var bindings = getCommandLineBindings(context, win, dglobal, contentView);

        resObj = dglobal.evalInGlobalWithBindings(expr, bindings);
    }
    else
    {
        resObj = dglobal.evalInGlobal(expr);
    }


    // In case of abnormal termination, as if by the "slow script" dialog box,
    // do not print anything in the console.
    if (!resObj)
    {
        if (FBTrace.DBG_ERROR)
            FBTrace.sysout("CommandLineExposed.evaluate; something went wrong when evaluating this"+
                " expression: "+expr);
        return;
    }

    if (resObj.hasOwnProperty("return"))
    {
        result = DebuggerLib.unwrapDebuggeeValue(resObj.return);
        if (resObj.return && resObj.return.handle)
        {
            resObj.return.handle();
            // Do not print anything in the console in case of getter commands.
            return;
        }
    }
    else if (resObj.hasOwnProperty("yield"))
    {
        result = DebuggerLib.unwrapDebuggeeValue(resObj.yield);
    }
    else if (resObj.hasOwnProperty("throw"))
    {
        var exc = DebuggerLib.unwrapDebuggeeValue(resObj.throw);
        handleException(exc, origExpr, context, onError);
        return;
    }

    executeInWindowContext(window, onSuccess, [result, context]);
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
// Helpers (not accessible from web content)

function copyCommandLine(commandLine, dglobal)
{
    var copy = dglobal.makeDebuggeeValue(Object.create(null));
    for (var name in commandLine)
        copy[name] = commandLine[name];
    return copy;
}

function findLineNumberInExceptionStack(splitStack)
{
    var m = splitStack[0].match(/:(\d+)$/);
    return m !== null ? +m[1] : null;
}

function correctStackTrace(splitStack)
{
    var filename = Components.stack.filename;
    // remove the frames over the evaluated expression
    for (var i = 0; i < splitStack.length-1 &&
        splitStack[i+1].indexOf(evaluate.name + "@" + filename, 0) === -1 ; i++);

    if (i >= splitStack.length)
        return false;
    splitStack.splice(0, i);
    return true;
}

function updateVars(commandLine, dglobal, context)
{
    var htmlPanel = context.getPanel("html", true);
    var vars = htmlPanel ? htmlPanel.getInspectorVars() : null;

    for (var prop in vars)
        commandLine[prop] = dglobal.makeDebuggeeValue(vars[prop]);

    // Iterate all registered commands and pick those which represents a 'variable'.
    // These needs to be available as variables within the Command Line namespace.
    for (var prop in userCommands)
    {
        var cmd = userCommands[prop];
        if (cmd.variable)
        {
            var value = cmd.handler.call(null, context);
            commandLine[prop] = dglobal.makeDebuggeeValue(value);
        }
    }
}

function removeConflictingNames(commandLine, context, contentView)
{
    for (var name in commandLine)
    {
        // Note: we cannot trust contentView.hasOwnProperty, so we use the "in" operator.
        if (name in contentView)
            delete commandLine[name];
    }
}

function handleException(exc, origExpr, context, onError)
{
    // Change source and line number of exceptions from commandline code
    // create new error since properties of nsIXPCException are not modifiable.
    // Example of code raising nsIXPCException: `alert({toString: function(){ throw "blah"; }})`

    // xxxFlorent: FIXME: we can't get the right stack trace with this example:
    //     function a(){
    //          throw new Error("error");
    //     }
    //     <ENTER>
    //     a();
    //     <ENTER>

    if (exc === null || exc === undefined)
        return;

    if (typeof exc !== "object")
    {
        exc = new Error(exc, null, null);
        exc.fileName = exc.lineNumber = exc.stack = null;
    }

    var shouldModify = false, isXPCException = false;
    var fileName = exc.filename || exc.fileName || "";
    var isInternalError = fileName.lastIndexOf("chrome://", 0) === 0;
    var lineNumber = null;
    var stack = null;
    var splitStack;
    var isFileNameMasked = DebuggerLib.isFrameLocationEval(fileName);
    if (isInternalError || isFileNameMasked)
    {
        shouldModify = true;
        isXPCException = (exc.filename !== undefined);

        // Lie and show the pre-transformed expression instead.
        fileName = "data:,/* " + Locale.$STR("commandline.errorSourceHeader") + " */"+
            encodeURIComponent("\n"+origExpr);

        if (isInternalError && typeof exc.stack === "string")
        {
            splitStack = exc.stack.split("\n");
            var correctionSucceeded = correctStackTrace(splitStack);
            if (correctionSucceeded)
            {
                // correct the line number so we take into account the comment prepended above
                lineNumber = findLineNumberInExceptionStack(splitStack) + 1;

                // correct the first trace
                splitStack.splice(0, 1, "@" + fileName + ":" + lineNumber);
                stack = splitStack.join("\n");
            }
            else
                shouldModify = false;
        }
        else
        {
            // correct the line number so we take into account the comment prepended above
            lineNumber = exc.lineNumber + 1;
        }
    }

    var result = new Error();

    if (shouldModify)
    {
        result.stack = stack;
        result.source = origExpr;
        result.message = exc.message;
        result.lineNumber = lineNumber;
        result.fileName = fileName;

        // The error message can also contain post-transform details about the
        // source, but it's harder to lie about. Make it prettier, at least.
        if (typeof result.message === "string")
            result.message = result.message.replace(/__fb_scopedVars\(/g, "<get closure>(");

        if (!isXPCException)
            result.name = exc.name;
    }
    else
    {
        Obj.getPropertyNames(exc).forEach(function(prop)
        {
            result[prop] = exc[prop];
        });
        result.stack = exc.stack;
        result.source = exc.source;
    }

    executeInWindowContext(window, onError, [result, context]);
}

/**
 * Executes a function in another window execution context.
 *
 * Useful when we have to pause some debuggee functions without freezing
 * the Firebug UI.
 *
 * @param {Window} win The window having the thread in which we want to execute the function
 * @param {function} func The function to execute
 * @param {Array or Array-Like object} args The arguments to pass to the function
 */
function executeInWindowContext(win, func, args)
{
    var listener = function()
    {
        win.document.removeEventListener("firebugCommandLine", listener);
        func.apply(null, args);
    };
    win.document.addEventListener("firebugCommandLine", listener);
    var event = document.createEvent("Events");
    event.initEvent("firebugCommandLine", true, false);
    win.document.dispatchEvent(event);
}

function getAutoCompletionList()
{
    if (unsortedCompletionList)
    {
        unsortedCompletionList = false;
        completionList.sort();
    }
    return completionList;
}

function getCommandLineBindings(context, win, dglobal, contentView)
{
    var commandLine = createFirebugCommandLine(context, win);

    updateVars(commandLine, dglobal, context);
    removeConflictingNames(commandLine, context, contentView);

    return commandLine;
}

// ********************************************************************************************* //
// Registration

Firebug.CommandLineExposed =
{
    createFirebugCommandLine: createFirebugCommandLine,
    commands: commandNames,
    consoleShortcuts: consoleShortcuts,
    properties: props,
    userCommands: userCommands,
    registerCommand: registerCommand,
    unregisterCommand: unregisterCommand,
    evaluate: evaluateInPageContext,
    getAutoCompletionList: getAutoCompletionList,
};

return Firebug.CommandLineExposed;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*jshint forin:false, noempty:false, esnext:true, es5:true, curly:false */
/*global FBTrace:true, Components:true, define:true, KeyEvent:true */

define("firebug/console/commandLine",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/lib/dom",
    "firebug/chrome/firefox",
    "firebug/chrome/window",
    "firebug/lib/system",
    "firebug/lib/string",
    "firebug/lib/persist",
    "firebug/console/console",
    "firebug/console/commandLineExposed",
    "firebug/console/closureInspector",
    "firebug/console/commandLineAPI",
    "firebug/console/autoCompleter",
    "firebug/console/commandHistory",
    "firebug/console/commands/commandLineHelp",
    "firebug/console/commands/commandLineInclude",
],
function(Module, Obj, Firebug, FirebugReps, Locale, Events, Url, Dom, Firefox, Win, System, Str,
    Persist, Console, CommandLineExposed, ClosureInspector, CommandLineAPI) {

"use strict";

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;

const commandPrefix = ">>> ";

// ********************************************************************************************* //
// Command Line

Firebug.CommandLine = Obj.extend(Module,
{
    dispatchName: "commandLine",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Evaluates an expression either in the global scope or in the current scope
     * of the JS debugger, depending on the state of Firebug (i.e. if the debugger is currently
     * active, etc.).
     *
     * @param {string} expr The expression.
     * @param {Context} context The Firebug context.
     * @param {*} [thisValue] Deprecated. Set it to null or undefined.
     * @param {Window} [targetWindow] The window in which the expression is evaluated.
     * @param {function} [successConsoleFunction] The callback function in case of 
     *      evaluation without errors.
     * @param {function} [exceptionFunction] The callback function in case of 
     *      evaluation with errors.
     * @param {object} [options] The options with the following properties:
     *      - noStateChange: if set to true, do not update the DOM and HTML panels. (default=false)
     *      - noCmdLineAPI: if set to true, do not evaluate with the Firebug commands. (default=false)
     */
    evaluate: function(expr, context, thisValue, targetWindow, successConsoleFunction,
        exceptionFunction, options)
    {
        if (!context)
            return;

        // Previously there was `noStateChange` in place of `options`. For backward compatibility,
        // if `options` is a boolean, its value is meant to be `noStateChange`.
        if (typeof options === "boolean")
            options = {noStateChange: options};
        else if (options == undefined)
            options = {};

        targetWindow = targetWindow || context.getCurrentGlobal();

        var debuggerState, result = null;
        try
        {
            debuggerState = Firebug.Debugger.beginInternalOperation();

            var self = this;
            var evaluate = function(newExpr)
            {
                if (this.isSandbox(context))
                {
                    this.evaluateInSandbox(newExpr, context, thisValue, targetWindow,
                        successConsoleFunction, exceptionFunction, expr);
                }
                else if (Firebug.Debugger.hasValidStack(context))
                {
                    this.evaluateInDebugFrame(newExpr, context, thisValue, targetWindow,
                        successConsoleFunction, exceptionFunction, expr);
                }
                else
                {
                    this.evaluateInGlobal(newExpr, context, thisValue, targetWindow,
                        successConsoleFunction, exceptionFunction, expr, options);
                }
            }.bind(this);

            if (options.noCmdLineAPI)
                evaluate(expr);
            else
                ClosureInspector.withExtendedLanguageSyntax(expr, targetWindow, context, evaluate);

            if (!options.noStateChange)
                context.invalidatePanels("dom", "html");
        }
        catch (exc)
        {
            // XXX jjb, I don't expect this to be taken, the try here is for the finally
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("commandLine.evaluate with context.stopped:" + context.stopped +
                    " EXCEPTION " + exc, exc);
            }
        }
        finally
        {
            Firebug.Debugger.endInternalOperation(debuggerState);
        }
    },

    /**
     * Evaluates an expression in the global scope.
     *
     * @param {string} expr The expression.
     * @param {Context} context The Firebug context.
     * @param {*} [thisValue] Deprecated. Set it to null or undefined.
     * @param {Window} [targetWindow] The window in which the expression is evaluated.
     * @param {function} [successConsoleFunction] The callback function in case of 
     *      evaluation without errors.
     * @param {function} [exceptionFunction] The callback function in case of 
     *      evaluation with errors.
     * @param {string} [origExpr] The original expression before it has been transformed
     *          (mainly used by ClosureInspector). If not set, origExpr=expr.
     * @param {object} [options] The options with the following properties:
     *      - noCmdLineAPI: if set to true, do not evaluate with the Firebug commands. (default=false)
     */
    evaluateInGlobal: function(expr, context, thisValue, targetWindow,
        successConsoleFunction, exceptionFunction, origExpr, options)
    {
        var win = targetWindow || context.getCurrentGlobal();
        options = options || {};

        if (!win)
        {
            if (FBTrace.DBG_ERRORS && FBTrace.DBG_COMMANDLINE)
                FBTrace.sysout("commandLine.evaluateInGlobal: no targetWindow!");
            return;
        }

        context.baseWindow = context.baseWindow || context.window;
        var onSuccess, onError;

        if (successConsoleFunction)
        {
            onSuccess = function(result)
            {
                if (FBTrace.DBG_COMMANDLINE)
                {
                    FBTrace.sysout("commandLine.evaluateInGlobal; the evaluation succeeded "+
                        "and returned: ", result);
                }

                if (Console.isDefaultReturnValue(result))
                    return;

                successConsoleFunction(result, context);
            }
        }

        if (!exceptionFunction)
        {
            exceptionFunction = function(result, context)
            {
                Firebug.Console.logFormatted([result], context, "error", true);
            }
        }

        onError = function(result)
        {
            if (FBTrace.DBG_COMMANDLINE)
            {
                FBTrace.sysout("commandLine.evaluateInGlobal; the evaluation threw "+
                    "an exception:" + result, result);
            }

            exceptionFunction(result, context, "errorMessage");
        };

        origExpr = origExpr || expr;
        CommandLineExposed.evaluate(context, win, expr, origExpr, onSuccess, onError, options);
    },

    evaluateInDebugFrame: function(expr, context, thisValue, targetWindow,
        successConsoleFunction, exceptionFunction)
    {
        var result = null;

        if (!context.commandLineAPI)
            context.commandLineAPI = CommandLineAPI.getCommandLineAPI(context);

        var htmlPanel = context.getPanel("html", true);
        var scope = {
            api       : context.commandLineAPI,
            vars      : htmlPanel ? htmlPanel.getInspectorVars() : null,
            thisValue : thisValue
        };

        try
        {
            result = Firebug.Debugger.evaluate(expr, context, scope);

            successConsoleFunction(result, context);
        }
        catch (e)
        {
            exceptionFunction(e, context);
        }

        return result;
    },

    evaluateInWebPage: function(expr, context, targetWindow)
    {
        var win = targetWindow || context.getCurrentGlobal();

        var element = Dom.addScript(win.document, "_firebugInWebPage", expr);
        if (!element)
            return;

        setTimeout(function delayRemoveScriptTag()
        {
            // we don't need the script element, result is in DOM object
            if (element.parentNode)
                element.parentNode.removeChild(element);
        });

        return "true";
    },

    // isSandbox(context) true, => context.global is a Sandbox
    evaluateInSandbox: function(expr, context, thisValue, targetWindow, successConsoleFunction,
        exceptionFunction)
    {
        var result,
            scriptToEval = expr;

        try
        {
            result = Components.utils.evalInSandbox(scriptToEval, context.global);

            if (FBTrace.DBG_COMMANDLINE)
                FBTrace.sysout("commandLine.evaluateInSandbox success for sandbox ", scriptToEval);

            successConsoleFunction(result, context);
        }
        catch (e)
        {
            if (FBTrace.DBG_ERRORS && FBTrace.DBG_COMMANDLINE)
                FBTrace.sysout("commandLine.evaluateInSandbox FAILED in "+context.getName()+
                    " because "+e, e);

            exceptionFunction(e, context);

            result = new FirebugReps.ErrorMessageObj("commandLine.evaluateInSandbox FAILED: " + e,
                Url.getDataURLForContent(scriptToEval, "FirebugCommandLineEvaluate"),
                e.lineNumber, 0, "js", context, null);
        }

        return result;
    },

    isSandbox: function (context)
    {
        return (context.global && context.global+"" === "[object Sandbox]");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    enter: function(context, command)
    {
        var expr = command ? command : this.getExpression(context);
        if (expr === "")
            return;

        if (!Firebug.commandEditor || context.panelName !== "console")
        {
            this.clear(context);
            Firebug.Console.log(commandPrefix + expr, context, "command", FirebugReps.Text);
        }
        else
        {
            var shortExpr = Str.cropString(Str.stripNewLines(expr), 100);
            Firebug.Console.log(commandPrefix + shortExpr, context, "command",
                FirebugReps.Text);
        }

        this.commandHistory.appendToHistory(expr);

        var noscript = getNoScript(), noScriptURI;
        if (noscript)
        {
            var currentURI = Firefox.getCurrentURI();
            noScriptURI = currentURI ? noscript.getSite(currentURI.spec) : null;
            if (noScriptURI)
                noScriptURI = (noscript.jsEnabled || noscript.isJSEnabled(noScriptURI)) ?
                    null : noScriptURI;
        }

        if (noscript && noScriptURI)
            noscript.setJSEnabled(noScriptURI, true);

        var self = this;
        var logResult = Firebug.Console.log.bind(Firebug.Console);

        function successHandler(result, context)
        {
            self.dispatch("expressionEvaluated", [context, expr, result, true]);
            logResult.apply(this, arguments);
        }

        function exceptionHandler(err, context)
        {
            self.dispatch("expressionEvaluated", [context, expr, err, false]);
            logResult.apply(this, arguments);
        }

        // Finally, let's evaluate the use expression!
        this.evaluate(expr, context, null, null, successHandler, exceptionHandler);

        if (noscript && noScriptURI)
            noscript.setJSEnabled(noScriptURI, false);

        var consolePanel = context.getPanel("console");
        if (consolePanel)
            Dom.scrollToBottom(consolePanel.panelNode);
    },

    enterInspect: function(context)
    {
        var expr = this.getCommandLine(context).value;
        if (expr === "")
            return;

        this.clear(context);
        this.commandHistory.appendToHistory(expr);

        this.evaluate(expr, context, null, null, function(result)
        {
            if (typeof result !== "undefined")
                Firebug.chrome.select(result);
        });
    },

    reenter: function(context)
    {
        var command = this.commandHistory.getLastCommand();
        this.enter(context, command);
    },

    copyBookmarklet: function(context)
    {
        // XXXsilin: This needs escaping, and stripNewLines is exactly the
        // wrong thing to do when it comes to JavaScript.
        var commandLine = this.getCommandLine(context);
        var expr = "javascript: " + Str.stripNewLines(commandLine.value);
        System.copyToClipboard(expr);
    },

    focus: function(context)
    {
        if (Firebug.isDetached())
            Firebug.chrome.focus();
        else
            Firebug.toggleBar(true);

        var commandLine = this.getCommandLine(context);

        if (!context.panelName)
        {
            Firebug.chrome.selectPanel("console");
        }
        else if (context.panelName !== "console")
        {
            this.Popup.toggle(Firebug.currentContext);
            setTimeout(function() { commandLine.select(); });
        }
        else
        {
            // We are already on the console, if the command line has also
            // the focus, toggle back. But only if the UI has been already
            // opened.
            if (Firebug.commandEditor)
                commandLine.focus();
            else if (commandLine.getAttribute("focused") !== "true")
                setTimeout(function() { commandLine.select(); });
        }
    },

    clear: function(context)
    {
        var commandLine = this.getCommandLine(context);

        if (commandLine.value)
        {
            commandLine.value = "";
            this.autoCompleter.hide();
            this.update(context);
            return true;
        }

        return false;
    },

    cancel: function(context)
    {
        return this.clear(context);
    },

    update: function(context)
    {
        var commandLine = this.getCommandLine(context);
        context.commandLineText = commandLine.value;
    },

    // xxxsz: setMultiLine should just be called when switching between Command Line
    // and Command Editor
    // xxxHonza: it is called for me when switching between the Command Line and
    // Command Editor 
    setMultiLine: function(multiLine, chrome, saveMultiLine)
    {
        var context = Firebug.currentContext;

        if (FBTrace.DBG_COMMANDLINE)
        {
            FBTrace.sysout("commandLine.setMultiline; multiLine: " + multiLine + " for: " +
                (context ? context.getName() : "no contet"));
        }

        if (context && context.panelName !== "console")
            return;

        Dom.collapse(chrome.$("fbCommandBox"), multiLine);
        Dom.collapse(chrome.$("fbPanelSplitter"), !multiLine);
        Dom.collapse(chrome.$("fbSidePanelDeck"), !multiLine);

        if (multiLine)
            chrome.$("fbSidePanelDeck").selectedPanel = chrome.$("fbCommandEditorBox");

        var commandLine = this.getSingleRowCommandLine();
        var commandEditor = this.getCommandEditor();

        // we are just closing the view
        if (saveMultiLine)
        {
            commandLine.value = commandEditor.value;
            return;
        }

        if (context)
        {
            var text = context.commandLineText || "";
            context.commandLineText = text;

            if (multiLine)
                commandEditor.value = Str.cleanIndentation(text);
            else
                commandLine.value = Str.stripNewLines(text);
        }
        // else we may be hiding a panel while turning Firebug off
    },

    toggleMultiLine: function(forceCommandEditor)
    {
        var showCommandEditor = !!forceCommandEditor || !Firebug.commandEditor;
        if (showCommandEditor != Firebug.commandEditor)
            Firebug.Options.set("commandEditor", showCommandEditor);
    },

    checkOverflow: function(context)
    {
        if (!context)
            return;

        var commandLine = this.getCommandLine(context);
        if (commandLine.value.indexOf("\n") >= 0)
        {
            setTimeout(Obj.bindFixed(function()
            {
                Firebug.Options.set("commandEditor", true);

                // Switch to the Console panel, where the multiline command line
                // is actually displayed. This should be improved see issue 5146
                Firebug.chrome.selectPanel("console");
            }, this));
        }
    },

    onCommandLineOverflow: function(event)
    {
        this.checkOverflow(Firebug.currentContext);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        this.setAutoCompleter();
        this.commandHistory = new Firebug.CommandHistory();

        if (Firebug.commandEditor)
            this.setMultiLine(true, Firebug.chrome);
    },

    // (Re)create the auto-completer for the small command line.
    setAutoCompleter: function()
    {
        if (this.autoCompleter)
            this.autoCompleter.shutdown();

        var commandLine = this.getSingleRowCommandLine();
        var completionBox = this.getCompletionBox();

        var options = {
            showCompletionPopup: Firebug.Options.get("commandLineShowCompleterPopup"),
            completionPopup: Firebug.chrome.$("fbCommandLineCompletionList"),
            popupMeasurer: Firebug.chrome.$("fbCommandLineMeasurer"),
            tabWarnings: true,
            includeCurrentScope: true,
            includeCommandLineAPI: true
        };

        this.autoCompleter = new Firebug.JSAutoCompleter(commandLine, completionBox, options);
    },

    initializeUI: function()
    {
        this.onCommandLineInput = Obj.bind(this.onCommandLineInput, this);
        this.onCommandLineOverflow = Obj.bind(this.onCommandLineOverflow, this);
        this.onCommandLineKeyUp = Obj.bind(this.onCommandLineKeyUp, this);
        this.onCommandLineKeyDown = Obj.bind(this.onCommandLineKeyDown, this);
        this.onCommandLineKeyPress = Obj.bind(this.onCommandLineKeyPress, this);
        this.attachListeners();
    },

    attachListeners: function()
    {
        var commandLine = this.getSingleRowCommandLine();

        Events.addEventListener(commandLine, "input", this.onCommandLineInput, true);
        Events.addEventListener(commandLine, "overflow", this.onCommandLineOverflow, true);
        Events.addEventListener(commandLine, "keyup", this.onCommandLineKeyUp, true);
        Events.addEventListener(commandLine, "keydown", this.onCommandLineKeyDown, true);
        Events.addEventListener(commandLine, "keypress", this.onCommandLineKeyPress, true);
    },

    shutdown: function()
    {
        var commandLine = this.getSingleRowCommandLine();

        if (this.autoCompleter)
            this.autoCompleter.shutdown();

        if (this.commandHistory)
            this.commandHistory.detachListeners();

        Events.removeEventListener(commandLine, "input", this.onCommandLineInput, true);
        Events.removeEventListener(commandLine, "overflow", this.onCommandLineOverflow, true);
        Events.removeEventListener(commandLine, "keyup", this.onCommandLineKeyUp, true);
        Events.removeEventListener(commandLine, "keydown", this.onCommandLineKeyDown, true);
        Events.removeEventListener(commandLine, "keypress", this.onCommandLineKeyPress, true);
    },

    destroyContext: function(context, persistedState)
    {
        var panelState = Persist.getPersistedState(this, "console");
        panelState.commandLineText = context.commandLineText;

        var commandLine = this.getCommandLine(context);
        commandLine.value = "";

        this.autoCompleter.hide();
        Persist.persistObjects(this, panelState);
        // more of our work is done in the Console

        // All command line handlers should be removed at this moment.
        for (var handler in context.activeCommandLineHandlers)
        {
            FBTrace.sysout("commandLine.destroyContext; ERROR active commandlinehandler for: " +
                context.getName());
        }
    },

    showPanel: function(browser, panel)
    {
        var context = Firebug.currentContext;
        if (!context)
            return;

        // Warn that FireClosure is integrated and will conflict.
        if (Firebug.JSAutoCompleter && Firebug.JSAutoCompleter.transformScopeExpr &&
            !this.hasWarnedAboutFireClosure)
        {
            this.hasWarnedAboutFireClosure = true;
            // Use English because this only reaches ~200 users anyway.
            var msg = "FireClosure has been integrated into Firebug. To avoid conflicts, please" +
                " uninstall it and restart your browser.";
            Firebug.Console.logFormatted([msg], context, "warn");
        }

        var panelState = Persist.getPersistedState(this, "console");
        if (panelState.commandLineText)
        {
            var value = panelState.commandLineText;
            var commandLine = this.getCommandLine(browser);
            context.commandLineText = value;

            commandLine.value = value;

            // We don't need the persistent value in this session/context any more. The showPanel
            // method is called every time the panel is selected and the text could have been
            // changed in this session/context already.
            delete panelState.commandLineText;
        }

        this.autoCompleter.hide();
    },

    updateOption: function(name, value)
    {
        if (name === "commandEditor")
            this.setMultiLine(value, Firebug.chrome);
        else if (name === "commandLineShowCompleterPopup")
            this.setAutoCompleter();
    },

    onCommandLineKeyUp: function(event)
    {
    },

    onCommandLineKeyDown: function(event)
    {
        var context = Firebug.currentContext;

        this.autoCompleter.handleKeyDown(event, context);

        if (event.keyCode === KeyEvent.DOM_VK_H && Events.isControl(event))
        {
            event.preventDefault();
            this.autoCompleter.hide();
            this.commandHistory.show(Firebug.chrome.$("fbCommandLineHistoryButton"));
            return true;
        }

        // Parts of the code moved into key-press handler due to bug 613752
    },

    onCommandLineKeyPress: function(event)
    {
        var context = Firebug.currentContext;

        if (!this.autoCompleter.handleKeyPress(event, context))
        {
            this.handleKeyPress(event);
        }
    },

    handleKeyPress: function(event)
    {
        switch (event.keyCode)
        {
            case KeyEvent.DOM_VK_RETURN:
            case KeyEvent.DOM_VK_ENTER:
                event.preventDefault();

                if (!event.metaKey && !event.shiftKey)
                {
                    Firebug.CommandLine.enter(Firebug.currentContext);
                    this.commandHistory.hide();
                    return true;
                }
                else if(!event.metaKey && event.shiftKey)
                {
                    Firebug.CommandLine.enterInspect(Firebug.currentContext);
                    this.commandHistory.hide();
                    return true;
                }
                break;

            case KeyEvent.DOM_VK_UP:
                event.preventDefault();
                this.commandHistory.cycleCommands(Firebug.currentContext, -1);
                return true;

            case KeyEvent.DOM_VK_DOWN:
                event.preventDefault();
                this.commandHistory.cycleCommands(Firebug.currentContext, 1);
                return true;

            case KeyEvent.DOM_VK_ESCAPE:
                event.preventDefault();
                if (Firebug.CommandLine.cancel(Firebug.currentContext))
                    Events.cancelEvent(event);
                this.commandHistory.hide();
                return true;
        }

        if (this.commandHistory.isOpen && !event.metaKey && !event.ctrlKey && !event.altKey)
            this.commandHistory.hide();

        return false;
    },

    onCommandLineInput: function(event)
    {
        var context = Firebug.currentContext;

        this.autoCompleter.complete(context);
        this.update(context);
    },

    getCommandLine: function(context)
    {
        return (!this.isInOtherPanel(context) && Firebug.commandEditor) ?
            this.getCommandEditor():
            this.getSingleRowCommandLine();
    },

    isInOtherPanel: function(context)
    {
        // Command line on other panels is never multiline.
        var visible = Firebug.CommandLine.Popup.isVisible();
        return visible && context.panelName !== "console";
    },

    getExpression: function(context)
    {
        return (!this.isInOtherPanel(context) && Firebug.commandEditor) ?
            this.getCommandEditor().getExpression() :
            this.getSingleRowCommandLine().value;
    },

    getCompletionBox: function()
    {
        return Firebug.chrome.$("fbCommandLineCompletion");
    },

    getSingleRowCommandLine: function()
    {
        return Firebug.chrome.$("fbCommandLine");
    },

    getCommandEditor: function()
    {
        return Firebug.CommandEditor;
    }
});

// ********************************************************************************************* //
// Helpers

var getNoScript = function()
{
    // The wrappedJSObject here is not a security wrapper, it is a property set by the service.
    var noscript = Cc["@maone.net/noscript-service;1"] &&
        Cc["@maone.net/noscript-service;1"].getService().wrappedJSObject;
    getNoScript = function()
    {
        return noscript;
    };
    return noscript;
};

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.CommandLine);

return Firebug.CommandLine;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/commandLinePopup",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/console/commandLine",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/string",
    "firebug/lib/xml",
    "firebug/lib/events",
],
function(Module, Obj, Firebug, CommandLine, Css, Dom, Str, Xml, Events) {

// ************************************************************************************************
// Constants

// ************************************************************************************************
// Implementation

/**
 * @module Command Line availability in other panels.
 */
Firebug.CommandLine.Popup = Obj.extend(Module,
{
    dispatchName: "commandLinePopup",
    lastFocused : null,

    initializeUI: function()
    {
        Module.initializeUI.apply(this, arguments);

        this.setPopupBrowserStyle(Firebug.chrome);

        this.onKeyPress = Obj.bind(this.onKeyPress, this);

        this.attachListeners();
    },

    shutdown: function()
    {
        var contentBox = Firebug.chrome.$("fbContentBox");
        Events.removeEventListener(contentBox, "keypress", this.onKeyPress, false);
    },

    initContext: function(context)
    {
        Module.showContext.apply(this, arguments);

        var show = Firebug.Options.get("alwaysShowCommandLine");
        if (show && !this.isVisible())
            this.toggle(context);
    },

    showPanel: function(browser, panel)
    {
        if (FBTrace.DBG_COMMANDLINE)
            FBTrace.sysout("commandLine.Popup.showPanel; " + (panel?panel.name:"null panel"));

        var chrome = Firebug.chrome;
        var visible = this.isVisible();
        var isConsole = (panel && panel.name == "console");
        var showCommandEditor = Firebug.commandEditor;

        // Disable the console popup button (Firebug toolbar) if the Console panel
        // is disabled or selected.
        var consolePanelType = Firebug.getPanelType("console");
        var disabled = consolePanelType.prototype.isEnabled() ? "false" : "true";
        if (isConsole || !panel)
            disabled = "true";

        chrome.$("fbCommandPopupButton").setAttribute("disabled", disabled);

        if ((showCommandEditor && isConsole) || !panel)
        {
            Dom.collapse(chrome.$("fbPanelSplitter"), panel ? false : true);
            Dom.collapse(chrome.$("fbSidePanelDeck"), panel ? false : true);
            Dom.collapse(chrome.$("fbCommandBox"), true);
            chrome.$("fbSidePanelDeck").selectedPanel = chrome.$("fbCommandEditorBox");
        }

        // The console can't be multiline on other panels, so hide the toggle-to-multiline
        // button (displayed at the end of the one line command line)
        Dom.collapse(chrome.$("fbToggleCommandLine"), !isConsole);

        // Update visibility of the console-popup (hidden if the Console panel is selected).
        this.updateVisibility(visible && !isConsole && panel && disabled != "true");

        // Make sure the console panel is attached to the proper document
        // (the one used by all panels, or the one used by console popup and available
        // for all the panels).
        if (panel)
            this.reattach(panel.context);

        // If the the console panel is opened on another panel, simulate show event for it.
        if (panel && !isConsole && visible)
            this.showPopupPanel(panel.context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

    setPopupBrowserStyle: function(chrome)
    {
        // Set additional style so we can make the panelNode-console node
        // always visible regardless of the currently selected panel.
        var doc = chrome.$("fbCommandPopupBrowser").contentDocument;
        var body = Dom.getBody(doc);
        Css.setClass(body, "commandPopup");
    },

    attachListeners: function()
    {
        // Register event listeners.
        var contentBox = Firebug.chrome.$("fbContentBox");
        Events.addEventListener(contentBox, "keypress", this.onKeyPress, false);
    },

    toggle: function(context)
    {
        var panel = Firebug.chrome.getSelectedPanel();
        if (panel && panel.name == "console")
            return;

        if (FBTrace.DBG_COMMANDLINE)
            FBTrace.sysout("commandLine.Popup.toggle;");

        var newState = !this.isVisible();
        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleCommandPopup", "checked", newState);
        Firebug.Options.set("alwaysShowCommandLine", newState);

        this.updateVisibility(newState);

        this.reattach(context);
        this.showPopupPanel(context);
    },

    showPopupPanel: function(context)
    {
        // If the the console panel is opened on another panel, simulate show event for it.
        if (this.isVisible())
        {
            var panel = context.getPanel("console", true);
            if (panel)
            {
                var state = Firebug.getPanelState(panel);
                panel.showPanel(state);
            }
        }
    },

    updateVisibility: function(visible)
    {
        var chrome = Firebug.chrome;
        var popup = chrome.$("fbCommandPopup");
        var splitter = chrome.$("fbCommandPopupSplitter");
        var cmdbox = chrome.$("fbCommandBox");
        var toggle = chrome.$("fbToggleCommandLine");

        // If all the visual parts are already visible then bail out.
        if (visible && !Dom.isCollapsed(popup) && !Dom.isCollapsed(splitter) &&
            !Dom.isCollapsed(cmdbox) && Dom.isCollapsed(toggle))
            return;

        Dom.collapse(popup, !visible);
        Dom.collapse(splitter, !visible);
        Dom.collapse(cmdbox, !visible);

        // The command line can't be multiline in other panels.
        Dom.collapse(toggle, visible);

        var commandLine = Firebug.CommandLine.getSingleRowCommandLine();
        var commandEditor = Firebug.CommandLine.getCommandEditor();

        // Focus the command line if it has been just displayed.
        if (visible)
        {
            this.lastFocused = document.commandDispatcher.focusedElement;
            commandLine.focus();
        }
        else if (this.lastFocused && Xml.isVisible(this.lastFocused) &&
            typeof this.lastFocused.focus == "function")
        {
            this.lastFocused.focus();
            this.lastFocused = null;
        }

        if (Firebug.commandEditor)
        {
            if (visible)
                commandLine.value = Str.stripNewLines(commandEditor.value);
            else
                commandEditor.value = Str.cleanIndentation(commandLine.value);
        }
    },

    isVisible: function()
    {
        var checked = Firebug.chrome.getGlobalAttribute("cmd_firebug_toggleCommandPopup", "checked");
        return (checked == "true") ? true : false;
    },

    reattach: function(context)
    {
        if (!context)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("commandLinePopup.reattach; ERROR No context");
            return;
        }

        var consolePanelType = Firebug.getPanelType("console");
        var doc = Firebug.chrome.getPanelDocument(consolePanelType);

        // Console doesn't have to be available (e.g. disabled)
        var panel = context.getPanel("console", true);
        if (panel)
            panel.reattach(doc);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Event Listeners

    onKeyPress: function(event)
    {
        if (!Events.noKeyModifiers(event))
            return false;

        // ESC
        var target = event.target;
        // prevent conflict with inline editors being closed
        if (this.isVisible() && target && event.keyCode == KeyEvent.DOM_VK_ESCAPE
            && !Css.hasClass(target, "textEditorInner"))
            this.toggle(Firebug.currentContext);
    }
});

// ************************************************************************************************
// Registration

Firebug.registerModule(Firebug.CommandLine.Popup);

return Firebug.CommandLine.Popup;

// ************************************************************************************************
});
/* See license.txt for terms of usage */

define("firebug/console/commands/commandLineHelp",
[
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/dom",
    "firebug/console/commandLineExposed",
    "firebug/chrome/window",
    "firebug/lib/xpcom",
    "firebug/lib/events",
    "firebug/lib/object",
],
function(Firebug, Domplate, Locale, Dom, CommandLineExposed, Win, Xpcom, Events, Obj) {

"use strict";

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

var CMD_TYPE_COMMAND = 1;
var CMD_TYPE_SHORTCUT = 2;
var CMD_TYPE_PROPERTY = 3;

const prompts = Xpcom.CCSV("@mozilla.org/embedcomp/prompt-service;1", "nsIPromptService");

var CLOSURE_INSPECTOR_HELP_URL = "https://getfirebug.com/wiki/index.php/Closure_Inspector";

// ********************************************************************************************* //
// Command Line Help

var {domplate, SPAN, TABLE, THEAD, TR, TH, DIV, TBODY, TD, A, UL, LI, FOR, TAG} = Domplate;

var HelpCaption = domplate(
{
    tag:
        SPAN({"class": "helpTitle"},
            SPAN({"class": "helpCaption"},
                Locale.$STR("console.cmd.help_title")
            ),
            SPAN({"class": "helpCaptionDesc"},
                Locale.$STR("console.cmd.help_title_desc")
            )
        ),

    groupable: false
});

// The table UI should be based on tableRep
var HelpTable = domplate(
{
    tag:
        TABLE({"class": "helpTable", cellspacing: 0, cellpadding: 0, width: "100%",
            "role": "grid"},
            THEAD({"class": "helpThead", "role": "presentation"},
                TR({"class": "headerRow focusRow helpRow subFocusRow", onclick: "$onClick",
                    "role": "row"},
                    TH({"class": "headerCell a11yFocus", "role": "columnheader", width: "10%"},
                        DIV({"class": "headerCellBox"},
                            Locale.$STR("Name")
                        )
                    ),
                    TH({"class": "headerCell a11yFocus", "role": "columnheader", width: "90%"},
                        DIV({"class": "headerCellBox"},
                            Locale.$STR("Description")
                        )
                    )
                )
            ),
            TBODY({"class": "helpTbody", "role": "presentation"})
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onClick: function(event)
    {
    }
});

var HelpEntry = domplate(
{
    tag:
        FOR("command", "$commands",
            TR({"class": "focusRow helpRow subFocusRow", "role": "row"},
                TD({"class": "a11yFocus helpCell commandName", "role": "presentation"},
                    A({"class": "objectLink", onclick: "$onClick", _repObject: "$command"},
                        "$command|getName"
                    )
                ),
                TD({"class": "a11yFocus helpCell commandDesc", "role": "gridcell"},
                    "$command|getDesc"
                )
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onClick: function(event)
    {
        Events.cancelEvent(event);

        var object = Firebug.getRepObject(event.target);

        if (object.noUserHelpUrl)
        {
            prompts.alert(null, Locale.$STR("Firebug"),
                Locale.$STR("console.cmd.helpUrlNotAvailable"));
            return;
        }

        var helpUrl = "http://getfirebug.com/wiki/index.php/" + object.name;
        if (object.helpUrl)
            helpUrl = object.helpUrl;

        Win.openNewTab(helpUrl);
    },

    getName: function(object)
    {
        var name = object.name;
        if (object.type != CMD_TYPE_PROPERTY)
            name = name + "()";
        return name;
    },

    getDesc: function(object)
    {
        if (object.nol10n)
            return object.desc;

        return Locale.$STR(object.desc);
    }
});

// ********************************************************************************************* //
// Command Line Tips

var TipsCaption = domplate(
{
    tag:
        SPAN({"class": "helpTitle"},
            SPAN({"class": "helpCaption"},
                Locale.$STR("console.cmd.tip_title")
            ),
            SPAN({"class": "helpCaptionDesc"},
                Locale.$STR("console.cmd.tip_title_desc")
            )
        ),

    groupable: false
});

var TipsList = domplate(
{
    tag:
        UL({"class": "tipsList"})
});

var Tip = domplate(
{
    loop:
        FOR("tip", "$tips",
            TAG("$tag", "$tip")
        ),

    tag:
        LI({"class": "tip"},
            SPAN({"class": "text"}, "$tip|getText"),
            SPAN("&nbsp;"),
            SPAN({"class": "example"},"$tip|getExample")
        ),

    getText: function(object)
    {
        return object.nol10n ? object.text : Locale.$STR(object.text);
    },

    getExample: function(object)
    {
        return object.example;
    }
});

// ********************************************************************************************* //
// Help Object

var CommandLineHelp = domplate(
{
    render: function(context)
    {
        this.renderHelp(context);
        this.renderTips(context);
    },

    renderHelp: function(context)
    {
        var row = Firebug.Console.openGroup("help", context, "help",
            HelpCaption, true, null, true);
        Firebug.Console.closeGroup(context, true);

        var logGroupBody = row.getElementsByClassName("logGroupBody")[0];
        var logContent = logGroupBody.getElementsByClassName("logContent")[0];
        var table = HelpTable.tag.append({}, logContent);
        var tBody = table.getElementsByClassName("helpTbody")[0];

        var commands = [];

        var ignore = ["traceCalls", "untraceCalls", "traceAll", "untraceAll"];
        for (var i=0; i<CommandLineExposed.commands.length; i++)
        {
            var cmd = CommandLineExposed.commands[i];

            // See Issue 5221
            if (ignore.indexOf(cmd) >= 0)
                continue;

            commands.push({
                name: cmd,
                desc: "console.cmd.help." + cmd,
                type: CMD_TYPE_COMMAND,
            });
        }

        for (var i=0; i<CommandLineExposed.consoleShortcuts.length; i++)
        {
            commands.push({
                name: CommandLineExposed.consoleShortcuts[i],
                desc: "console.cmd.help." + CommandLineExposed.consoleShortcuts[i],
                type: CMD_TYPE_SHORTCUT,
            });
        }

        for (var i=0; i<CommandLineExposed.properties.length; i++)
        {
            commands.push({
                name: CommandLineExposed.properties[i],
                desc: "console.cmd.help." + CommandLineExposed.properties[i],
                type: CMD_TYPE_PROPERTY,
            });
        }

        for (var name in CommandLineExposed.userCommands)
        {
            var config = CommandLineExposed.userCommands[name];
            var prop = config.getter || config.variable;

            commands.push({
                name: name,
                desc: config.description,
                nol10n: true,
                noUserHelpUrl: !config.helpUrl,
                helpUrl: config.helpUrl ? config.helpUrl: null,
                type: prop ? CMD_TYPE_PROPERTY : CMD_TYPE_COMMAND,
            });
        }

        // Sort commands
        commands.sort(function sortName(a, b) { return a.name > b.name ? 1 : -1; });

        // Generate table
        HelpEntry.tag.insertRows({commands: commands}, tBody);
    },

    renderTips: function(context)
    {
        var row = Firebug.Console.openGroup("help", context, "help",
            TipsCaption, true, null, true);
        Firebug.Console.closeGroup(context, true);

        var logGroupBody = row.getElementsByClassName("logGroupBody")[0];
        var logContent = logGroupBody.getElementsByClassName("logContent")[0];
        var list = TipsList.tag.append({}, logContent);

        // #1) Render basic command line syntax tip
        var tip = {
            example: "1 + 1",
            text: "console.cmd.tip.javascript"
        };
        Tip.tag.append({tip: tip}, list);

        // #2) Render closure syntax tip
        tip = {
            example: "myObject.%closureVarName",
            text: "console.cmd.tip.closures"
        };

        function onClickLink()
        {
            Win.openNewTab(CLOSURE_INSPECTOR_HELP_URL);
        }

        var node = Tip.tag.append({tip: tip}, list);
        var textNode = node.getElementsByClassName("text").item(0);
        FirebugReps.Description.render(Locale.$STR(tip.text), textNode, onClickLink);
    }
});

// ********************************************************************************************* //
// Command Implementation

function onExecuteCommand(context)
{
    CommandLineHelp.render(context);
    return Firebug.Console.getDefaultReturnValue();
}

// ********************************************************************************************* //
// Registration

Firebug.registerCommand("help", {
    helpUrl: "http://getfirebug.com/wiki/index.php/help",
    handler: onExecuteCommand,
    description: Locale.$STR("console.cmd.help.help"),
    getter: true,
    isCallableGetter: true,
});

return CommandLineHelp;

// ********************************************************************************************* //
});/* See license.txt for terms of usage */

define("firebug/console/commands/commandLineInclude",
[
    "firebug/chrome/module",
    "firebug/chrome/reps",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/dom",
    "firebug/chrome/window",
    "firebug/lib/css",
    "firebug/lib/string",
    "firebug/lib/options",
    "firebug/chrome/menu",
    "firebug/lib/system",
    "firebug/lib/xpcom",
    "firebug/lib/object",
    "firebug/chrome/tableRep",
    "firebug/console/console",
    "firebug/editor/editor",
    "firebug/editor/inlineEditor",
],
function(Module, FirebugReps, Domplate, Locale, Dom, Win, Css, Str, Options, Menu, System, Xpcom,
    Obj, TableRep, Console, Editor, InlineEditor) {

// ********************************************************************************************* //
// Constants

var {domplate, DomplateTag, SPAN, TR, P, LI, A, BUTTON} = Domplate;

const Ci = Components.interfaces;
const Cu = Components.utils;
const removeConfirmation = "commandline.include.removeConfirmation";
const prompts = Xpcom.CCSV("@mozilla.org/embedcomp/prompt-service;1", "nsIPromptService");
const storeFilename = "includeAliases.json";

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

var ScratchpadManager;

try
{
    var scope = {};
    Cu.import("resource:///modules/devtools/scratchpad-manager.jsm", scope);
    ScratchpadManager = scope.ScratchpadManager;
}
catch(ex)
{
    // Scratchpad does not exists (when using Seamonkey ...)
}

var storageScope = {}, StorageService;
Cu.import("resource://firebug/storageService.js", storageScope);
StorageService = storageScope.StorageService;

var defaultAliases = {
    "jquery": "http://code.jquery.com/jquery-latest.js"
};

// ********************************************************************************************* //
// Implementation

var CommandLineIncludeRep = domplate(TableRep,
{
    tableClassName: "tableCommandLineInclude dataTable",

    tag:
        FirebugReps.OBJECTBOX({_repObject: "$object"},
            TableRep.tag
        ),

    inspectable: false,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Domplate Handlers

    getValueTag: function(object)
    {
        if (object.cons === DomplateTag)
            return object;
        else
            return TableRep.getValueTag(object);
    },

    getUrlTag: function(href, aliasName)
    {
        var urlTag =
            SPAN({style: "height:100%"},
                A({"href": href, "target": "_blank", "class": "url"},
                    Str.cropString(href, 100)
                ),
                SPAN({"class": "commands"}
                // xxxFlorent: temporarily disabled, see:
                //    http://code.google.com/p/fbug/issues/detail?id=5878#c27
                /*,
                SPAN({
                    "class":"closeButton",
                    onclick: this.deleteAlias.bind(this, aliasName),
                })*/
                )
            );

        return urlTag;
    },

    displayAliases: function(context)
    {
        var store = CommandLineInclude.getStore();
        var keys = store.getKeys();
        var arrayToDisplay = [];
        var returnValue = Firebug.Console.getDefaultReturnValue();

        if (keys.length === 0)
        {
            var msg = Locale.$STR("commandline.include.noDefinedAlias");
            Firebug.Console._log(msg, context, null, FirebugReps.Hint);
            return returnValue;
        }

        for (var i=0; i<keys.length; i++)
        {
            var aliasName = keys[i];
            arrayToDisplay.push({
                alias: SPAN({"class": "aliasName", "data-aliasname": aliasName}, aliasName),
                URL: this.getUrlTag(store.getItem(aliasName), aliasName, context)
            });
        }

        var columns = [
            {
                property: "alias",
                label: Locale.$STR("commandline.include.Alias")
            },
            {
                property: "URL",
                label: Locale.$STR("commandline.include.URL")
            }
        ];

        var input = new CommandLineIncludeObject();
        this.log(arrayToDisplay, columns, context, input);
        return returnValue;
    },

    deleteAlias: function(aliasName, ev)
    {
        // NOTE: that piece of code has not been tested since deleting aliases through the table
        // has been disabled.
        // Once it is enabled again, make sure FBTests is available for this feature
        var store = CommandLineInclude.getStore();
        if (!Options.get(removeConfirmation))
        {
            var check = {value: false};
            var flags = prompts.BUTTON_POS_0 * prompts.BUTTON_TITLE_YES +
            prompts.BUTTON_POS_1 * prompts.BUTTON_TITLE_NO;

            if (prompts.confirmEx(context.chrome.window, Locale.$STR("Firebug"),
                Locale.$STR("commandline.include.confirmDelete"), flags, "", "", "",
                Locale.$STR("Do_not_show_this_message_again"), check) > 0)
            {
                return;
            }

            // Update 'Remove Cookies' confirmation option according to the value
            // of the dialog's "do not show again" checkbox.
            Options.set(removeConfirmation, !check.value);
        }
        store.removeItem(aliasName);
    },

    startEditing: function(target)
    {
        var editor = this.getEditor(target.ownerDocument);
        Editor.startEditing(target, target.dataset.aliasname, editor);
    },

    editAliasName: function(tr)
    {
        var target = tr.querySelector(".aliasName");
        this.startEditing(target);
    },

    editAliasURL: function(tr)
    {
        var target = tr.querySelector(".url");
        this.startEditing(target);
    },

    openInScratchpad: function(url)
    {
        var spWin = ScratchpadManager.openScratchpad();
        var scriptContent = null;
        var editor = null;

        spWin.onload = function()
        {
            var spInstance = spWin.Scratchpad;
            //intro = spInstance.strings.GetStringFromName("scratchpadIntro");
            spInstance.addObserver(
            {
                onReady: function()
                {
                    editor = spInstance.editor;

                    // if the content of the script is loaded, we write the content in the editor
                    // otherwise, we write a text that asks the user to wait
                    if (scriptContent)
                        editor.setText(scriptContent);
                    else
                        editor.setText("// "+Locale.$STR("scratchpad.loading"));
                }
            });
        };

        var xhr = new XMLHttpRequest({mozAnon: true});
        xhr.open("GET", url, true);

        xhr.onload = function()
        {
            if (spWin.closed)
                return;

            scriptContent = xhr.responseText;

            // if the editor is ready, we put the content on it now
            // otherwise, we wait for the editor
            if (editor)
                editor.setText(scriptContent);
        };

        xhr.onerror = function()
        {
            if (spWin.closed)
                return;

            spInstance.setText("// "+Locale.$STR("scratchpad.failLoading"));
        };

        xhr.send(null);
    },

    supportsObject: function(object, type)
    {
        return object instanceof CommandLineIncludeObject;
    },

    getContextMenuItems: function(object, target, context)
    {
        var tr = Dom.getAncestorByTagName(target, "tr");
        if (!tr)
            return [];

        var url = tr.querySelector("a.url").href;
        var aliasName = tr.querySelector(".aliasName").dataset.aliasname;
        var context = Firebug.currentContext;
        var items = [
            {
                label: "CopyLocation",
                id: "fbCopyLocation",
                tooltiptext: "clipboard.tip.Copy_Location",
                command: Obj.bindFixed(System.copyToClipboard, System, url)
            },
            // xxxFlorent: temporarily disabled, see:
            //    http://code.google.com/p/fbug/issues/detail?id=5878#c27
            /*"-",
            {
                label: "commandline.label.EditAliasName",
                id: "fbEditAliasName",
                tooltiptext: "commandline.tip.Edit_Alias_Name",
                command: this.editAliasName.bind(this, tr)
            },
            {
                label: "commandline.label.EditAliasURL",
                id: "fbEditAliasUrl",
                tooltiptext: "commandline.tip.Edit_Alias_URL",
                command: this.editAliasURL.bind(this, tr)
            },
            {
                label: "commandline.label.DeleteAlias",
                id: "fbDeleteAlias",
                tooltiptext: "commandline.tip.Delete_Alias",
                command: this.deleteAlias.bind(this, aliasName, ev)
            },*/
            "-",
            {
                label: Locale.$STRF("commandline.label.IncludeScript", [aliasName]),
                id: "fbInclude",
                tooltiptext: "commandline.tip.Include_Script",
                command: Obj.bindFixed(CommandLineInclude.include, CommandLineInclude,
                    context, aliasName)
            },
            "-",
            {
                label: "OpenInTab",
                id: "fbOpenInTab",
                tooltiptext: "firebug.tip.Open_In_Tab",
                command: Obj.bindFixed(Win.openNewTab, Win, url)
            }
        ];

        if (ScratchpadManager)
        {
            items.push({
                label: "commandline.label.OpenInScratchpad",
                id: "fbOpenInScratchpad",
                tooltiptext: "commandline.tip.Open_In_Scratchpad",
                command: this.openInScratchpad.bind(this, url)
            });
        }

        return items;
    },

    getEditor: function(doc)
    {
        if (!this.editor)
            this.editor = new IncludeEditor(doc);
        return this.editor;
    }
});

// ********************************************************************************************* //

function CommandLineIncludeObject()
{
}

// ********************************************************************************************* //

var CommandLineInclude = Obj.extend(Module,
{
    onSuccess: function(newAlias, context, loadingMsgRow, xhr, hasWarnings)
    {
        var urlComponent = xhr.channel.URI.QueryInterface(Ci.nsIURL);
        var filename = urlComponent.fileName, url = urlComponent.spec;
        // clear the message saying "loading..."
        this.clearLoadingMessage(loadingMsgRow);

        if (newAlias)
        {
            var store = this.getStore();
            store.setItem(newAlias, url);
            this._log("aliasCreated", [newAlias], [context, "info"]);
        }

        if (!hasWarnings)
            this._log("includeSuccess", [filename], [context, "info", true]);
    },

    onError: function(context, url, loadingMsgRow)
    {
        this.clearLoadingMessage(loadingMsgRow);
        this._log("loadFail", [url], [context, "error"]);
    },

    clearLoadingMessage: function(loadingMsgRow)
    {
        if (loadingMsgRow && loadingMsgRow.parentNode)
            loadingMsgRow.parentNode.removeChild(loadingMsgRow);
    },

    getStore: function()
    {
        if (!this.store)
        {
            var isNewStore = !StorageService.hasStorage(storeFilename);
            // Pass also the parent window to the new storage. The window will be
            // used to figure out whether the browser is running in private mode.
            // If yes, no data will be persisted.
            this.store = StorageService.getStorage(storeFilename,
                Firebug.chrome.window);

            // If the file did not exist, we put in there the default aliases.
            if (isNewStore)
            {
                for (var alias in defaultAliases)
                    this.store.setItem(alias, defaultAliases[alias]);
            }
        }

        // Let's log when the store could not be opened.
        if (!this.store)
        {
            if (FBTrace.DBG_COMMANDLINE)
                FBTrace.sysout("CommandLineInclude.getStore; can't open or create the store");
        }

        return this.store;
    },

    // xxxFlorent: Prefix with underscore until we fix Issue 6806
    // since we're listening to Firebug.Console events.
    _log: function(localeStr, localeArgs, logArgs, noAutoPrefix)
    {
        var prefixedLocaleStr = (noAutoPrefix ? localeStr : "commandline.include." + localeStr);
        var msg = Locale.$STRF(prefixedLocaleStr, localeArgs);
        logArgs.unshift([msg]);
        return Firebug.Console.logFormatted.apply(Firebug.Console, logArgs);
    },

    /**
     * Includes a remote script.
     * Executed by the include() command.
     *
     * @param {Context} context The Firebug context.
     * @param {string} url The location of the script.
     * @param {string} [newAlias] The alias to define for the script.
     */
    include: function(context, url, newAlias)
    {
        var reNotAlias = /[\.\/]/;
        var urlIsAlias = url !== null && !reNotAlias.test(url);
        var returnValue = Firebug.Console.getDefaultReturnValue();

        // checking arguments:
        if ((newAlias !== undefined && typeof newAlias !== "string") || newAlias === "")
        {
            this._log("invalidAliasArgumentType", [], [context, "error"]);
            return returnValue;
        }

        if (url !== null && typeof url !== "string" || !url && !newAlias)
        {
            this._log("invalidUrlArgumentType", [], [context, "error"]);
            return returnValue;
        }

        if (newAlias !== undefined)
            newAlias = newAlias.toLowerCase();

        if ((urlIsAlias && url.length > 30) || (newAlias && newAlias.length > 30))
        {
            this._log("tooLongAliasName", [newAlias || url], [context, "error"]);
            return returnValue;
        }

        if (newAlias !== undefined && reNotAlias.test(newAlias))
        {
            this._log("invalidAliasName", [newAlias], [context, "error"]);
            return returnValue;
        }

        if (urlIsAlias)
        {
            var store = this.getStore();
            var aliasName = url.toLowerCase();
            url = store.getItem(aliasName);
            if (url === undefined)
            {
                this._log("aliasNotFound", [aliasName], [context, "error"]);
                return returnValue;
            }
        }

        // if the URL is null, we delete the alias
        if (newAlias !== undefined && url === null)
        {
            var store = this.getStore();
            if (store.getItem(newAlias) === undefined)
            {
                this._log("aliasNotFound", [newAlias], [context, "error"]);
                return returnValue;
            }

            store.removeItem(newAlias);
            this._log("aliasRemoved", [newAlias], [context, "info"]);
            return returnValue;
        }
        var loadingMsgRow = this._log("Loading", [], [context, "loading", true], true);
        var onSuccess = this.onSuccess.bind(this, newAlias, context, loadingMsgRow);
        var onError = Obj.bindFixed(this.onError, this, context, url, loadingMsgRow);
        this.evaluateRemoteScript(url, context, onSuccess, onError, loadingMsgRow);

        return returnValue;
    },

    /**
     * Evaluates a remote script. Prints a warning message in the console in case of syntax error.
     *
     * @param {string} url The URL.
     * @param {Context} context The Firebug context.
     * @param {function} [successFunction] The callback if the script has been successfully run.
     * @param {function} [errorFunction] The callback if the expression has been run with errors.
     * @param {*} [loadingMsgRow] The row in the console printed while the script is loading and
     *      that has to be cleared.
     */
    evaluateRemoteScript: function(url, context, successFunction, errorFunction, loadingMsgRow)
    {
        var xhr = new XMLHttpRequest({ mozAnon: true, timeout:30});
        var acceptedSchemes = ["http", "https"];
        var absoluteURL = context.browser.currentURI.resolve(url);

        xhr.onload = function()
        {
            if (xhr.status !== 200)
                return errorFunction.apply(this, arguments);
            var codeToEval = xhr.responseText;
            var hasWarnings = false;

            // test if the content is an HTML file, which is the most current after a mistake
            if (!isValidJS(codeToEval))
            {
                CommandLineInclude._log("invalidSyntax", [], [context, "warn"]);
                CommandLineInclude.clearLoadingMessage(loadingMsgRow);
                hasWarnings = true;
            }

            // Do not print anything if  the inclusion succeeds.
            var successFunctionEval = function() { };
            // Let's use the default function to handle errors.
            var errorFunctionEval = null;

            // xxxFlorent: Using evaluateInGlobal doesn't allow to stop execution in the script
            //             panel. Just use it when having CSP until we migrate to JSD2.
            //             (see Issue 6551)
            if (CommandLineInclude.isCSPDoc(context))
            {
                if (FBTrace.DBG_COMMANDLINE)
                {
                    FBTrace.sysout("CommandLineInclude.evaluateRemoteScript; "+
                        "document is using CSP. use evaluateInGlobal");
                }
                Firebug.CommandLine.evaluateInGlobal(codeToEval, context, undefined, undefined,
                    successFunctionEval, errorFunctionEval, undefined, {noCmdLineAPI: true});
            }
            else
            {
                Firebug.CommandLine.evaluateInWebPage(codeToEval, context);
            }

            if (successFunction)
                successFunction(xhr, hasWarnings);
        };

        if (errorFunction)
        {
            xhr.ontimeout = xhr.onerror = errorFunction;
        }

        try
        {
            xhr.open("GET", absoluteURL, true);
        }
        catch(ex)
        {
            this.clearLoadingMessage(loadingMsgRow);
            if (ex.name === "NS_ERROR_UNKNOWN_PROTOCOL")
            {
                this._log("invalidRequestProtocol", [], [context, "error"]);
                return;
            }
            throw ex;
        }

        if (acceptedSchemes.indexOf(xhr.channel.URI.scheme) === -1)
        {
            this._log("invalidRequestProtocol", [], [context, "error"]);
            this.clearLoadingMessage(loadingMsgRow);
            return;
        }

        xhr.send(null);
    },

    /**
     * Hack; Should only be used inside CommandLineInclude.
     * Test whether the current global is under CSP.
     *
     * @param {Context} context
     *
     * @return boolean
     */
    isCSPDoc: function(context)
    {
        // Create a random variable name:
        var varName = "_" + Math.ceil(Math.random() * 1000000);
        var codeToEval = "window['" + varName + "']" + " = true;";

        var global = context.getCurrentGlobal();

        context.includePatternToBlock = codeToEval;
        Firebug.CommandLine.evaluateInWebPage(codeToEval, context);
        var ret = global.wrappedJSObject[varName] !== true;

        if (ret)
            delete global.wrappedJSObject[varName];

        return ret;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *  //
    // Module events:

    resetAllOptions: function()
    {
        if (StorageService.hasStorage(storeFilename))
        {
            StorageService.removeStorage(storeFilename);
            this.store = null;
        }
    },

    /**
     * Hack; Should only be used inside CommandLineInclude.
     * Intercept the display of a warning if related to the use of isCSPDoc().
     *
     * Event triggered by Firebug.Console.logRow().
     */
    onLogRowCreated: function(panel, row, context)
    {
        if (row && row.className.indexOf("warningMessage") !== -1 &&
            context.includePatternToBlock &&
            row.textContent.indexOf(context.includePatternToBlock) !== -1)
        {
            row.parentNode.removeChild(row);
            context.includePatternToBlock = "";
        }
    }
});

// ********************************************************************************************* //
// Command Handler

function onCommand(context, args)
{
    if (args.length === 0)
        return CommandLineIncludeRep.displayAliases(context);

    var self = CommandLineInclude;
    Array.unshift(args, context);
    return CommandLineInclude.include.apply(self, args);
}

// ********************************************************************************************* //
// Local Helpers

function IncludeEditor(doc)
{
    InlineEditor.call(this, doc);
}

IncludeEditor.prototype = domplate(InlineEditor.prototype,
{
    endEditing: function(target, value, cancel)
    {
        if (cancel)
            return;

        var context = Firebug.currentContext;
        if (Css.hasClass(target, "aliasName"))
            this.updateAliasName(target, value, context);
        else if (Css.hasClass(target, "url"))
            this.updateURL(target, value, context);
    },

    updateURL: function(target, value, context)
    {
        var tr = Dom.getAncestorByTagName(target, "tr");
        var aliasName = tr.querySelector(".aliasName").textContent;
        CommandLineInclude.include(context, value, aliasName, {"onlyUpdate":true});
        target.textContent = value;
    },

    updateAliasName: function(target, value, context)
    {
        var oldAliasName = target.textContent;
        var store = CommandLineInclude.getStore();
        var url = store.getItem(oldAliasName);
        store.removeItem(oldAliasName);
        store.setItem(value, url);
        target.dataset.aliasname = value;
        target.textContent = value;
    }
});

function isValidJS(codeToCheck)
{
    try
    {
        new Function(codeToCheck);
        return true;
    }
    catch(ex)
    {
        if (ex instanceof SyntaxError)
            return false;
        else
            throw ex;
    }
};

// ********************************************************************************************* //
// Registration

Firebug.registerCommand("include", {
    handler: onCommand,
    description: Locale.$STR("console.cmd.help.include"),
    helpUrl: "http://getfirebug.com/wiki/index.php/include"
});

Firebug.registerRep(CommandLineIncludeRep);

Firebug.registerModule(CommandLineInclude);
Console.addListener(CommandLineInclude);

return CommandLineInclude;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/commands/eventMonitor",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/events",
    "firebug/lib/locale",
    "firebug/lib/dom",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/chrome/menu",
],
function(Module, Obj, Firebug, FBTrace, Events, Locale, Dom, Domplate, FirebugReps, Menu) {

"use strict";

// ********************************************************************************************* //
// EventMonitor Module

var EventMonitor = Obj.extend(Module,
{
    dispatchName: "eventMonitor",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);
        Firebug.registerUIListener(this);
    },

    shutdown: function()
    {
        Firebug.unregisterUIListener(this);
        Module.shutdown.apply(this, arguments);
    },

    destroyContext: function(context, persistedState)
    {
        // Clean up all existing monitors.
        var monitoredEvents = context.monitoredEvents;
        if (monitoredEvents)
        {
            for (var i=0; i<monitoredEvents.length; ++i)
            {
                var m = monitoredEvents[i];

                if (!m.type)
                    Events.detachAllListeners(m.object, context.onMonitorEvent, context);
                else
                    Events.removeEventListener(m.object, m.type, context.onMonitorEvent, false);
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Event Monitor

    toggleMonitorEvents: function(object, types, monitor, context)
    {
        if (monitor)
            this.monitorEvents(object, types, context);
        else
            this.unmonitorEvents(object, types, context);
    },

    monitorEvents: function(object, types, context)
    {
        if (object && object.addEventListener)
        {
            if (!context.onMonitorEvent)
            {
                var self = this;
                context.onMonitorEvent = function(event) {
                    self.onMonitorEvent(event, context);
                };
            }

            if (!context.monitoredEvents)
                context.monitoredEvents = new Map();

            var monitoredEvents = context.monitoredEvents;
            var eventTypes = getMonitoredEventTypes(types);

            if (FBTrace.DBG_EVENTS)
                FBTrace.sysout("EventMonitor.monitorEvents", eventTypes);

            if (!context.monitoredEvents.has(object))
                context.monitoredEvents.set(object, new Set());

            var monitoredEventTypes = monitoredEvents.get(object);
            for (var i = 0, len = eventTypes.length; i < len; ++i)
            {
                if (!this.areEventsMonitored(object, eventTypes[i], context))
                {
                    Events.addEventListener(object, eventTypes[i], context.onMonitorEvent, false);
                    monitoredEventTypes.add(eventTypes[i]);
                }
            }
        }
    },

    unmonitorEvents: function(object, types, context)
    {
        var monitoredEvents = context.monitoredEvents;

        if (!monitoredEvents)
            return;

        var eventTypes = getMonitoredEventTypes(types);

        if (FBTrace.DBG_EVENTS)
            FBTrace.sysout("EventMonitor.unmonitorEvents", eventTypes);

        if (object)
        {
            if (monitoredEvents.has(object))
            {
                var monitoredObjectEvents = monitoredEvents.get(object);
                for (var i = 0, len = eventTypes.length; i < len; ++i)
                {
                     if (monitoredObjectEvents.has(eventTypes[i]))
                     {
                        Events.removeEventListener(object, eventTypes[i],
                            context.onMonitorEvent, false);
                        monitoredObjectEvents["delete"](eventTypes[i]);
                     }
                }
            }
        }
    },

    areEventsMonitored: function(object, types, context, allMonitored)
    {
        var monitoredEvents = context.monitoredEvents;
        if (!monitoredEvents)
        {
            if (FBTrace.DBG_EVENTS)
                FBTrace.sysout("EventMonitor.areEventsMonitored - No events monitored", object);

            return false;
        }

        var eventTypes = getMonitoredEventTypes(types);
        var monitoredObjectEvents = monitoredEvents.get(object);
        if (!monitoredObjectEvents)
            return false;

        if (typeof allMonitored == "undefined")
            allMonitored = true;

        for (var i=0, len=eventTypes.length; i<len; ++i)
        {
            var monitored = monitoredObjectEvents.has(eventTypes[i]);

            if (!monitored)
            {
                if (FBTrace.DBG_EVENTS)
                {
                    FBTrace.sysout("EventMonitor.areEventsMonitored - Events not monitored for '" +
                        eventTypes[i] + "'");
                }

                if (allMonitored)
                    return false;
            }
            else
            {
                if (FBTrace.DBG_EVENTS)
                {
                    FBTrace.sysout("EventMonitor.areEventsMonitored - Events monitored for '" +
                        eventTypes[i] + "'");
                }

                if (!allMonitored)
                    return true;
            }
        }

        return allMonitored;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Logging

    onMonitorEvent: function(event, context)
    {
        var obj = new EventLog(event);
        Firebug.Console.log(obj, context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Listener

    onContextMenu: function(items, object, target, context, panel, popup)
    {
        if (panel.name != "html")
            return items;

        var before = popup.querySelector("#fbScrollIntoView");
        if (!before)
            return items;

        var elt = object;

        function onToggleAll(event)
        {
            Events.cancelEvent(event);

            var checked = event.target.getAttribute("checked") == "true";
            var menupopup = event.target.parentNode;

            // Iterate over all event families (menu items) and check/uncheck them.
            var child = menupopup.firstChild;
            while (child)
            {
                if (child.tagName != "separator" && child.id != "fbLogAllEvents")
                    child.setAttribute("checked", checked ? "true" : "false");

                child = child.nextSibling;
            }

            this.toggleMonitorEvents(elt, null, checked, context);
        }

        var logEventItems = [];

        // The first item allows to select all event type (families) at once. Just like if
        // the user clicks directly the parent item (it's split-menu).
        logEventItems.push({
            label: "html.logAllEvents",
            tooltiptext: "html.logAllEvents.tip",
            id: "fbLogAllEvents",
            type: "checkbox",
            checked: this.areEventsMonitored(elt, null, context, true),
            command: onToggleAll.bind(this),
        });

        logEventItems.push("-");

        // Create sub-menu-items for "Log Event"
        var eventFamilies = Events.getEventFamilies();
        for (var i=0, count=eventFamilies.length; i<count; ++i)
        {
            var family = eventFamilies[i];

            // Compose a tooltip for the menu item.
            var tooltipText = "Monitor " + eventFamilies[i] + " events:";
            var types = Events.getEventTypes(family);
            tooltipText += "\n" + types.join(", ");

            // xxxHonza: there could be a helper for getting the CSS selector
            var Element = FirebugReps.Element;
            var selector = Element.getSelectorTag(elt) +
                Element.getSelectorId(elt) +
                Element.getSelectorClasses(elt);

            // xxxHonza: localization?
            tooltipText += "\n\nCommand Line Example:\n" +
                "monitorEvents($('" + selector + "'), '" + family + "')";

            logEventItems.push({
                nol10n: true,
                label: Locale.$STR(family),
                tooltiptext: tooltipText,
                id: "monitor" + family + "Events",
                type: "checkbox",
                checked: this.areEventsMonitored(elt, family, context),
                command: Obj.bind(this.onToggleMonitorEvents, this, elt, family, context)
            });
        }

        // Helper for monitoring all event families at once.
        function onCommand(event)
        {
            Events.cancelEvent(event);

            var checked = this.areEventsMonitored(elt, null, context, false);
            this.toggleMonitorEvents(elt, null, !checked, context);
        }

        var item = {
            label: "ShowEventsInConsole",
            tooltiptext: "html.tip.Show_Events_In_Console",
            id: "fbShowEventsInConsole",
            items: logEventItems
        };

        var logEventsItem = Menu.createMenuItem(popup, item, before);
        var separator = Menu.createMenuItem(popup, "-", before);

        return items;
    },

    onToggleMonitorEvents: function(event, elt, type, context)
    {
        var checked = event.target.getAttribute("checked") == "true";
        this.toggleMonitorEvents(elt, type, checked, context);

        Events.cancelEvent(event);

        // The 'Log All Events' helper item.
        var doc = event.target.ownerDocument;
        var logAllEvents = doc.getElementById("fbLogAllEvents");
        logAllEvents.setAttribute("checked", this.areEventsMonitored(elt, null, context, true));
    },
});

// ********************************************************************************************* //
// Helpers

function getMonitoredEventTypes(types)
{
    var eventTypes = [];
    if (!types)
    {
        eventTypes = Events.getEventTypes();
    }
    else
    {
        if (typeof types == "string")
        {
            eventTypes = Events.isEventFamily(types) ? Events.getEventTypes(types) : [types];
        }
        else
        {
            for (var i = 0; i < types.length; ++i)
            {
                if (Events.isEventFamily(types[i]))
                {
                    var familyEventTypes = Events.getEventTypes(types[i]);
                    for (var j = 0; j < familyEventTypes.length; ++j)
                        eventTypes.push(familyEventTypes[j]);
                }
                else
                {
                    eventTypes.push(types[i]);
                }
            }
        }
    }

    return eventTypes;
}

// ********************************************************************************************* //
// Rep Object

var EventLog = function(event)
{
    this.event = event;
};

// ********************************************************************************************* //
// Rep Template

var {domplate, TAG, SPAN} = Domplate;

var EventLogRep = domplate(FirebugReps.Event,
{
    className: "eventLog",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    tag:
        TAG("$copyEventTag", {object: "$object|copyEvent"}),

    copyEventTag:
        SPAN(
            FirebugReps.OBJECTLINK("$object|summarizeEvent"),
            SPAN("&nbsp;"),
            SPAN("&#187;"),
            SPAN("&nbsp;"),
            TAG("$object|getTargetTag", {object: "$object|getTarget"})
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    copyEvent: function(log)
    {
        return new Dom.EventCopy(log.event);
    },

    getTarget: function(event)
    {
        return event.target;
    },

    getTargetTag: function(event)
    {
        var rep = Firebug.getRep(event.target);
        return rep.shortTag ? rep.shortTag : rep.tag;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsObject: function(object, type)
    {
        return object instanceof EventLog;
    },
});

// ********************************************************************************************* //
// CommandLine Support

function monitorEvents(context, args)
{
    var object = args[0];
    var types = args[1];

    EventMonitor.monitorEvents(object, types, context);
    return Firebug.Console.getDefaultReturnValue();
}

function unmonitorEvents(context, args)
{
    var object = args[0];
    var types = args[1];

    EventMonitor.unmonitorEvents(object, types, context);
    return Firebug.Console.getDefaultReturnValue();
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(EventMonitor);
Firebug.registerRep(EventLogRep);

Firebug.registerCommand("monitorEvents", {
    handler: monitorEvents.bind(this),
    helpUrl: "http://getfirebug.com/wiki/index.php/monitorEvents",
    description: Locale.$STR("console.cmd.help.monitorEvents")
});

Firebug.registerCommand("unmonitorEvents", {
    handler: unmonitorEvents.bind(this),
    helpUrl: "http://getfirebug.com/wiki/index.php/unmonitorEvents",
    description: Locale.$STR("console.cmd.help.unmonitorEvents")
});

return EventMonitor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*global define:1*/

define("firebug/console/commands/getEventListeners",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/wrapper",
    "firebug/lib/events",
    "firebug/lib/domplate",
    "firebug/console/console",
    "firebug/chrome/tableRep",
],
function(Firebug, Module, FBTrace, Obj, Locale, Wrapper, Events, Domplate, Console,
    TableRep) {

"use strict";

// ********************************************************************************************* //
// Resources

// Bug 912874 - New API to enumerate mutation observers
// Bug 448602 - Have a way to enumerate event listeners
// Issue 6740: Display registered MutationObservers for an element

// ********************************************************************************************* //
// Constants

var {domplate, SPAN, TAG} = Domplate;

var TraceError = FBTrace.to("DBG_ERRORS");

var mutationObservers = "MutationObservers";
var parents = "Parents";

// ********************************************************************************************* //
// Module Implementation

/**
 * @module The modules registers a console listeners that logs a pretty-printed
 * information about listeners and mutation observers for a target element.
 *
 * The log lists listeners/observers registered for the target element as well as those
 * registered for parent elements.
 *
 * The pretty-print log is made only for getEventListeners() return value. So, if the method
 * is used within an expression where the return value is e.g. a particular
 * listener, the pretty-print log is not created.
 *
 * Examples:
 * > getEventListeners(target);             // pretty print log is created.
 * > getEventListeners(target).click[0];    // pretty print log is not created.
 */
var GetEventListenersModule = Obj.extend(Module,
/** @lends GetEventListenersModule */
{
    dispatchName: "getEventListenersModule",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    initialize: function()
    {
        Module.initialize.apply(this, arguments);
        Console.addListener(this);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);
        Console.removeListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Console Listener

    log: function(context, object, className, sourceLink)
    {
        if (!context || !object)
            return;

        // The log we are waiting for must be Object type.
        if (typeof(object) != "object")
            return;

        var cache = context.getEventListenersCache;
        if (!cache)
            return false;

        // Objects keys in the cache-map are using wrappers, so don't forget to
        // wrap it before lookup. The map is initialized within onExecuteCommand
        // where the Console log object is created (and exposed to the content).
        object = Wrapper.wrapObject(object);

        // If the currently logged object is stored within the cache-map, we are dealing
        // with a return value of getEventListeners() command. In such case we can append
        // additional pretty-printed info into the Console panel.
        var logInfo = cache.get(object);
        if (logInfo)
            consoleLog(context, logInfo.target, logInfo.listeners, logInfo.observers);
    },
});

// ********************************************************************************************* //
// Command Implementation

/**
 * This function is executed by the framework when getEventListener() is executed
 * on the command line. The first argument must be reference to the target element.
 */
function onExecuteCommand(context, args)
{
    var target = args[0];
    var noParents = args[1] || false;

    if (typeof target !== "object" || target === null)
        return undefined;

    try
    {
        var result = {};

        // Get event listeners and construct the result log-object.
        var listeners = getEventListeners(target, !noParents);
        var map = getListenerMap(listeners.targetListeners);
        if (map)
            result = map;

        // parentListeners array is empty in case of noParents == true.
        map = getListenerMap(listeners.parentListeners);
        if (map)
            result[parents] = map;

        // Append also mutation observers into the result (if there are any).
        var observers = getMutationObservers(target, !noParents);
        if (observers.targetObservers && observers.targetObservers.length > 0)
            result[mutationObservers] = observers.targetObservers;

        // parentObservers array is empty in case of noParents == true.
        if (observers.parentObservers && observers.parentObservers.length > 0)
        {
            if (!result[mutationObservers])
                result[mutationObservers] = [];

            var array = result[mutationObservers];
            array[parents] = observers.parentObservers;
        }

        // Make sure the result structure with listeners and observers is properly
        // cloned into the content scope.
        var global = context.getCurrentGlobal();
        var recursiveClone = function(obj)
        {
            var res;
            if (Array.isArray(obj))
                res = [];
            else if (obj instanceof Object && Object.getPrototypeOf(obj) === Object.prototype)
                res = {};
            else
                return obj;
            for (var prop in obj)
                res[prop] = recursiveClone(obj[prop]);
            return Wrapper.cloneIntoContentScope(global, res);
        };
        var object = recursiveClone(result);

        if (!context.getEventListenersCache)
            context.getEventListenersCache = new WeakMap();

        // The logged object doesn't have any specific type since returned from
        // Wrapper.cloneIntoContentScope, which is based on Cu.createObjectIn.
        // (using specific types will be able as soon as bug 914970 is fixed)
        // So, store the result logged-object into a weak-map, which will be used
        // later (within 'log' event handler) to figure out whether additional
        // pretty-printed logs should be appended in to the Console.
        // See {@GetEventListenersModule} above.
        context.getEventListenersCache.set(Wrapper.wrapObject(object), {
            target: target,
            listeners: listeners,
            observers: observers
        });

        return object;
    }
    catch (exc)
    {
        TraceError.sysout("getEventListeners FAILS " + exc, exc);
    }

    return undefined;
}

// ********************************************************************************************* //
// Event Listeners

/**
 * Get sorted list of listeners registered for the target and list of listeners
 * registered for all ancestor elements (if required).
 *
 * @param context {TabContext} The current Firebug context.
 * @param target {Object} The event target for which listeners should be returned.
 * @param includeParents {Boolean} True if parent listeners should also be returned.
 */
function getEventListeners(target, includeParents)
{
    var targetListeners;
    var parentListeners = [];

    // Iterate also all parent nodes and look for listeners that can be
    // executed during bubble phase.
    var element = target;
    while (element)
    {
        try
        {
            var listeners = Events.getEventListenersForTarget(element);

            // Listeners coming from parent elements are stored into
            // parentListeners array.
            if (!targetListeners)
            {
                targetListeners = listeners;
            }
            else
            {
                parentListeners.push.apply(parentListeners, listeners.filter(function(listener)
                {
                    return Events.eventTypeBubblesToDocument(listener.type);
                }));
            }
        }
        catch (exc)
        {
            TraceError.sysout("getEventListenersForTarget threw an EXCEPTION " + exc, exc);
            return undefined;
        }

        // Break the loop if we don't need listeners for element ancestors.
        if (!includeParents)
            break;

        // Use 'parentElement' so, document isn't included as a parent. The document
        // object is special case handled below.
        element = element.parentElement;
    }

    // Special case for document object.
    var doc = target.ownerDocument;
    if (doc && includeParents && target != doc)
    {
        var listeners = Events.getEventListenersForTarget(doc);
        parentListeners.push.apply(parentListeners, listeners.filter(function(listener)
        {
            return Events.eventTypeBubblesToDocument(listener.type);
        }));
    }

    // Special case for window object.
    var win = doc && doc.defaultView;
    if (win && includeParents && target != win)
    {
        var listeners = Events.getEventListenersForTarget(win);
        parentListeners.push.apply(parentListeners, listeners.filter(function(listener)
        {
            return Events.eventTypeBubblesToDocument(listener.type);
        }));
    }

    function sort(a, b)
    {
        if (a.type === b.type)
            return 0;
        return (a.type < b.type ? -1 : 1);
    }

    // Sort listeners by type in alphabetical order, so they show up as such
    // in the returned object.
    targetListeners.sort(sort);
    parentListeners.sort(sort);

    return {
        targetListeners: targetListeners,
        parentListeners: parentListeners
    };
}

/**
 * Transform simple array of listeners into a structure that is directly logged
 * into the Console panel. Note that this result log can be further inspected by the user
 * within the DOM panel.
 */
function getListenerMap(listeners)
{
    if (!listeners || !listeners.length)
        return undefined;

    var map = {};

    for (var i = 0; i < listeners.length; i++)
    {
        var li = listeners[i];
        if (!map[li.type])
            map[li.type] = [];

        map[li.type].push({
            listener: li.func,
            useCapture: li.capturing,
            target: li.target,
        });
    }

    return map;
}

// ********************************************************************************************* //
// Mutation Observers

/**
 * Get list of mutation observers registered for given target as well as list of observers
 * registered for parent elements (if required). Observers registered for parent elements
 * must have 'subtree' flag set to 'true' to be included in the result list.
 */
function getMutationObservers(target, includeParents)
{
    var targetObservers;
    var parentObservers = [];

    // Iterate all parent nodes and look for observers that are watching
    // also children nodes (subtree == true)
    var element = target;
    while (element)
    {
        var parent = targetObservers;
        var result = getMutationObserversForTarget(element, parent);

        if (!parent)
            targetObservers = result;
        else
            parentObservers.push.apply(parentObservers, result);

        // Break the loop if observers registered for target ancestors aren't required.
        if (!includeParents)
            break;

        element = element.parentNode;
    }

    return {
        targetObservers: targetObservers,
        parentObservers: parentObservers
    };
}

/**
 * Get list of observers registered for specific target.
 */
function getMutationObserversForTarget(target, parent)
{
    var result = [];

    // getBoundMutationObservers() API has been introduced in Firefox 23
    // Also |window| that can be passed as an event target doeesn't implement
    // the method.
    if (typeof(target.getBoundMutationObservers) != "function")
        return result;

    // Get all mutation observers registered for given target.
    var observers = target.getBoundMutationObservers();
    for (var i=0; i<observers.length; i++)
    {
        var observer = observers[i];
        var observingInfo = observer.getObservingInfo();
        for (var j=0; j<observingInfo.length; j++)
        {
            var info = observingInfo[j];

            // Get only observers that are registered for:
            // a) the original target
            // b) a parent element with subtree == true.
            if (parent && !info.subtree)
                continue;

            // OK, insert the observer into the result array.
            result.push({
                attributeOldValue: info.attributeOldValue,
                attributes: info.attributes,
                characterData: info.characterData,
                characterDataOldValue: info.characterDataOldValue,
                childList: info.childList,
                subtree: info.subtree,
                observedNode: info.observedNode,
                mutationCallback: observer.mutationCallback,
            });
        }
    }

    return result;
}

// ********************************************************************************************* //
// Console Logging

/**
 * Append pretty-printed information about listeners and mutation observers (for a target)
 * into the Console panel.
 */
function consoleLog(context, target, listenersObj, observersObj)
{
    var input = {
        target: target,
    };

    // Display listeners registered for the target as well as any possible
    // listeners registered for parent elements.
    var listeners = [];
    listeners.push.apply(listeners, listenersObj.targetListeners);
    listeners.push.apply(listeners, listenersObj.parentListeners);

    if (listeners && listeners.length > 0)
    {
        // Group for event listeners list
        input.title = Locale.$STR("eventListeners.group_title");
        Console.openCollapsedGroup(input, context, "eventListenersDetails",
            GroupCaption, true, null, true);

        TableRep.log(listeners, ["type", "capturing", "allowsUntrusted", "func", "target"], context);
        Console.closeGroup(context, true);
    }

    // Similarly as for listeners, the observers list is computed for those observers
    // registered for the target as well as those registered for any ancestor.
    var observers = [];
    observers.push.apply(observers, observersObj.targetObservers);
    observers.push.apply(observers, observersObj.parentObservers);

    if (observers && observers.length > 0)
    {
        // Group for mutation observers list
        input.title = Locale.$STR("mutationObservers.group_title");
        Console.openCollapsedGroup(input, context, "eventListenersDetails",
            GroupCaption, true, null, true);

        TableRep.log(observers, ["attributeOldValue", "attributes", "characterData",
            "characterDataOldValue", "childList", "subtree", "mutationCallback",
            "observedNode"], context);

        Console.closeGroup(context, true);
    }
}

// ********************************************************************************************* //
// Domplate Templates

var GroupCaption = domplate(
{
    tag:
        SPAN({"class": "eventListenersTitle"},
            SPAN({"class": "eventListenersCaption"},
                "$object.title"
            ),
            SPAN("&nbsp;"),
            SPAN("&#187;"),
            SPAN("&nbsp;"),
            SPAN({"class": "eventListenersTarget"},
                TAG("$object|getTargetTag", {object: "$object.target"})
            )
        ),

    getTargetTag: function(object)
    {
        var rep = Firebug.getRep(object.target);
        return rep.shortTag ? rep.shortTag : rep.tag;
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(GetEventListenersModule);

Firebug.registerCommand("getEventListeners", {
    helpUrl: "https://getfirebug.com/wiki/index.php/getEventListeners",
    handler: onExecuteCommand.bind(this),
    description: Locale.$STR("console.cmd.help.getEventListeners")
});

return {
    getEventListeners: onExecuteCommand
};

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/commands/lastCommandLineResult",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/lib/trace",
    "firebug/console/console",
    "firebug/console/commandLine",
    "firebug/lib/locale",
    "firebug/lib/object",
],
function(Firebug, Module, FBTrace, Console, CommandLine, Locale, Obj) {

// ********************************************************************************************* //
// CommandLine Listener

var LastCommandLineResult = Obj.extend(Module,
{
    dispatchName: "LastCommandLineResult",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Extends Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        CommandLine.addListener(this);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        CommandLine.removeListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // CommandLine Listener

    expressionEvaluated: function(context, expr, result, success)
    {
        // Remember the last evaluated result (only in case of success).
        if (success)
            context.lastCommandLineResult = result;
    }
});

// ********************************************************************************************* //
// Command Implementation

function onExecuteCommand(context)
{
    return context.lastCommandLineResult;
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(LastCommandLineResult);

Firebug.registerCommand("$_", {
    variable: true,
    helpUrl: "https://getfirebug.com/wiki/index.php/Dollar-underscore",
    handler: onExecuteCommand.bind(this),
    description: Locale.$STR("console.cmd.help.$_")
});

return LastCommandLineResult;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/commands/profiler",
[
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/wrapper",
    "firebug/lib/url",
    "firebug/js/stackFrame",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/string",
    "firebug/js/fbs",
],
function(Module, Rep, Obj, Firebug, Domplate, FirebugReps, Locale, Wrapper, Url, StackFrame,
    Events, Css, Dom, Str, FBS) {

// ********************************************************************************************* //
// Constants

var {domplate, TAG, DIV, SPAN, TD, TR, TH, TABLE, THEAD, TBODY, P, UL, LI, A} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //
// Profiler

Firebug.Profiler = Obj.extend(Module,
{
    dispatchName: "profiler",

    profilerEnabled: false,

    initialize: function()
    {
        Firebug.connection.addListener(this);
    },

    shutdown: function()
    {
        Firebug.connection.removeListener(this);
    },

    showContext: function(browser, context)
    {
        this.setEnabled(context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Activation

    showPanel: function(browser, panel)
    {
        if (FBTrace.DBG_PROFILER)
            FBTrace.sysout("Profiler.showPanel");
        this.setEnabled();
    },

    setEnabled: function()
    {
        var context = Firebug.currentContext;
        if (!context)
            return;

        // The profiler is available only if the Script panel and Console are enabled
        var enabled = context.isPanelEnabled("script") && context.isPanelEnabled("console");

        if (enabled)
        {
            // The profiler is available only if the Debugger is activated
            var debuggerTool = Firebug.connection.getTool("script");
            enabled = debuggerTool && debuggerTool.getActive();
        }

        this.profilerEnabled = enabled;

        if (!enabled && this.isProfiling())
            this.stopProfiling(context);

        // Attributes must be modified on the <command> element. All toolbar buttons
        // and menuitems are hooked up to the command.
        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleProfiling", "disabled",
            enabled ? "false" : "true");

        // Update the button's tooltip.
        var tooltipText = Locale.$STR("ProfileButton.Tooltip");
        if (!enabled)
            tooltipText = Locale.$STRF("script.Script_panel_must_be_enabled", [tooltipText]);
        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleProfiling", "tooltiptext", tooltipText);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onConsoleCleared: function(context)
    {
        if (this.isProfiling())
            this.stopProfiling(context, true);
    },

    onDebuggerEnabled: function()
    {
        this.setEnabled();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    toggleProfiling: function(context)
    {
        if (FBS.profiling)
            this.stopProfiling(context);
        else
            this.startProfiling(context);
    },

    startProfiling: function(context, title)
    {
        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleProfiling", "checked", "true");

        if (FBS.profiling)
            return;

        FBS.startProfiling();

        var originalTitle = title;
        var isCustomMessage = !!title;
        if (!isCustomMessage)
            title = Locale.$STR("ProfilerStarted");

        context.profileRow = this.logProfileRow(context, title);
        context.profileRow.customMessage = isCustomMessage;
        context.profileRow.originalTitle = originalTitle;

        Events.dispatch(this.fbListeners, "startProfiling", [context, originalTitle]);
        Firebug.Console.addListener(this);
    },

    stopProfiling: function(context, cancelReport)
    {
        var totalTime = FBS.stopProfiling();
        if (totalTime == -1)
            return;

        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleProfiling", "checked", "false");

        if (cancelReport)
            delete context.profileRow;
        else
            this.logProfileReport(context, cancelReport);

        Firebug.Console.removeListener(this);

        // stopProfiling event fired within logProfileReport
    },

    isProfiling: function()
    {
        return (Firebug.chrome.getGlobalAttribute("cmd_firebug_toggleProfiling", "checked") === "true");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    logProfileRow: function(context, title)
    {
        var objects =
        {
            title: title
        };
        var row = Firebug.Console.openGroup(objects, context, "profile",
            Firebug.Profiler.ProfileCaption, true, null, true);
        Css.setClass(row, "profilerRunning");

        Firebug.Console.closeGroup(context, true);

        return row;
    },

    logProfileReport: function(context, cancelReport)
    {
        var calls = [];
        var totalCalls = 0;
        var totalTime = 0;

        var sourceFileMap = context.sourceFileMap;
        if (FBTrace.DBG_PROFILER)
        {
            for (var url in sourceFileMap)
                FBTrace.sysout("logProfileReport: "+sourceFileMap[url]+"\n");
        }

        var jsd = Cc["@mozilla.org/js/jsd/debugger-service;1"].getService(Ci.jsdIDebuggerService);
        jsd.enumerateScripts({enumerateScript: function(script)
        {
            if (script.callCount)
            {
                if (!Firebug.filterSystemURLs || !Url.isSystemURL(script.fileName))
                {
                    var sourceLink = Firebug.SourceFile.getSourceLinkForScript(script, context);
                    if (sourceLink && sourceLink.href in sourceFileMap)
                    {
                        var call = new ProfileCall(script, context, script.callCount,
                            script.totalExecutionTime, script.totalOwnExecutionTime,
                            script.minExecutionTime, script.maxExecutionTime, sourceLink);

                        calls.push(call);

                        totalCalls += script.callCount;
                        totalTime += script.totalOwnExecutionTime;
                    }
                }
                script.clearProfileData();
            }
        }});

        for (var i = 0; i < calls.length; ++i)
            calls[i].percent = Math.round((calls[i].totalOwnTime/totalTime) * 100 * 100) / 100;

        calls.sort(function(a, b)
        {
           return a.totalOwnTime < b.totalOwnTime ? 1 : -1;
        });

        totalTime = Math.round(totalTime * 1000) / 1000;

        var groupRow = context.profileRow && context.profileRow.ownerDocument
            ? context.profileRow
            : this.logProfileRow(context, "");
        delete context.profileRow;

        Css.removeClass(groupRow, "profilerRunning");

        if (totalCalls > 0)
        {
            var captionBox = groupRow.getElementsByClassName("profileCaption").item(0);
            if (!groupRow.customMessage)
                captionBox.textContent = Locale.$STR("Profile");

            var timeBox = groupRow.getElementsByClassName("profileTime").item(0);
            timeBox.textContent = Locale.$STRP("plural.Profile_Time2", [totalTime, totalCalls], 1);

            var groupBody = groupRow.getElementsByClassName("logGroupBody")[0];
            var sizer = Firebug.Profiler.ProfileTable.tag.replace({}, groupBody);
            var table = sizer.firstChild;
            var tHeader = table.lastChild;  // no rows inserted.

            var tag = Firebug.Profiler.ProfileCall.tag;
            var insert = tag.insertRows;

            for (var i = 0; i < calls.length; ++i)
            {
                calls[i].index = i;
                context.throttle(insert, tag, [{object: calls[i]}, tHeader]);
            }

            context.throttle(groupRow.scrollIntoView, groupRow, []);
        }
        else
        {
            var captionBox = groupRow.getElementsByClassName("profileCaption").item(0);
            captionBox.textContent = Locale.$STR("NothingToProfile");
        }

        Events.dispatch(this.fbListeners, "stopProfiling", [context,
            groupRow.originalTitle, calls, cancelReport]);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    commandLineProfileStart: function(context, title)
    {
        if (!this.profilerEnabled)
        {
            var msg = Locale.$STR("ProfilerRequiresTheScriptPanel");
            Firebug.Console.logFormatted([msg], context, "warn");
            return;
        }
        Firebug.Profiler.startProfiling(context, title);
    },

    commandLineProfileEnd: function(context)
    {
        if (this.profilerEnabled)
            this.stopProfiling(context);
    }
});

// ********************************************************************************************* //

Firebug.Profiler.ProfileTable = domplate(
{
    tag:
        DIV({"class": "profileSizer", "tabindex": "-1" },
            TABLE({"class": "profileTable", cellspacing: 0, cellpadding: 0, width: "100%",
                "role": "grid"},
                THEAD({"class": "profileThead", "role": "presentation"},
                    TR({"class": "headerRow focusRow profileRow subFocusRow", onclick: "$onClick",
                        "role": "row"},
                        TH({"class": "headerCell alphaValue a11yFocus", "role": "columnheader"},
                            DIV({"class": "headerCellBox"},
                                Locale.$STR("Function")
                            )
                        ),
                        TH({"class": "headerCell a11yFocus", "role": "columnheader"},
                            DIV({"class": "headerCellBox", title: Locale.$STR("CallsHeaderTooltip")},
                                Locale.$STR("Calls")
                            )
                        ),
                        TH({"class": "headerCell headerSorted a11yFocus", "role": "columnheader",
                            "aria-sort": "descending"},
                            DIV({"class": "headerCellBox", title: Locale.$STR("PercentTooltip")},
                                Locale.$STR("Percent")
                            )
                        ),
                        TH({"class": "headerCell a11yFocus", "role": "columnheader"},
                            DIV({"class": "headerCellBox", title: Locale.$STR("OwnTimeHeaderTooltip")},
                                Locale.$STR("OwnTime")
                            )
                        ),
                        TH({"class": "headerCell a11yFocus", "role": "columnheader"},
                            DIV({"class": "headerCellBox", title: Locale.$STR("TimeHeaderTooltip")},
                                Locale.$STR("Time")
                            )
                        ),
                        TH({"class": "headerCell a11yFocus", "role": "columnheader"},
                            DIV({"class": "headerCellBox", title: Locale.$STR("AvgHeaderTooltip")},
                                Locale.$STR("Avg")
                            )
                        ),
                        TH({"class": "headerCell a11yFocus", "role": "columnheader"},
                            DIV({"class": "headerCellBox", title: Locale.$STR("MinHeaderTooltip")},
                                Locale.$STR("Min")
                            )
                        ),
                        TH({"class": "headerCell a11yFocus", "role": "columnheader"},
                            DIV({"class": "headerCellBox", title: Locale.$STR("MaxHeaderTooltip")},
                                Locale.$STR("Max")
                            )
                        ),
                        TH({"class": "headerCell alphaValue a11yFocus", "role": "columnheader"},
                            DIV({"class": "headerCellBox"},
                                Locale.$STR("File")
                            )
                        )
                    )
                ),
                TBODY({"class": "profileTbody", "role": "presentation"})
            )
        ),

    onClick: function(event)
    {
        var table = Dom.getAncestorByClass(event.target, "profileTable");
        var header = Dom.getAncestorByClass(event.target, "headerCell");
        if (!header)
            return;

        var numerical = !Css.hasClass(header, "alphaValue");

        var colIndex = 0;
        for (header = header.previousSibling; header; header = header.previousSibling)
            ++colIndex;

        this.sort(table, colIndex, numerical);
    },

    sort: function(table, colIndex, numerical)
    {
        sortAscending = function()
        {
            Css.removeClass(header, "sortedDescending");
            Css.setClass(header, "sortedAscending");
            header.setAttribute("aria-sort", "ascending");

            header.sorted = -1;

            for (var i = 0; i < values.length; ++i)
                tbody.appendChild(values[i].row);
        },

        sortDescending = function()
        {
          Css.removeClass(header, "sortedAscending");
          Css.setClass(header, "sortedDescending");
          header.setAttribute("aria-sort", "descending");

          header.sorted = 1;

          for (var i = values.length-1; i >= 0; --i)
              tbody.appendChild(values[i].row);
        };

        var tbody = Dom.getChildByClass(table, "profileTbody");
        var thead = Dom.getChildByClass(table, "profileThead");

        var values = [];
        for (var row = tbody.childNodes[0]; row; row = row.nextSibling)
        {
            var cell = row.childNodes[colIndex];
            var value = numerical ? parseFloat(cell.textContent) : cell.textContent;
            values.push({row: row, value: value});
        }

        values.sort(function(a, b) { return a.value < b.value ? -1 : 1; });

        var headerRow = thead.firstChild;
        var headerSorted = Dom.getChildByClass(headerRow, "headerSorted");
        Css.removeClass(headerSorted, "headerSorted");
        if (headerSorted)
            headerSorted.removeAttribute('aria-sort');

        var header = headerRow.childNodes[colIndex];
        Css.setClass(header, "headerSorted");

        if (numerical)
        {
            if (!header.sorted || header.sorted == -1)
            {
                sortDescending();
            }
            else
            {
                sortAscending();
            }
        }
        else
        {
            if (!header.sorted || header.sorted == -1)
            {
                sortAscending();
            }
            else
            {
                sortDescending();
            }
        }
    }
});

// ********************************************************************************************* //

Firebug.Profiler.ProfileCaption = domplate(Rep,
{
    tag:
        SPAN({"class": "profileTitle", "role": "status"},
            SPAN({"class": "profileCaption"}, "$object.title"),
            " ",
            SPAN({"class": "profileTime"}, "")
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    groupable: false
});

// ********************************************************************************************* //

Firebug.Profiler.ProfileCall = domplate(Rep,
{
    tag:
        TR({"class": "focusRow profileRow subFocusRow", "role": "row"},
            TD({"class": "profileCell", "role": "presentation"},
                FirebugReps.OBJECTLINK("$object|getCallName")
            ),
            TD({"class": "a11yFocus profileCell", "role": "gridcell"}, "$object.callCount"),
            TD({"class": "a11yFocus profileCell", "role": "gridcell"}, "$object.percent%"),
            TD({"class": "a11yFocus profileCell", "role": "gridcell"}, "$object.totalOwnTime|roundTime\\ms"),
            TD({"class": "a11yFocus profileCell", "role": "gridcell"}, "$object.totalTime|roundTime\\ms"),
            TD({"class": "a11yFocus profileCell", "role": "gridcell"}, "$object|avgTime|roundTime\\ms"),
            TD({"class": "a11yFocus profileCell", "role": "gridcell"}, "$object.minTime|roundTime\\ms"),
            TD({"class": "a11yFocus profileCell", "role": "gridcell"}, "$object.maxTime|roundTime\\ms"),
            TD({"class": "linkCell profileCell", "role": "presentation"},
                TAG(FirebugReps.SourceLink.tag, {object: "$object|getSourceLink"})
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getCallName: function(call)
    {
        return Str.cropString(StackFrame.getFunctionName(call.script, call.context), 60);
    },

    avgTime: function(call)
    {
        return call.totalTime / call.callCount;
    },

    getSourceLink: function(call)
    {
        return call.sourceLink;
    },

    roundTime: function(ms)
    {
        return Math.round(ms * 1000) / 1000;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "profile",

    supportsObject: function(object, type)
    {
        return object instanceof ProfileCall;
    },

    inspectObject: function(call, context)
    {
        var sourceLink = this.getSourceLink(call);
        Firebug.chrome.select(sourceLink);
    },

    getTooltip: function(call)
    {
        try
        {
            var fn = StackFrame.getFunctionName(call.script, call.context);
            return FirebugReps.Func.getTooltip(fn, call.context);
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("profiler.getTooltip FAILS ", exc);
        }
    },

    getContextMenuItems: function(call, target, context)
    {
        var fn = Wrapper.unwrapIValue(call.script.functionObject);
        return FirebugReps.Func.getContextMenuItems(fn, call.script, context);
    }
});

// ********************************************************************************************* //

function ProfileCall(script, context, callCount, totalTime, totalOwnTime, minTime, maxTime, sourceLink)
{
    this.script = script;
    this.context = context;
    this.callCount = callCount;
    this.totalTime = totalTime;
    this.totalOwnTime = totalOwnTime;
    this.minTime = minTime;
    this.maxTime = maxTime;
    this.sourceLink = sourceLink;
}

// ********************************************************************************************* //
// CommandLine Support

function profile(context, args)
{
    var title = args[0];
    Firebug.Profiler.commandLineProfileStart(context, title);
    return Firebug.Console.getDefaultReturnValue();
};

function profileEnd(context)
{
    Firebug.Profiler.commandLineProfileEnd(context);
    return Firebug.Console.getDefaultReturnValue();
};

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.Profiler);
Firebug.registerRep(Firebug.Profiler.ProfileCall);

Firebug.registerCommand("profile", {
    handler: profile.bind(this),
    helpUrl: "http://getfirebug.com/wiki/index.php/profile",
    description: Locale.$STR("console.cmd.help.profile")
});

Firebug.registerCommand("profileEnd", {
    handler: profileEnd.bind(this),
    helpUrl: "http://getfirebug.com/wiki/index.php/profileEnd",
    description: Locale.$STR("console.cmd.help.profileEnd")
});

return Firebug.Profiler;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/commands/useInCommandLine",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/lib/trace",
    "firebug/console/commandLine",
    "firebug/lib/locale",
    "firebug/lib/object",
    "firebug/chrome/menu",
    "firebug/js/sourceLink",
    "firebug/lib/string",
],
function(Firebug, Module, FBTrace, CommandLine, Locale, Obj, Menu, SourceLink, Str) {

"use strict";

// ********************************************************************************************* //
// UseInCommandLine Implementation

/**
 * @module Responsible for implementing 'Use in Command Line' feature.
 * See also: https://getfirebug.com/wiki/index.php/$p
 */
var UseInCommandLine = Obj.extend(Module,
/** @lends UseInCommandLine */
{
    dispatchName: "UseInCommandLine",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Extends Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        Firebug.registerUIListener(this);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        Firebug.unregisterUIListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Listener

    onContextMenu: function(items, object, target, context, panel, popup)
    {
        if (typeof object === "boolean" || object === undefined || object === null)
            return;

        var rep = Firebug.getRep(object, context);
        if (!rep || !rep.inspectable)
            return;

        // Get the object that should be associated with '$p' variable.
        // The same way is used by e.g. 'Inspect In DOM panel' command.
        object = rep.getRealObject(object, context);
        if (object instanceof SourceLink.SourceLink)
            return;

        var item = {
            label: "commandline.Use_in_Command_Line",
            tooltiptext: "commandline.tip.Use_in_Command_Line",
            id: "fbUseInCommandLine",
            command: this.useInCommandLine.bind(this, context, object)
        };

        // Add the item before the first "Inspect in * Panel" option (or at the bottom
        // together with a separator if there is none).
        var before = Array.prototype.filter.call(popup.childNodes, function(node)
        {
            return Str.hasPrefix(node.id, "InspectIn");
        })[0];

        if (!before)
            Menu.createMenuSeparator(popup);

        Menu.createMenuItem(popup, item, before);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Context Menu Actions

    useInCommandLine: function(context, object)
    {
        context.rememberedObject = object;

        var panel = Firebug.chrome.getSelectedPanel();

        var hasConsole = !!context.getPanel("console", true);
        if (!hasConsole)
            Firebug.chrome.selectPanel("console");
        else if (panel && panel.name != "console" && !CommandLine.Popup.isVisible())
            CommandLine.Popup.toggle(context);

        var commandLine = CommandLine.getCommandLine(context);
        var valueLength = commandLine.value.length;
        var ins = "$p";

        commandLine.value += ins;
        commandLine.focus();
        commandLine.setSelectionRange(valueLength, valueLength + ins.length);

        CommandLine.autoCompleter.hide();
        CommandLine.update(context);
    }
});

// ********************************************************************************************* //
// Command Implementation

function onExecuteCommand(context)
{
    return context.rememberedObject;
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(UseInCommandLine);

Firebug.registerCommand("$p", {
    variable: true,
    handler: onExecuteCommand.bind(this),
    description: Locale.$STR("console.cmd.help.$p")
});

return UseInCommandLine;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/consoleExposed",
[
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/wrapper",
    "firebug/lib/url",
    "firebug/lib/string",
    "firebug/js/stackFrame",
    "firebug/console/errors",
    "firebug/trace/debug",
    "firebug/console/console",
    "firebug/lib/options",
    "firebug/debugger/debuggerLib",
    "firebug/chrome/tableRep",
],
function(FirebugReps, Locale, Wrapper, Url, Str, StackFrame, Errors, Debug, Console, Options,
    DebuggerLib, TableRep) {

// Note: since we are using .caller and .arguments for stack walking, we can not use strict mode.
//"use strict";

// ********************************************************************************************* //

/**
 * Returns a console object (bundled with passed window through closure). The object
 * provides all necessary APIs as described here: http://getfirebug.com/wiki/index.php/Console_API
 *
 * @param {Object} context
 * @param {Object} win
 */
function createFirebugConsole(context, win)
{
    // Defined as a chrome object, but exposed into the web content scope.
    var console = {
        __exposedProps__: {}
    };

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Exposed Properties

    console.log = function log()
    {
        return logFormatted(arguments, "log", true);
    };

    console.debug = function debug()
    {
        return logFormatted(arguments, "debug", true);
    };

    console.info = function info()
    {
        return logFormatted(arguments, "info", true);
    };

    console.warn = function warn()
    {
        return logFormatted(arguments, "warn", true);
    };

    console.exception = function exception()
    {
        return logAssert("error", arguments);
    };

    console.assert = function assert(x)
    {
        if (!x)
        {
            var rest = [];
            for (var i = 1; i < arguments.length; i++)
                rest.push(arguments[i]);
            return logAssert("assert", rest);
        }

        return Console.getDefaultReturnValue();
    };

    console.dir = function dir(o)
    {
        Firebug.Console.log(o, context, "dir", Firebug.DOMPanel.DirTable);
        return Console.getDefaultReturnValue();
    };

    console.dirxml = function dirxml(o)
    {
        if (o instanceof Wrapper.getContentView(win).Window)
            o = o.document.documentElement;
        else if (o instanceof Wrapper.getContentView(win).Document)
            o = o.documentElement;

        Firebug.Console.log(o, context, "dirxml", Firebug.HTMLPanel.SoloElement);
        return Console.getDefaultReturnValue();
    };

    console.trace = function firebugDebuggerTracer()
    {
        var trace = getJSDUserStack();
        if (!trace)
            trace = getComponentsUserStack();

        // This should never happen, but inform the user if it does.
        if (!trace)
            trace = "(No stack trace available)";

        Firebug.Console.log(trace, context, "stackTrace");
        return Console.getDefaultReturnValue();
    };

    console.group = function group()
    {
        var sourceLink = getStackLink();
        Firebug.Console.openGroup(arguments, null, "group", null, false, sourceLink);
        return Console.getDefaultReturnValue();
    };

    console.groupEnd = function()
    {
        Firebug.Console.closeGroup(context);
        return Console.getDefaultReturnValue();
    };

    console.groupCollapsed = function()
    {
        var sourceLink = getStackLink();

        // noThrottle true can't be used here (in order to get the result row now)
        // because there can be some logs delayed in the queue and they would end up
        // in a different group.
        // Use rather a different method that causes auto collapsing of the group
        // when it's created.
        Firebug.Console.openCollapsedGroup(arguments, null, "group", null, false, sourceLink);
        return Console.getDefaultReturnValue();
    };

    console.profile = function(title)
    {
        Firebug.Profiler.commandLineProfileStart(context, title);
        return Console.getDefaultReturnValue();
    };

    console.profileEnd = function()
    {
        Firebug.Profiler.commandLineProfileEnd(context);
        return Console.getDefaultReturnValue();
    };

    console.count = function(key)
    {
        var frameId = getStackFrameId();
        if (frameId)
        {
            if (!context.frameCounters)
                context.frameCounters = {};

            if (key != undefined)
                frameId += key;

            var frameCounter = context.frameCounters[frameId];
            if (!frameCounter)
            {
                var logRow = logFormatted(["0"], null, true, true);

                frameCounter = {logRow: logRow, count: 1};
                context.frameCounters[frameId] = frameCounter;
            }
            else
            {
                ++frameCounter.count;
            }

            var label = key == undefined
                ? frameCounter.count
                : key + " " + frameCounter.count;

            var node = frameCounter.logRow.getElementsByClassName("objectBox-text")[0];
            node.firstChild.nodeValue = label;
        }
        return Console.getDefaultReturnValue();
    };

    console.clear = function()
    {
        Firebug.Console.clear(context);
        return Console.getDefaultReturnValue();
    };

    console.time = function(name, reset)
    {
        if (!name)
            return Console.getDefaultReturnValue();

        var time = new Date().getTime();

        if (!this.timeCounters)
            this.timeCounters = {};

        var key = "KEY"+name.toString();

        if (!reset && this.timeCounters[key])
            return Console.getDefaultReturnValue();

        this.timeCounters[key] = time;
        return Console.getDefaultReturnValue();
    };

    console.timeEnd = function(name)
    {
        var time = new Date().getTime();
        var diff = undefined;

        if (!this.timeCounters)
            return Console.getDefaultReturnValue();

        var key = "KEY"+name.toString();

        var timeCounter = this.timeCounters[key];
        if (timeCounter)
        {
            diff = time - timeCounter;
            var label = name + ": " + diff + "ms";

            this.info(label);

            delete this.timeCounters[key];
        }
        return diff;
    };

    console.timeStamp = function(label)
    {
        label = label || "";

        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("consoleExposed.timeStamp; " + label);

        var now = new Date();
        Firebug.NetMonitor.addTimeStamp(context, now.getTime(), label);

        var formattedTime = now.getHours() + ":" + now.getMinutes() + ":" +
            now.getSeconds() + "." + now.getMilliseconds();
        return logFormatted([formattedTime, label], "timeStamp");
    };

    console.table = function(data, columns)
    {
        TableRep.log(data, columns, context);
        return Console.getDefaultReturnValue();
    };

    console.error = function error()
    {
        if (arguments.length == 1)
        {
            return logAssert("error", arguments);  // add more info based on stack trace
        }
        else
        {
            Errors.increaseCount(context);
            return logFormatted(arguments, "error", true);  // user already added info
        }
    };

    // Expose only these properties to the content scope (read only).
    console.__exposedProps__.log = "r";
    console.__exposedProps__.debug = "r";
    console.__exposedProps__.info = "r";
    console.__exposedProps__.warn = "r";
    console.__exposedProps__.exception = "r";
    console.__exposedProps__.assert = "r";
    console.__exposedProps__.dir = "r";
    console.__exposedProps__.dirxml = "r";
    console.__exposedProps__.trace = "r";
    console.__exposedProps__.group = "r";
    console.__exposedProps__.groupEnd = "r";
    console.__exposedProps__.groupCollapsed = "r";
    console.__exposedProps__.time = "r";
    console.__exposedProps__.timeEnd = "r";
    console.__exposedProps__.timeStamp = "r";
    console.__exposedProps__.profile = "r";
    console.__exposedProps__.profileEnd = "r";
    console.__exposedProps__.count = "r";
    console.__exposedProps__.clear = "r";
    console.__exposedProps__.table = "r";
    console.__exposedProps__.error = "r";

    // DBG console.uid = Math.random();

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Helpers (not accessible from web content)

    function logFormatted(args, className, linkToSource, noThrottle)
    {
        var sourceLink = null;

        // Using JSD to get user stack is time consuming, so there is a pref.
        if (Options.get("preferJSDSourceLinks"))
        {
            var stack = getJSDUserStack();
            if (stack && stack.toSourceLink)
                sourceLink = stack.toSourceLink();
        }

        if (!sourceLink)
            sourceLink = linkToSource ? getStackLink() : null;

        var ignoreReturnValue = Firebug.Console.getDefaultReturnValue();
        var rc = Firebug.Console.logFormatted(args, context, className, noThrottle, sourceLink);
        return rc ? rc : ignoreReturnValue;
    }

    function logAssert(category, args)
    {
        Errors.increaseCount(context);

        var msg = (!args || !args.length || args.length == 0) ?
            [Locale.$STR("Assertion")] : args[0];

        // If there's no error message, there's also no stack trace. See Issue 4700.
        var trace;
        if (msg && msg.stack)
        {
            trace = StackFrame.parseToStackTrace(msg.stack, context);
            if (FBTrace.DBG_CONSOLE)
                FBTrace.sysout("logAssert trace from msg.stack", trace);
        }
        else
        {
            trace = getJSDUserStack();
            if (FBTrace.DBG_CONSOLE)
                FBTrace.sysout("logAssert trace from getJSDUserStack", trace);

            if (!trace)
            {
                trace = getComponentsUserStack();
                if (FBTrace.DBG_CONSOLE)
                    FBTrace.sysout("logAssert trace from getComponentsUserStack", trace);
            }
        }

        trace = StackFrame.cleanStackTraceOfFirebug(trace);

        var url = msg && msg.fileName ? msg.fileName : win.location.href;

        // we may have only the line popped above
        var lineNo = (trace && msg && msg.lineNumber) ? msg.lineNumber : 0;
        var errorObject = new FirebugReps.ErrorMessageObj(msg, url, lineNo, "",
            category, context, trace);

        if (trace && trace.frames && trace.frames[0])
            errorObject.correctWithStackTrace(trace);

        errorObject.resetSource();

        if (args.length > 1)
        {
            errorObject.objects = [];
            for (var i = 1; i < args.length; i++)
                errorObject.objects.push(args[i]);
        }

        var row = Firebug.Console.log(errorObject, context, "errorMessage");
        if (row)
            row.scrollIntoView();

        return Console.getDefaultReturnValue();
    }

    function getComponentsStackDump()
    {
        // Starting with our stack, walk back to the user-level code
        var frame = Components.stack;
        var userURL = win.location.href.toString();

        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("consoleInjector.getComponentsStackDump initial stack for userURL " +
                userURL, frame);

        // Drop frames until we get into user code.
        while (frame && Url.isSystemURL(frame.filename) )
            frame = frame.caller;

        // Drop two more frames, the injected console function and firebugAppendConsole()
        //if (frame)
        //    frame = frame.caller;
        //if (frame)
        //    frame = frame.caller;

        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("consoleInjector.getComponentsStackDump final stack for userURL " +
                userURL, frame);

        return frame;
    }

    function getStackLink()
    {
        var sourceLink = StackFrame.getFrameSourceLink(getComponentsStackDump());
        // xxxFlorent: should be reverted if we integrate 
        // https://github.com/fflorent/firebug/commit/d5c65e8 (related to issue6268)
        if (DebuggerLib.isFrameLocationEval(sourceLink.href))
            return null;
        return sourceLink;
    }

    function removeChromeFrames(trace)
    {
        var frames = trace ? trace.frames : null;
        if (!frames || !frames.length)
            return null;

        var filteredFrames = [];
        for (var i = 0; i < frames.length; i++)
        {
            if (Str.hasPrefix(frames[i].href, "chrome:"))
                continue;

            if (Str.hasPrefix(frames[i].href, "resource:"))
                continue;

            // firebug-service scope reached, in some cases the url starts with file://
            if (frames[i].href.indexOf("modules/firebug-service.js") != -1)
                continue;

            // xxxFlorent: should be reverted if we integrate
            // https://github.com/fflorent/firebug/commit/d5c65e8 (related to issue6268)
            if (DebuggerLib.isFrameLocationEval(frames[i].href))
                continue;

            // command line
            var fn = frames[i].getFunctionName() + "";
            if (fn && (fn.indexOf("_firebugEvalEvent") != -1))
                continue;

            filteredFrames.push(frames[i]);
        }

        trace.frames = filteredFrames;

        return trace;
    }

    function getJSDUserStack()
    {
        if (!Firebug.Debugger.isAlwaysEnabled())
            return null;
        var trace = Firebug.Debugger.getCurrentStackTrace(context);
        return removeChromeFrames(trace);
    }

    function getComponentsUserStack()
    {
        // Walk Components.stack and function.caller/arguments simultaneously.
        var func = arguments.callee;
        var seenFunctions = new Set();
        seenFunctions.add(func);

        var trace = new StackFrame.StackTrace();
        var frame = Components.stack;
        while (frame)
        {
            var fileName = frame.filename;
            if (fileName)
            {
                var frameName = frame.name;
                var args = [];
                if (func)
                {
                    try
                    {
                        if (func.name && func.name !== frameName)
                        {
                            // Something is off, abort!
                            func = null;
                        }
                        else
                        {
                            var argValues = Array.prototype.slice.call(func.arguments);
                            var argNames = StackFrame.guessFunctionArgNamesFromSource(func + "");
                            if (argNames && argNames.length === func.length)
                            {
                                for (var i = 0; i < func.length; i++)
                                    args.push({name: argNames[i], value: argValues[i]});
                            }
                        }
                    }
                    catch (exc) {} // strict mode etc.
                }

                var sframe = new StackFrame.StackFrame({href: fileName},
                    frame.lineNumber, frameName, args, null, null, context);
                trace.frames.push(sframe);
            }

            frame = frame.caller;
            if (func)
            {
                try
                {
                    func = func.caller;
                    if (seenFunctions.has(func))
                    {
                        // Recursion; we cannot go on unfortunately.
                        func = null;
                    }
                    else
                    {
                        seenFunctions.add(func);
                    }
                }
                catch (exc)
                {
                    // Strict mode functions etc.
                    func = null;
                }
            }
        }

        return removeChromeFrames(trace);
    }

    function getStackFrameId(inputFrame)
    {
        for (var frame = Components.stack; frame; frame = frame.caller)
        {
            if (frame.languageName == "JavaScript"
                && !(frame.filename && frame.filename.indexOf("://firebug/") > 0))
            {
                return frame.filename + "/" + frame.lineNumber;
            }
        }
        return null;
    }

    return console;
}

// ********************************************************************************************* //
// Registration

Firebug.ConsoleExposed =
{
    createFirebugConsole: createFirebugConsole
};

return Firebug.ConsoleExposed;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/consoleInjector",
[
    "firebug/firebug",
    "firebug/console/console",
    "firebug/console/consoleExposed",
    "firebug/console/errors",
],
function(Firebug, Console) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cu = Components.utils;

var wmExposedConsoles = new WeakMap();

// ********************************************************************************************* //
// Console Injector

Firebug.Console.injector =
{
    attachConsoleInjector: function(context, win)
    {
        try
        {
            var url = win.location.href;
            var winDoc = win.document;
            // Don't run the function twice for the same window and the same context.
            if (wmExposedConsoles.has(winDoc) &&
                wmExposedConsoles.get(winDoc).context === context)
            {
                if (FBTrace.DBG_CONSOLE)
                    FBTrace.sysout("Console already attached for " + url + ". Skipping.");
                return;
            }
            // Get the 'console' object (this comes from chrome scope).
            var console = Firebug.ConsoleExposed.createFirebugConsole(context, win);

            // Do not expose the chrome object as is but, rather do a wrapper, see below.
            //win.wrappedJSObject.console = console;
            //return;

            // Construct a script string that defines a function. This function returns
            // an object that wraps every 'console' method. This function will be evaluated
            // in a window content sandbox and return a wrapper for the 'console' object.
            // Note that this wrapper appends an additional frame that shouldn't be displayed
            // to the user.
            //
            // Since we are using .caller and .arguments for stack walking, the function must
            // not be in strict mode.
            var expr = "(function(x) { return {\n";
            for (var p in console)
            {
                var func = console[p];
                if (typeof(func) == "function")
                {
                    expr += p + ": function() { return Function.apply.call(x." + p +
                        ", x, arguments); },\n";
                }
            }
            expr += "};})";

            // Evaluate the function in the window sandbox/scope and execute. The return value
            // is a wrapper for the 'console' object.
            var sandbox = Cu.Sandbox(win);
            var getConsoleWrapper = Cu.evalInSandbox(expr, sandbox);
            var exposedConsole = getConsoleWrapper(console);

            // Store the context and the exposedConsole in a WeakMap.
            wmExposedConsoles.set(winDoc, {
                context: context,
                console: exposedConsole
            });

            win.wrappedJSObject.console = exposedConsole;

            if (FBTrace.DBG_CONSOLE)
                FBTrace.sysout("console.attachConsoleInjector; Firebug console attached to: " +
                    url);
        }
        catch (ex)
        {
            if (FBTrace.DBG_ERROR)
            {
                FBTrace.sysout("consoleInjector.attachConsoleInjector; exception while injecting",
                    ex);
            }
        }
    },

    getExposedConsole: function(win)
    {
        var winDoc = win.document;
        return  wmExposedConsoles.has(winDoc) ?
                wmExposedConsoles.get(winDoc).console :
                undefined;
    },

    // For extensions that still use this function.
    getConsoleHandler: function(context, win)
    {
        return {
            win: Wrapper.wrapObject(win),
            context: context,
            console: this.getExposedConsole(win)
        };
    }
};

// ********************************************************************************************* //
// Registration

return Firebug.Console.injector;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/console",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/lib/events",
    "firebug/lib/locale",
    "firebug/chrome/window",
    "firebug/lib/search",
    "firebug/lib/xml",
    "firebug/lib/options",
    "firebug/chrome/panelNotification",
    "firebug/chrome/activableModule",
    "firebug/console/commands/profiler",
    "firebug/chrome/searchBox",
    "firebug/console/consolePanel",
    "firebug/console/commandEditor",
    "firebug/console/functionMonitor",
    "firebug/console/commands/eventMonitor",
    "firebug/console/performanceTiming",
],
function(Obj, Firebug, Firefox, Events, Locale, Win, Search, Xml, Options,
    PanelNotification, ActivableModule) {

// ********************************************************************************************* //
// Constants

var maxQueueRequests = 500;

// Note: createDefaultReturnValueInstance() is a local helper (see below).
var defaultReturnValue = createDefaultReturnValueInstance();

// ********************************************************************************************* //

Firebug.ConsoleBase =
{
    log: function(object, context, className, rep, noThrottle, sourceLink)
    {
        Events.dispatch(this.fbListeners,"log",[context, object, className, sourceLink]);
        return this.logRow(appendObject, object, context, className, rep, sourceLink, noThrottle);
    },

    logFormatted: function(objects, context, className, noThrottle, sourceLink)
    {
        Events.dispatch(this.fbListeners,"logFormatted",[context, objects, className, sourceLink]);
        return this.logRow(appendFormatted, objects, context, className, null, sourceLink,
            noThrottle);
    },

    openGroup: function(objects, context, className, rep, noThrottle, sourceLink, noPush)
    {
        return this.logRow(appendOpenGroup, objects, context, className, rep, sourceLink,
            noThrottle);
    },

    openCollapsedGroup: function(objects, context, className, rep, noThrottle, sourceLink, noPush)
    {
        return this.logRow(appendCollapsedGroup, objects, context, className, rep, sourceLink,
            noThrottle);
    },

    closeGroup: function(context, noThrottle)
    {
        return this.logRow(appendCloseGroup, null, context, null, null, null, noThrottle, true);
    },

    logRow: function(appender, objects, context, className, rep, sourceLink, noThrottle, noRow)
    {
        if (!context)
            context = Firebug.currentContext;

        if (FBTrace.DBG_ERRORS && FBTrace.DBG_CONSOLE && !context)
            FBTrace.sysout("Console.logRow has no context, skipping objects", objects);

        if (!context)
            return;

        if (noThrottle || !context)
        {
            var panel = this.getPanel(context);
            if (panel)
            {
                var row = panel.append(appender, objects, className, rep, sourceLink, noRow);
                var container = panel.panelNode;

                while (container.childNodes.length > maxQueueRequests + 1)
                {
                    container.removeChild(container.firstChild.nextSibling);
                    panel.limit.config.totalCount++;
                    PanelNotification.updateCounter(panel.limit);
                }
                Events.dispatch(this.fbListeners, "onLogRowCreated", [panel, row, context]);
                return row;
            }
        }
        else
        {
            if (!context.throttle)
            {
                FBTrace.sysout("console.logRow has not context.throttle! ");
                return;
            }
            var args = [appender, objects, context, className, rep, sourceLink, true, noRow];
            context.throttle(this.logRow, this, args);
        }
    },

    appendFormatted: function(args, row, context)
    {
        if (!context)
            context = Firebug.currentContext;

        var panel = this.getPanel(context);
        panel.appendFormatted(args, row);
    },

    clear: function(context)
    {
        if (!context)
            context = Firebug.currentContext;

        if (context)
        {
            // There could be some logs waiting in the throttle queue, so
            // clear asynchronously after the queue is flushed.
            context.throttle(this.clearPanel, this, [context]);

            // Also clear now
            this.clearPanel(context);

            // Let listeners react to console clearing
            Events.dispatch(this.fbListeners, "onConsoleCleared", [context]);
        }
    },

    clearPanel: function(context)
    {
        Firebug.Errors.clear(context);

        var panel = this.getPanel(context, true);
        if (panel)
            panel.clear();
    },

    // Override to direct output to your panel
    getPanel: function(context, noCreate)
    {
        if (context)
            return context.getPanel("console", noCreate);
    },
};

// ********************************************************************************************* //

/**
 * @module Represents module for the Console panel. Responsible e.g. for handling
 * user actions related to Console panel filter.
 */
var ActivableConsole = Obj.extend(ActivableModule, Firebug.ConsoleBase);
Firebug.Console = Obj.extend(ActivableConsole,
/** @lends Firebug.Console */
{
    dispatchName: "console",
    toolName: "console",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    showPanel: function(browser, panel)
    {
    },

    getExposedConsole: function(win)
    {
        return this.injector.getExposedConsole(win);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    initialize: function()
    {
        // Initialize log limit.
        this.updateMaxLimit();

        ActivableModule.initialize.apply(this, arguments);

        Firebug.connection.addListener(this);
    },

    initializeUI: function()
    {
        // Synchronize UI buttons with the current filter
        this.syncFilterButtons(Firebug.chrome);

        // Initialize filter button tooltips
        var doc = Firebug.chrome.window.document;
        var filterButtons = doc.getElementsByClassName("fbConsoleFilter");
        for (var i=0, len=filterButtons.length; i<len; ++i)
        {
            if (filterButtons[i].id != "fbConsoleFilter-all")
            {
                filterButtons[i].tooltipText = Locale.$STRF("firebug.labelWithShortcut",
                    [filterButtons[i].tooltipText, Locale.$STR("tooltip.multipleFiltersHint")]);
            }
        }
    },

    shutdown: function()
    {
        Firebug.connection.removeListener(this);
        ActivableModule.shutdown.apply(this, arguments);
    },

    initContext: function(context, persistedState)
    {
        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("Console.initContext");

        ActivableModule.initContext.apply(this, arguments);

        this.attachConsoleToWindows(context);
    },

    destroyContext: function(context)
    {
        if (context && context.consoleOnDOMWindowCreated)
        {
            context.browser.removeEventListener("DOMWindowCreated",
                context.consoleOnDOMWindowCreated);

            context.consoleOnDOMWindowCreated = null;
        }
    },

    /**
     * Attach the `console` object to the window of the context and its iframes.
     * Also listen to iframe creations to attach it automatically.
     *
     * *Caution*: Designed to be used only in Firebug.Console. Should not be used elsewhere.
     *
     * @param {Context} context
     */
    attachConsoleToWindows: function(context)
    {
        // Attach the Console for the window and its iframes.
        Win.iterateWindows(context.window, function(win)
        {
            Firebug.Console.injector.attachConsoleInjector(context, win);
        });

        // Listen to DOMWindowCreated for future iframes. Also necessary when Firebug is enabled at
        // page load.
        if (!context.consoleOnDOMWindowCreated)
        {
            context.consoleOnDOMWindowCreated = function(ev)
            {
                if (ev && ev.target)
                    Firebug.Console.injector.attachConsoleInjector(context, ev.target.defaultView);
            };
            context.browser.addEventListener("DOMWindowCreated", context.consoleOnDOMWindowCreated);
        }
    },

    togglePersist: function(context)
    {
        var panel = context.getPanel("console");
        panel.persistContent = panel.persistContent ? false : true;

        Firebug.chrome.setGlobalAttribute("cmd_firebug_togglePersistConsole", "checked",
            panel.persistContent);
    },

    showContext: function(browser, context)
    {
        Firebug.chrome.setGlobalAttribute("cmd_firebug_clearConsole", "disabled", !context);

        ActivableModule.showContext.apply(this, arguments);
    },

    updateOption: function(name, value)
    {
        if (name == "console.logLimit")
            this.updateMaxLimit();
    },

    updateMaxLimit: function()
    {
        var value = Options.get("console.logLimit");
        maxQueueRequests =  value ? value : maxQueueRequests;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extend ActivableModule

    onObserverChange: function(observer)
    {
        if (!Firebug.getSuspended())  // then Firebug is in action
            this.onResumeFirebug();   // and we need to test to see if we need to addObserver
        else
            this.onSuspendFirebug();
    },

    onSuspendFirebug: function()
    {
        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.onSuspendFirebug isAlwaysEnabled:" +
                Firebug.Console.isAlwaysEnabled());

        if (Firebug.Errors.toggleWatchForErrors(false))
        {
            this.setStatus();
            // Make sure possible errors coming from the page and displayed in the Firefox
            // status bar are removed.
            this.clear();
        }
    },

    onResumeFirebug: function()
    {
        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.onResumeFirebug\n");

        var watchForErrors = Firebug.Console.isAlwaysEnabled() || Firebug.Console.hasObservers();
        if (Firebug.Errors.toggleWatchForErrors(watchForErrors))
            this.setStatus();
    },

    onToggleFilter: function(event, context, filterType)
    {
        if (!context)
            context = Firebug.currentContext;

        var filterTypes = [];
        if (Events.isControl(event) && filterType != "all")
        {
            filterTypes = Options.get("consoleFilterTypes").split(" ");
            var filterTypeIndex = filterTypes.indexOf(filterType);
            if (filterTypeIndex == -1)
                filterTypes.push(filterType);
            else
                filterTypes.splice(filterTypeIndex, 1);
        }
        else
        {
            filterTypes.push(filterType);
        }

        // Remove "all" filter in case several filters are selected
        if (filterTypes.length > 1)
        {
            var allIndex = filterTypes.indexOf("all");
            if (allIndex != -1)
                filterTypes.splice(allIndex, 1);
        }

        // If no filter categories are selected, use the default
        if (filterTypes.length == 0)
            filterTypes = Options.getDefault("consoleFilterTypes").split(" ");

        Options.set("consoleFilterTypes", filterTypes.join(" "));

        this.syncFilterButtons(Firebug.chrome);

        Events.dispatch(Firebug.Console.fbListeners, "onFiltersSet", [filterTypes]);
    },

    syncFilterButtons: function(chrome)
    {
        var filterTypes = new Set();
        Options.get("consoleFilterTypes").split(" ").forEach(function(element)
        {
            filterTypes.add(element);
        });
        var doc = chrome.window.document;
        var buttons = doc.getElementsByClassName("fbConsoleFilter");

        for (var i=0, len=buttons.length; i<len; ++i)
        {
            var filterType = buttons[i].id.substr(buttons[i].id.search("-") + 1);
            buttons[i].checked = filterTypes.has(filterType);
        }
    },

    setStatus: function()
    {
        var fbStatus = Firefox.getElementById("firebugStatus");
        if (fbStatus)
        {
            if (Firebug.Errors.watchForErrors)
                fbStatus.setAttribute("console", "on");
            else
                fbStatus.removeAttribute("console");
        }
        else
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("console.setStatus ERROR no firebugStatus element");
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    logRow: function(appender, objects, context, className, rep, sourceLink, noThrottle, noRow)
    {
        if (!context)
            context = Firebug.currentContext;

        if (FBTrace.DBG_WINDOWS && !context)
            FBTrace.sysout("Console.logRow: no context \n");

        if (this.isAlwaysEnabled())
            return Firebug.ConsoleBase.logRow.apply(this, arguments);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    /**
     * Returns the value that the console must ignore.
     *
     * @return {*} The default value
     */
    getDefaultReturnValue: function()
    {
        return defaultReturnValue;
    },

    /**
     * Returns true if the passed object has to be ignored by the console.
     *
     * @param {*} o The object to test
     *
     * @return {boolean} The result of the test
     */
    isDefaultReturnValue: function(obj)
    {
        return obj === defaultReturnValue;
    }
});

// ********************************************************************************************* //

Firebug.ConsoleListener =
{
    log: function(context, object, className, sourceLink)
    {
    },

    logFormatted: function(context, objects, className, sourceLink)
    {
    }
};

// ********************************************************************************************* //

var appendObject = Firebug.ConsolePanel.prototype.appendObject;
var appendFormatted = Firebug.ConsolePanel.prototype.appendFormatted;
var appendOpenGroup = Firebug.ConsolePanel.prototype.appendOpenGroup;
var appendCollapsedGroup = Firebug.ConsolePanel.prototype.appendCollapsedGroup;
var appendCloseGroup = Firebug.ConsolePanel.prototype.appendCloseGroup;

// ********************************************************************************************* //
// Local Helpers

function createDefaultReturnValueInstance()
{
    var proto = {
        __exposedProps__: {
            "toString": "rw"
        },
        toString: function()
        {
            return undefined;
        }
    };

    return Object.preventExtensions(Object.create(proto));
}

// ********************************************************************************************* //
// Registration

Firebug.registerActivableModule(Firebug.Console);

return Firebug.Console;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/consolePanel",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/search",
    "firebug/chrome/menu",
    "firebug/lib/options",
    "firebug/chrome/panelNotification",
    "firebug/chrome/activablePanel",
    "firebug/console/commands/profiler",
    "firebug/chrome/searchBox"
],
function(Obj, Firebug, Domplate, FirebugReps, Locale, Events, Css, Dom, Search, Menu, Options,
    PanelNotification, ActivablePanel) {

// ********************************************************************************************* //
// Constants

var {domplate, DIV, SPAN, TD, TR, TABLE, TBODY, P, A} = Domplate;

var reAllowedCss = /^(-moz-)?(background|border|color|font|line|margin|padding|text)/;

const Cc = Components.classes;
const Ci = Components.interfaces;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

const logTypes =
{
    "error": 1,
    "warning": 1,
    "info": 1,
    "debug": 1,
    "profile": 1,
    "table": 1,
    "group": 1,
    "command": 1,
    "stackTrace": 1,
    "log": 1,
    "dir": 1,
    "assert": 1,
    "spy": 1
};

// ********************************************************************************************* //

Firebug.ConsolePanel = function () {};

Firebug.ConsolePanel.prototype = Obj.extend(ActivablePanel,
{
    template: domplate(
    {
        logRowTag:
            DIV({"class": "$className", role: "listitem"},
                DIV(
                    DIV({"class": "logContent"}),
                    DIV({"class": "logCounter"},
                        SPAN({"class": "logCounterValue"})
                    )
                )
            ),

        limitTag:
            DIV({"class": "panelNotificationBox collapsed"},
                TABLE({width: "100%", cellpadding: 0, cellspacing: 0},
                    TBODY(
                        TR(
                            TD({"class": "consolPanelNotification"})
                        )
                    )
                )
            ),
    }),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Members

    wasScrolledToBottom: false,
    messageCount: 0,
    lastLogTime: 0,
    groups: null,
    limit: null,
    order: 10,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    name: "console",
    searchable: true,
    breakable: true,
    editable: false,
    enableA11y: true,

    initialize: function()
    {
        ActivablePanel.initialize.apply(this, arguments);  // loads persisted content

        this.filterMatchSet = [];

        if (!this.persistedContent && Firebug.Console.isAlwaysEnabled())
            this.insertLogLimit(this.context);

        // Listen for set filters, so the panel is properly updated when needed
        Firebug.Console.addListener(this);
    },

    destroy: function(state)
    {
        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.destroy; wasScrolledToBottom: " +
                this.wasScrolledToBottom + " " + this.context.getName());

        if (state)
            state.wasScrolledToBottom = this.wasScrolledToBottom;

        // If we are profiling and reloading, save the profileRow for the new context
        if (this.context.profileRow && this.context.profileRow.ownerDocument)
        {
            this.context.profileRow.parentNode.removeChild(this.context.profileRow);
            state.profileRow = this.context.profileRow;
        }

        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.destroy; wasScrolledToBottom: " +
                this.wasScrolledToBottom + ", " + this.context.getName());

        Firebug.Console.removeListener(this);
        ActivablePanel.destroy.apply(this, arguments);  // must be called last
    },

    initializeNode: function()
    {
        ActivablePanel.initializeNode.apply(this, arguments);

        this.onScroller = Obj.bind(this.onScroll, this);
        Events.addEventListener(this.panelNode, "scroll", this.onScroller, true);

        this.onResizer = Obj.bind(this.onResize, this);
        this.resizeEventTarget = Firebug.chrome.$('fbContentBox');
        Events.addEventListener(this.resizeEventTarget, "resize", this.onResizer, true);
    },

    destroyNode: function()
    {
        ActivablePanel.destroyNode.apply(this, arguments);

        if (this.onScroller)
            Events.removeEventListener(this.panelNode, "scroll", this.onScroller, true);

        Events.removeEventListener(this.resizeEventTarget, "resize", this.onResizer, true);
    },

    show: function(state)
    {
        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("Console.panel show; wasScrolledToBottom: " +
                (state ? state.wasScrolledToBottom : "no prev state") +
                " " + this.context.getName(), state);

        this.showCommandLine(true);
        if (Firebug.chrome.hasFocus())
            Firebug.CommandLine.focus(this.context);

        this.showToolbarButtons("fbConsoleButtons", true);

        if (!this.filterTypes)
            this.setFilter(Options.get("consoleFilterTypes").split(" "));

        Firebug.chrome.setGlobalAttribute("cmd_firebug_togglePersistConsole", "checked",
            this.persistContent);

        this.showPanel(state);
    },

    showPanel: function(state)
    {
        var wasScrolledToBottom;
        if (state)
            wasScrolledToBottom = state.wasScrolledToBottom;

        if (typeof wasScrolledToBottom == "boolean")
        {
            this.wasScrolledToBottom = wasScrolledToBottom;
            delete state.wasScrolledToBottom;
        }
        else if (typeof this.wasScrolledToBottom != "boolean")
        {
            // If the previous state doesn't says where to scroll,
            // scroll to the bottom by default.
            this.wasScrolledToBottom = true;
        }

        if (this.wasScrolledToBottom)
            Dom.scrollToBottom(this.panelNode);

        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.show; wasScrolledToBottom: " +
                this.wasScrolledToBottom + ", " + this.context.getName());

        if (state && state.profileRow) // then we reloaded while profiling
        {
            if (FBTrace.DBG_CONSOLE)
                FBTrace.sysout("console.show; state.profileRow:", state.profileRow);

            this.context.profileRow = state.profileRow;
            this.panelNode.appendChild(state.profileRow);
            delete state.profileRow;
        }
    },

    hide: function(state)
    {
        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.hide; wasScrolledToBottom: " +
                this.wasScrolledToBottom + " " + this.context.getName());

        if (state)
            state.wasScrolledToBottom = this.wasScrolledToBottom;

        this.showCommandLine(false);

        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.hide; wasScrolledToBottom: " +
                this.wasScrolledToBottom + ", " + this.context.getName());
    },

    shouldBreakOnNext: function()
    {
        // xxxHonza: shouldn't the breakOnErrors be context related?
        // xxxJJB, yes, but we can't support it because we can't yet tell
        // which window the error is on.
        return Options.get("breakOnErrors");
    },

    getBreakOnNextTooltip: function(enabled)
    {
        return (enabled ? Locale.$STR("console.Disable Break On All Errors") :
            Locale.$STR("console.Break On All Errors"));
    },

    /**
     * Support for panel activation.
     */
    onActivationChanged: function(enable)
    {
        if (FBTrace.DBG_CONSOLE || FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("console.ConsolePanel.onActivationChanged; " + enable);

        if (enable)
            Firebug.Console.addObserver(this);
        else
            Firebug.Console.removeObserver(this);
    },

    getOptionsMenuItems: function()
    {
        return [
            Menu.optionMenu("ShowJavaScriptErrors", "showJSErrors",
                "console.option.tip.Show_JavaScript_Errors"),
            Menu.optionMenu("ShowJavaScriptWarnings", "showJSWarnings",
                "console.option.tip.Show_JavaScript_Warnings"),
            Menu.optionMenu("ShowCSSErrors", "showCSSErrors",
                "console.option.tip.Show_CSS_Errors"),
            Menu.optionMenu("ShowXMLHTMLErrors", "showXMLErrors",
                "console.option.tip.Show_XML_HTML_Errors"),
            Menu.optionMenu("ShowXMLHttpRequests", "showXMLHttpRequests",
                "console.option.tip.Show_XMLHttpRequests"),
            Menu.optionMenu("ShowChromeErrors", "showChromeErrors",
                "console.option.tip.Show_System_Errors"),
            Menu.optionMenu("ShowChromeMessages", "showChromeMessages",
                "console.option.tip.Show_System_Messages"),
            Menu.optionMenu("ShowNetworkErrors", "showNetworkErrors",
                "console.option.tip.Show_Network_Errors"),
            this.getShowStackTraceMenuItem(),
            this.getStrictOptionMenuItem(),
            "-",
            Menu.optionMenu("console.option.Show_Command_Editor", "commandEditor",
                "console.option.tip.Show_Command_Editor"),
            Menu.optionMenu("commandLineShowCompleterPopup", "commandLineShowCompleterPopup",
                "console.option.tip.Show_Completion_List_Popup")
        ];
    },

    getShowStackTraceMenuItem: function()
    {
        var label = Locale.$STR("ShowStackTrace");
        var tooltip = Locale.$STR("console.option.tip.Show_Stack_Trace");
        tooltip = Locale.$STRF("script.Script_panel_must_be_enabled", [tooltip]);

        var menuItem = Menu.optionMenu(label, "showStackTrace", tooltip);
        menuItem.nol10n = true;

        if (Firebug.currentContext && !Firebug.Debugger.isAlwaysEnabled())
            menuItem.disabled = true;

        return menuItem;
    },

    getStrictOptionMenuItem: function()
    {
        var strictDomain = "javascript.options";
        var strictName = "strict";
        var strictValue = Options.getPref(strictDomain, strictName);

        return {
            label: "JavascriptOptionsStrict",
            type: "checkbox",
            checked: strictValue,
            tooltiptext: "console.option.tip.Show_Strict_Warnings",
            command: function()
            {
                var checked = this.hasAttribute("checked");
                Options.setPref(strictDomain, strictName, checked);
            }
        };
    },

    getBreakOnMenuItems: function()
    {
       return [];
    },

    setFilter: function(filterTypes)
    {
        this.filterTypes = filterTypes;

        var panelNode = this.panelNode;
        Events.dispatch(this.fbListeners, "onFiltersSet", [logTypes]);

        // Make previously visible nodes invisible again
        if (this.filterMatchSet)
        {
            for (var i in this.filterMatchSet)
                Css.removeClass(this.filterMatchSet[i], "contentMatchesFilter");
        }

        this.filterMatchSet = [];

        for (var type in logTypes)
        {
            if (filterTypes.join(" ") != "all" && filterTypes.indexOf(type) == -1)
            {
                Css.setClass(panelNode, "hideType-" + type);
            }
            else
            {
                Css.removeClass(panelNode, "hideType-" + type);

                // xxxsz: There can be two kinds of error and warning messages,
                // which have one type. So map the type to the classes, which match it.
                // TODO: Merge different CSS class names for log message types
                var classNames = [type];
                if (type == "errorMessage")
                    classNames = ["error"];
                else if (type == "warning")
                    classNames = ["warn", "warningMessage"];

                for (var i=0, classNamesLen=classNames.length; i<classNamesLen; ++i)
                {
                    var logRows = panelNode.getElementsByClassName("logRow-" + classNames[i]);
                    for (var j=0, len=logRows.length; j<len; ++j)
                    {
                        // Mark the groups, in which the log row is located, also as matched
                        for (var group = Dom.getAncestorByClass(logRows[j], "logRow-group"); group;
                            group = Dom.getAncestorByClass(group.parentNode, "logRow-group"))
                        {
                            Css.setClass(group, "contentMatchesFilter");
                            this.filterMatchSet.push(group);
                        }
                    }
                }
            }
        }
    },

    matchesFilter: function(logRow)
    {
        if (!this.filterTypes || this.filterTypes.join(" ") == "all")
            return true;

        var type = this.getLogRowType(logRow);
        return this.filterTypes.indexOf(type) != -1;
    },

    search: function(text)
    {
        // Make previously visible nodes invisible again
        if (this.matchSet)
        {
            for (var i in this.matchSet)
                Css.removeClass(this.matchSet[i], "matched");
        }

        if (!text)
            return;

        this.matchSet = [];

        function findRow(node)
        {
            return Dom.getAncestorByClass(node, "logRow");
        }

        var search = new Search.TextSearch(this.panelNode, findRow);

        var logRow = search.find(text, false, Firebug.Search.isCaseSensitive(text));
        if (!logRow)
        {
            Events.dispatch(this.fbListeners, "onConsoleSearchMatchFound", [this, text, []]);
            return false;
        }

        for (; logRow; logRow = search.findNext(undefined, undefined, undefined,
            Firebug.Search.isCaseSensitive(text)))
        {
            if (this.matchesFilter(logRow))
            {
                Css.setClass(logRow, "matched");

                // Mark the groups, in which the log row is located, also as matched
                for (var group = Dom.getAncestorByClass(logRow, "logRow-group"); group;
                    group = Dom.getAncestorByClass(group.parentNode, "logRow-group"))
                {
                    Css.setClass(group, "matched");
                    this.matchSet.push(group);
                }
                this.matchSet.push(logRow);
            }
        }

        Events.dispatch(this.fbListeners, "onConsoleSearchMatchFound",
            [this, text, this.matchSet]);

        return true;
    },

    breakOnNext: function(breaking)
    {
        Options.set("breakOnErrors", breaking);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Console Listeners

    onFiltersSet: function(filterTypes)
    {
        this.setFilter(filterTypes);
        Firebug.Search.update(this.context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getMessageMatcher: function(object, appender, className, rep, sourceLink, level)
    {
        function matchesMetaData(otherAppender, otherClassName, otherRep, otherLink, otherLevel)
        {
            if (otherAppender !== appender)
                return false;

            if (otherClassName !== className)
                return false;

            if (otherRep !== rep || (rep && rep.groupable === false))
                return false;

            if (otherLevel !== level)
                return false;

            var currentSourceInfo = (sourceLink ? sourceLink.href + ":" + sourceLink.line +
                (sourceLink.col ? ":" + sourceLink.col : "") : "");
            var otherSourceInfo = (otherLink ? otherLink.href + ":" + otherLink.line +
                (otherLink.col ? ":" + otherLink.col : "") : "");
            return currentSourceInfo === otherSourceInfo;
        }

        /**
         * Checks whether two variables are equal.
         *
         * @param {*} a First variable to be compared
         * @param {*} b Second variable to be compared
         * @returns {Boolean|undefined} True if values are equal, false if not,
         *     undefined if they are similar
         */
        function areEqual(a, b)
        {
            if (typeof a === "object" && a !== null)
                return false;

            if (a === b)
                return true;

            if (typeof a === "number" && typeof b === "number")
                return isNaN(a) && isNaN(b);

            return false;
        }

        return function matchMessage(otherObject, otherAppender, otherClassName, otherRep,
            otherSourceLink, otherLevel)
        {
            try
            {
                if (!matchesMetaData(otherAppender, otherClassName, otherRep, otherSourceLink,
                    otherLevel))
                {
                    return false;
                }

                var str = Object.prototype.toString.call(object);
                var isArray = (str === "[object Arguments]" || str === "[object Array]");
                if (isArray && rep !== FirebugReps.Arr)
                {
                    // console.log et al.
                    if (object.length !== otherObject.length)
                        return false;

                    for (var i=0, len=object.length; i<len; ++i)
                    {
                        if (!areEqual(object[i], otherObject[i]))
                            return false;
                    }

                    return true;
                }

                // Internal chrome objects are allowed to implement a custom "getId" function.
                if (object instanceof Object && "getId" in object)
                    return ("getId" in otherObject && object.getId() === otherObject.getId());

                return areEqual(object, otherObject);
            }
            catch (exc)
            {
                if (FBTrace.DBG_CONSOLE)
                    FBTrace.sysout("consolePanel.getMessageMatcher; failed to check equality", exc);

                return false;
            }
        };
    },

    increaseRowCount: function(row)
    {
        var counter = row.getElementsByClassName("logCounter").item(0);
        if (!counter)
            return;
        var value = counter.getElementsByClassName("logCounterValue").item(0);
        if (!value)
            return;

        var count = parseInt(value.textContent);
        if (isNaN(count))
            count = 1;

        count++;
        counter.setAttribute("count", count);
        value.textContent = count;
    },

    append: function(appender, objects, className, rep, sourceLink, noRow)
    {
        var row;
        var container = this.getTopContainer();
        if (noRow)
        {
            appender.apply(this, [objects]);
        }
        else
        {
            row = this.createRow("logRow", className);
            var logContent = row.getElementsByClassName("logContent").item(0);
            appender.apply(this, [objects, logContent, rep]);

            // If sourceLink is not provided and the object is an instance of Error
            // convert it into ErrorMessageObj instance, which implements getSourceLink
            // method.
            // xxxHonza: is there a better place where to make this kind of conversion?
            if (!sourceLink && (objects instanceof Error))
                objects = FirebugReps.Except.getErrorMessage(objects);

            if (!sourceLink && objects && objects.getSourceLink)
                sourceLink = objects.getSourceLink();

            if (Options.get("console.groupLogMessages") && this.matchesLastMessage &&
                this.matchesLastMessage(objects, appender, className, rep, sourceLink,
                    this.groups ? this.groups.length : 0))
            {
                this.increaseRowCount(container.lastChild);
                row = container.lastChild;
            }
            else
            {
                if (sourceLink)
                    FirebugReps.SourceLink.tag.append({object: sourceLink}, row.firstChild);

                container.appendChild(row);
            }

            this.matchesLastMessage = this.getMessageMatcher(objects, appender, className, rep,
                sourceLink, this.groups ? this.groups.length : 0);

            this.filterLogRow(row, this.wasScrolledToBottom);

            if (FBTrace.DBG_CONSOLE)
            {
                FBTrace.sysout("console.append; wasScrolledToBottom " + this.wasScrolledToBottom +
                    " " + row.textContent);
            }

            if (this.wasScrolledToBottom)
                Dom.scrollToBottom(this.panelNode);

            return row;
        }
    },

    clear: function()
    {
        if (this.panelNode)
        {
            if (FBTrace.DBG_CONSOLE)
                FBTrace.sysout("ConsolePanel.clear");

            Dom.clearNode(this.panelNode);
            this.insertLogLimit(this.context);

            Dom.scrollToBottom(this.panelNode);
            this.wasScrolledToBottom = true;

            // Don't forget to clear opened groups, if any.
            this.groups = null;

            this.matchesLastMessage = null;
        }
    },

    insertLogLimit: function()
    {
        // Create limit row. This row is the first in the list of entries
        // and initially hidden. It's displayed as soon as the number of
        // entries reaches the limit.
        var row = this.createRow("limitRow");

        // Configure the panel notification box.
        var prefName = Options.prefDomain + ".console.logLimit";
        var config = {
            totalCount: 0,
            prefName: prefName,
            buttonTooltip: Locale.$STRF("LimitPrefsTitle", [prefName])
        };

        var container = this.template.limitTag.replace({}, row);
        container = container.querySelector(".consolPanelNotification");

        this.limit = PanelNotification.render(container, config);

        this.panelNode.insertBefore(row, this.panelNode.firstChild);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    appendObject: function(object, row, rep)
    {
        if (!rep)
            rep = Firebug.getRep(object, this.context);

        // Don't forget to pass the template itself as the 'self' parameter so that it's used
        // by domplate as the 'subject' for the generation. Note that the primary purpose
        // of the subject is to provide a context object ('with (subject) {...}') for data that
        // are dynamically consumed during the rendering process.
        // This allows to derive new templates from an existing ones, without breaking
        // the default subject set within domplate() function.
        try
        {
            // XXX Hack until we get IF support in domplate (or bug 116083 gets fixed).
            var tag = rep.tag;
            if (rep === FirebugReps.Text)
                tag = rep.getWhitespaceCorrectedTag(object);
            return tag.append({object: object}, row, rep);
        }
        catch (e)
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("consolePanel.appendObject; EXCEPTION " + e, e);
                FBTrace.sysout("consolePanel.appendObject; rep " + rep.className, rep);
            }
        }
    },

    appendFormatted: function(objects, row, rep)
    {
        function logText(text, row)
        {
            var nodeSpan = row.ownerDocument.createElement("span");
            Css.setClass(nodeSpan, "logRowHint");
            var node = row.ownerDocument.createTextNode(text);
            row.appendChild(nodeSpan);
            nodeSpan.appendChild(node);
        }

        function logTextNode(text, row)
        {
            var nodeSpan = row.ownerDocument.createElement("span");
            if (text === "" || text === null || typeof(text) == "undefined")
                Css.setClass(nodeSpan, "logRowHint");

            if (text === "")
                text = Locale.$STR("console.msg.an_empty_string");

            var node = row.ownerDocument.createTextNode(text);
            row.appendChild(nodeSpan);
            nodeSpan.appendChild(node);
        }

        function addStyle(node, css)
        {
            var dummyEl = node.ownerDocument.createElementNS("http://www.w3.org/1999/xhtml", "div");
            dummyEl.setAttribute("style", css);
            node.setAttribute("style", "");
            for (var i = 0; i < dummyEl.style.length; i++)
            {
                var prop = dummyEl.style[i];
                if (reAllowedCss.test(prop))
                    node.style.setProperty(prop, dummyEl.style.getPropertyValue(prop));
            }
        }

        if (!objects || !objects.length)
        {
            // Make sure the log-row has proper height (even if empty).
            logText(Locale.$STR("console.msg.nothing_to_output"), row);
            return;
        }

        var format = objects[0];
        var objIndex = 1;

        if (typeof(format) != "string")
        {
            format = "";
            objIndex = 0;
        }
        else
        {
            // So, we have only a string...
            if (objects.length === 1)
            {
                // ...and it has no characters.
                if (format.length < 1)
                {
                    logText(Locale.$STR("console.msg.an_empty_string"), row);
                    return;
                }
            }
        }

        var parts = parseFormat(format);
        var trialIndex = objIndex;
        for (var i = 0; i < parts.length; i++)
        {
            var part = parts[i];
            if (part && typeof(part) == "object")
            {
                if (trialIndex++ >= objects.length)
                {
                    // Too few parameters for format, assume unformatted.
                    format = "";
                    objIndex = 0;
                    parts.length = 0;
                    break;
                }
            }
        }

        // Last CSS style defined using "%c" that should be applied on
        // created log-row parts (elements). See issue 6064.
        // Example: console.log('%cred-text %cgreen-text', 'color:red', 'color:green');
        var lastStyle;

        for (var i = 0; i < parts.length; ++i)
        {
            var node;
            var part = parts[i];
            if (part && typeof(part) == "object")
            {
            	var object = objects[objIndex];
                if (part.type == "%c")
                {
                    lastStyle = object.toString();
                }
                else if (objIndex < objects.length)
                {
                    if (part.type == "%f" && part.precision != -1)
                        object = parseFloat(object).toFixed(part.precision);
                    node = this.appendObject(object, row, part.rep);
                }
                else
                {
                    node = this.appendObject(part.type, row, FirebugReps.Text);
                }
                objIndex++;
            }
            else
            {
                var tag = FirebugReps.Text.getWhitespaceCorrectedTag(part);
                node = tag.append({object: part}, row);
            }

            // Apply custom style if available.
            if (lastStyle && node)
                addStyle(node, lastStyle);

            node = null;
        }

        for (var i = objIndex; i < objects.length; ++i)
        {
            logTextNode(" ", row);

            var object = objects[i];
            if (typeof(object) == "string")
                logTextNode(object, row);
            else
                this.appendObject(object, row);
        }
    },

    appendCollapsedGroup: function(objects, row, rep)
    {
        this.appendOpenGroup(objects, row, rep);
        Css.removeClass(row, "opened");
    },

    appendOpenGroup: function(objects, row, rep)
    {
        if (!this.groups)
            this.groups = [];

        Css.setClass(row, "logGroup");
        Css.setClass(row, "opened");

        var innerRow = this.createRow("logRow");
        Css.setClass(innerRow, "logGroupLabel");

        // Custom rep is used in place of group label.
        if (rep)
            rep.tag.replace({"object": objects}, innerRow);
        else
            this.appendFormatted(objects, innerRow, rep);

        row.appendChild(innerRow);
        Events.dispatch(this.fbListeners, "onLogRowCreated", [this, innerRow]);

        // Create group body, which is displayed when the group is expanded.
        var groupBody = this.createRow("logGroupBody");
        row.appendChild(groupBody);
        groupBody.setAttribute("role", "group");
        this.groups.push(groupBody);

        // Expand/collapse logic.
        Events.addEventListener(innerRow, "mousedown", function(event)
        {
            if (Events.isLeftClick(event))
            {
                var groupRow = event.currentTarget.parentNode;
                if (Css.hasClass(groupRow, "opened"))
                {
                    Css.removeClass(groupRow, "opened");
                    event.target.setAttribute("aria-expanded", "false");
                }
                else
                {
                    Css.setClass(groupRow, "opened");
                    event.target.setAttribute("aria-expanded", "true");
                }
            }
        }, false);
    },

    appendCloseGroup: function(object, row, rep)
    {
        if (this.groups)
            this.groups.pop();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // private

    createRow: function(rowName, className)
    {
        var elt = this.document.createElement("div");
        var row = this.template.logRowTag.append({className: rowName +
            (className ? " " + rowName + "-" + className : "")}, elt);
        return row;
    },

    getTopContainer: function()
    {
        if (this.groups && this.groups.length)
            return this.groups[this.groups.length-1];
        else
            return this.panelNode;
    },

    getLogRowType: function(logRow)
    {
        var typeMatch = /logRow-(\S*)/.exec(logRow.classList);
        var type = typeMatch ? typeMatch[1] : "";

        // xxxsz: There can be two kinds of error and warning messages,
        // which have one type. So map the different classes to the type
        // they represent.
        // TODO: Merge different CSS class names for log message types
        if (type == "errorMessage")
            type = "error";
        else if (type == "warn" || type == "warningMessage")
            type = "warning";

        return type;
    },

    filterLogRow: function(logRow, scrolledToBottom)
    {
        if (this.matchesFilter(logRow))
        {
            // Mark the groups, in which the log row is located, also as matched
            for (var group = Dom.getAncestorByClass(logRow, "logRow-group"); group;
                group = Dom.getAncestorByClass(group.parentNode, "logRow-group"))
            {
                Css.setClass(group, "contentMatchesFilter");
                this.filterMatchSet.push(group);
            }
        }

        if (this.searchText)
        {
            Css.setClass(logRow, "matching");
            Css.setClass(logRow, "matched");

            // Search after a delay because we must wait for a frame to be created for
            // the new logRow so that the finder will be able to locate it
            setTimeout(Obj.bindFixed(function()
            {
                if (this.searchFilter(this.searchText, logRow))
                    this.matchSet.push(logRow);
                else
                    Css.removeClass(logRow, "matched");

                Css.removeClass(logRow, "matching");

                if (scrolledToBottom)
                    Dom.scrollToBottom(this.panelNode);
            }, this), 100);
        }
    },

    searchFilter: function(text, logRow)
    {
        var count = this.panelNode.childNodes.length;
        var searchRange = this.document.createRange();
        searchRange.setStart(this.panelNode, 0);
        searchRange.setEnd(this.panelNode, count);

        var startPt = this.document.createRange();
        startPt.setStartBefore(logRow);

        var endPt = this.document.createRange();
        endPt.setStartAfter(logRow);

        return Search.finder.Find(text, searchRange, startPt, endPt) != null;
    },

    showCommandLine: function(shouldShow)
    {
        if (shouldShow)
        {
            Dom.collapse(Firebug.chrome.$("fbCommandBox"), false);
            Firebug.CommandLine.setMultiLine(Firebug.commandEditor, Firebug.chrome);
        }
        else
        {
            // Make sure that entire content of the Console panel is hidden when
            // the panel is disabled.
            Firebug.CommandLine.setMultiLine(false, Firebug.chrome, Firebug.commandEditor);
            Dom.collapse(Firebug.chrome.$("fbCommandBox"), true);
        }
    },

    onScroll: function(event)
    {
        // Update the scroll position flag if the position changes.
        this.wasScrolledToBottom = Dom.isScrolledToBottom(this.panelNode);

        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.onScroll; wasScrolledToBottom: " +
                this.wasScrolledToBottom + ", wasScrolledToBottom: " +
                this.context.getName(), event);
    },

    onResize: function(event)
    {
        if (FBTrace.DBG_CONSOLE)
            FBTrace.sysout("console.onResize; wasScrolledToBottom: " +
                this.wasScrolledToBottom + ", offsetHeight: " + this.panelNode.offsetHeight +
                ", scrollTop: " + this.panelNode.scrollTop + ", scrollHeight: " +
                this.panelNode.scrollHeight + ", " + this.context.getName(), event);

        if (this.wasScrolledToBottom)
            Dom.scrollToBottom(this.panelNode);
    },

    showInfoTip: function(infoTip, target, x, y)
    {
        var object = Firebug.getRepObject(target);
        var rep = Firebug.getRep(object, this.context);
        if (!rep)
            return false;

        return rep.showInfoTip(infoTip, target, x, y);
    }
});

// ********************************************************************************************* //

function parseFormat(format)
{
    var parts = [];
    if (format.length <= 0)
        return parts;

    var reg = /(%{1,2})(\.\d+)?([a-zA-Z])/;
    for (var m = reg.exec(format); m; m = reg.exec(format))
    {
        // If the percentage sign is escaped, then just output it
        if (m[1] == "%%")
        {
            parts.push(format.substr(0, m.index) + m[0].substr(1));
        }
        // A pattern was found, so it needs to be interpreted
        else
        {
            var type = m[3];
            var precision = m[2] ? parseInt(m[2].substr(1)) : -1;

            var rep = null;
            switch (type)
            {
                case "s":
                    rep = FirebugReps.Text;
                    break;

                case "f":
                case "i":
                case "d":
                    rep = FirebugReps.Number;
                    break;

                case "o":
                case "c":
                    rep = null;
                    break;
            }

            parts.push(format.substr(0, m.index));
            parts.push({rep: rep, precision: precision, type: "%" + type});
        }

        format = format.substr(m.index + m[0].length);
    }

    parts.push(format);
    return parts;
}

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(Firebug.ConsolePanel);

return Firebug.ConsolePanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/errorCopy",
[
    "firebug/lib/trace",
    "firebug/chrome/reps",
],
function(FBTrace, FirebugReps) {

"use strict"

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //
// ErrorCopy Object Implementation

var ErrorCopy = function(message)
{
    this.message = message;
}

// ********************************************************************************************* //
// Registration

// xxxHonza: back compatibility
FirebugReps.ErrorCopy = ErrorCopy;

return ErrorCopy;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/errorMessageObj",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/js/sourceFile",
    "firebug/js/sourceLink",
    "firebug/chrome/reps",
],
function(Firebug, FBTrace, SourceFile, SourceLink, FirebugReps) {

"use strict"

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

// ********************************************************************************************* //
// ErrorMessageObj Implementation

/**
 * @object This object collects data about an error that happens in the content. It's used
 * by {@ErrorMessage} Domplate template as the data source.
 */
function ErrorMessageObj(message, href, lineNo, source, category, context,
    trace, msgId, colNumber)
{
    this.message = message;
    this.href = href;
    this.lineNo = lineNo;
    this.source = source;
    this.category = category;
    this.context = context;
    this.trace = trace;
    this.msgId = msgId || this.getId();
    this.colNumber = colNumber;
};

ErrorMessageObj.prototype =
/** @lends ErrorMessageObj */
{
    getSourceLine: function()
    {
        if (this.href === null)
            return "";

        if (!this.context.sourceCache)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("reps.ErrorMessageObj.getSourceLine; ERROR no source cache!");
            return "";
        }

        return this.context.sourceCache.getLine(this.href, this.lineNo);
    },

    getSourceLink: function()
    {
        var ext = this.category == "css" ? "css" : "js";
        return this.lineNo ? new SourceLink.SourceLink(this.href, this.lineNo, ext,
            null, null, this.colNumber) : null;
    },

    resetSource: function()
    {
        if (this.href && this.lineNo != null)
            this.source = this.getSourceLine();
    },

    correctWithStackTrace: function(trace)
    {
        var frame = trace.frames[0];
        if (frame)
        {
            this.href = frame.href;
            this.lineNo = frame.line;
            this.trace = trace;
        }
    },

    correctSourcePoint: function(sourceName, lineNumber)
    {
        this.href = sourceName;
        this.lineNo = lineNumber;
    },

    getId: function()
    {
        return this.href + ":" + this.message + ":" + this.lineNo + ":" +
            (this.colNumber ? this.colNumber : "");
    }
};

// ********************************************************************************************* //
// Registration

// xxxHonza: back compatibility
FirebugReps.ErrorMessageObj = ErrorMessageObj;

return ErrorMessageObj;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/errorMessageRep",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/domplate",
    "firebug/console/errors",
    "firebug/console/errorMessageObj",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/url",
    "firebug/lib/string",
    "firebug/js/sourceLink",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/object",
    "firebug/chrome/menu",
    "firebug/lib/system",
    "firebug/lib/events",
    "firebug/js/fbs",
    "firebug/chrome/panelActivation",
],
function(Firebug, Module, Rep, FBTrace, Domplate, Errors, ErrorMessageObj, FirebugReps, Locale,
    Url, Str, SourceLink, Dom, Css, Obj, Menu, System, Events, FBS, PanelActivation) {

"use strict"

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

var {domplate, TAG, SPAN, DIV, TD, TR, TABLE, TBODY, A, PRE} = Domplate;

// ********************************************************************************************* //
// ErrorMessage Template Implementation

/**
 * @domplate Domplate template used to represent Error logs in the UI. Registered as Firebug rep.
 * This template is used for {@ErrorMessageObj} instances.
 */
var ErrorMessage = domplate(Rep,
/** @lends ErrorMessage */
{
    className: "errorMessage",
    inspectable: false,
    sourceLimit: 80,
    alterText: "...",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    tag:
        FirebugReps.OBJECTBOX({
            $hasTwisty: "$object|hasStackTrace",
            $hasBreakSwitch: "$object|hasBreakSwitch",
            $breakForError: "$object|hasErrorBreak",
            _repObject: "$object",
            _stackTrace: "$object|getLastErrorStackTrace",
            onclick: "$onToggleError"},
            DIV({"class": "errorTitle focusRow subLogRow", role: "listitem"},
                SPAN({"class": "errorMessage"},
                    "$object.message"
                )
            ),
            DIV({"class": "errorTrace", role: "presentation"}),
            TAG("$object|getObjectsTag", {object: "$object.objects"}),
            DIV({"class": "errorSourceBox errorSource-$object|getSourceType focusRow subLogRow",
                role: "listitem"},
                TABLE({cellspacing: 0, cellpadding: 0},
                    TBODY(
                        TR(
                            TD(
                                SPAN({"class": "$object|isBreakableError a11yFocus",
                                    role: "checkbox", "aria-checked": "$object|hasErrorBreak",
                                    title: Locale.$STR("console.Break On This Error")})
                            ),
                            TD(
                                A({"class": "errorSource a11yFocus"},
                                    PRE({"class": "errorSourceCode",
                                        title: "$object|getSourceTitle"}, "$object|getSource")
                                )
                            )
                        ),
                        TR({$collapsed: "$object|hideErrorCaret"},
                            TD(),
                            TD(
                                DIV({"class": "errorColPosition"},
                                    "$object|getColumnPosition"
                                ),
                                DIV({"class": "errorColCaret"})
                            )
                        )
                    )
                )
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getObjectsTag: function(error)
    {
        return error.objects ? FirebugReps.Arr.tag : SPAN();
    },

    getLastErrorStackTrace: function(error)
    {
        return error.trace;
    },

    hasStackTrace: function(error)
    {
        if (!error)
            return false;

        if (error.trace)
            return true;

        // The expand icon is displayed also in case where the actual stack trace
        // isn't available because the debugger (the Script panel) was disabled.
        // In this case, an explanatory message is shown instead.
        if (error.missingTraceBecauseNoDebugger)
            return true;

        return false;
    },

    hasBreakSwitch: function(error)
    {
        return error.href && error.lineNo > 0;
    },

    isBreakableError: function(error)
    {
        return (error.category === "js") ? "errorBreak" : "errorUnbreakable";
    },

    hasErrorBreak: function(error)
    {
        return FBS.hasErrorBreakpoint(Url.normalizeURL(error.href), error.lineNo);
    },

    getSource: function(error, noCrop)
    {
        if (error.source && noCrop)
        {
            return error.source;
        }
        else if (error.source)
        {
            return Str.cropStringEx(Str.trim(error.source), this.sourceLimit,
                this.alterText, error.colNumber);
        }

        if (error.category == "js" && error.href &&
            error.href.indexOf("XPCSafeJSObjectWrapper") != -1)
        {
            return "";
        }

        var source = error.getSourceLine();
        if (source && noCrop)
        {
            return source;
        }
        else if (source)
        {
            return Str.cropStringEx(Str.trim(source), this.sourceLimit,
                this.alterText, error.colNumber);
        }

        return "";
    },

    hideErrorCaret: function(error)
    {
        var source = this.getSource(error);
        if (!source)
            return true;

        if (typeof(error.colNumber) == "undefined")
            return true;

        return false;
    },

    getColumnPosition: function(error)
    {
        if (this.hideErrorCaret(error))
            return "";

        var colNumber = error.colNumber;
        var originalLength = error.source.length;
        var trimmedLength = Str.trimLeft(error.source).length;

        // The source line is displayed without starting whitespaces.
        colNumber -= (originalLength - trimmedLength);

        var source = this.getSource(error, true);
        if (!source)
            return "";

        source = Str.trim(source);

        // Count how much the pivot needs to be adjusted (based on Str.cropStringEx)
        var halfLimit = this.sourceLimit/2;
        var pivot = error.colNumber;
        if (pivot < halfLimit)
            pivot = halfLimit;

        if (pivot > source.length - halfLimit)
            pivot = source.length - halfLimit;

        // Subtract some columns if the text has been cropped at the beginning.
        var begin = Math.max(0, pivot - halfLimit);
        colNumber -= begin;

        // Add come cols because there is an alterText at the beginning now.
        if (begin > 0)
            colNumber += this.alterText.length;

        var text = "";
        for (var i=0; i<colNumber; i++)
            text += "-";

        return text;
    },

    getSourceTitle: function(error)
    {
        var source = this.getSource(error, true);
        return source ? Str.trim(source) : "";
    },

    getSourceType: function(error)
    {
        // Errors occurring inside of HTML event handlers look like "foo.html (line 1)"
        // so let's try to skip those
        if (error.source)
            return "syntax";
        else if (error.category == "css")
            return "show";
        else if (!error.href || !error.lineNo)
            return "none";
        // Why do we have that at all?
        else if (error.lineNo == 1 && Url.getFileExtension(error.href) != "js")
            return "none";
        else
            return "show";
    },

    onToggleError: function(event)
    {
        var target = event.currentTarget;
        if (Css.hasClass(event.target, "errorBreak"))
        {
            var panel = Firebug.getElementPanel(event.target);
            this.breakOnThisError(target.repObject, panel.context);
            return;
        }
        else if (Css.hasClass(event.target, "errorSourceCode"))
        {
            var panel = Firebug.getElementPanel(event.target);
            this.inspectObject(target.repObject, panel.context);
            return;
        }

        var errorTitle = Dom.getAncestorByClass(event.target, "errorTitle");
        if (errorTitle)
        {
            var traceBox = target.getElementsByClassName("errorTrace").item(0);

            Css.toggleClass(target, "opened");
            event.target.setAttribute("aria-expanded", Css.hasClass(target, "opened"));

            if (Css.hasClass(target, "opened"))
            {
                if (target.stackTrace)
                {
                    FirebugReps.StackTrace.tag.append({object: target.stackTrace}, traceBox);
                }
                else if (target.repObject.missingTraceBecauseNoDebugger)
                {
                    this.renderStackTraceMessage(traceBox);
                }

                if (Firebug.A11yModel.enabled)
                {
                    var panel = Firebug.getElementPanel(event.target);
                    Events.dispatch(panel.fbListeners, "modifyLogRow", [panel, traceBox]);
                }
            }
            else
            {
                Dom.clearNode(traceBox);
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Stack Trace Message

    renderStackTraceMessage: function(parentNode)
    {
        var hasScriptPanel = PanelActivation.isPanelEnabled("script");
        var type = hasScriptPanel ? "reload" : "enable";
        var clickHandler = this.onClickStackTraceMessage.bind(this, type);
        var msg = (hasScriptPanel ? Locale.$STR("console.DebuggerWasDisabledForError") :
            Locale.$STR("console.ScriptPanelMustBeEnabledForTraces"));

        parentNode.classList.add("message");

        FirebugReps.Description.render(msg, parentNode, clickHandler);
    },

    onClickStackTraceMessage: function(type, event)
    {
        var target = event.target;

        if (type == "enable")
        {
            // Enable the Script panel.
            var scriptPanelType = Firebug.getPanelType("script");
            PanelActivation.enablePanel(scriptPanelType);
        }
        else if (type == "reload")
        {
            var panel = Firebug.getElementPanel(target);
            Firebug.TabWatcher.reloadPageFromMemory(panel.context);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    copyError: function(error)
    {
        var message = [
            error.message,
            error.href,
            "Line " +  error.lineNo
        ];
        System.copyToClipboard(message.join(Str.lineBreak()));
    },

    breakOnThisError: function(error, context)
    {
        var compilationUnit = context.getCompilationUnit(Url.normalizeURL(error.href));
        if (!compilationUnit)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("reps.breakOnThisError has no source file for error.href: " +
                    error.href + "  error:" + error, context);
            return;
        }

        if (this.hasErrorBreak(error))
            Firebug.Debugger.clearErrorBreakpoint(compilationUnit, error.lineNo);
        else
            Firebug.Debugger.setErrorBreakpoint(compilationUnit, error.lineNo);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsObject: function(object, type)
    {
        return object instanceof ErrorMessageObj;
    },

    inspectObject: function(error, context)
    {
        var sourceLink = error.getSourceLink();
        FirebugReps.SourceLink.inspectObject(sourceLink, context);
    },

    getContextMenuItems: function(error, target, context)
    {
        var breakOnThisError = this.hasErrorBreak(error);

        var items = [
            {
                label: "CopyError",
                tooltiptext: "console.menu.tip.Copy_Error",
                command: Obj.bindFixed(this.copyError, this, error)
            }
        ];

        if (error.category != "css")
        {
            items.push(
                "-",
                {
                    label: "BreakOnThisError",
                    tooltiptext: "console.menu.tip.Break_On_This_Error",
                    type: "checkbox",
                    checked: breakOnThisError,
                    command: Obj.bindFixed(this.breakOnThisError, this, error, context)
                },
                Menu.optionMenu("BreakOnAllErrors", "breakOnErrors",
                    "console.menu.tip.Break_On_All_Errors")
            );
        }

        return items;
    },
});

// ********************************************************************************************* //
// ErrorMessageUpdater Module

/**
 * @module Responsible for asynchronous UI update or ErrorMessage template.
 */
var ErrorMessageUpdater = Obj.extend(Module,
/** @lends ErrorMessageUpdater */
{
    dispatchName: "ErrorMessageUpdater",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);
        PanelActivation.addListener(this);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);
        PanelActivation.removeListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // PanelActivation

    activationChanged: function(panelType, enable)
    {
        // The Script panel's activation changed. Make sure all trace messages (for errors)
        // are updated. It must be done for all contexts since panel activation always
        // applies to all contexts.
        if (panelType.prototype.name == "script")
            Firebug.connection.eachContext(this.updateConsolePanel.bind(this));
    },

    updateConsolePanel: function(context)
    {
        var panel = context.getPanel("console", true);
        if (!panel)
            return;

        // Update all existing user messages in the panel.
        var messages = panel.panelNode.querySelectorAll(".errorTrace.message");
        for (var i=0; i<messages.length; i++)
            ErrorMessage.renderStackTraceMessage(messages[i]);
    }
});

// ********************************************************************************************* //
// Registration

// xxxHonza: back compatibility
FirebugReps.ErrorMessage = ErrorMessage;

Firebug.registerModule(ErrorMessageUpdater);
Firebug.registerRep(ErrorMessage);

return ErrorMessage;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/errors",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/reps",
    "firebug/lib/xpcom",
    "firebug/console/console",
    "firebug/lib/css",
    "firebug/chrome/window",
    "firebug/lib/array",
    "firebug/lib/string"
],
function(Module, Obj, Firebug, FirebugReps, Xpcom, Console, Css, Win, Arr, Str) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const nsIScriptError = Ci.nsIScriptError;
const nsIConsoleMessage = Ci.nsIConsoleMessage;

const WARNING_FLAG = nsIScriptError.warningFlag;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

const urlRe = new RegExp("([^:]*):(//)?([^/]*)");
const reUncaught = /uncaught exception/;
// regular expressions for parsing uncaught exceptions
// see http://lxr.mozilla.org/mozilla/source/js/src/xpconnect/src/xpcexception.cpp#347
// and http://lxr.mozilla.org/mozilla/source/js/src/xpconnect/src/xpcstack.cpp#318
// and http://lxr.mozilla.org/mozilla/source/dom/src/base/nsDOMException.cpp#351
const reException1 = /^(?:uncaught exception: )?\[Exception... "(?!<no message>)([\s\S]+)"  nsresult: "0x\S+ \((.+)\)"  location: "(?:(?:JS|native) frame :: (?!<unknown filename>)(.+) :: .+ :: line (\d+)|<unknown>)"  data: (?:yes|no)\]$/;
const reException2 = /^(?:uncaught exception: )?\[Exception... "(?!<no message>)([\s\S]+)"  code: "\d+" nsresult: "0x\S+ \((.+)\)"  location: "(?:(.+) Line: (\d+)|<unknown>)"\]$/;
const pointlessErrors =
{
    "uncaught exception: Permission denied to call method Location.toString": 1,
    "uncaught exception: Permission denied to get property Window.writeDebug": 1,
    "uncaught exception: Permission denied to get property XULElement.accessKey": 1,
    "this.docShell has no properties": 1,
    "aDocShell.QueryInterface(Components.interfaces.nsIWebNavigation).currentURI has no properties": 1,
    "Deprecated property window.title used. Please use document.title instead.": 1,
    "Key event not available on GTK2:": 1
};

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

Components.utils["import"]("resource://firebug/firebug-service.js");

const consoleService = Xpcom.CCSV("@mozilla.org/consoleservice;1", "nsIConsoleService");
const domWindowUtils = window.QueryInterface(Ci.nsIInterfaceRequestor)
    .getInterface(Ci.nsIDOMWindowUtils);

const wm = Xpcom.CCSV("@mozilla.org/appshell/window-mediator;1", "nsIWindowMediator");

// ********************************************************************************************* //

var Errors = Firebug.Errors = Obj.extend(Module,
{
    dispatchName: "errors",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    shutdown: function()
    {
        // Make sure the error observer is removed.
        this.stopObserving();

        Module.shutdown.apply(this, arguments);
    },

    initContext: function(context)
    {
        this.clear(context);
    },

    showContext: function(browser, context)
    {
        this.showCount(context ? context.errorCount : 0);
    },

    // called for top window and frames.
    unwatchWindow: function(context, win)
    {
        // If we ever get errors by window from Firefox we can cache by window.
        this.clear(context);
    },

    destroyContext: function(context, persistedState)
    {
        this.showCount(0);

        if (FBTrace.DBG_ERRORLOG && FBTrace.DBG_CSS && "initTime" in this)
        {
            var deltaT = new Date().getTime() - this.initTime.getTime();

            FBTrace.sysout("errors.destroyContext sheets: " + Css.totalSheets + " rules: " +
                Css.totalRules + " time: " + deltaT);
        }
    },

    updateOption: function(name, value)
    {
        this.checkEnabled();

        if (name == "showErrorCount")
            this.toggleShowErrorCount();
    },

    toggleShowErrorCount: function()
    {
        this.showContext(null, Firebug.currentContext);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    clear: function(context)
    {
        // reset the UI counter
        this.setCount(context, 0);

        // clear the counts of dropped errors
        delete context.droppedErrors;
    },

    increaseCount: function(context)
    {
        this.setCount(context, context.errorCount + 1);
    },

    setCount: function(context, count)
    {
        context.errorCount = count;

        if (context == Firebug.currentContext)
            this.showCount(context.errorCount);
    },

    showCount: function(errorCount)
    {
        Firebug.StartButton.showCount(errorCount);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Called by Console

    startObserving: function()
    {
        if (this.isObserving)
            return;

        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("Errors.startObserving");

        if (consoleService)
            consoleService.registerListener(this);

        this.isObserving = true;
    },

    stopObserving: function()
    {
        if (!this.isObserving)
            return;

        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("Errors.stopObserving");

        if (consoleService)
            consoleService.unregisterListener(this);

        this.isObserving = false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends consoleListener

    observe: function(object)
    {
        // Make sure the argument is an error object. 'instanceof' also
        // queries the object so e.g. outerWindowID (nsIScriptError2) is available.
        // nsIScriptError2 was merged with nsIScriptError, see
        // https://bugzilla.mozilla.org/show_bug.cgi?id=711721
        if (!(object instanceof Ci.nsIScriptError) ||
            (Ci.nsIScriptError2 && !(object instanceof Ci.nsIScriptError2)))
        {
            return;
        }

        try
        {
            if (window.closed)
                this.stopObserving();

            if (typeof FBTrace == "undefined")
                return;

            if (!FBTrace)
                return;
        }
        catch (exc)
        {
            return;
        }

        try
        {
            this.onConsoleLog(object);
        }
        catch (exc)
        {
            // Errors prior to console init will come out here, eg error message
            // from Firefox startup jjb.
            if (FBTrace.DBG_ERRORLOG)
            {
                FBTrace.sysout("errors.observe FAILS " + exc, exc);
                FBTrace.sysout("errors.observe object " + object, object);
            }
        }
    },

    onConsoleLog: function(object)
    {
        var ScriptError = object instanceof nsIScriptError;
        var ConsoleMessage = object instanceof nsIConsoleMessage;

        // This cannot be pulled in front of the instanceof
        var isWarning = object && object.flags & WARNING_FLAG;
        var CSSParser = object && object.category == "CSS Parser";
        var XPConnect = object && object.category &&
            object.category.split(' ').indexOf("XPConnect") != -1;

        // Some categories say "content javascript" even if they come from chrome space.
        var sourceName = (object && object.sourceName) ? object.sourceName : "";
        if (Str.hasPrefix(sourceName, "chrome:") || Str.hasPrefix(sourceName, "resource:"))
            XPConnect = true;

        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("errors.observe; ScriptError: " + ScriptError +
                ", XPConnect: " + XPConnect + ", sourceName: " + sourceName);

        if (ScriptError && !XPConnect)  // all branches should trace 'object'
        {
            if (FBTrace.DBG_ERRORLOG)
            {
                FBTrace.sysout("errors.observe nsIScriptError: " + object.errorMessage,
                    object);
            }

            // after instanceof
            var context = this.getErrorContext(object);
            if (context)
                return this.logScriptError(context, object, isWarning);

            if (FBTrace.DBG_ERRORLOG)
            {
                FBTrace.sysout("errors.observe nsIScriptError no context! " +
                    object.errorMessage, object);
            }
        }
        else
        {
            if (Firebug.showChromeMessages)
            {
                if (ConsoleMessage)
                {
                    if (FBTrace.DBG_ERRORLOG)
                    {
                        FBTrace.sysout("errors.observe nsIConsoleMessage: " +
                            object.message, object);
                    }

                    var context = this.getErrorContext(object);  // after instanceof
                    if (!context)
                        context = Firebug.currentContext;

                    var msgId = lessTalkMoreAction(context, object, isWarning);
                    if (!msgId)
                        return;

                    if (context)
                    {
                        // Even chrome errors can be nicely formatted in the Console panel
                        this.logScriptError(context, object, isWarning);
                        //Console.log(object.message, context, "consoleMessage",
                        //FirebugReps.Text);
                    }
                }
                else if (object.message)
                {
                    if (FBTrace.DBG_ERRORLOG)
                        FBTrace.sysout("errors.observe object.message:", object);

                    var context = this.getErrorContext(object);

                    if (!context)
                        context = Firebug.currentContext;

                    if (context)
                    {
                        // Even chrome errors can be nicely formatted in the Console panel
                        this.logScriptError(context, object, isWarning);
                        //Console.log(object.message, context, "consoleMessage",
                        //FirebugReps.Text);
                    }
                    else
                    {
                        FBTrace.sysout("errors.observe, no context for message", object);
                    }
                }
                else
                {
                    FBTrace.sysout("errors.observe, no message in object", object);
                }
            }
            else
            {
                if (FBTrace.DBG_ERRORLOG)
                    FBTrace.sysout("errors.observe showChromeMessages off, dropped:", object);
                return;
            }
        }

        if (FBTrace.DBG_ERRORLOG)
        {
            if (context)
            {
                if (context.window)
                {
                    FBTrace.sysout((isWarning?"warning":"error") + " logged to " +
                        context.getName());
                }
                else
                {
                    FBTrace.sysout("errors.observe, context with no window, " +
                        (isWarning?"warning":"error")+" object:", object);

                    FBTrace.sysout("errors.observe, context with no window, context:",
                        context);
                }
            }
            else
            {
                FBTrace.sysout("errors.observe, no context!");
            }
        }
    },

    logScriptError: function(context, object, isWarning)
    {
        if (!context)
            return;

        if (FBTrace.DBG_ERRORLOG)
        {
            FBTrace.sysout("errors.observe logScriptError " +
                (Firebug.errorStackTrace ? "have " : "NO ") +
                (Firebug.showStackTrace ? "show stack trace" : "do not show stack trace ") +
                "errorStackTrace error object:",
                {object: object, errorStackTrace: Firebug.errorStackTrace});
        }

        var category = getBaseCategory(object.category);
        var isJSError = category == "js" && !isWarning;

        // the sourceLine will cause the source to be loaded.
        var error = new FirebugReps.ErrorMessageObj(object.errorMessage, object.sourceName,
            object.lineNumber, object.sourceLine, category, context, null);

        // Display column info only if it isn't zero.
        if (object.columnNumber > 0)
            error.colNumber = object.columnNumber;

        if (checkForException(context, object))
        {
            context = getExceptionContext(context, object);
            correctLineNumbersOnExceptions(object, error);
        }

        if (Firebug.errorStackTrace)
        {
            error.correctWithStackTrace(Firebug.errorStackTrace);
            if (!Firebug.showStackTrace)
                error.trace = null;
        }
        else if (Firebug.showStackTrace && !context.isPanelEnabled("script"))
        {
            error.missingTraceBecauseNoDebugger = true;
        }

        var msgId = lessTalkMoreAction(context, object, isWarning);
        if (!msgId)
            return null;

        // clear global: either we copied it or we don't use it.
        Firebug.errorStackTrace = null;

        if (!isWarning)
            this.increaseCount(context);

        var className = isWarning ? "warningMessage" : "errorMessage";

        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("errors.observe delayed log to " + context.getName());

        // report later to avoid loading sourceS
        context.throttle(this.delayedLogging, this, [msgId, context, error, context, className,
            false, true], true);
    },

    delayedLogging: function()
    {
        var args = Arr.cloneArray(arguments);
        var msgId = args.shift();
        var context = args.shift();
        var row = Console.log.apply(Console, args);
        return row;
    },

    getErrorContext: function(object)
    {
        var url = object.sourceName;

        // If window is not associated bail out to avoid reporting errors that are not
        // page related (issue 4991).
        if (!url && !object.outerWindowID)
        {
            if (FBTrace.DBG_ERRORLOG)
                FBTrace.sysout("errors.getErrorContext; No URL & no outer-window. " +
                    "url: " + url + ", outerWindowID: " + object.outerWindowID, object);
            return null;
        }

        if (url && url.indexOf("://chromebug/") > 0)
            return Firebug.currentContext; // no context for self

        // Correct the error routing in the case that the new window id will work (R10860).
        // Don't pass the current context (issue 4504)
        var errorContext = getExceptionContext(null, object);
        if (errorContext)
            return errorContext;

        var errorContext = null;
        Firebug.connection.eachContext(
            function findContextByURL(context)
            {
                if (FBTrace.DBG_ERRORLOG && FBTrace.DBG_CSS)
                    FBTrace.sysout("findContextByURL " + context.getName());

                if (!context.window || !context.getWindowLocation())
                    return false;

                // If the error's parent window is available, check if it
                // corresponds to the context.window. If not bail out to avoid
                // error reporting in a wrong window.
                var errorWindow = getErrorWindow(object);
                if (errorWindow && errorWindow != context.window)
                    return false;

                if (FBTrace.DBG_ERRORLOG)
                {
                    FBTrace.sysout("findContextByURL seeking " + url + " in " +
                        (context.loaded ? "loaded" : "not loaded") +
                        " window location: " + context.getWindowLocation().toString());
                }

                if (context.getWindowLocation().toString() == url)
                {
                    if (FBTrace.DBG_ERRORLOG && FBTrace.DBG_CSS)
                        FBTrace.sysout("findContextByURL found match to context window location");

                    return errorContext = context;
                }
                else
                {
                    if (context.sourceFileMap && context.sourceFileMap[url])
                    {
                        if (FBTrace.DBG_ERRORLOG && FBTrace.DBG_CSS)
                            FBTrace.sysout("findContextByURL found match in sourceFileMap");
                        return errorContext = context;
                    }
                }

                if (context.loaded)
                {
                    if (Css.getStyleSheetByHref(url, context))
                    {
                        if (FBTrace.DBG_ERRORLOG && FBTrace.DBG_CSS)
                        {
                            FBTrace.sysout("findContextByURL found match to in loaded " +
                                "styleSheetMap");
                        }

                        return errorContext = context;
                    }
                    else
                    {
                        return false;
                    }
                }
                else  // then new stylesheets are still coming in.
                {
                    if (context.getCompilationUnit(url))
                    {
                        if (FBTrace.DBG_EERRORLOG)
                            FBTrace.sysout("findContextByURL found match in compilationUnits");

                        return errorContext = context;
                    }

                    if (Css.getStyleSheetByHref(url, context))
                    {
                        if (FBTrace.DBG_ERRORLOG && FBTrace.DBG_CSS)
                        {
                            FBTrace.sysout("findContextByURL found match to in non-loaded " +
                                "styleSheetMap");
                        }

                        // but we already have this one.
                        errorContext = context;
                    }

                    // clear the cache for next time.
                    delete context.styleSheetMap;
                }
            });

        if (FBTrace.DBG_ERRORLOG && FBTrace.DBG_CSS && "initTime" in this)
        {
            var deltaT = new Date().getTime() - this.initTime.getTime();
            FBTrace.sysout("errors.getErrorContext sheets: " + Css.totalSheets +
                " rules: " + Css.totalRules + " time: " + deltaT);
        }

        if (!errorContext)
        {
            if (FBTrace.DBG_ERRORLOG)
                FBTrace.sysout("errors.getErrorContext no context from error filename:"+
                    url, object);
        }

        // Use nsIScriptError/nsIScriptError2 to compare the parent window
        // guessed by Firebug with the window found through outerWindowID
        if (FBTrace.DBG_ERRORLOG)
        {
            var win1 = getErrorWindow(object);
            var win2 = errorContext ? errorContext.window : null;

            win1 = Win.getRootWindow(win1);
            win2 = Win.getRootWindow(win2);

            var id1 = Win.getWindowProxyIdForWindow(win1);
            var id2 = Win.getWindowProxyIdForWindow(win2);

            if (win1 && id1 != id2 && errorContext)
            {
                var win1Name = Win.safeGetWindowLocation(win1);
                var win2Name = Win.safeGetWindowLocation(win2);
                var moreInfo = {object: object, fromError2: win1, fromFirebug: win2};

                FBTrace.sysout("errors.getErrorContext; ERROR wrong parent window? " +
                    win1Name + " !== " + win2Name, moreInfo);
            }
        }

        // we looked everywhere...
        return errorContext;
    },

    toggleWatchForErrors: function(watchForErrors)
    {
        var previous = this.watchForErrors;
        this.watchForErrors = watchForErrors;
        this.checkEnabled();

        return (previous !== this.watchForErrors);
    },

    checkEnabled: function()
    {
        var beEnabled = this.watchForErrors && this.mustBeEnabled();
        if (beEnabled)
        {
            if (!this.isObserving)
                this.startObserving();
            // else we must be and we are observing
        }
        else
        {
            if (this.isObserving)
                this.stopObserving();
            // else we must not be and we are not
        }

        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("errors.checkEnabled mustBeEnabled: " + this.mustBeEnabled() +
                " Console.isAlwaysEnabled " + Console.isAlwaysEnabled() +
                " isObserving:" + this.isObserving);
    },

    mustBeEnabled: function()
    {
        var optionMap =
        {
            showJSErrors:1,
            showJSWarnings:1,
            showCSSErrors:1,
            showXMLErrors: 1,
            showChromeErrors: 1,
            showChromeMessages: 1,
            showXMLHttpRequests: 1,
            showStackTrace: 1
        };

        for (var p in optionMap)
        {
            if (Firebug[p])
                return true;
        }

        return false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    reparseXPC: function(errorMessage, context)
    {
        var reXPCError = /JavaScript Error:\s*\"([^\"]*)\"/;
        var reFile = /file:\s*\"([^\"]*)\"/;
        var reLine = /line:\s*(\d*)/;
        var m = reXPCError.exec(errorMessage);
        if (!m)
            return null;

        var msg = m[1];
        var sourceFile = null;
        m = reFile.exec(errorMessage);
        if (m)
            sourceFile = m[1];

        var sourceLineNo = 0;
        m = reLine.exec(errorMessage);
        if (m)
            sourceLineNo = m[1];

        var sourceLine = null;
        if (sourceFile && sourceLineNo && sourceLineNo != 0)
        {
            if (context.sourceCache)
            {
                sourceLine = context.sourceCache.getLine(sourceFile, sourceLineNo);
            }
            else if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("errors.reparseXPC; ERROR, NULL context.sourceCache, " +
                    sourceFile + ", " + sourceLineNo);
            }
        }

        var error = new FirebugReps.ErrorMessageObj(msg, sourceFile,
            sourceLineNo, sourceLine, "error", context, null);
        return error;
    }
});

// ********************************************************************************************* //
// Local Helpers

const categoryMap =
{
    "javascript": "js",
    "JavaScript": "js",
    "DOM": "js",
    "DOM:HTML": "js",
    "Events": "js",
    "CSS": "css",
    "HTML": "xml",
    "XML": "xml",
    "malformed-xml": "xml"
};

function getBaseCategory(categories)
{
    var categoryList = categories.split(" ");
    for (var i=0; i<categoryList.length; ++i)
    {
        var category = categoryList[i];
        if (categoryMap.hasOwnProperty(category))
            return categoryMap[category];
    }
}

function whyNotShown(url, categoryList, isWarning)
{
    var m = urlRe.exec(url);
    var errorScheme = m ? m[1] : "";
    if (errorScheme == "javascript")
        return null;

    var isChrome = false;

    if (!categoryList)
    {
        return Firebug.showChromeErrors ? null :
            "no category, assume chrome, showChromeErrors false";
    }

    var categories = categoryList.split(" ");
    for (var i=0; i<categories.length; ++i)
    {
        var category = categories[i];
        if (category == "CSS" && !Firebug.showCSSErrors)
        {
            return "showCSSErrors";
        }
        else if ((category == "HTML" || category == "XML" || category == "malformed-xml") &&
            !Firebug.showXMLErrors)
        {
            return "showXMLErrors";
        }
        else if ((category == "javascript" || category == "JavaScript" || category == "DOM")
            && !isWarning && !Firebug.showJSErrors)
        {
            return "showJSErrors";
        }
        else if ((category == "javascript" || category == "JavaScript" || category == "DOM" ||
                category == "DOM:HTML")
            && isWarning && !Firebug.showJSWarnings)
        {
            return "showJSWarnings";
        }
        else if (errorScheme == "chrome" || category == "XUL" || category == "chrome" ||
            category == "XBL" || category == "component")
        {
            isChrome = true;
        }
    }

    if (isChrome && !Firebug.showChromeErrors)
        return "showChromeErrors";

    return null;
}

function lessTalkMoreAction(context, object, isWarning)
{
    if (!context)
    {
        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("errors.observe dropping " + object.category + " no context");
        return false;
    }

    var enabled = Console.isAlwaysEnabled();
    if (!enabled)
        return null;

    var why = whyNotShown(object.sourceName, object.category, isWarning);
    if (why)
    {
        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("errors.observe dropping " + object.category + " because: " + why);

        context.droppedErrors = context.droppedErrors || {};

        if (!context.droppedErrors[object.category])
            context.droppedErrors[object.category] = 1;
        else
            context.droppedErrors[object.category] += 1;

        return null;
    }

    // nsIScriptError
    var incoming_message = object.errorMessage;

    // nsIConsoleMessage
    if (!incoming_message)
        incoming_message = object.message;

    if (Firebug.suppressPointlessErrors)
    {
        for (var msg in pointlessErrors)
        {
            if (msg.charAt(0) == incoming_message.charAt(0))
            {
                if (Str.hasPrefix(incoming_message, msg))
                {
                    if (FBTrace.DBG_ERRORLOG)
                        FBTrace.sysout("errors.observe dropping pointlessError: " + msg);
                    return null;
                }
            }
        }
    }

    var msgId = [incoming_message, object.sourceName, object.lineNumber].join("/");
    return msgId;
}

function checkForException(context, object)
{
    if (object.flags & object.exceptionFlag)
    {
        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("errors.observe is exception");

        if (context.thrownStackTrace)
        {
            Firebug.errorStackTrace = context.thrownStackTrace;

            if (FBTrace.DBG_ERRORLOG)
                FBTrace.sysout("errors.observe trace.frames", context.thrownStackTrace.frames);

            delete context.thrownStackTrace;
        }
        else
        {
             if (FBTrace.DBG_ERRORLOG)
                FBTrace.sysout("errors.observe NO context.thrownStackTrace");
        }
        return true;
    }

    delete context.thrownStackTrace;
    return false;
}

/**
 * Returns a parent window (outer window) for given error object (an object
 * that is passed into a consoleListener).
 * This method should be the primary way how to find the parent window for any
 * error object.
 *
 * @param {Object} object Error object (implementing nsIScriptError2 or nsIScriptError)
 */
function getErrorWindow(object)
{
    try
    {
        // nsIScriptError2 is merged into nsIScriptError in Firefox 12 (bug
        // 711721), so check for the one that is relevant.
        var why;
        if (object instanceof (Ci["nsIScriptError2"] || Ci["nsIScriptError"]))
        {
            if (object.outerWindowID)
            {
                var win;

                // getOuterWindowWithId moved to nsIWindowMediator in Firefox 23
                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=861495
                if (typeof(wm.getOuterWindowWithId) == "function")
                    win = wm.getOuterWindowWithId(object.outerWindowID);
                else
                    win = domWindowUtils.getOuterWindowWithId(object.outerWindowID);

                if (win)
                    return win;
                else
                    why = "no getOuterWindowWithId";
            }
            else
            {
                why = "no outerWindowID";
            }
        }
        else
        {
            why = "not an nsIScriptError";
        }

        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("errors.getErrorWindow failed " + why, object);
    }
    catch (err)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("errors.getErrorWindow; EXCEPTION" + err, err);
    }

    return null;
}

function getExceptionContext(context, object)
{
    var errorWin = getErrorWindow(object);
    if (errorWin)
    {
        var errorContext = Firebug.connection.getContextByWindow(errorWin);
        if (FBTrace.DBG_ERRORLOG)
        {
            FBTrace.sysout("errors.observe exception context: " +
                (errorContext ? errorContext.getName() : "none") + " errorWin: " +
                    Win.safeGetWindowLocation(errorWin));
        }

        if (errorContext)
            return errorContext;
    }

    return context;
}

function correctLineNumbersOnExceptions(object, error)
{
    var m = reException1.exec(object.errorMessage) || reException2.exec(object.errorMessage);
    if (m)
    {
        var exception = m[1];
        if (exception)
            error.message = exception;
        var sourceName = m[3];
        var lineNumber = parseInt(m[4]);

        error.correctSourcePoint(sourceName, lineNumber);

        if (FBTrace.DBG_ERRORLOG)
        {
            FBTrace.sysout("errors.correctLineNumbersOnExceptions corrected message " +
                "with sourceName: "+ sourceName + "@" + lineNumber);
        }
    }
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Errors);

return Firebug.Errors;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/exceptionRep",
[
    "firebug/firebug",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/domplate",
    "firebug/console/errorMessageObj",
    "firebug/console/errorMessageRep",
    "firebug/console/errorCopy",
    "firebug/chrome/reps",
    "firebug/js/stackFrame",
],
function(Firebug, Rep, FBTrace, Obj, Domplate, ErrorMessageObj, ErrorMessage, ErrorCopy,
    FirebugReps, StackFrame) {

"use strict"

// ********************************************************************************************* //
// Constants

var {domplate, TAG} = Domplate;

// ********************************************************************************************* //
// Exception Template Implementation

/**
 * @domplate This template represents exceptions that happen in the content and appear
 * within Firebug UI. It's registered as Firebug rep.
 */
var Exception = domplate(Rep,
/** @lends Exception */
{
    tag:
        TAG(ErrorMessage.tag, {object: "$object|getErrorMessage"}),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    className: "exception",

    getTitle: function(object)
    {
        if (object.name)
            return object.name + (object.message ? ": " + object.message : "");

        if (object.message)
            return object.message;

        return "Exception";
    },

    getErrorMessage: function(object)
    {
        var context = Firebug.currentContext;
        var win = context ? context.window : null;

        var url = object.fileName ? object.fileName : (win ? win.location.href : "");
        var lineNo = object.lineNumber ? object.lineNumber : 0;
        var message = this.getTitle(object);

        var trace;
        if (object.stack)
        {
            trace = StackFrame.parseToStackTrace(object.stack, context);
            trace = StackFrame.cleanStackTraceOfFirebug(trace);

            if (!trace)
                lineNo = 0;
        }

        var errorObject = new ErrorMessageObj(message, url, lineNo, "", "js",
            context, trace);

        if (trace && trace.frames && trace.frames[0])
            errorObject.correctWithStackTrace(trace);

        errorObject.resetSource();
        return errorObject;
    },

    supportsObject: function(object, type)
    {
        return (object instanceof ErrorCopy) || Obj.XW_instanceof(object, Error);
    }
});

// ********************************************************************************************* //
// Registration

// xxxHonza: back compatibility
FirebugReps.Except = Exception;

Firebug.registerRep(Exception);

return Exception;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/functionMonitor",
[
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/js/stackFrame",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/url",
],
function(Module, Rep, FBTrace, Obj, Domplate, Reps, StackFrame, Events, Css, Dom, Url) {

"use strict";

// ********************************************************************************************* //
// Constants

var {domplate, A, SPAN, FOR, TAG, DIV} = Domplate;

// ********************************************************************************************* //
// Function Monitor

var FunctionMonitor = Obj.extend(Module,
{
    dispatchName: "functionMonitor",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);
        Firebug.connection.addListener(this);
    },

    shutdown: function()
    {
        Firebug.connection.removeListener(this);
        Module.shutdown.apply(this, arguments);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug.Debugger listener

    onMonitorScript: function(context, frame)
    {
        var stackTrace = StackFrame.buildStackTrace(frame);
        Firebug.Console.log(new FunctionLog(frame, stackTrace), context);
    },

    onFunctionCall: function(context, frame, depth, calling)
    {
        //var url = Url.normalizeURL(frame.script.fileName);
        //var sourceFile = context.sourceFileMap[url];
        // Firebug.errorStackTrace = StackFrame.getCorrectedStackTrace(frame, context);
        //var sourceFile = Firebug.SourceFile.getSourceFileByScript(context, frame.script);
        if (Url.isSystemURL(Url.normalizeURL(frame.script.fileName)))
            return;

        // xxxHonza: traceCall and traceCallAll need to be fixed yet.
        FBTrace.sysout("functionMonitor.onFunctionCall; ", sourceFile);

        if (calling)
            Firebug.Console.openGroup([frame, "depth:" + depth], context);
        else
            Firebug.Console.closeGroup(context);
    },
});

// ********************************************************************************************* //
// Rep Object

function FunctionLog(frame, stackTrace)
{
    this.frame = frame;
    this.stackTrace = stackTrace;
}

// ********************************************************************************************* //
// Function Monitor Rep

var FunctionMonitorRep = domplate(Rep,
{
    className: "functionCall",

    tag:
        Reps.OBJECTBLOCK({$hasTwisty: "$object|hasStackTrace", _repObject: "$object",
            onclick: "$onToggleStackTrace"},
            A({"class": "objectLink functionCallTitle a11yFocus", _repObject: "$object"},
                "$object|getCallName"
            ),
            SPAN("("),
            SPAN({"class": "arguments"},
                FOR("arg", "$object|argIterator",
                    SPAN({"class": "argName"}, "$arg.name"),
                    SPAN("="),
                    TAG("$arg.tag", {object: "$arg.value"}),
                    SPAN({"class": "arrayComma"}, "$arg.delim")
                )
            ),
            SPAN(")"),
            SPAN({"class": "objectLink-sourceLink objectLink a11yFocus",
                _repObject: "$object|getSourceLink",
                role: "link"},
                "$object|getSourceLinkTitle"),
            DIV({"class": "stackTrace"})
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    hasStackTrace: function(object)
    {
        return true;
    },

    getTitle: function(object)
    {
        return object.frame.getFunctionName();
    },

    getCallName: function(object)
    {
        return this.getTitle(object);
    },

    getSourceLink: function(object)
    {
        return Reps.StackFrame.getSourceLink(object.frame);
    },

    getSourceLinkTitle: function(object)
    {
        return Reps.StackFrame.getSourceLinkTitle(object.frame);
    },

    argIterator: function(object)
    {
        return Reps.StackFrame.argIterator(object.frame);
    },

    onToggleStackTrace: function(event)
    {
        var target = event.originalTarget;

        // Only clicking on the expand button or the function title actually expands
        // the function call log. All other clicks keep default behavior
        if (!(Css.hasClass(target, "objectBox-functionCall") ||
            Css.hasClass(target, "functionCallTitle")))
        {
            return;
        }

        var objectBox = Dom.getAncestorByClass(target, "objectBox-functionCall");
        if (!objectBox)
            return;

        var traceBox = objectBox.getElementsByClassName("stackTrace").item(0);
        Css.toggleClass(traceBox, "opened");

        if (Css.hasClass(traceBox, "opened"))
        {
            var functionCall = objectBox.repObject;
            Reps.StackTrace.tag.append({object: functionCall.stackTrace}, traceBox);
        }
        else
        {
            Dom.clearNode(traceBox);
        }

        Events.cancelEvent(event);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsObject: function(object, type)
    {
        return object instanceof FunctionLog;
    },

    getRealObject: function(object)
    {
        return object.frame;
    },
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(FunctionMonitor);
Firebug.registerRep(FunctionMonitorRep);

return FunctionMonitor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/console/performanceTiming",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/domplate",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/dom",
    "firebug/lib/events",
    "firebug/lib/string",
    "firebug/lib/wrapper",
    "firebug/lib/css",
],
function(Firebug, Module, Rep, FBTrace, Domplate, Obj, Locale, Dom, Events, Str, Wrapper, Css) {

"use strict";

// ********************************************************************************************* //
// Documentation

// See http://www.w3.org/TR/navigation-timing/

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

// List of timing properties in performance.timing structure.
var timingProps = [
    "connectEnd",
    "connectStart",
    "domComplete",
    "domContentLoadedEventEnd",
    "domContentLoadedEventStart",
    "domInteractive",
    "domLoading",
    "domainLookupEnd",
    "domainLookupStart",
    "fetchStart",
    "loadEventEnd",
    "loadEventStart",
    "navigationStart",
    "redirectCount",
    "redirectEnd",
    "redirectStart",
    "requestStart",
    "responseEnd",
    "responseStart",
    "unloadEventEnd",
    "unloadEventStart",
];

var {domplate, TABLE, THEAD, TH, TBODY, TR, TD, DIV, SPAN, FOR} = Domplate;

// ********************************************************************************************* //
// Module

var PerformanceTimingModule = Obj.extend(Module,
{
    initialize: function(prefDomain, prefNames)
    {
        Module.initialize.apply(this, arguments);
        Firebug.Console.addListener(ConsoleListener);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);
        Firebug.Console.removeListener(ConsoleListener);
    },
});

// ********************************************************************************************* //
// Domplate

/**
 * This template is used to render the timing waterfall graph.
 */
var PerformanceTimingRep = domplate(Rep,
/** @lends PerformanceTimingRep */
{
    className: "perfTiming",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    tag:
        TABLE({"class": "perfTimingTable", cellspacing: 0, cellpadding: 0, width: "100%",
            "role": "grid", _repObject: "$object"},
            TBODY({"class": "perfTimingTbody", "role": "presentation"},
                FOR("bar", "$object.bars",
                    TR(
                        TD(
                            DIV({"class": "perfTimingBox"},
                                DIV({"class": "perfTimingBar $bar.className",
                                    style: "left: $bar.left%; width: $bar.width%"},
                                    SPAN({"class": "perfTimingBarLabel"}, "$bar.label")
                                ),
                                DIV({"class": "perfTimingEvent domLoading",
                                    style: "left: $bar.domLoading%;"}
                                ),
                                DIV({"class": "perfTimingEvent domInteractive",
                                    style: "left: $bar.domInteractive%;"}
                                ),
                                DIV({"class": "perfTimingEvent domContentLoaded",
                                    style: "left: $bar.domContentLoaded%;"}
                                ),
                                DIV({"class": "perfTimingEvent onLoad",
                                    style: "left: $bar.onLoad%;"}
                                ),
                                DIV({"class": "perfTimingEvent cursor"})
                            )
                        )
                    )
                )
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getRealObject: function(object)
    {
        return Wrapper.unwrapObject(object.timing);
    },

    supportsObject: function(object, type)
    {
        return (object instanceof PerfTimingObj);
    },

    getContextMenuItems: function(object, target, context)
    {
        return [];
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    showInfoTip: function(infoTip, target, x, y)
    {
        var table = Dom.getAncestorByClass(target, "perfTimingTable");
        if (!table)
            return false;

        var timingObj = table.repObject;
        return PerfInfoTip.render(timingObj.timing, infoTip);
    }
});

// ********************************************************************************************* //
// InfoTip

/**
 * Hovering mouse over the waterfall graph shows an infotip. This template is responsible
 * for rendering its content.
 */
var PerfInfoTip = domplate(Rep,
/** @lends PerfInfoTip */
{
    tableTag:
        TABLE({"class": "timeInfoTip", "id": "fbPerfTimingInfoTip"},
            TBODY()
        ),

    timingsTag:
        FOR("bar", "$bars",
            TR({"class": "timeInfoTipRow", $collapsed: "$bar|hideBar"},
                TD({"class": "timeInfoTipBar $bar|getClassName"}),
                TD({"class": "timeInfoTipCell startTime"},
                    "$bar.start|formatStartTime"
                ),
                TD({"class": "timeInfoTipCell elapsedTime"},
                    "$bar.elapsed|formatTime"
                ),
                TD("$bar|getLabel")
            )
        ),

    separatorTag:
        TR(
            TD({"class": "timeInfoTipSeparator", "colspan": 4, "height": "10px"},
                SPAN("$label")
            )
        ),

    eventsTag:
        FOR("event", "$events",
            TR({"class": "timeInfoTipEventRow"},
                TD({"class": "timeInfoTipBar", align: "center"},
                    DIV({"class": "$event|getClassName timeInfoTipEventBar"})
                ),
                TD("$event.start|formatStartTime"),
                TD({"class": "timeInfotTipEventName", "colspan": 2},
                    "$event|getTimeStampLabel"
                )
            )
        ),

    hideBar: function(obj)
    {
        return !obj.elapsed && obj.className == "redirect";
    },

    getClassName: function(obj)
    {
        return obj.className;
    },

    formatTime: function(time)
    {
        return Str.formatTime(time);
    },

    formatStartTime: function(time)
    {
        var label = Str.formatTime(time);
        if (!time)
            return label;

        return (time > 0 ? "+" : "") + label;
    },

    getLabel: function(obj)
    {
        return Locale.$STR("perftiming." + obj.label);
    },

    getTimeStampLabel: function(obj)
    {
        return obj.name;
    },

    render: function(timing, parentNode)
    {
        var infoTip = PerfInfoTip.tableTag.replace({}, parentNode);

        // Insert top description.
        this.separatorTag.insertRows({label: Locale.$STR("perftiming.bars.label")},
            infoTip.firstChild);

        // Insert request timing info.
        var bars = calculateBars(timing);
        this.timingsTag.insertRows({bars: bars}, infoTip.firstChild);

        var t = timing;

        var events = [];
        events.push({
            name: "DOM Loading",
            className: "domLoading",
            start: t.domLoading - t.navigationStart
        });

        events.push({
            name: "DOM Interactive",
            className: "domInteractive",
            start: t.domInteractive - t.navigationStart,
        });

        events.push({
            name: "DOMContentLoaded",
            className: "domContentLoaded",
            start: t.domContentLoadedEventStart - t.navigationStart,
        });

        events.push({
            name: "load",
            className: "onLoad",
            start: t.loadEventStart - t.navigationStart,
        });

        // Insert separator.
        this.separatorTag.insertRows({label: Locale.$STR("requestinfo.timings.label")},
            infoTip.firstChild);

        this.eventsTag.insertRows({events: events}, infoTip.firstChild);

        return true;
    }
});

// ********************************************************************************************* //
// Rep Object

function PerfTimingObj(bars, timing)
{
    this.bars = bars;
    this.timing = timing;
}

// ********************************************************************************************* //

/**
 * Console listener is responsible for rendering the Performance visualization every time
 * the user logs 'performance.timing' on the command line.
 */
var ConsoleListener =
/** @lends ConsoleListener */
{
    tag:
        DIV({_repObject: "$object"},
            DIV({"class": "documentCookieBody"})
        ),

    log: function(context, object, className, sourceLink)
    {
        if (!context || !object)
            return;

        var type = Object.prototype.toString.call(object);
        if (type === "[object PerformanceTiming]")
            performanceTiming(context, object);
    },

    logFormatted: function(context, objects, className, sourceLink)
    {
    }
};

// ********************************************************************************************* //
// Console Logging

/**
 * This function is responsible for inserting the waterfall graph into the Console panel.
 */
function performanceTiming(context, timing)
{
    var t = timing;
    var elapsed = t.loadEventEnd - t.navigationStart;

    var objects = [];
    var rep = PerformanceTimingRep;
    var bars = calculateBars(t);

    var result = [];
    for (var i=0; i<bars.length; i++)
    {
        var bar = bars[i];

        // Filter our empty bars.
        if (!bar.elapsed)
            continue;

        bar.left = calculatePos(bar.start, elapsed);
        bar.width = calculatePos(bar.elapsed, elapsed);
        bar.label = bar.label + " " + Str.formatTime(bar.elapsed);

        result.push(bar);
    }

    // Events
    var domLoading = calculatePos(t.domLoading - t.navigationStart, elapsed);
    var domInteractive = calculatePos(t.domInteractive - t.navigationStart, elapsed);
    var domContentLoaded = calculatePos(t.domContentLoadedEventStart - t.navigationStart, elapsed);
    var onLoad = calculatePos(t.loadEventStart - t.navigationStart, elapsed);

    for (var i=0; i<result.length; i++)
    {
        var bar = result[i];
        bar.domLoading = domLoading;
        bar.domInteractive = domInteractive;
        bar.domContentLoaded = domContentLoaded;
        bar.onLoad = onLoad;
    }

    var input = new PerfTimingObj(result, t);
    Firebug.Console.log(input, context, "perfTiming", rep, true);

    // Create a log group first (collapsed by default). All the timing details will be rendered
    // inside the group (within 'logGroupBody' element).
    var row = Firebug.Console.openCollapsedGroup("perfTimingDetails", context, "perfTimingDetails",
        DetailsCaption, true, null, true);
    Firebug.Console.closeGroup(context, true);

    // Get 'logGroupBody' element and render the timing details.
    var logGroupBody = row.getElementsByClassName("logGroupBody")[0];
    var table = DetailsTable.tag.replace({object: t}, logGroupBody);
    var tBody = table.lastChild;

    // Iterate only known properties (these are also localized).
    var timings = [];
    for (var i=0; i<timingProps.length; i++)
    {
        var name = timingProps[i];
        var value = t[name];
        var startTime = value ? (value - t.navigationStart) : 0;
        var timing = {
            name: name,
            timeLabel: startTime ? "+" + Str.formatTime(startTime) : 0,
            desc: Locale.$STR("perftiming." + name),
            time: startTime,
        };
        timings.push(timing);
    }

    timings.sort(function(a, b) {
        return a.time > b.time ? 1 : -1;
    });

    DetailsEntry.tag.insertRows({timings: timings}, tBody);

    return Firebug.Console.getDefaultReturnValue();
}

// ********************************************************************************************* //
// Detailed Log

/**
 * A caption for detailed performance timing info.
 */
var DetailsCaption = domplate(
/** @lends DetailsCaption */
{
    tag:
        SPAN({"class": "timingTitle"},
            SPAN({"class": "timingCaption"},
                Locale.$STR("perftiming.details_title")
            ),
            SPAN({"class": "timingCaptionDesc"},
                Locale.$STR("perftiming.details_title_desc")
            )
        )
});

// ********************************************************************************************* //

/**
 * This template represents a table with detailed timing info.
 */
var DetailsTable = domplate(
/** @lends DetailsTable */
{
    tag:
        TABLE({"class": "timingTable", cellspacing: 0, cellpadding: 0, width: "100%",
            "role": "grid", _repObject: "$object"},
            THEAD({"class": "timingThead", "role": "presentation"},
                TR({"class": "headerRow focusRow timingRow subFocusRow", "role": "row"},
                    TH({"class": "headerCell a11yFocus", "role": "columnheader", width: "10%"},
                        DIV({"class": "headerCellBox"},
                            Locale.$STR("Name")
                        )
                    ),
                    TH({"class": "headerCell a11yFocus", "role": "columnheader", width: "10%"},
                        DIV({"class": "headerCellBox"},
                            Locale.$STR("Time")
                        )
                    ),
                    TH({"class": "headerCell a11yFocus", "role": "columnheader", width: "70%"},
                        DIV({"class": "headerCellBox"},
                            Locale.$STR("Description")
                        )
                    )
                )
            ),
            TBODY({"class": "perfTimingTbody", "role": "presentation"}
            )
        ),
});

// ********************************************************************************************* //

/**
 * A row within detailed performance timing info.
 */
var DetailsEntry = domplate(
/** @lends DetailsEntry */
{
    tag:
        FOR("timing", "$timings",
            TR({"class": "focusRow timingRow subFocusRow", "role": "row", _repObject: "$timing",
                onmousemove: "$onMouseMove", onmouseout: "$onMouseOut"},
                TD({"class": "a11yFocus timingCell timingName", "role": "gridcell"},
                    "$timing.name"
                ),
                TD({"class": "a11yFocus timingCell timingTime", "role": "gridcell"},
                    "$timing.timeLabel"
                ),
                TD({"class": "a11yFocus timingCell timingDesc", "role": "gridcell"},
                    "$timing.desc"
                )
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onMouseMove: function(event)
    {
        var row = Dom.getAncestorByClass(event.target, "timingRow");
        if (!row)
            return;

        var log = Dom.getAncestorByClass(row, "logRow-perfTimingDetails");
        var graph = log.previousSibling;
        if (!Css.hasClass(graph, "logRow-perfTiming"))
            return;

        var table = Dom.getAncestorByClass(row, "timingTable");
        var timing = table.repObject;

        var elapsed = timing.loadEventEnd - timing.navigationStart;
        var startTime = row.repObject.time;

        var tBody = graph.getElementsByClassName("perfTimingTbody")[0];
        var rows = tBody.getElementsByTagName("tr");
        for (var i=0; i<rows.length; i++)
        {
            var row = rows[i];
            var cursor = row.getElementsByClassName("cursor")[0];

            Dom.hide(cursor, false);
            cursor.style.left = calculatePos(startTime, elapsed) + "%";
        }
    },

    onMouseOut: function(event)
    {
        var row = Dom.getAncestorByClass(event.target, "timingRow");
        if (!row)
            return;

        var log = Dom.getAncestorByClass(row, "logRow-perfTimingDetails");
        var graph = log.previousSibling;
        if (!Css.hasClass(graph, "logRow-perfTiming"))
            return;

        var tBody = graph.getElementsByClassName("perfTimingTbody")[0];
        var rows = tBody.getElementsByTagName("tr");
        for (var i=0; i<rows.length; i++)
        {
            var row = rows[i];
            var cursor = row.getElementsByClassName("cursor")[0];
            Dom.hide(cursor, true);
        }
    }
});

// ********************************************************************************************* //
// Helpers

function calculatePos(time, elapsed)
{
    return Math.round((time / elapsed) * 100);
}

function calculateBars(timing)
{
    var result = [];
    var t = timing;

    // Page Load bar
    result.push({
        className: "pageLoad",
        start: 0,
        elapsed: t.loadEventEnd - t.navigationStart,
        label: Locale.$STR("Page Load"),
    });

    // Redirect
    result.push({
        className: "redirect",
        start: t.redirectStart ? t.redirectStart - t.navigationStart : 0,
        elapsed: t.redirectStart ? t.redirectEnd - t.redirectStart : 0,
        label: Locale.$STR("Redirect"),
    });

    // DNS
    var dns = t.domainLookupEnd - t.domainLookupStart;
    result.push({
        className: "dns",
        start: t.domainLookupStart - t.navigationStart,
        elapsed: t.domainLookupEnd - t.domainLookupStart,
        label: Locale.$STR("DNS"),
    });

    // Connect bar
    result.push({
        className: "connecting",
        start: t.connectStart - t.navigationStart,
        elapsed: t.connectEnd - t.connectStart,
        label: Locale.$STR("Connecting"),
    });

    // Waiting bar
    result.push({
        className: "waiting",
        start: t.requestStart - t.navigationStart,
        elapsed: t.responseStart - t.requestStart,
        label: Locale.$STR("Waiting"),
    });

    // Response bar
    result.push({
        className: "response",
        start: t.responseStart - t.navigationStart,
        elapsed: t.responseEnd - t.responseStart,
        label: Locale.$STR("Receiving"),
    });

    // Processing bar
    result.push({
        className: "processing",
        start: t.responseEnd - t.navigationStart,
        elapsed: t.loadEventStart - t.responseEnd,
        label: Locale.$STR("DOM Processing"),
    });

    // DOMContentLoaded
    result.push({
        className: "DOMContentLoaded",
        start: t.domContentLoadedEventStart - t.navigationStart,
        elapsed: t.domContentLoadedEventEnd - t.domContentLoadedEventStart,
        label: Locale.$STR("DOMContentLoaded"),
    });

    // onLoad
    result.push({
        className: "onLoad",
        start: t.loadEventStart - t.navigationStart,
        elapsed: t.loadEventEnd - t.loadEventStart,
        label: Locale.$STR("onLoad"),
    });

    return result;
}

// ********************************************************************************************* //
// Registration

Firebug.registerRep(PerformanceTimingRep);
Firebug.registerModule(PerformanceTimingModule);

return PerformanceTimingModule;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/cookies/baseObserver",
[
],
function() {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //
// Base observer

var BaseObserver =
{
    QueryInterface : function (aIID) 
    {
        if (aIID.equals(Ci.nsIObserver) ||
            aIID.equals(Ci.nsISupportsWeakReference) ||
            aIID.equals(Ci.nsISupports))
        {
            return this;
        }

        throw Components.results.NS_NOINTERFACE;
    }
};

// ********************************************************************************************* //

return BaseObserver;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/cookies/breakpoints",
[
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/string",
    "firebug/lib/domplate",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/events",
    "firebug/cookies/cookieUtils"
],
function(Rep, Obj, Locale, Str, Domplate, Dom, Css, Events, CookieUtils) {

"use strict";

// ********************************************************************************************* //
// Constants

var panelName = "cookies";

var {domplate, DIV, INPUT, SPAN} = Domplate;

// ********************************************************************************************* //
// Implementation

var Breakpoints =
{
    breakOnCookie: function(context, cookie, action)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.breakOnCookie; " + action);

        var halt = false;
        var conditionIsFalse = false;

        // If there is an enabled breakpoint with condition:
        // 1) break if the condition is evaluated to true.
        var bp = context.cookies.breakpoints.findBreakpoint(CookieUtils.makeCookieObject(cookie));
        if (bp && bp.checked)
        {
            halt = true;
            if (bp.condition)
            {
                halt = bp.evaluateCondition(context, cookie);
                conditionIsFalse = !halt;
            }
        }

        // 2) If break on next flag is set and there is no condition evaluated to false,
        // break with "break on next" breaking cause (this new breaking cause can override
        // an existing one that is set when evaluating a breakpoint condition).
        if (context.breakOnCookie && !conditionIsFalse)
        {
            context.breakingCause = {
                title: Locale.$STR("cookies.Break On Cookie"),
                message: Str.cropString(unescape(cookie.name + "; " + cookie.value), 200)
            };
            halt = true;
        }

        // Ignore if there is no reason to break.
        if (!halt)
            return;

        // Even if the execution was stopped at breakpoint reset the global
        // breakOnCookie flag.
        context.breakOnCookie = false;

        this.breakNow(context);

        // Clear breakpoint associated with removed cookie.
        if (action == "deleted")
        {
            breakpoints.removeBreakpoint(bp);
            context.invalidatePanels("breakpoints");
        }
    },

    breakNow: function(context)
    {
        if (Firebug.Breakpoint && Firebug.Breakpoint.updatePanelTab)
        {
            var panel = context.getPanel(panelName, true);
            Firebug.Breakpoint.updatePanelTab(panel, false);
            Firebug.Breakpoint.breakNow(context.getPanel(panelName, true));
        }
    },

    getContextMenuItems: function(cookie, target, context)
    {
        var items = [];
        items.push("-");

        var cookieName = Str.cropString(cookie.cookie.name, 40);
        var bp = context.cookies.breakpoints.findBreakpoint(cookie.cookie);

        items.push({
            nol10n: true,
            tooltiptext: Locale.$STRF("cookies.menu.tooltip.Break On Cookie", [cookieName]),
            label: Locale.$STRF("cookies.menu.Break On Cookie", [cookieName]),
            type: "checkbox",
            checked: bp != null,
            command: Obj.bindFixed(this.onBreakOnCookie, this, context, cookie),
        });

        if (bp)
        {
            items.push(
                {label: "cookies.menu.Edit Breakpoint Condition",
                    command: Obj.bindFixed(this.editBreakpointCondition, this, context, cookie) }
            );
        }

        return items;
    },

    onBreakOnCookie: function(context, cookie)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.breakOnCookie; ", context);

        var breakpoints = context.cookies.breakpoints;

        // Remove an existing or create a new breakpoint.
        var row = cookie.row;
        cookie = cookie.cookie;
        var bp = breakpoints.findBreakpoint(cookie);
        if (bp)
        {
            breakpoints.removeBreakpoint(cookie);
            row.removeAttribute("breakpoint");
            row.removeAttribute("disabledBreakpoint");
        }
        else
        {
            breakpoints.addBreakpoint(cookie);
            row.setAttribute("breakpoint", "true");
        }
    },

    updateBreakpoint: function(context, cookie)
    {
        // Make sure a breakpoint is displayed.
        var bp = context.cookies.breakpoints.findBreakpoint(cookie.cookie);
        if (!bp)
            return;

        var row = cookie.row;
        row.setAttribute("breakpoint", "true");
        row.setAttribute("disabledBreakpoint", bp.checked ? "false" : "true");
    },

    onContextMenu: function(context, event)
    {
        if (!Css.hasClass(event.target, "sourceLine"))
            return;

        var row = Dom.getAncestorByClass(event.target, "cookieRow");
        if (!row)
            return;

        var cookie = row.repObject;
        var bp = context.cookies.breakpoints.findBreakpoint(cookie.cookie);
        if (!bp)
            return;

        this.editBreakpointCondition(context, cookie);
        Events.cancelEvent(event);
    },

    editBreakpointCondition: function(context, cookie)
    {
        var bp = context.cookies.breakpoints.findBreakpoint(cookie.cookie);
        if (!bp)
            return;

        var condition = bp ? bp.condition : "";

        var panel = context.getPanel(panelName);
        panel.selectedSourceBox = cookie.row;
        Firebug.Editor.startEditing(cookie.row, condition);
    }
};

// ********************************************************************************************* //
// Cookie Breakpoints

Breakpoints.BreakpointTemplate = Domplate.domplate(Rep,
{
    inspectable: false,

    tag:
        DIV({"class": "breakpointRow focusRow", $disabled: "$bp|isDisabled", _repObject: "$bp",
            role: "option", "aria-checked": "$bp.checked"},
            DIV({"class": "breakpointBlockHead"},
                INPUT({"class": "breakpointCheckbox", type: "checkbox",
                    _checked: "$bp.checked", tabindex: "-1", onclick: "$onEnable"}),
                SPAN("$bp|getTitle"),
                DIV({"class": "breakpointMutationType"}, "$bp|getType"),
                SPAN({"class": "closeButton", onclick: "$onRemove"})
            ),
            DIV({"class": "breakpointCode"},
                SPAN("$bp|getValue")
            )
        ),

    getTitle: function(bp)
    {
        return bp.name;
    },

    getValue: function(bp)
    {
        return bp.host + bp.path;
    },

    getType: function(bp)
    {
        return Locale.$STR("Break On Cookie Change");
    },

    isDisabled: function(bp)
    {
        return !bp.checked;
    },

    onRemove: function(event)
    {
        Events.cancelEvent(event);

        var bpPanel = Firebug.getElementPanel(event.target);
        var context = bpPanel.context;

        if (!Css.hasClass(event.target, "closeButton"))
            return;

        // Remove from list of breakpoints.
        var row = Dom.getAncestorByClass(event.target, "breakpointRow");
        context.cookies.breakpoints.removeBreakpoint(row.repObject);

        bpPanel.refresh();

        var cookiePanel = context.getPanel(panelName, true);
        if (!cookiePanel)
            return;

        var cookie = cookiePanel.findRepObject(row.repObject);
        if (cookie)
        {
            cookie.row.removeAttribute("breakpoint");
            cookie.row.removeAttribute("disabledBreakpoint");
        }
    },

    onEnable: function(event)
    {
        var checkBox = event.target;
        var bpRow = Dom.getAncestorByClass(checkBox, "breakpointRow");

        if (checkBox.checked)
        {
            Css.removeClass(bpRow, "disabled");
            bpRow.setAttribute("aria-checked", "true");
        }
        else
        {
            Css.setClass(bpRow, "disabled");
            bpRow.setAttribute("aria-checked", "false");
        }

        var bp = bpRow.repObject;
        bp.checked = checkBox.checked;

        var bpPanel = Firebug.getElementPanel(checkBox);

        var cookiePanel = bpPanel.context.getPanel(panelName, true);
        if (!cookiePanel)
            return;

        var cookie = cookiePanel.findRepObject(bp);
        if (cookie)
            cookie.row.setAttribute("disabledBreakpoint", bp.checked ? "false" : "true");
    },

    supportsObject: function(object)
    {
        return object instanceof Breakpoints.Breakpoint;
    }
});

// ********************************************************************************************* //
// Editor for Cookie breakpoint condition.

Breakpoints.ConditionEditor = function(doc)
{
    Firebug.Breakpoint.ConditionEditor.apply(this, arguments);
};

Breakpoints.ConditionEditor.prototype = Domplate.domplate(Firebug.Breakpoint.ConditionEditor.prototype,
{
    endEditing: function(target, value, cancel)
    {
        if (cancel)
            return;

        var cookie = target.repObject;
        var panel = Firebug.getElementPanel(target);
        var bp = panel.context.cookies.breakpoints.findBreakpoint(cookie.cookie);
        if (bp)
            bp.condition = value;
    }
});

// ********************************************************************************************* //

/**
 * @domplate Template for cookie breakpoint displayed in the Breakpoints side
 * panel.
 */
Breakpoints.Breakpoint = function(cookie)
{
    this.name = cookie.name;
    this.host = cookie.host;
    this.path = cookie.path;

    this.condition = "";
    this.checked = true;

    this.onEvaluateFails = Obj.bind(this.onEvaluateFails, this);
    this.onEvaluateSucceeds =  Obj.bind(this.onEvaluateSucceeds, this);
};

Breakpoints.Breakpoint.prototype =
{
    evaluateCondition: function(context, cookie)
    {
        try
        {
            var scope = {};
            scope["value"] = cookie.value;
            scope["cookie"] = CookieUtils.makeCookieObject(cookie);

            // The callbacks will set this if the condition is true or if the eval faults.
            delete context.breakingCause;

            // Construct expression to evaluate. Native JSON support is available since
            // Firefox 3.5 and breakpoints since Firebug 1.5, which supports min Fx 3.5
            // So, all is good.
            var expr = "(function (){var scope = " + JSON.stringify(scope) +
                "; with (scope) { return " + this.condition + ";}})();";

            // Evaluate condition using Firebug's command line.
            Firebug.CommandLine.evaluate(expr, context, null, context.window,
                this.onEvaluateSucceeds, this.onEvaluateFails);

            if (FBTrace.DBG_COOKIES)
            {
                FBTrace.sysout("cookies.evaluateCondition", {expr: expr, scope: scope});
            }

            return !!context.breakingCause;
        }
        catch (err)
        {
            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.evaluateCondition; EXCEPTION", err);
        }

        return false;
    },

    onEvaluateSucceeds: function(result, context)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onEvaluateSucceeds; " + result, result);

        // Don't set the breakingCause if the breakpoint condition is evaluated to false.
        if (!result)
            return;

        context.breakingCause = {
            title: Locale.$STR("cookies.Break On Cookie"),
            message: Str.cropString(unescape(this.name + "; " + this.condition + "; "), 200)
        };
    },

    onEvaluateFails: function(result, context)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onEvaluateFails; " + result, result);

        context.breakingCause = {
            title: Locale.$STR("cookies.Break On Cookie"),
            message: Locale.$STR("cookies.Breakpoint condition evaluation fails"),
            prevValue: this.condition, newValue:result
        };
    }
};

// ********************************************************************************************* //
// Registration

Firebug.registerRep(Breakpoints.BreakpointTemplate);

return Breakpoints;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/cookies/cookieClipboard",
[
    "firebug/lib/object",
    "firebug/lib/xpcom",
],
function(Obj, Xpcom) {

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;

var clipboard = Xpcom.CCSV("@mozilla.org/widget/clipboard;1", "nsIClipboard");

// ********************************************************************************************* //
// Clipboard helper

/**
 * @class This class implements clibpoard functionality.
 */
var CookieClipboard = Obj.extend(Object,
/** @lends CookieClipboard */
{
    cookieFlavour: "text/firebug-cookie",
    unicodeFlavour: "text/unicode",

    copyTo: function(cookie)
    {
        try
        {
            var trans = this.createTransferData(cookie);
            if (trans && clipboard)
                clipboard.setData(trans, null, Ci.nsIClipboard.kGlobalClipboard);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.CookieClipboard.copyTo; EXCEPTION " + err, err);
        }
    },

    getFrom: function()
    {
        try
        {
            var str = this.getTransferData();

            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.Get Cookie data from clipboard: " + str);

            return parseFromJSON(str);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.CookieClipboard.getFrom; EXCEPTION " + err, err);
        }

        return null;
    },

    isCookieAvailable: function()
    {
        try
        {
            if (!clipboard)
                return false;

            return clipboard.hasDataMatchingFlavors([this.cookieFlavour], 1,
                Ci.nsIClipboard.kGlobalClipboard);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.isCookieAvailable; EXCEPTION " + err, err);
        }

        return false;
    },

    createTransferData: function(cookie)
    {
        var trans = Xpcom.CCIN("@mozilla.org/widget/transferable;1", "nsITransferable");

        // See https://bugzilla.mozilla.org/show_bug.cgi?id=722872
        if (typeof(trans.init) == "function")
            trans.init(null);

        var json = cookie.toJSON();
        var wrapper1 = Xpcom.CCIN("@mozilla.org/supports-string;1", "nsISupportsString");
        wrapper1.data = json;
        trans.addDataFlavor(this.cookieFlavour);
        trans.setTransferData(this.cookieFlavour, wrapper1, json.length * 2);

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.Create JSON transfer data : " + json, cookie);

        var str = cookie.toString();
        var wrapper2 = Xpcom.CCIN("@mozilla.org/supports-string;1", "nsISupportsString");
        wrapper2.data = str;
        trans.addDataFlavor(this.unicodeFlavour);
        trans.setTransferData(this.unicodeFlavour, wrapper2, str.length * 2);

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.Create string transfer data : " + str, cookie);

        return trans;
    },

    getTransferData: function()
    {
        var trans = Xpcom.CCIN("@mozilla.org/widget/transferable;1", "nsITransferable");

        // See https://bugzilla.mozilla.org/show_bug.cgi?id=722872
        if (typeof(trans.init) == "function")
            trans.init(null);

        trans.addDataFlavor(this.cookieFlavour);

        clipboard.getData(trans, Ci.nsIClipboard.kGlobalClipboard);

        var str = new Object();
        var strLength = new Object();

        trans.getTransferData(this.cookieFlavour, str, strLength);

        if (!str.value) 
            return null;

        str = str.value.QueryInterface(Ci.nsISupportsString);
        return str.data.substring(0, strLength.value / 2);
    }
});

// ********************************************************************************************* //
// Helpers

function parseFromJSON(json)
{
    try
    {
        // Parse JSON string. In case of Firefox 3.5 the native support is used,
        // otherwise the cookie clipboard doesn't work.
        return JSON.parse(json);
    }
    catch (err)
    {
        if (FBTrace.DBG_ERRORS || FBTrace.DBG_COOKIES)
            FBTrace.sysout("Failed to parse a cookie from JSON data: " + err, err);
    }

    return null;
}

// ********************************************************************************************* //
// Registration

return CookieClipboard;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/cookies/cookieEvents",
[
    "firebug/cookies/cookieUtils"
],
function(CookieUtils) {

// ********************************************************************************************* //
// Cookie Event objects

/**
 * This object represents a "cookie-changed" event (repObject). 
 * There are three types of cookie modify events: 
 * "changed", "added" and "deleted".
 * Appropriate type is specified by action parameter.
 */
function CookieChangedEvent(context, cookie, action)
{
    this.context = context;
    this.cookie = cookie;
    this.action = action;
    this.rawHost = CookieUtils.makeStrippedHost(cookie.host);
    this.getId = function()
    {
        return this.action + this.rawHost + this.cookie.name + ":" + this.cookie.value;
    };
}

/**
 * This object represents "cleared" event, which is raised when the user
 * deletes all cookies (e.g. in the system cookies dialog).
 */
function CookieClearedEvent()
{
}

/**
 * This object represents "cookie-rejected" event, which is fired if cookies
 * from specific domain are rejected.
 */
function CookieRejectedEvent(context, uri)
{
    this.context = context;
    this.uri = uri;
}

// ********************************************************************************************* //
// Registration

return {
    CookieChangedEvent: CookieChangedEvent,
    CookieClearedEvent: CookieClearedEvent,
    CookieRejectedEvent: CookieRejectedEvent
};

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/cookies/cookie",
[
    "firebug/lib/xpcom",
    "firebug/lib/json",
    "firebug/lib/string",
],
function(Xpcom, Json) {

// ********************************************************************************************* //
// Constants

const ioService = Xpcom.CCSV("@mozilla.org/network/io-service;1", "nsIIOService");

// ********************************************************************************************* //
// Cookie object

/**
 * @class Represents a cookie object that is created as a representation of
 * nsICookie component in the browser.
 */
function Cookie(cookie, action)
{
    this.cookie = cookie;
    this.action = action; 
    this.rawHost = makeStrippedHost(cookie.host);
}

Cookie.prototype =
/** @lends Cookie */
{
    cookie: null,
    action: null,

    toString: function(noDomain)
    {
        var expires = this.cookie.expires ? new Date(this.cookie.expires * 1000) : null;
        return this.cookie.name + "=" + this.cookie.rawValue +
            (expires ? "; expires=" + expires.toGMTString() : "") +
            (this.cookie.maxAge ? "; Max-Age=" + this.cookie.maxAge : "") +
            ((this.cookie.path) ? "; path=" + this.cookie.path : "; path=/") +
            (noDomain ? "" : ((this.cookie.host) ? "; domain=" + this.cookie.host : "")) +
            ((this.cookie.isSecure) ? "; Secure" : "") + 
            ((this.cookie.isHttpOnly) ? "; HttpOnly" : "");
    },

    toJSON: function()
    {
        return JSON.stringify({
            name: this.cookie.name,
            value: this.cookie.rawValue,
            expires: (this.cookie.expires ? this.cookie.expires : 0),
            maxAge: (this.cookie.maxAge ? this.cookie.maxAge : ""),
            path: (this.cookie.path ? this.cookie.path : "/"),
            host: this.cookie.host,
            isHttpOnly: (this.cookie.isHttpOnly),
            isSecure: (this.cookie.isSecure)
        });
    },

    toText: function()
    {
        return this.cookie.host + "\t" +
            new String(this.cookie.isDomain).toUpperCase() + "\t" +
            this.cookie.path + "\t" +
            new String(this.cookie.isSecure).toUpperCase() + "\t" +
            this.cookie.expires + "\t" +
            this.cookie.maxAge + "\t" +
            this.cookie.name + "\t" +
            this.cookie.rawValue + "\r\n";
    },

    getJsonValue: function()
    {
        if (this.json)
            return this.json;

        var jsonString = new String(this.cookie.value);
        if (jsonString.indexOf("{") != 0)
            return null;

        var currentURI = Firebug.chrome.getCurrentURI();
        var jsonObject = Json.parseJSONString(jsonString, currentURI.spec);
        if (typeof (jsonObject) != "object")
            return null;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.getJsonValue for: " + this.cookie.name, jsonObject);

        return (this.json = jsonObject);
    },

    getXmlValue: function()
    {
        if (this.xml)
            return this.xml;

        try
        {
            var value = this.cookie.value;

            // Simple test if the source is XML (to avoid errors in the Firefox Error console)
            if (value.indexOf("<") != 0)
                return null; 

            var parser = Xpcom.CCIN("@mozilla.org/xmlextras/domparser;1", "nsIDOMParser");
            var doc = parser.parseFromString(value, "text/xml");
            var docElem = doc.documentElement;

            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.getXmlValue for: " + this.cookie.name);

            // Error handling
            var nsURI = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
            if (docElem.namespaceURI == nsURI && docElem.nodeName == "parsererror")
                return null; 

            return (this.xml = docElem);
        }
        catch (e)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.getXmlValue ERROR " + this.cookie.name, e);
        }

        return null;
    },

    getURI: function()
    {
        try
        {
            var host = this.cookie.host;
            var path = this.cookie.path;

            var httpProtocol = this.cookie.isSecure ? "https://" : "http://";
            var uri = httpProtocol + host + (path ? path : "");
            return ioService.newURI(uri, null, null);
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS || FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.getURI FAILS for " + this.cookie.name);
        }

        return null;
    },

    getSize: function()
    {
        return this.cookie.name.length + this.cookie.value.length;
    },

    getRawSize: function()
    {
        return this.cookie.name.length + this.cookie.rawValue.length;
    }
};

// ********************************************************************************************* //
// Helpers

// xxxHonza: duplicated in CookieUtils since cycle dep
function makeStrippedHost(aHost)
{
    if (!aHost)
        return aHost;

    var formattedHost = aHost.charAt(0) == "." ? aHost.substring(1, aHost.length) : aHost;
    return formattedHost.substring(0, 4) == "www." ? formattedHost.substring(4, formattedHost.length) : formattedHost;
}

// ********************************************************************************************* //

return Cookie;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/cookies/cookieModule",
[
    "firebug/chrome/activableModule",
    "firebug/chrome/rep",
    "firebug/lib/xpcom",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/domplate",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/lib/persist",
    "firebug/lib/string",
    "firebug/lib/http",
    "firebug/lib/css",
    "firebug/lib/events",
    "firebug/lib/array",
    "firebug/cookies/baseObserver",
    "firebug/cookies/menuUtils",
    "firebug/cookies/cookieReps",
    "firebug/cookies/cookieUtils",
    "firebug/cookies/cookie",
    "firebug/cookies/breakpoints",
    "firebug/cookies/cookieObserver",
    "firebug/cookies/cookieClipboard",
    "firebug/chrome/tabWatcher",
    "firebug/cookies/httpObserver",
    "firebug/lib/system",
    "firebug/cookies/cookie",
    "firebug/cookies/cookiePermissions",
    "firebug/cookies/editCookie",
    "firebug/trace/traceListener",
    "firebug/trace/traceModule",
    "firebug/chrome/firefox",
    "firebug/chrome/window",
    "firebug/lib/url",
    "firebug/cookies/legacy",
],
function(ActivableModule, Rep, Xpcom, Obj, Locale, Domplate, Dom, Options, Persist, Str, Http,
    Css, Events, Arr, BaseObserver, MenuUtils, CookieReps, CookieUtils, Cookier, Breakpoints,
    CookieObserver, CookieClipboard, TabWatcher, HttpObserver, System, Cookie, CookiePermissions,
    EditCookie, TraceListener, TraceModule, Firefox, Win, Url) {

// ********************************************************************************************* //
// Constants

var {domplate, DIV, SPAN, TR, P, UL, A, BUTTON} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;

// Firefox Preferences
const networkPrefDomain = "network.cookie";
const cookieBehaviorPref = "cookieBehavior";
const cookieLifeTimePref = "lifetimePolicy";

// Cookies preferences
const clearWhenDeny = "cookies.clearWhenDeny";
const defaultExpireTime = "cookies.defaultExpireTime";
const removeConfirmation = "cookies.removeConfirmation";
const removeSessionConfirmation = "cookies.removeSessionConfirmation";

// Services
const cookieManager = Xpcom.CCSV("@mozilla.org/cookiemanager;1", "nsICookieManager2");
const observerService = Xpcom.CCSV("@mozilla.org/observer-service;1", "nsIObserverService");
const prompts = Xpcom.CCSV("@mozilla.org/embedcomp/prompt-service;1", "nsIPromptService");

// Preferences
const PrefService = Cc["@mozilla.org/preferences-service;1"];
const prefService = PrefService.getService(Ci.nsIPrefService);
const prefs = PrefService.getService(Ci.nsIPrefBranch);

// Cookie panel ID.
const panelName = "cookies";

// Helper array for prematurely created contexts
var contexts = new Array();

// Register stylesheet in Firebug. This method is introduced in Firebug 1.6
Firebug.registerStylesheet("chrome://firebug/skin/cookies/cookies.css");

// ********************************************************************************************* //
// Module Implementation

/**
 * @module This object represents a <i>module</i> for Cookies panel.
 * The module supports activation (enable/disable of the Cookies panel).
 * This functionality has been introduced in Firebug 1.2 and makes possible
 * to control activity of Firebug panels in order to avoid (performance) expensive
 * features.
 */
Firebug.CookieModule = Obj.extend(ActivableModule,
/** @lends Firebug.CookieModule */
{
    contexts: contexts,

    // Set to true if all hooks for monitoring cookies are registered; otherwise false.
    observersRegistered: false,

    /**
     * Called by Firebug when Firefox window is opened.
     *
     * @param {String} prefDomain Preference domain (e.g. extensions.firebug)
     * @param {Array} prefNames Default Firebug preference array.
     */
    initialize: function(prefDomain, prefNames)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.CookieModule.initialize; ");

        this.traceListener = new TraceListener("cookies.", "DBG_COOKIES", true,
            "chrome://firebug/skin/cookies/trace.css");

        TraceModule.addListener(this.traceListener);

        this.panelName = panelName;
        this.description = Locale.$STR("cookies.modulemanager.description");

        ActivableModule.initialize.apply(this, arguments);

        var permTooltip = Firebug.chrome.$("fcPermTooltip");
        permTooltip.fcEnabled = true;

        // All the necessary observers are registered by default. Even if the
        // panel can be disabled (entirely or for a specific host) there is
        // no simple way to find out this now, as the context isn't available.
        // All will be unregistered again in the initContext (if necessary).
        // There is no big overhead, the initContext is called just after the
        // first document request.
        //this.registerObservers();

        // Register listener for NetInfoBody (if the API is available) so,
        // a new tab (Cookies) can be appended into the Net panel request info.
        var netInfoBody = Firebug.NetMonitor.NetInfoBody;
        if ("addListener" in netInfoBody)
            netInfoBody.addListener(this.NetInfoBody);

        // Register listener within the Console panel. If document.cookie property
        // is logged, formatted output is used.
        //Firebug.Console.addListener(this.ConsoleListener);

        // Register debugger listener for providing cookie-breakpoints.
        //Firebug.Debugger.addListener(this.DebuggerListener);

        // Dynamically overlay Break on Next button in FB 1.5.1
        // There is a small decoration coming from each panel.
        var bonStack = Firebug.chrome.$("fbBreakOnNextButtonStack");
        if (bonStack)
        {
            var image = document.createElement("image");
            image.setAttribute("id", "fbBreakOnImageCookies");
            image.setAttribute("class", "fbBreakOnImage");
            image.setAttribute("src", "chrome://firebug/skin/cookies/breakOnCookie.png");
            bonStack.appendChild(image);
        }

        Firebug.registerUIListener(this);
    },

    initializeUI: function()
    {
        ActivableModule.initializeUI.apply(this, arguments);

        // Append the styleesheet to a new console popup panel introduced in Firebug 1.6
        this.addStyleSheet(null);

        Dom.collapse(Firebug.chrome.$("fbConsoleFilter-cookies"), false);
    },

    /**
     * Peforms clean up when Firebug is destroyed.
     * Called by the framework when Firebug is closed for an existing Firefox window.
     */
    shutdown: function()
    {
        this.unregisterObservers();

        // Support for trace-console customization in Firebug 1.3
        TraceModule.removeListener(this.traceListener);

        var netInfoBody = Firebug.NetMonitor.NetInfoBody;
        if ("removeListener" in netInfoBody)
            netInfoBody.removeListener(this.NetInfoBody);

        //Firebug.Console.removeListener(this.ConsoleListener);
        //Firebug.Debugger.removeListener(this.DebuggerListener);

        Firebug.unregisterUIListener(this);
    },

    registerObservers: function()
    {
        if (this.observersRegistered)
        {
            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.cookieModule.registerObservers; Observers ALREADY registered");
            return;
        }

        observerService.addObserver(HttpObserver, "http-on-modify-request", false);
        observerService.addObserver(HttpObserver, "http-on-examine-response", false);
        observerService.addObserver(PermissionObserver, "perm-changed", false);
        registerCookieObserver(CookieObserver);
        prefs.addObserver(networkPrefDomain, PrefObserver, false);

        this.observersRegistered = true;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.cookieModule.registerObservers;");
    },

    unregisterObservers: function(context)
    {
        if (!this.observersRegistered)
        {
            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.cookieModule.registerObservers; " +
                    "Observers ALREADY un-registered");
            return;
        }

        observerService.removeObserver(HttpObserver, "http-on-modify-request");
        observerService.removeObserver(HttpObserver, "http-on-examine-response");
        observerService.removeObserver(PermissionObserver, "perm-changed");
        unregisterCookieObserver(CookieObserver);
        prefs.removeObserver(networkPrefDomain, PrefObserver);

        this.observersRegistered = false;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.cookieModule.unregisterObservers;");
    },

    // Helper context
    initTempContext: function(tempContext)
    {
        tempContext.cookieTempObserver = registerCookieObserver(new CookieTempObserver(tempContext));

        // Create sub-context for cookies.
        tempContext.cookies = {};
        tempContext.cookies.activeHosts = [];
    },

    destroyTempContext: function(tempContext, context)
    {
        if (!tempContext)
            return;

        if (FBTrace.DBG_COOKIES)
        {
            FBTrace.sysout("cookies.Copy " + tempContext.events.length +
                " events to real-context.");

            var message = "cookies.Copy active hosts (";
            for (var host in tempContext.cookies.activeHosts)
                message += host + ", ";
            message = message.substring(0, message.length - 2);
            message += ") from temp context into the real context.";
            FBTrace.sysout(message, tempContext);
        }

        // Copy all active hosts on the page. In case of redirects or embedded IFrames, there
        // can be more hosts (domains) involved on the page. Cookies must be displayed for
        // all of them.
        context.cookies.activeHosts = cloneMap(tempContext.cookies.activeHosts);

        // Clone all active (received) cookies on the page.
        // This is probably not necessary, as the first cookie is received
        // in http-on-examine-response and at that time the real context
        // is already created.
        context.cookies.activeCookies = cloneMap(tempContext.cookies.activeCookies);

        // Fire all lost cookie events (those from the temp context).
        var events = tempContext.events;
        for (var i=0; i<events.length; i++) {
            var e = events[i];
            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.Fire fake cookie event: " + e.topic + ", " + e.data + "\n");
            CookieObserver.observe(e.subject, e.topic, e.data);
        }

        delete tempContext.cookies.activeHosts;
        delete tempContext.cookies.activeCookies;
        delete tempContext.cookies;

        // Unregister temporary cookie observer.
        tempContext.cookieTempObserver = unregisterCookieObserver(tempContext.cookieTempObserver);
    },

    /**
     * Called by the framework when a context is created for Firefox tab.
     *
     *  @param {Firebug.TabContext} Context for the current Firefox tab.
     */
    initContext: function(context)
    {
        var tabId = Firebug.getTabIdForWindow(context.window);

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.INIT real context for: " + tabId + ", " +
                context.getName());

        // Create sub-context for cookies.
        // xxxHonza: the cookies object exists within the context even if
        // the panel is disabled.
        context.cookies = {};
        context.cookies.activeHosts = [];

        // Initialize custom path filter for this context
        context.cookies.pathFilter = "/";

        // List of breakpoints.
        context.cookies.breakpoints = new CookieBreakpointGroup();
        context.cookies.breakpoints.load(context);

        // The temp context isn't created e.g. for empty tabs, chrome pages.
        var tempContext = contexts[tabId];
        if (tempContext)
        {
            this.destroyTempContext(tempContext, context);
            delete contexts[tabId];

            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.DESTROY temporary context, tabId: " + tempContext.tabId);
        }

        // The base class must be called after the context for Cookies panel is
        // properly initialized. The panel can be created inside this function
        // (within ActivableModule.enablePanel), which can result in
        // calling CookiePanel.initialize method. This method directly calls
        // CookiePanel.refresh, which needs the context.cookies object ready.
        ActivableModule.initContext.apply(this, arguments);

        // Unregister all observers if the panel is disabled.
        if (!this.isEnabled(context))
            this.unregisterObservers(context);
    },

    destroyContext: function(context)
    {
        ActivableModule.destroyContext.apply(this, arguments);

        if (!context.cookies)
        {
            if (FBTrace.DBG_COOKIES)
            {
                var tabId = Firebug.getTabIdForWindow(context.window);
                FBTrace.sysout("cookies.DESTROY context ERROR: No context.cookies available, tabId: " +
                    tabId + ", " + context.getName());
            }
            return;
        }

        context.cookies.breakpoints.store(context);

        for (var p in context.cookies)
            delete context.cookies[p];

        delete context.cookies;

        if (FBTrace.DBG_COOKIES)
        {
            var tabId = Firebug.getTabIdForWindow(context.window);
            FBTrace.sysout("cookies.DESTROY context, tabId: " + tabId +
                ", " + context.getName());
        }
    },

    addStyleSheet: function(panel)
    {
        // Use registration function instead (introduced in Firebug 1.6)
        if (Firebug.registerStylesheet)
            return;

        function privateAppend(doc)
        {
            // Make sure the stylesheet isn't appended twice.
            if (!Firebug.chrome.$("fcStyles", doc))
            {
                var styleSheet = createStyleSheet(doc, "chrome://firebug/skin/cookies/cookies.css");
                styleSheet.setAttribute("id", "fcStyles");
                addStyleSheet(doc, styleSheet);
            }
        }

        if (panel)
            privateAppend(panel.document);

        // Firebug 1.6 introduces another panel for console preview on other panels
        // The allows to use command line in other panels too.
        var preview = Firebug.chrome.$("fbCommandPreviewBrowser");
        if (preview)
            privateAppend(preview.contentDocument);
    },

    updateOption: function(name, value)
    {
        if (name == "consoleFilterTypes")
        {
            this.updateConsoleFilter();
        }
    },

    updateConsoleFilter: function()
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.updateConsoleFilter;");

        if (!Firebug.currentContext)
            return;

        // The panel can be disabled.
        var panel = Firebug.currentContext.getPanel("console");
        if (!panel)
            return;

        var panelNode = panel.panelNode;
        var className = "hideType-cookies";
        var filterTypes = Firebug.consoleFilterTypes;

        Css.setClass(panelNode, className);

        var positiveFilters = ["all", "cookies"];
        for (var i=0; i<positiveFilters.length; i++)
        {
            if (filterTypes.indexOf(positiveFilters[i]) >= 0)
            {
                Css.removeClass(panelNode, className);
                break;
            }
        }
    },

    showPanel: function(browser, panel)
    {
        // Update panel's toolbar
        var isCookiePanel = panel && panel.name == panelName;

        // Firebug 1.4, chrome changes.
        var chrome = browser.chrome ? browser.chrome : Firebug.chrome;

        var cookieButtons = Firebug.chrome.$("fbCookieButtons");
        Dom.collapse(cookieButtons, !isCookiePanel);

        // The console panel can be displayed sooner than the Cookies
        // panel, in such a case the Stylesheet must be ready as
        // there are cookies logs in the console.
        // Cookie table is also used within the net panel.
        if (panel && (panel.name == "console" || panel.name == "net"))
            this.addStyleSheet(panel);
    },

    watchWindow: function(context, win)
    {
        context.window.addEventListener("beforeunload", this.onBeforeUnload, false);
    },

    onBeforeUnload: function(event)
    {
        var view = event.target.defaultView;
        var context = TabWatcher.getContextByWindow(view);
        if (!context)
            return;

        var panel = context.getPanel(panelName, true);
        if (panel)
            panel.clear();

        if (FBTrace.DBG_COOKIES || FBTrace.DBG_ERRORS)
        {
            var tabId = Firebug.getTabIdForWindow(view);

            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.On before unload tab:  " + tabId);

            if (contexts[tabId])
            {
                delete contexts[tabId];

                if (FBTrace.DBG_COOKIES)
                    FBTrace.sysout("cookies.CookieModule.onBeforeUnload; There is a temp context leak!");
            }
        }
    },

    /**
     * Creates a new cookie in the browser.
     * This method is used by {@link EditCookie} dialog and also when a cookie is
     * pasted from the clipboard.
     *
     * @param {Cookie} Cookie object with appropriate properties. See {@link Cookie} object.
     */
    createCookie: function(cookie)
    {
        try
        {
            var uri = cookie.getURI();
            if (!uri)
                return;

            var c = cookie.cookie;

            // Fix for issue 34. The domain must be included in the cookieString if it
            // starts with "." But don't include it otherwise, since the "." would be
            // appended by the service.
            var host = cookie.cookie.host;
            var cookieString = cookie.toString(!(host.charAt(0) == "."));

            // Fix for issue 37: httpOnly cookies, and issue 47: Cannot change the HttpOnly flag
            // HttpOnly cookies can't be changed by setCookie string
            // See also: https://bugzilla.mozilla.org/show_bug.cgi?id=178993
            //cookieService.setCookieString(uri, null, cookieString, null);

            // Doesn't work in FF4 (issue 95)
            //cookieService.setCookieStringFromHttp(uri, uri, null, cookieString,
            //    c.expires, null);

            //xxxHonza: in what cases the cookie should be removed?
            //var cm = Cc["@mozilla.org/cookiemanager;1"].getService(Ci.nsICookieManager);
            //cm.remove(c.host, c.name, c.path, false);

            var isSession = CookieUtils.isSessionCookie(c);
            var cm2 = Cc["@mozilla.org/cookiemanager;1"].getService(Ci.nsICookieManager2);
            cm2.add(c.host, c.path, c.name, c.rawValue, c.isSecure, c.isHttpOnly, isSession,
                c.expires || Math.round((new Date()).getTime() / 1000 + 9999999999));

            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.createCookie: set cookie string: " + cookieString, cookie);

            // xxxHonza: this shouldn't be necessary, but sometimes the CookieObserver
            // is not triggered.
            TabWatcher.iterateContexts(function(context)
            {
                context.getPanel(panelName).refresh();
            });
        }
        catch (e)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.createCookie: set cookie string ERROR " +
                    cookieString, e);
        }
    },

    removeCookie: function(host, name, path)
    {
        cookieManager.remove(host, name, path, false);

        // xxxHonza: this shouldn't be necessary, but sometimes the CookieObserver
        // is not triggered.
        TabWatcher.iterateContexts(function(context)
        {
            context.getPanel(panelName).refresh();
        });
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Support for ActivableModule 1.6

    /**
     * It's just here to exists (calling base class only)
     */
    isEnabled: function(context)
    {
        return ActivableModule.isEnabled.apply(this, arguments);
    },

    /**
     * Called when an observer (e.g. panel) is added/removed into/from the model.
     * This is the moment when the model needs to decide whether to activate.
     */
    onObserverChange: function(observer)
    {
        if (this.hasObservers())
            TabWatcher.iterateContexts(Firebug.CookieModule.registerObservers);
        else
            TabWatcher.iterateContexts(Firebug.CookieModule.unregisterObservers);

        this.setStatus();
    },

    onSuspendFirebug: function()
    {
        TabWatcher.iterateContexts(Firebug.CookieModule.unregisterObservers);

        this.setStatus();

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onSuspendFirebug");
    },

    onResumeFirebug: function(context)
    {
        if (Firebug.CookieModule.isAlwaysEnabled())
            TabWatcher.iterateContexts(Firebug.CookieModule.registerObservers);

        this.setStatus();

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onResumeFirebug");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    setStatus: function()
    {
        var fbStatus = Firefox.getElementById("firebugStatus");
        if (fbStatus)
        {
            if (this.hasObservers())
                fbStatus.setAttribute(panelName, "on");
            else
                fbStatus.removeAttribute(panelName);
        }
        else
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.setStatus ERROR no firebugStatus element");
        }
    },

    getMenuLabel: function(option, location)
    {
        var host = getURIHost(location);

        // In case of local files or system pages use this labels instead of host.
        // xxxHonza: the panel should be automatically disabled for local files
        // and system pages as there are no cookies associated.
        // These options shouldn't be available at all.
        if (isSystemURL(location.spec))
            host = Locale.$STR("cookies.SystemPages");
        else if (!getURIHost(location))
            host = Locale.$STR("cookies.LocalFiles");

        // Translate these two options in panel activable menu from cookies.properties
        switch (option)
        {
        case "disable-site":
            return Locale.$STRF("cookies.HostDisable", [host]);
        case "enable-site":
            return Locale.$STRF("cookies.HostEnable", [host]);
        }

        return ActivableModule.getMenuLabel.apply(this, arguments);
    },

    // xxxHonza: This method is overriden just to provide translated strings from
    // cookies.properties file.
    openPermissions: function(event, context)
    {
        Events.cancelEvent(event);

        var browserURI = Firebug.chrome.getBrowserURI(context);
        var host = this.getHostForURI(browserURI);

        var params = {
            permissionType: this.getPrefDomain(),
            windowTitle: Locale.$STR(this.panelName + ".Permissions"),
            introText: Locale.$STR(this.panelName + ".PermissionsIntro"),
            blockVisible: true,
            sessionVisible: false,
            allowVisible: true,
            prefilledHost: host,
        };

        openWindow("Browser:Permissions", "chrome://browser/content/preferences/permissions.xul",
            "", params);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Remove Cookies

    onRemoveAllShowTooltip: function(tooltip, context)
    {
        tooltip.label = Locale.$STR("cookies.removeall.tooltip");
        return true;
    },

    onRemoveAllSessionShowTooltip: function(tooltip, context)
    {
        tooltip.label = Locale.$STR("cookies.removeallsession.tooltip");
        return true;
    },

    /**
     * Removes cookies defined for a website. This method removes all cookies for
     * the current page (including cookies from embedded iframes). The method
     * doesn't check any UI filters.
     *
     * @param {Object} context context, in which the cookies are defined
     * @param {Object} [filter] filter to define, which cookies should be removed
     *   (format: {session: true/false, host: string})
     */
    removeCookies: function(context, filter)
    {
        var panel = context.getPanel(panelName, true);
        if (!panel)
            return;

        var hosts = context.cookies.activeHosts;

        // If Firebug has been opened after page load, the activeHosts map
        // is empty since it's being initialized during the page load time
        // (in HttpObserver.onModifiedRequest).
        // Use the current window and iframes in such case (see issue 6469).
        if (!Obj.hasProperties(hosts))
        {
            hosts = {};

            Win.iterateWindows(context.window, function(win)
            {
                var host = Url.getURIHost(win.location);
                hosts[host] = true;
            });
        }

        for (var host in hosts)
        {
            var cookieEnumerator = cookieManager.getCookiesFromHost(host);
            while (cookieEnumerator.hasMoreElements())
            {
                var cookie = cookieEnumerator.getNext().QueryInterface(Ci.nsICookie2);
                this.removeCookieHelper(cookie, filter);
            }
        }
    },

    /**
     * Removes displayed cookies in the Cookies panel.
     *
     * @param {Object} context context, in which the cookies are defined
     * @param {Object} [filter] filter to define, which cookies should be removed
     *   (format: {session: true/false, host: string})
     */
    removeDisplayedCookies: function(context, filter)
    {
        var panel = context.getPanel("cookies", false);
        if (!panel)
            return;

        // Enumerate all displayed cookies and remove them step by step.
        var self = this;
        panel.enumerateCookies(function(cookie)
        {
            self.removeCookieHelper(cookie.cookie, filter);
        });
    },

    removeCookieHelper: function(cookie, filter)
    {
        // Remove the cookie only if the filter says so.
        if (!filter || ((!filter.session || cookie.isSession) &&
            (!filter.host || filter.host == cookie.host)))
        {
            cookieManager.remove(cookie.host, cookie.name, cookie.path, false);
        }
    },

    onRemoveAll: function(context)
    {
        if (Options.get(removeConfirmation))
        {
            var check = {value: false};
            var flags = prompts.BUTTON_POS_0 * prompts.BUTTON_TITLE_YES +
            prompts.BUTTON_POS_1 * prompts.BUTTON_TITLE_NO;

            if (!prompts.confirmEx(context.chrome.window, Locale.$STR("Firebug"),
                Locale.$STR("cookies.confirm.removeall"), flags, "", "", "",
                Locale.$STR("Do_not_show_this_message_again"), check) == 0)
            {
                return;
            }

            // Update 'Remove Cookies' confirmation option according to the value
            // of the dialog's "do not show again" checkbox.
            Options.set(removeConfirmation, !check.value);
        }

        Firebug.CookieModule.removeDisplayedCookies(context);
    },

    onRemoveAllSession: function(context)
    {
        if (Options.get(removeSessionConfirmation))
        {
            var check = {value: false};
            var flags = prompts.BUTTON_POS_0 * prompts.BUTTON_TITLE_YES +
                prompts.BUTTON_POS_1 * prompts.BUTTON_TITLE_NO;

            if (!prompts.confirmEx(context.chrome.window, Locale.$STR("Firebug"),
                Locale.$STR("cookies.confirm.removeallsession"), flags, "", "", "",
                Locale.$STR("Do_not_show_this_message_again"), check) == 0)
            {
                return;
            }

            // Update 'Remove Session Cookies' confirmation option according to the value
            // of the dialog's "do not show again" checkbox.
            Options.set(removeSessionConfirmation, !check.value);
        }

        Firebug.CookieModule.removeDisplayedCookies(context, {session: true});
    },

    onRemoveAllFromHost: function(context, host)
    {
        if (Options.get(removeConfirmation))
        {
            var check = {value: false};
            var flags = prompts.BUTTON_POS_0 * prompts.BUTTON_TITLE_YES +
                prompts.BUTTON_POS_1 * prompts.BUTTON_TITLE_NO;

            if (!prompts.confirmEx(context.chrome.window, Locale.$STR("Firebug"),
                Locale.$STRF("cookies.confirm.Remove_All_From_Host", [host]), flags, "", "", "",
                Locale.$STR("Do_not_show_this_message_again"), check) == 0)
            {
                return;
            }

            // Update 'Remove Cookies' confirmation option according to the value
            // of the dialog's "do not show again" checkbox.
            Options.set(removeConfirmation, !check.value);
        }

        Firebug.CookieModule.removeCookies(context, {host: host});
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Create Cookies

    onCreateCookieShowTooltip: function(tooltip, context)
    {
        var host = context.window.location.host;
        tooltip.label = Locale.$STRF("cookies.createcookie.tooltip", [host]);
        return true;
    },

    onCreateCookie: function(context)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onCreateCookie");

        // There is an excepion if the window is closed or not initialized (empty tab)
        var host;
        try
        {
            host = context.window.location.host;
        }
        catch (err)
        {
            alert(Locale.$STR("cookies.message.There_is_no_active_page"));
            return;
        }

        // Name and domain.
        var cookie = new Object();
        cookie.name = this.getDefaultCookieName(context);
        cookie.host = host;

        // The edit dialog uses raw value.
        cookie.rawValue = Locale.$STR("cookies.createcookie.defaultvalue");

        // Default path
        var path = context.window.location.pathname || "/";
        cookie.path = path.substr(0, (path.lastIndexOf("/") || 1));

        // Set defaul expiration time.
        cookie.expires = this.getDefaultCookieExpireTime();

        var params = {
            cookie: cookie,
            action: "create",
            window: context.window,
            EditCookie: EditCookie,
            Firebug: Firebug,
            FBTrace: FBTrace,
        };

        var parent = context.chrome.window;
        parent.openDialog("chrome://firebug/content/cookies/editCookie.xul",
            "_blank", "chrome,centerscreen,resizable=yes,modal=yes",
            params);
    },

    getDefaultCookieName: function(context, defaultName)
    {
        var counter = 0;
        var cookieDefaultName = defaultName || "Cookie";
        var cookieName = cookieDefaultName;
        var exists = false;
        var panel = context.getPanel(panelName);

        do
        {
            exists = false;

            var row = Dom.getElementByClass(panel.panelNode, "cookieRow");
            while (row)
            {
                var rep = row.repObject;

                // If the cookie is expanded, there is a row without the repObject
                if (rep && rep.cookie.name == cookieName)
                {
                    counter++;
                    exists = true;
                    cookieName = cookieDefaultName + "-" + counter;
                    break;
                }
                row = row.nextSibling;
            }
        } while (exists)

        return cookieName;
    },

    getDefaultCookieExpireTime: function()
    {
        // Get default expire time interval (in seconds) and add it to the
        // current time.
        var defaultInterval = Options.get(defaultExpireTime);
        var now = new Date();
        now.setTime(now.getTime() + (defaultInterval * 1000));

        // Return final expiration time.
        return (now.getTime() / 1000);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Exports all existing cookies in the browser into a cookies.txt file.
     * This action is available in the Cookies panel toolbar.
     */
    onExportAll: function(context)
    {
        try
        {
            var fp = Xpcom.CCIN("@mozilla.org/filepicker;1", "nsIFilePicker");
            fp.init(window, null, Ci.nsIFilePicker.modeSave);
            fp.appendFilters(Ci.nsIFilePicker.filterAll | Ci.nsIFilePicker.filterText);
            fp.filterIndex = 1;
            fp.defaultString = "cookies.txt";

            var rv = fp.show();
            if (rv == Ci.nsIFilePicker.returnOK || rv == Ci.nsIFilePicker.returnReplace)
            {
                var foStream = Xpcom.CCIN("@mozilla.org/network/file-output-stream;1", "nsIFileOutputStream");
                foStream.init(fp.file, 0x02 | 0x08 | 0x20, 0666, 0); // write, create, truncate

                var e = cookieManager.enumerator;
                while(e.hasMoreElements())
                {
                    var cookie = e.getNext();
                    cookie = cookie.QueryInterface(Ci.nsICookie2);
                    var cookieWrapper = new Cookie(CookieUtils.makeCookieObject(cookie));
                    var cookieInfo = cookieWrapper.toText();
                    foStream.write(cookieInfo, cookieInfo.length);
                }

                foStream.close();
            }
        }
        catch (err)
        {
            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.onExportAll EXCEPTION", err);
        }
    },

    onExportForSiteShowTooltip: function(tooltip, context)
    {
        var host = context.window.location.host;
        tooltip.label = Locale.$STRF("cookies.export.Export_For_Site_Tooltip", [host]);
        return true;
    },

    /**
     * Exports cookies for the current site into a cookies.txt file
     * This action is available in the Cookies panel toolbar.
     */
    onExportForSite: function(context)
    {
        try
        {
            var fp = Xpcom.CCIN("@mozilla.org/filepicker;1", "nsIFilePicker");
            fp.init(window, null, Ci.nsIFilePicker.modeSave);
            fp.appendFilters(Ci.nsIFilePicker.filterAll | Ci.nsIFilePicker.filterText);
            fp.filterIndex = 1;
            fp.defaultString = "cookies.txt";

            var rv = fp.show();
            if (rv == Ci.nsIFilePicker.returnOK || rv == Ci.nsIFilePicker.returnReplace)
            {
                var foStream = Xpcom.CCIN("@mozilla.org/network/file-output-stream;1",
                    "nsIFileOutputStream");
                foStream.init(fp.file, 0x02 | 0x08 | 0x20, 0666, 0); // write, create, truncate

                var panel = context.getPanel(panelName, true);
                var tbody = Dom.getElementByClass(panel.panelNode, "cookieTable").firstChild;
                for (var row = tbody.firstChild; row; row = row.nextSibling)
                {
                    if (Css.hasClass(row, "cookieRow") && row.repObject)
                    {
                        var cookieInfo = row.repObject.toText();
                        foStream.write(cookieInfo, cookieInfo.length);
                    }
                }

                foStream.close();
            }
        }
        catch (err)
        {
            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.onExportForSite EXCEPTION", err);
        }
    },

    onFilter: function(context, pref)
    {
        var value = Options.get(pref);
        Options.set(pref, !value);

        TabWatcher.iterateContexts(function(context)
        {
            var panel = context.getPanel(panelName, true);
            if (panel)
                panel.refresh();
        });
    },

    onFilterPopupShowing: function(menu)
    {
        var items = menu.getElementsByTagName("menuitem");
        for (var i=0; i<items.length; i++)
        {
            var item = items[i];
            var prefValue = Options.get(item.value);
            if (prefValue)
                item.setAttribute("checked", "true");
            else
                item.removeAttribute("checked");
        }

        return true;
    },

    // Custom path filter
    onFilterPanelShowing: function(filterPanel, context)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onFilterPanelShowing ", filterPanel);

        // Initialize filter input field.
        filterPanel.init(context.cookies.pathFilter);

        // A menu does not take the keyboard focus and keyboard messages are
        // sent to the window. In order to avoid unwante shortcuts execution
        // register a window keypress listeners for the time when the filter
        // popup is displayed and stop propagation of these events.
        // https://developer.mozilla.org/en/XUL/PopupGuide/PopupKeys
        window.addEventListener("keypress", this.onFilterKeyPress, true);
        return true;
    },

    onFilterPanelHiding: function(filterPanel, context)
    {
        window.removeEventListener("keypress", this.onFilterKeyPress, true);
        return true;
    },

    onFilterKeyPress: function(event)
    {
        // Stop propagation of keypress events when filter popup is displayed.
        event.stopPropagation();
    },

    onFilterPanelApply: function(context)
    {
        var parentMenu = Firebug.chrome.$("fcFilterMenuPopup");
        var filterPanel = Firebug.chrome.$("fcCustomPathFilterPanel");

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onApplyPathFilter, filter: " + filterPanel.value,
                filterPanel);

        // Use the filter from panel.
        context.cookies.pathFilter = filterPanel.value;

        // Refresh cookie list.
        var panel = context.getPanel(panelName);
        panel.refresh();

        // Close menu.
        parentMenu.hidePopup();
    },

    onViewAll: function(context)
    {
        parent.openDialog("chrome://browser/content/preferences/cookies.xul",
            "_blank", "chrome,resizable=yes", null);
    },

    onViewExceptions: function(context)
    {
        var params = {
            blockVisible   : true,
            sessionVisible : true,
            allowVisible   : true,
            prefilledHost  : "",
            permissionType : "cookie",
            windowTitle    : Locale.$STR("cookies.ExceptionsTitle"),
            introText      : Locale.$STR("cookies.Intro")
        };

        parent.openDialog("chrome://browser/content/preferences/permissions.xul",
            "_blank","chrome,resizable=yes", params);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Console Panel Options

    /**
     * Extend Console panel's option menu.
     */
    onOptionsMenu: function(context, panel, items)
    {
        if (panel.name != "console")
            return;

        var cookies = [
            MenuUtils.optionMenu(context, "cookies.showCookieEvents",
                "cookies.tip.showCookieEvents", Firebug.prefDomain, "cookies.logEvents"),
        ];

        // The option is disabled if the panel is disabled.
        if (!this.isEnabled(context))
            cookies[0].disabled = true;

        // Append new option at the right position.
        for (var i=0; i<items.length; i++)
        {
            var item = items[i];
            if (item.option == "showStackTrace")
            {
                Arr.arrayInsert(items, i+1, cookies);
                return;
            }
        }

        // If "showStackTrace" is not there append at the end.
        Arr.arrayInsert(items, items.length, cookies);
    },
});

// ********************************************************************************************* //
// Custom info tab within Net panel

/**
 * @domplate Represents domplate template for cookie body that is displayed if
 * a cookie entry in the cookie list is expanded.
 */
Firebug.CookieModule.NetInfoBody = domplate(Rep,
/** @lends Firebug.CookieModule.NetInfoBody */
{
    tag:
        DIV({"class": "netInfoCookiesList"},
            DIV({"class": "netInfoHeadersGroup netInfoCookiesGroup", $collapsed: "$cookiesInfo|hideReceivedCookies"},
                SPAN(Locale.$STR("cookies.netinfo.Received Cookies"))
            ),
            DIV({"class": "netInfoReceivedCookies netInfoCookies"}),
            DIV({"class": "netInfoHeadersGroup netInfoCookiesGroup", $collapsed: "$cookiesInfo|hideSentCookies"},
                SPAN(Locale.$STR("cookies.netinfo.Sent Cookies"))
            ),
            DIV({"class": "netInfoSentCookies netInfoCookies"})
        ),

    hideReceivedCookies: function(cookiesInfo)
    {
        return !cookiesInfo.receivedCookies.length;
    },

    hideSentCookies: function(cookiesInfo)
    {
        return !cookiesInfo.sentCookies.length;
    },

    // NetInfoBody listener
    initTabBody: function(infoBox, file)
    {
        var sentCookiesHeader = this.findHeader(file.requestHeaders, "Cookie");
        var receivedCookiesHeader = this.findHeader(file.responseHeaders, "Set-Cookie");

        // Create tab only if there are some cookies.
        if (sentCookiesHeader || receivedCookiesHeader)
            Firebug.NetMonitor.NetInfoBody.appendTab(infoBox, "Cookies",
                Locale.$STR("cookies.Panel"));
    },

    destroyTabBody: function(infoBox, file)
    {
    },

    updateTabBody: function(infoBox, file, context)
    {
        var tab = infoBox.selectedTab;
        if (!tab || tab.dataPresented || !Css.hasClass(tab, "netInfoCookiesTab"))
            return;

        tab.dataPresented = true;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.NetInfoBodyListener.updateTabBody",
                [file.requestHeaders, file.responseHeaders]);

        var sentCookiesHeader = this.findHeader(file.requestHeaders, "Cookie");
        var receivedCookiesHeader = this.findHeader(file.responseHeaders, "Set-Cookie");

        // Parse all received cookies and generate UI.
        var receivedCookies = [];
        var sentCookies = [];

        // Parse received cookies.
        if (receivedCookiesHeader) {
            var cookies = receivedCookiesHeader.split("\n");
            for (var i=0; i<cookies.length; i++) {
                var cookie = CookieUtils.parseFromString(cookies[i]);
                if (!cookie.host)
                    cookie.host = file.request.URI.host;
                receivedCookies.push(new Cookie(CookieUtils.makeCookieObject(cookie)));
            }
        }

        // Parse sent cookies.
        sentCookies = CookieUtils.parseSentCookiesFromString(sentCookiesHeader);

        // Create basic UI content
        var tabBody = Dom.getElementByClass(infoBox, "netInfoCookiesText");
        this.tag.replace({cookiesInfo: {
            receivedCookies: receivedCookies,
            sentCookies: sentCookies,
        }}, tabBody);

        // Generate UI for received cookies.
        if (receivedCookies.length) {
            CookieReps.CookieTable.render(receivedCookies,
                Dom.getElementByClass(tabBody, "netInfoReceivedCookies"));
        }

        // Generate UI for sent cookies.
        if (sentCookies.length) {
            CookieReps.CookieTable.render(sentCookies,
                Dom.getElementByClass(tabBody, "netInfoSentCookies"));
        }
    },

    // Helpers
    findHeader: function(headers, name)
    {
        if (!headers)
            return null;

        for (var i=0; i<headers.length; i++) {
            if (headers[i].name == name)
                return headers[i].value;
        }

        return null;
    }
});

// ********************************************************************************************* //
// Permission observer

/**
 * @class Represents an observer for perm-changed event that is dispatched
 * by Firefox is cookie permissions are changed.
 */
var PermissionObserver = Obj.extend(BaseObserver,
/** @lends PermissionObserver */
{
    observe: function(aSubject, aTopic, aData)
    {
        if (aTopic != "perm-changed")
            return;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.observe: " + aTopic + ", " + aData);

        var fn = Obj.bind(CookiePermissions.updatePermButton, CookiePermissions);
        TabWatcher.iterateContexts(fn);
    }
});

// ********************************************************************************************* //

function CookieBreakpointGroup()
{
    this.breakpoints = [];
}

CookieBreakpointGroup.prototype = Obj.extend(new Firebug.Breakpoint.BreakpointGroup(),
{
    name: "cookieBreakpoints",
    title: Locale.$STR("cookies.Cookie Breakpoints"),

    addBreakpoint: function(cookie)
    {
        this.breakpoints.push(new Breakpoints.Breakpoint(cookie));
    },

    removeBreakpoint: function(cookie)
    {
        var bp = this.findBreakpoint(cookie);
        Arr.remove(this.breakpoints, bp);
    },

    matchBreakpoint: function(bp, args)
    {
        var cookie = args[0];
        return (bp.name == cookie.name) &&
            (bp.host == cookie.host) &&
            (bp.path == cookie.path);
    },

    // Persistence
    load: function(context)
    {
        var panelState = Persist.getPersistedState(context, panelName);
        if (panelState.breakpoints)
            this.breakpoints = panelState.breakpoints;
    },

    store: function(context)
    {
        var panelState = Persist.getPersistedState(context, panelName);
        panelState.breakpoints = this.breakpoints;
    }
});

// ********************************************************************************************* //
// Registration Helpers

function registerCookieObserver(observer)
{
    if (observer.registered)
        return;

    if (FBTrace.DBG_COOKIES)
        FBTrace.sysout("cookies.registerCookieObserver");

    observerService.addObserver(observer, "cookie-changed", false);
    observerService.addObserver(observer, "cookie-rejected", false);

    observer.registered = true;

    return observer;
}

function unregisterCookieObserver(observer)
{
    if (!observer.registered)
        return;

    if (FBTrace.DBG_COOKIES)
        FBTrace.sysout("cookies.unregisterCookieObserver");

    observerService.removeObserver(observer, "cookie-changed");
    observerService.removeObserver(observer, "cookie-rejected");

    observer.registered = false;
}

// ********************************************************************************************* //
// Preference observer

// xxxHonza: is this still needed?
/**
 * @class Represents an observer for nsPref:changed event dispatched when
 * an user preference is changed (e.g. using about:config)
 */
var PrefObserver = Obj.extend(BaseObserver,
/** @lends PrefObserver */
{
    observe: function(aSubject, aTopic, aData)
    {
        if (aTopic != "nsPref:changed")
            return;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.observe: " + aTopic + ", " + aData);

        if (aData == networkPrefDomain + "." + cookieBehaviorPref ||
            aData == networkPrefDomain + "." + cookieLifeTimePref) {
            var fn = CookiePermissions.updatePermButton;
            TabWatcher.iterateContexts(fn);
        }
    }
});

// ********************************************************************************************* //
// Used till the real context isn't available (in initContext), bug if Firebug)

function CookieTempObserver(tempContext) {
    this.tempContext = tempContext;
}

CookieTempObserver.prototype = Obj.extend(BaseObserver, {
    observe: function(subject, topic, data) {
        this.tempContext.appendCookieEvent(subject, topic, data);
    }
});

// ********************************************************************************************* //
// Array Helpers

function cloneMap(map)
{
    var newMap = [];
    for (var item in map)
        newMap[item] = map[item];

    return newMap;
}

// ********************************************************************************************* //
// Firebug Registration

// Expose to XUL scope
Firebug.CookieModule.Perm = CookiePermissions;

// Expose for tests
Firebug.CookieModule.CookieReps = CookieReps;

Firebug.registerActivableModule(Firebug.CookieModule);

return Firebug.CookieModule;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/cookies/cookieObserver",
[
    "firebug/lib/xpcom",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/domplate",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/lib/persist",
    "firebug/lib/string",
    "firebug/lib/http",
    "firebug/lib/css",
    "firebug/lib/events",
    "firebug/cookies/baseObserver",
    "firebug/chrome/tabWatcher",
    "firebug/cookies/cookieReps",
    "firebug/cookies/cookieUtils",
    "firebug/cookies/cookie",
    "firebug/cookies/breakpoints",
    "firebug/cookies/cookieEvents",
    "firebug/lib/array",
],
function(Xpcom, Obj, Locale, Domplate, Dom, Options, Persist, Str, Http, Css, Events,
    BaseObserver, TabWatcher, CookieReps, CookieUtils, Cookie, Breakpoints, CookieEvents, Arr) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const filterByPath = "cookies.filterByPath";

const panelName = "cookies";

const idnService = Xpcom.CCSV("@mozilla.org/network/idn-service;1", "nsIIDNService");

// ********************************************************************************************* //
// Cookie observer

/**
 * @class This class represents an observer (nsIObserver) for cookie-changed
 * and cookie-rejected events. These events are dispatche by Firefox
 * see https://developer.mozilla.org/En/Observer_Notifications.
 */
var CookieObserver = Obj.extend(BaseObserver,
/** @lends CookieObserver */
{
    // nsIObserver
    observe: function(aSubject, aTopic, aData)
    {
        try
        {
            if (!Firebug.CookieModule.isAlwaysEnabled())
                return;

            // See: https://developer.mozilla.org/en/XPCOM_Interface_Reference/nsICookieService
            // For all possible values.
            if (aTopic == "cookie-changed")
            {
                var cookies = [];
                if (aData == "batch-deleted")
                {
                    // In this case the subject is nsIArray.
                    var enumerator = aSubject.QueryInterface(Ci.nsIArray).enumerate();
                    while (enumerator.hasMoreElements())
                        cookies.push(enumerator.getNext().QueryInterface(Ci.nsICookie2));

                    // The event will be further distributed as standard "delete" event.
                    aData = "deleted";
                }
                else
                {
                    aSubject = aSubject ? aSubject.QueryInterface(Ci.nsICookie2) : null;
                    cookies.push(aSubject);
                }

                for (var i=0; i<cookies.length; i++)
                    this.iterateContexts(this.onCookieChanged, cookies[i], aData);
            }
            else if (aTopic == "cookie-rejected")
            {
                aSubject = aSubject.QueryInterface(Ci.nsIURI);
                this.iterateContexts(this.onCookieRejected, aSubject, aData);
            }
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("cookies.CookieObserver.observe; ERROR " +
                    aTopic + ", " + aData, err);
                FBTrace.sysout("cookies.CookieObserver.observe; subject ", aSubject);
            }
        }
    },

    iterateContexts: function(fn)
    {
        var oThis = this;
        var args = Arr.cloneArray(arguments);
        TabWatcher.iterateContexts(function(context)
        {
            args[0] = context;
            fn.apply(oThis, args);
        });
    },

    /**
     * @param {String} activeUri This object represents currently active host. Notice that there
     *      can be more active hosts (activeHosts map) on one page in case 
     *      of embedded iframes or/and previous redirects.
     *      Properties:
     *      host: www.example.com
     *      path: /subdir/
     *
     * @param {String} host: Represents the host of a cookie for which
     *      we are checking if it should be displayed for the active URI.
     * 
     * @param {String} path: Represents the path of a cookie for which
     *      we are checking if it should be displayed for the active URI.
     * 
     * @returns {Boolean} If the method returns true the host/path belongs
     *      to the activeUri.
     */
    isHostFromURI: function(activeUri, host, cookiePath)
    {
        var pathFilter = Options.get(filterByPath);

        // Compute the default path of the cookie according to the algorithm
        // defined in RFC 6265 section 5.1.4
        //
        // Steps 2 and 3 (output "/" in case the cookie path is empty, its first
        // character is "/" or there is no more than one "/")
        if (cookiePath.length == 0 || cookiePath.charAt(0) != "/" ||
            cookiePath.lastIndexOf("/") == 0)
        {
            cookiePath = "/";
        }
        else
        {
            // Step 4 (remove slash at the end of the active path according to)
            cookiePath = cookiePath.substr(0, cookiePath.lastIndexOf("/"));
        }

        // If the path filter is on, only cookies that match given path
        // according to RFC 6265 section 5.1.4 will be displayed.
        var requestPath = activeUri.path;
        if (pathFilter && (cookiePath != requestPath && !(Str.hasPrefix(requestPath, cookiePath) &&
            (Str.endsWith(cookiePath, "/") || requestPath.substr(cookiePath.length, 1) == "/"))))
        {
            return false;
        }

        // The cookie must belong to given URI from this context,
        // otherwise it won't be displayed in this tab.
        var uri = CookieUtils.makeStrippedHost(activeUri.host);
        if (uri == host)
            return true;

        if (uri.length < host.length)
            return false;

        var h = "." + host;
        var u = "." + uri;
        if (u.substr(u.length - h.length) == h)
            return true;

        return false;
    },

    isHostFromContext: function(context, host, path)
    {
        var location;
        try
        {
            host = idnService.convertACEtoUTF8(host);
        }
        catch(exc)
        {
            if (FBTrace.DBG_ERRORS || FBTrace.DBG_COOKIES)
                FBTrace.sysout("Host could not be converted to UTF-8", exc);
        }

        // Invalid in Chromebug.
        try
        {
            location = context.window.location;
            if (!location || !location.protocol)
                return;
        }
        catch (err)
        {
            return false;
        }

        if (location.protocol.indexOf("http") != 0)
            return false;

        var rawHost = CookieUtils.makeStrippedHost(host);

        // Test the current main URI first.
        // The location isn't nsIURI, so make a fake object (aka nsIURI). 
        var fakeUri = {host: location.host, path: location.pathname};
        if (this.isHostFromURI(fakeUri, rawHost, path))
            return true;

        // xxxHonza
        // If the context.cookies is not initialized, it's bad. It means that
        // neither temporary context no real context has been initialized
        // One reason is that Sript model issues panel.show in onModuleActivate
        // which consequently requests a file (double load prblem), which
        // consequently rises this cookie event.
        if (!context.cookies)
            return false;

        // Now test if the cookie doesn't belong to some of the
        // activeHosts (redirects, frames).    
        var activeHosts = context.cookies.activeHosts;
        for (var activeHost in activeHosts)
        {
            if (this.isHostFromURI(activeHosts[activeHost], rawHost, path))
                return true;
        }

        return false;
    },

    isCookieFromContext: function(context, cookie)
    {
        return this.isHostFromContext(context, cookie.host, cookie.path);
    },

    onCookieChanged: function(context, cookie, action)
    {
        // If the action == "cleared" the cookie is *not* set. This action is triggered
        // when all cookies are removed (cookieManager.removeAll)
        // In such a case let's displaye the event in all contexts.
        if (cookie && !this.isCookieFromContext(context, cookie))
            return;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onCookieChanged: '" + (cookie ? cookie.name : "null") +
                "', " + action);

        if (action != "cleared")
        {
            // If log into the Console tab is on, create "deleted", "added" and "changed" events.
            if (logEvents())
                this.logEvent(new CookieEvents.CookieChangedEvent(context, CookieUtils.makeCookieObject(cookie),
                    action), context, "cookie");

            // Break on cookie if "Break On" is activated or if a cookie breakpoint exist.
            Breakpoints.breakOnCookie(context, cookie, action);
        }

        switch(action)
        {
          case "deleted":
            this.onRemoveCookie(context, cookie);
            break;
          case "added":
            this.onAddCookie(context, cookie);
            break;
          case "changed":
            this.onUpdateCookie(context, cookie);
            break;
          case "cleared":
            this.onClear(context);
            return;
          case "reload":
            context.invalidatePanels(panelName);
            return;
        }
    },

    onClear: function(context)
    {
        var panel = context.getPanel(panelName);
        panel.clear();

        if (logEvents())
            this.logEvent(new CookieEvents.CookieClearedEvent(), context, "cookiesCleared");
    },

    onCookieRejected: function(context, uri)
    {
        var path = uri.path.substr(0, (uri.path.lastIndexOf("/") || 1));
        if (!this.isHostFromContext(context, uri.host, path))
            return;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onCookieRejected: " + uri.spec);

        // Mark host and all its cookies as rejected.
        // xxxHonza there was an exception "context.cookies is undefined".
        var activeHost = context.cookies.activeHosts[uri.host];
        if (activeHost)
            activeHost.rejected = true;

        var receivedCookies = activeHost ? activeHost.receivedCookies : null;
        for (var i=0; receivedCookies && i<receivedCookies.length; i++)
            receivedCookies[i].cookie.rejected = true;

        // Refresh the panel asynchronously.
        context.invalidatePanels(panelName);

        // Bail out if events are not logged into the Console.
        if (!logEvents())
            return;

        // The "cookies-rejected" event is sent even if no cookies
        // from the blocked site have been actually received.
        // So, the receivedCookies array can be null.
        // Don't display anything in the console in that case,
        // there could be a lot of "Cookie Rejected" events.
        // There would be actually one for each embedded request.
        if (!receivedCookies)
            return;

        // Create group log for list of rejected cookies.
        var groupRow = Firebug.Console.openGroup(
            [new CookieEvents.CookieRejectedEvent(context, uri)], 
            context, "cookiesRejected", null, true, null, true);

        // The console can be disabled (since FB 1.2).
        if (!groupRow)
            return;

        // It's closed by default.
        Css.removeClass(groupRow, "opened");
        Firebug.Console.closeGroup(context, true);

        // Create embedded table.
        CookieReps.CookieTable.render(receivedCookies, groupRow.lastChild);
    },

    onAddCookie: function(context, cookie)
    {
        var panel = context.getPanel(panelName, true);
        var repCookie = panel ? panel.findRepObject(cookie) : null;
        if (repCookie)
        {
            this.onUpdateCookie(context, cookie);
            return;
        }

        if (!panel || !panel.table)
            return;

        var repCookie = panel ? panel.findRepObject(cookie) : null;

        cookie = new Cookie(CookieUtils.makeCookieObject(cookie));

        var tbody = panel.table.lastChild;
        var parent = tbody.lastChild ? tbody.lastChild : tbody;
        var row = CookieReps.CookieRow.cookieTag.insertRows({cookies: [cookie]}, parent)[0];

        cookie.row = row;
        row.repObject = cookie;

        //xxxHonza the new cookie should respect current sorting.
    },

    onUpdateCookie: function(context, cookie)
    {
        var panel = context.getPanel(panelName, true);

        // The table doesn't have to be initialized yet.
        if (!panel || !panel.table)
            return;

        var repCookie = panel ? panel.findRepObject(cookie) : null;
        if (!repCookie)
        {
            this.onAddCookie(context, cookie);
            return;
        }

        repCookie.cookie = CookieUtils.makeCookieObject(cookie);
        repCookie.rawHost = CookieUtils.makeStrippedHost(cookie.host);

        // These are helpers so, the XML and JSON cookies don't have to be parsed
        // again and again. But we need to reset them if the value is changed.
        repCookie.json = null;
        repCookie.xml = null;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onUpdateCookie: " + cookie.name, repCookie);

        var row = repCookie.row;
        var rowTemplate = CookieReps.CookieRow;

        if (Css.hasClass(row, "opened"))
        {
            var cookieInfoBody = Dom.getElementByClass(row.nextSibling, "cookieInfoBody");

            // Invalidate content of all tabs.
            cookieInfoBody.valuePresented = false;
            cookieInfoBody.rawValuePresented = false;
            cookieInfoBody.xmlPresented = false;
            cookieInfoBody.jsonPresented = false;

            // Update tabs visibility and content of the selected tab.
            rowTemplate.updateTabs(cookieInfoBody, repCookie, context);
            rowTemplate.updateInfo(cookieInfoBody, repCookie, context);
        }

        rowTemplate.updateRow(repCookie, context);
    },

    onRemoveCookie: function(context, cookie)
    {
        var panel = context.getPanel(panelName, true);
        var repCookie = panel ? panel.findRepObject(cookie) : null;
        if (!repCookie)
            return;

        // Remove cookie from UI.
        var row = repCookie.row;
        var parent = repCookie.row.parentNode;

        if (Css.hasClass(repCookie.row, "opened"))
            parent.removeChild(row.nextSibling);

        if (!parent)
            return;

        parent.removeChild(repCookie.row);
    },

    logEvent: function(eventObject, context, className)
    {
        // xxxHonza: if the cookie is changed befor initContext, the log in
        // console is lost.
        Firebug.Console.log(eventObject, context, className, null, true);
    }
});

// ********************************************************************************************* //
// Helpers

function logEvents()
{
    return Options.get("cookies.logEvents");
}

// ********************************************************************************************* //

return CookieObserver;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/cookies/cookiePanel",
[
    "firebug/chrome/activableModule",
    "firebug/chrome/activablePanel",
    "firebug/lib/xpcom",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/domplate",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/lib/persist",
    "firebug/lib/string",
    "firebug/lib/http",
    "firebug/lib/css",
    "firebug/lib/events",
    "firebug/lib/array",
    "firebug/lib/search",
    "firebug/cookies/menuUtils",
    "firebug/cookies/cookieReps",
    "firebug/cookies/headerResizer",
    "firebug/cookies/cookieObserver",
    "firebug/cookies/cookieUtils",
    "firebug/cookies/cookie",
    "firebug/cookies/breakpoints",
    "firebug/cookies/cookiePermissions",
    "firebug/cookies/cookieClipboard",
],
function(ActivableModule, ActivablePanel, Xpcom, Obj, Locale, Domplate, Dom, Options, Persist,
    Str, Http, Css, Events, Arr, Search, MenuUtils, CookieReps, HeaderResizer, CookieObserver,
    CookieUtils, Cookie, Breakpoints, CookiePermissions, CookieClipboard) {

// ********************************************************************************************* //
// Constants

var {domplate, DIV, TR, P, A} = Domplate;

const Ci = Components.interfaces;

// Cookies preferences
const showRejectedCookies = "cookies.showRejectedCookies";
const lastSortedColumn = "cookies.lastSortedColumn";
const hiddenColsPref = "cookies.hiddenColumns";
const removeConfirmation = "cookies.removeConfirmation";

// Services
var cookieManager = Xpcom.CCSV("@mozilla.org/cookiemanager;1", "nsICookieManager2");

const panelName = "cookies";

// ********************************************************************************************* //
// Panel Implementation

/**
 * @panel This class represents the Cookies panel that is displayed within
 * Firebug UI.
 */
function CookiePanel() {}

CookiePanel.prototype = Obj.extend(ActivablePanel,
/** @lends CookiePanel */
{
    name: panelName,
    title: Locale.$STR("cookies.Panel"),
    searchable: true,
    breakable: true,

    // Place just after the Net panel
    order: 200,

    initialize: function(context, doc)
    {
        // xxxHonza:
        // This initialization is made as soon as the Cookies panel
        // is opened the first time.
        // This means that columns are *not* resizable within the console
        // (rejected cookies) till this activation isn't executed.

        // Initialize event listeners before the ancestor is called
        var hcr = HeaderResizer;
        this.onMouseClick = Obj.bind(hcr.onMouseClick, hcr);
        this.onMouseDown = Obj.bind(hcr.onMouseDown, hcr);
        this.onMouseMove = Obj.bind(hcr.onMouseMove, hcr);
        this.onMouseUp = Obj.bind(hcr.onMouseUp, hcr);
        this.onMouseOut = Obj.bind(hcr.onMouseOut, hcr);

        this.onContextMenu = Obj.bind(this.onContextMenu, this);

        ActivablePanel.initialize.apply(this, arguments);

        Firebug.ConsolePanel.prototype.addListener(this);

        // Just after the initialization, so the this.document member is set
        Firebug.CookieModule.addStyleSheet(this);

        this.refresh();
    },

    shutdown: function()
    {
        Firebug.ConsolePanel.prototype.removeListener(this);
    },

    /**
     * Renders the list of cookies displayed within the Cookies panel
     */
    refresh: function()
    {
        if (!Firebug.CookieModule.isEnabled(this.context))
            return;

        // Create cookie list table
        this.table = CookieReps.CookieTable.createTable(this.panelNode);

        // Cookies are displayed only for web pages
        var location = this.context.window.location;
        if (!location)
            return;

        var protocol = location.protocol;
        if (protocol.indexOf("http") != 0)
            return;

        // Get list of cookies for the current page
        var cookies = [];
        var iter = cookieManager.enumerator;
        while (iter.hasMoreElements())
        {
            var cookie = iter.getNext();
            if (!cookie)
                break;

            cookie = cookie.QueryInterface(Ci.nsICookie2);
            if (!CookieObserver.isCookieFromContext(this.context, cookie))
                continue;

            var cookieWrapper = new Cookie(CookieUtils.makeCookieObject(cookie));
            cookies.push(cookieWrapper);
        }

        // If the filter allows it, display all rejected cookies as well.
        if (Options.get(showRejectedCookies))
        {
            // xxxHonza: this.context.cookies is sometimes null, but
            // this must be because FB isn't correctly initialized.
            if (!this.context.cookies)
            {
                if (FBTrace.DBG_COOKIES)
                {
                    FBTrace.sysout(
                        "cookies.Cookie context isn't properly initialized - ERROR: " +
                        this.context.getName());
                }
                return;
            }

            var activeHosts = this.context.cookies.activeHosts;
            for (var hostName in activeHosts)
            {
                var host = activeHosts[hostName];
                if (!host.rejected)
                    continue;

                var receivedCookies = host.receivedCookies;
                if (receivedCookies)
                    cookies = Arr.extendArray(cookies, receivedCookies);
            }
        }

        // Generate HTML list of cookies using Domplate
        if (cookies.length)
        {
            var header = Dom.getElementByClass(this.table, "cookieHeaderRow");
            var tag = CookieReps.CookieRow.cookieTag;
            var row = tag.insertRows({cookies: cookies}, header)[0];
            for (var i=0; i<cookies.length; i++)
            {
                var cookie = cookies[i];
                cookie.row = row;

                Breakpoints.updateBreakpoint(this.context, cookie);
                row = row.nextSibling;
            }
        }

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.Cookie list refreshed.", cookies);

        // Automatically sort the last sorted column. The preference stores
        // two things: name of the sorted column and sort direction asc|desc.
        // Example: colExpires asc
        var prefValue = Options.get(lastSortedColumn);
        if (prefValue)
        {
            var values = prefValue.split(" ");
            CookieReps.CookieTable.sortColumn(this.table, values[0], values[1]);
        }

        // Update visibility of columns according to the preferences
        var hiddenCols = Options.get(hiddenColsPref);
        if (hiddenCols)
            this.table.setAttribute("hiddenCols", hiddenCols);

        // Remove certain context menu items on cookiePanel display
        this.table.setAttribute("removedCols", ["colMaxAge"]);
    },

    initializeNode: function(oldPanelNode)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.CookiePanel.initializeNode");

        // xxxHonza:
        // This method isn't called when FB UI is detached. So, the columns
        // are *not* resizable when FB is open in an external window.

        // Register event handlers for table column resizing
        this.document.addEventListener("click", this.onMouseClick, true);
        this.document.addEventListener("mousedown", this.onMouseDown, true);
        this.document.addEventListener("mousemove", this.onMouseMove, true);
        this.document.addEventListener("mouseup", this.onMouseUp, true);
        this.document.addEventListener("mouseout", this.onMouseOut, true);

        this.panelNode.addEventListener("contextmenu", this.onContextMenu, false);
    },

    destroyNode: function()
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.CookiePanel.destroyNode");

        this.document.removeEventListener("mouseclick", this.onMouseClick, true);
        this.document.removeEventListener("mousedown", this.onMouseDown, true);
        this.document.removeEventListener("mousemove", this.onMouseMove, true);
        this.document.removeEventListener("mouseup", this.onMouseUp, true);
        this.document.removeEventListener("mouseout", this.onMouseOut, true);

        this.panelNode.removeEventListener("contextmenu", this.onContextMenu, false);
    },

    onContextMenu: function(event)
    {
        Breakpoints.onContextMenu(this.context, event);
    },

    detach: function(oldChrome, newChrome)
    {
        ActivablePanel.detach.apply(this, arguments);
    },

    reattach: function(doc)
    {
        ActivablePanel.reattach.apply(this, arguments);
    },

    clear: function()
    {
        if (this.panelNode)
            Dom.clearNode(this.panelNode);

        this.table = null;
    },

    show: function(state)
    {
        // Update permission button in the toolbar
        CookiePermissions.updatePermButton(this.context);

        // For backward compatibility with Firebug 1.1
        //
        // Firebug 1.6 removes Firebug.DisabledPanelPage, simplifies the activation
        // and the following code is not necessary any more.
        if (ActivableModule && Firebug.DisabledPanelPage)
        {
            var shouldShow = Firebug.CookieModule.isEnabled(this.context);
            this.showToolbarButtons("fbCookieButtons", shouldShow);
            if (!shouldShow)
            {
                // The activation model has been changed in Firebug 1.4. This is
                // just to keep backward compatibility.
                if (Firebug.DisabledPanelPage.show)
                    Firebug.DisabledPanelPage.show(this, Firebug.CookieModule);
                else
                    Firebug.CookieModule.disabledPanelPage.show(this);
                return;
            }
        }
        else
        {
            this.showToolbarButtons("fbCookieButtons", true);
        }

        if (Firebug.chrome.setGlobalAttribute)
        {
            Firebug.chrome.setGlobalAttribute("cmd_firebug_resumeExecution", "breakable", "true");
            Firebug.chrome.setGlobalAttribute("cmd_firebug_resumeExecution", "tooltiptext",
                Locale.$STR("cookies.Break On Cookie"));
        }
    },

    hide: function()
    {
        this.showToolbarButtons("fbCookieButtons", false);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Options menu

    getOptionsMenuItems: function(context)
    {
        return [
            MenuUtils.optionAllowGlobally(context, "cookies.AllowGlobally",
                "cookies.tip.AllowGlobally", "network.cookie", "cookieBehavior"),
            /*MenuUtils.optionMenu(context, "cookies.clearWhenDeny",
                "cookies.tip.clearWhenDeny", Firebug.prefDomain, clearWhenDeny),*/
            MenuUtils.optionMenu(context, "cookies.Confirm cookie removal",
                "cookies.tip.Confirm cookie removal", Firebug.prefDomain, removeConfirmation)
        ];
    },

    getContextMenuItems: function(object, target)
    {
        var items = [];

        // If the user clicked a cookie row, the context menu is already
        // initialized and so bail out.
        var cookieRow = Dom.getAncestorByClass(target, "cookieRow");
        if (cookieRow)
            return items;

        // Also bail out if the user clicked on the header.
        var header = Dom.getAncestorByClass(target, "cookieHeaderRow");
        if (header)
            return items;

        // Make sure default items (cmd_copy) are removed
        CookieReps.Rep.getContextMenuItems.apply(this, arguments);

        return items;
    },

    search: function(text)
    {
        if (!text)
            return;

        // Make previously visible nodes invisible again
        if (this.matchSet)
        {
            for (var i in this.matchSet)
                Css.removeClass(this.matchSet[i], "matched");
        }

        this.matchSet = [];

        function findRow(node)
        {
            return Dom.getAncestorByClass(node, "cookieRow");
        }

        var search = new Search.TextSearch(this.panelNode, findRow);

        var caseSensitive = Firebug.Search.isCaseSensitive(text);
        var cookieRow = search.find(text, false, caseSensitive);
        if (!cookieRow)
            return false;

        for (; cookieRow; cookieRow = search.findNext(false, false, false, caseSensitive))
        {
            Css.setClass(cookieRow, "matched");
            this.matchSet.push(cookieRow);
        }

        return true;
    },

    getPopupObject: function(target)
    {
        var header = Dom.getAncestorByClass(target, "cookieHeaderRow");
        if (header)
            return CookieReps.CookieTable;

        return ActivablePanel.getPopupObject.apply(this, arguments);
    },

    findRepObject: function(cookie)
    {
        var strippedHost = CookieUtils.makeStrippedHost(cookie.host);

        var result = null;
        this.enumerateCookies(function(rep)
        {
            if (rep.rawHost == strippedHost &&
                rep.cookie.name == cookie.name &&
                rep.cookie.path == cookie.path)
            {
                result = rep;
                return true; // break iteration
            }
        });

        return result;
    },

    supportsObject: function(object)
    {
        return object instanceof Cookie;
    },

    updateSelection: function(cookie)
    {
        var repCookie = this.findRepObject(cookie.cookie);
        if (!repCookie)
            return;

        CookieReps.CookieRow.toggleRow(repCookie.row, true);
        Dom.scrollIntoCenterView(repCookie.row);
    },

    enumerateCookies: function(fn)
    {
        if (!this.table)
            return;

        var rows = Dom.getElementsByClass(this.table, "cookieRow");
        rows = Arr.cloneArray(rows);
        for (var i=0; i<rows.length; i++)
        {
            var cookie = Firebug.getRepObject(rows[i]);
            if (!cookie)
                continue;

            if (fn(cookie))
                break;
        }
    },

    getEditor: function(target, value)
    {
        if (!this.conditionEditor)
            this.conditionEditor = new Breakpoints.ConditionEditor(this.document);
        return this.conditionEditor;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Support for Break On Next

    breakOnNext: function(breaking)
    {
        this.context.breakOnCookie = breaking;

        if (FBTrace.DBG_COOKIES)
        {
            FBTrace.sysout("cookies.breakOnNext; " + this.context.breakOnCookie + ", " +
                this.context.getName());
        }
    },

    shouldBreakOnNext: function()
    {
        return this.context.breakOnCookie;
    },

    getBreakOnNextTooltip: function(enabled)
    {
        return (enabled ? Locale.$STR("cookies.Disable Break On Cookie") :
            Locale.$STR("cookies.Break On Cookie"));
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Console Panel Listeners

    onFiltersSet: function(logTypes)
    {
        logTypes.cookies = 1;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Panel Activation

    onActivationChanged: function(enable)
    {
        if (FBTrace.DBG_COOKIES || FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("cookies.CookiePanel.onActivationChanged; " + enable);

        if (enable)
        {
            Firebug.CookieModule.addObserver(this);
            Firebug.Debugger.addListener(Firebug.CookieModule.DebuggerListener);
            Firebug.Console.addListener(Firebug.CookieModule.ConsoleListener);
        }
        else
        {
            Firebug.CookieModule.removeObserver(this);
            Firebug.Debugger.removeListener(Firebug.CookieModule.DebuggerListener);
            Firebug.Console.removeListener(Firebug.CookieModule.ConsoleListener);
        }
    },

    // Support for info tips.
    showInfoTip: function(infoTip, target, x, y)
    {
        var row = Dom.getAncestorByClass(target, "cookieRow");
        if (row && row.repObject)
        {
            if (Dom.getAncestorByClass(target, "cookieSizeCol") ||
                Dom.getAncestorByClass(target, "cookieRawSizeCol"))
            {
                var infoTipCookieId = "cookiesize-"+row.repObject.name;
                if (infoTipCookieId == this.infoTipCookieId && row.repObject == this.infoTipCookie)
                    return true;

                this.infoTipCookieId = infoTipCookieId;
                this.infoTipCookie = row.repObject;
                return this.populateSizeInfoTip(infoTip, row.repObject);
            }
        }

        delete this.infoTipCookieId;
        return false;
    },

    populateSizeInfoTip: function(infoTip, cookie)
    {
        CookieReps.SizeInfoTip.render(cookie, infoTip);
        return true;
    },
});

// ********************************************************************************************* //
// Cookie Breakpoints

/**
 * @class Represents an {@link Firebug.Debugger} listener. This listener is reponsible for
 * providing a list of cookie breakpoints for the Breakpoints side panel.
 */
Firebug.CookieModule.DebuggerListener =
{
    getBreakpoints: function(context, groups)
    {
        if (!context.cookies.breakpoints.isEmpty())
            groups.push(context.cookies.breakpoints);
    }
};

// ********************************************************************************************* //
// Custom output in the Console panel for document.cookie

Firebug.CookieModule.ConsoleListener =
{
    tag:
        DIV({_repObject: "$object"},
            DIV({"class": "documentCookieBody"})
        ),

    log: function(context, object, className, sourceLink)
    {
        //xxxHonza: Chromebug says it's null sometimes.
        if (!context)
            return;

        if (object !== context.window.document.cookie)
            return;

        // Parse "document.cookie" string
        var cookies = CookieUtils.parseSentCookiesFromString(object);
        if (!cookies || !cookies.length)
            return;

        // Create an empty log row that serves as a container for the list of cookies
        // created from the document.cookie property
        var appendObject = Firebug.ConsolePanel.prototype.appendObject;
        var row = Firebug.ConsoleBase.logRow(appendObject, object, context,
            "documentCookie", this, null, true);

        var rowBody = Dom.getElementByClass(row, "documentCookieBody");
        CookieReps.CookieTable.render(cookies, rowBody);
    },

    logFormatted: function(context, objects, className, sourceLink)
    {
    }
};

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(CookiePanel);

return CookiePanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/cookies/cookiePermissions",
[
    "firebug/lib/object",
    "firebug/lib/xpcom",
    "firebug/lib/locale",
    "firebug/lib/options",
],
function(Obj, Xpcom, Locale, Options) {

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

var permissionManager = Xpcom.CCSV("@mozilla.org/permissionmanager;1", "nsIPermissionManager");

// Firefox Preferences
const networkPrefDomain = "network.cookie";
const cookieBehaviorPref = "cookieBehavior";
const cookieLifeTimePref = "lifetimePolicy";

// The second item in the array says if the localized string expects
// a domain name at the end.
const permOptions =
{
    "default-session": ["cookies.default.session", false],
    "default-third-party-session": ["cookies.default.thirdPartySession", false],
    "default-third-party": ["cookies.default.thirdParty", false],
    "default-limit-third-party": ["cookies.default.limitThirdParty", false],
    "default-allow": ["cookies.default.allow", false],
    "default-deny": ["cookies.default.deny", false],
    "default-warn": ["cookies.default.warn", false],
    "host-allow-session": ["cookies.host.session", true],
    "host-allow": ["cookies.host.accept", true],
    "host-deny": ["cookies.host.reject", true],
    "host-limit-third-party": ["cookies.host.limitThirdParty", true],
};

// ********************************************************************************************* //
// Cookie Permissions

/**
 * @class This class is responsible for managing cookie permissions.
 */
var CookiePermissions = Obj.extend(Object,
/** @lends CookiePermissions */
{
    onCommand: function(event, context, location)
    {
        var menu = event.target;
        this.setPermission(context, menu.value, location);
    },

    onTooltipShowing: function(tooltip, context)
    {
        if (tooltip.fcEnabled)
        {
            var host = context.window.location.host;
            tooltip.label = Locale.$STRF("cookies.perm.manage.tooltip", [host]);
        }

        return tooltip.fcEnabled;
    },

    onPopupShowing: function(menu, context)
    {
        var permTooltip = Firebug.chrome.$("fcPermTooltip");
        permTooltip.fcEnabled = false;

        var items = menu.getElementsByTagName("menuitem");
        var location = context.browser.currentURI;

        var value = this.getPermission(location);
        var defaultValue = (value.indexOf("default") == 0) ? value : this.getDefaultPref();

        items[0].value = defaultValue;

        for (var i=0; i<items.length; i++)
        {
            var option = items[i].value;
            if (option == value)
                items[i].setAttribute("checked", "true");
            items[i].label = this.getLabel(option, location);
        }

        return true;
    },

    onPopupHiding: function(menu, context)
    {
        var permTooltip = Firebug.chrome.$("fcPermTooltip");
        permTooltip.fcEnabled = true;
        return true;
    },

    getContextMenuItems: function(cookie, target, context)
    {
        if (context.browser.currentURI.host == cookie.cookie.host)
            return null;

        var location = cookie.getURI();
        var value = this.getPermission(location);
        var defaultValue = (value.indexOf("default") == 0) ? value : this.getDefaultPref();

        var items = [];
        items.push("-");

        var menu = Firebug.chrome.$("fcPermMenuPopup");
        menu.childNodes[0].value = defaultValue;
        for (var i=0; i<menu.childNodes.length; i++)
        {
            var item = menu.childNodes[i];
            var option = item.value;

            items.push({
                label: this.getLabel(option, location),
                type: "radio",
                checked: (option == value),
                nol10n: true,
                command: Obj.bindFixed(this.onCommand, this, {target: item}, context, location),
            });
        }

        return items;
    },

    getPermission: function(location)
    {
        switch (permissionManager.testPermission(location, "cookie"))
        {
            case Ci.nsIPermissionManager.ALLOW_ACTION:
                return "host-allow";
            case Ci.nsIPermissionManager.DENY_ACTION:
                return "host-deny";
            case Ci.nsICookiePermission.ACCESS_SESSION:
                return "host-allow-session";
            case Ci.nsICookiePermission.ACCESS_LIMIT_THIRD_PARTY:
                return "host-limit-third-party";

            default:
                return this.getDefaultPref();
        }
    },

    setPermission: function(context, option, location)
    {
        var location = location ? location : context.browser.currentURI;
        permissionManager.remove(location.host, "cookie");
        switch(option)
        {
            case "host-allow-session":
                permissionManager.add(location, "cookie", Ci.nsICookiePermission.ACCESS_SESSION);
                break;
            case "host-limit-third-party":
                permissionManager.add(location, "cookie", Ci.nsICookiePermission.ACCESS_LIMIT_THIRD_PARTY);
                break;
            case "host-allow":
                permissionManager.add(location, "cookie", permissionManager.ALLOW_ACTION);
                break;
            case "host-deny":
                permissionManager.add(location, "cookie", permissionManager.DENY_ACTION);

            case "default-deny":
                if (Options.get("cookies.clearWhenDeny"))
                    Firebug.CookieModule.onRemoveAllFromHost(context, location.host);
                break;
        }

        this.updatePermButton(context);
    },

    updatePermButton: function(context, chrome)
    {
        if (!chrome)
            chrome = context.chrome;

        // This is called through TabWatcher.iterateContexts and
        // "this" isn't passed along
        var location = context.browser.currentURI;
        var value = this.getPermission(location);

        var button = Firebug.chrome.$("fcPerm");
        button.label = this.getLabel(value, location);
        button.removeAttribute("disabled");
        button.setAttribute("value", value);
    },

    getLabel: function (option, location)
    {
        var optionInfo = permOptions[option];
        if (!optionInfo)
            return null;

        if (optionInfo[1])
            return Locale.$STRF(optionInfo[0], [location.host]);

        return Locale.$STR(optionInfo[0]);
    },

    getDefaultPref: function()
    {
        var behavior = Options.getPref(networkPrefDomain, cookieBehaviorPref);
        if (typeof(behavior) == "undefined")
            behavior = 0;

        if (behavior == 2)
            return "default-deny";

        switch (Options.getPref(networkPrefDomain, cookieLifeTimePref))
        {
            case 1:
                return "default-warn";
            case 2:
                return (behavior == 0) ? "default-third-party-session" : "default-session";
        }

        switch (behavior)
        {
            case 0:
                return "default-third-party";
            case 1:
                return "default-allow";
            case 3:
                return "default-limit-third-party";
        }

        return null;
    }
});

// ********************************************************************************************* //
// Registration

return CookiePermissions;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/cookies/cookieReps",
[
    "firebug/chrome/rep",
    "firebug/lib/xpcom",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/domplate",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/lib/persist",
    "firebug/lib/string",
    "firebug/lib/http",
    "firebug/lib/css",
    "firebug/lib/events",
    "firebug/lib/array",
    "firebug/lib/system",
    "firebug/cookies/baseObserver",
    "firebug/cookies/menuUtils",
    "firebug/cookies/cookieUtils",
    "firebug/cookies/cookie",
    "firebug/cookies/breakpoints",
    "firebug/cookies/cookieEvents",
    "firebug/cookies/cookiePermissions",
    "firebug/cookies/editCookie",
    "firebug/cookies/cookieClipboard",
],
function(Rep, Xpcom, Obj, Locale, Domplate, Dom, Options, Persist, Str, Http, Css, Events, Arr,
    System, BaseObserver, MenuUtils, CookieUtils, Cookie, Breakpoints, CookieEvents,
    CookiePermissions, EditCookie, CookieClipboard) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, TAG, DIV, SPAN, TD, TR, TABLE, TBODY, P, LI, A} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;

const lastSortedColumn = "cookies.lastSortedColumn";
const hiddenColsPref = "cookies.hiddenColumns";

const panelName = "cookies";

// ********************************************************************************************* //
// Templates Helpers

// Object with all rep CookieReps.
var CookieReps = {};

/**
 * @domplate Basic template for Cookies panel UI.
 */
CookieReps.Rep = domplate(Rep,
{
    getContextMenuItems: function(cookie, target, context)
    {
        // xxxHonza not sure how to do this better if the default Firebug's "Copy"
        // command (cmd_copy) shouldn't be there.
        var popup = Firebug.chrome.$("fbContextMenu");
        if (popup.firstChild && popup.firstChild.getAttribute("command") == "cmd_copy")
            popup.removeChild(popup.firstChild);
    }
});

// ********************************************************************************************* //
// Cookie Template (domplate)

/**
 * @domplate Represents a domplate template for cookie entry in the cookie list.
 */
CookieReps.CookieRow = domplate(CookieReps.Rep,
/** @lends CookieReps.CookieRow */
{
    inspectable: true,

    cookieTag:
        FOR("cookie", "$cookies",
            TR({"class": "cookieRow", _repObject: "$cookie", onclick: "$onClickRow",
                $sessionCookie: "$cookie|isSessionCookie",
                $rejectedCookie: "$cookie|isRejected",
                $deletedCookie: "$cookie|isDeletedCookie"},
                TD({"class": "cookieDebugCol cookieCol"},
                   DIV({"class": "sourceLine cookieRowHeader", onclick: "$onClickRowHeader"},
                        "&nbsp;"
                   )
                ),
                TD({"class": "cookieNameCol cookieCol"},
                    DIV({"class": "cookieNameLabel cookieLabel"}, "$cookie|getName")
                ),
                TD({"class": "cookieValueCol cookieCol"},
                    DIV({"class": "cookieValueLabel cookieLabel"},
                        SPAN("$cookie.cookie.value|getValue")
                    )
                ),
                TD({"class": "cookieRawValueCol cookieCol"},
                    DIV({"class": "cookieRawValueLabel cookieLabel"},
                        SPAN("$cookie.cookie.rawValue|getValue")
                    )
                ),
                TD({"class": "cookieDomainCol cookieCol"},
                    SPAN({"class": "cookieDomainLabel cookieLabel", onclick: "$onClickDomain"},
                        "$cookie|getDomain")
                ),
                TD({"class": "cookieRawSizeCol cookieCol"},
                    DIV({"class": "cookieRawSizeLabel cookieLabel"}, "$cookie|getRawSize")
                ),
                TD({"class": "cookieSizeCol cookieCol"},
                    DIV({"class": "cookieSizeLabel cookieLabel"}, "$cookie|getSize")
                ),
                TD({"class": "cookiePathCol cookieCol"},
                    DIV({"class": "cookiePathLabel cookieLabel", "title": "$cookie|getPath"},
                        SPAN("$cookie|getPath")
                    )
                ),
                TD({"class": "cookieExpiresCol cookieCol"},
                    DIV({"class": "cookieExpiresLabel cookieLabel", "title": "$cookie|getDurationTooltip"}, "$cookie|getExpires")
                ),
                TD({"class": "cookieMaxAgeCol cookieCol"},
                    DIV({"class": "cookieMaxAgeLabel cookieLabel", "title": "$cookie|getDurationTooltip"}, "$cookie|getMaxAge")
                ),
                TD({"class": "cookieHttpOnlyCol cookieCol"},
                    DIV({"class": "cookieHttpOnlyLabel cookieLabel"}, "$cookie|isHttpOnly")
                ),
                TD({"class": "cookieSecurityCol cookieCol"},
                    DIV({"class": "cookieSecurityLabel cookieLabel"}, "$cookie|isSecure")
                )
            )
        ),

    bodyRow:
        TR({"class": "cookieInfoRow"},
            TD({"class": "sourceLine cookieRowHeader"}),
            TD({"class": "cookieInfoCol", colspan: 12})
        ),

    bodyTag:
        DIV({"class": "cookieInfoBody", _repObject: "$cookie"},
            DIV({"class": "cookieInfoTabs"},
                A({"class": "cookieInfoValueTab cookieInfoTab", onclick: "$onClickTab",
                    view: "Value"},
                    Locale.$STR("cookies.info.valuetab.label")
                ),
                A({"class": "cookieInfoRawValueTab cookieInfoTab", onclick: "$onClickTab",
                    view: "RawValue",
                    $collapsed: "$cookie|hideRawValueTab"},
                    Locale.$STR("cookies.info.rawdatatab.Raw Data")
                ),
                A({"class": "cookieInfoJsonTab cookieInfoTab", onclick: "$onClickTab",
                    view: "Json",
                    $collapsed: "$cookie|hideJsonTab"},
                    Locale.$STR("cookies.info.jsontab.JSON")
                ),
                A({"class": "cookieInfoXmlTab cookieInfoTab", onclick: "$onClickTab",
                    view: "Xml",
                    $collapsed: "$cookie|hideXmlTab"},
                    Locale.$STR("cookies.info.xmltab.XML")
                )
            ),
            DIV({"class": "cookieInfoValueText cookieInfoText"}),
            DIV({"class": "cookieInfoRawValueText cookieInfoText"}),
            DIV({"class": "cookieInfoJsonText cookieInfoText"}),
            DIV({"class": "cookieInfoXmlText cookieInfoText"})
        ),

    hideRawValueTab: function(cookie)
    {
        return (cookie.cookie.value == cookie.cookie.rawValue);
    },

    hideJsonTab: function(cookie)
    {
        return cookie.getJsonValue() ? false : true;
    },

    hideXmlTab: function(cookie)
    {
        return cookie.getXmlValue() ? false : true;
    },

    getAction: function(cookie)
    {
        return cookie.action;
    },

    getName: function(cookie)
    {
        return cookie.cookie.name;
    },

    getValue: function(value)
    {
        return Str.escapeNewLines(Str.cropString(value));
    },

    getDomain: function(cookie)
    {
        if (!cookie.cookie.host)
            return "";

        return cookie.cookie.host;
    },

    getMaxAge: function(cookie)
    {
        if (!cookie.cookie.maxAge)
            return "";

        return Str.formatTime(cookie.cookie.maxAge * 1000);
    },

    getExpires: function(cookie)
    {
        if (cookie.cookie.expires == undefined)
            return "";

        // The first character is space so, if the table is sorted according
        // to this column, all "Session" cookies are displayed at the begining.
        if (CookieUtils.isSessionCookie(cookie.cookie))
            return " " + Locale.$STR("cookies.Session");

        try
        {
            // Format the expires date using the current locale.
            var date = new Date(cookie.cookie.expires * 1000);
            return date.toLocaleString();
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.CookieRow.getExpires; EXCEPTION " + err, err);
        }

        return "";
    },

    getDurationTooltip: function(cookie)
    {
        if (CookieUtils.isDeletedCookie(cookie.cookie))
            return Locale.$STR("cookies.netinfo.deleted.tooltip");
    },

    isHttpOnly: function(cookie)
    {
        return cookie.cookie.isHttpOnly ? "HttpOnly" : "";
    },

    isSessionCookie: function(cookie)
    {
        return CookieUtils.isSessionCookie(cookie.cookie);
    },

    isDeletedCookie: function(cookie)
    {
        return CookieUtils.isDeletedCookie(cookie.cookie);
    },

    isRejected: function(cookie)
    {
        return !!cookie.cookie.rejected;
    },

    getRawSize: function(cookie)
    {
        var size = cookie.cookie.name.length + cookie.cookie.rawValue.length;
        return Str.formatSize(size);
    },

    getSize: function(cookie)
    {
        var size = cookie.cookie.name.length + cookie.cookie.value.length;
        return Str.formatSize(size);
    },

    getPath: function(cookie)
    {
        var path = cookie.cookie.path;
        return path ? path : "";
    },

    isDomainCookie: function(cookie)
    {
        return cookie.cookie.isDomain ? Locale.$STR("cookies.domain.label") : "";
    },

    isSecure: function(cookie)
    {
        return cookie.cookie.isSecure ? Locale.$STR("cookies.secure.label") : "";
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Highlighter

    highlightObject: function(object, context)
    {
    },

    unhighlightObject: function(object, context)
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug rep support

    supportsObject: function(cookie)
    {
        return cookie instanceof Cookie;
    },

    browseObject: function(cookie, context)
    {
        return false;
    },

    getRealObject: function(cookie, context)
    {
        var realObject = cookie.cookie.rawCookie;
        if (!realObject)
        {
            if (FBTrace.DBG_COOKIES || FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.getRealObject; ERROR no real cookie object!");

            realObject = cookie.cookie;
        }

        return CookieUtils.getRealObject(realObject, context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Context Menu

    getContextMenuItems: function(cookie, target, context)
    {
        CookieReps.Rep.getContextMenuItems.apply(this, arguments);

        var items = [];
        var rejected = cookie.cookie.rejected;

        if (!rejected)
        {
            items.push({
              label: Locale.$STR("cookies.Cut"),
              nol10n: true,
              command: Obj.bindFixed(this.onCut, this, cookie)
            });
        }

        items.push({
          label: Locale.$STR("cookies.Copy"),
          nol10n: true,
          command: Obj.bindFixed(this.onCopy, this, cookie)
        });

        if (!rejected)
        {
            items.push({
              label: Locale.$STR("cookies.Paste"),
              nol10n: true,
              disabled: CookieClipboard.isCookieAvailable() ? false : true,
              command: Obj.bindFixed(this.onPaste, this, cookie)
            });
            items.push("-");
        }

        items.push({
          label: Locale.$STR("cookies.CopyAll"),
          nol10n: true,
          command: Obj.bindFixed(this.onCopyAll, this, cookie)
        });

        if (!rejected)
        {
            items.push("-");
            items.push({
              label: Locale.$STR("cookies.Delete"),
              nol10n: true,
              command: Obj.bindFixed(this.onRemove, this, cookie)
            });

            items.push("-");
            items.push({
              label: Locale.$STR("cookies.Edit"),
              nol10n: true,
              command: Obj.bindFixed(this.onEdit, this, cookie)
            });

            if (cookie.cookie.rawValue)
            {
                items.push({
                  label: Locale.$STR("cookies.Clear Value"),
                  nol10n: true,
                  command: Obj.bindFixed(this.onClearValue, this, cookie)
                });
            }
        }

        // Permissions
        var permItems = CookiePermissions.getContextMenuItems(cookie, target, context);
        if (permItems)
            items = items.concat(permItems);

        // Breakpoints
        var breakOnItems = Breakpoints.getContextMenuItems(cookie, target, context);
        if (breakOnItems)
            items = items.concat(breakOnItems);

        return items;
    },

    // Context menu commands
    onCut: function(clickedCookie)
    {
        this.onCopy(clickedCookie);
        this.onRemove(clickedCookie);
    },

    onCopy: function(clickedCookie)
    {
        CookieClipboard.copyTo(clickedCookie);
    },

    onCopyAll: function(clickedCookie)
    {
        var text = "";
        var tbody = Dom.getAncestorByClass(clickedCookie.row, "cookieTable").firstChild;
        for (var row = tbody.firstChild; row; row = row.nextSibling) {
            if (Css.hasClass(row, "cookieRow") && row.repObject)
                text += row.repObject.toString() + "\n";
        }

        System.copyToClipboard(text);
    },

    onPaste: function(clickedCookie) // clickedCookie can be null if the user clicks within panel area.
    {
        var context = Firebug.currentContext;
        var values = CookieClipboard.getFrom();
        if (!values || !context)
            return;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.Get cookie values from clipboard", values);

        // Change name so it's unique and use the current host.
        values.name = Firebug.CookieModule.getDefaultCookieName(context, values.name);
        values.host = context.browser.currentURI.host;

        values.rawValue = values.value;
        values.value = unescape(values.value);

        // If the expire time isn't set use the default value.
        if (values.expires == undefined)
            values.expires = Firebug.CookieModule.getDefaultCookieExpireTime();

        // Create/modify cookie.
        var cookie = new Cookie(values);
        Firebug.CookieModule.createCookie(cookie);

        if (FBTrace.DBG_COOKIES)
            checkList(context.getPanel(panelName, true));
    },

    onRemove: function(cookie)
    {
        // Get the real XPCOM cookie object and remove it.
        var realCookie = cookie.cookie;
        if (!cookie.cookie.rejected)
            Firebug.CookieModule.removeCookie(realCookie.host, realCookie.name, realCookie.path);
    },

    onEdit: function(cookie)
    {
        var params = {
            cookie: cookie.cookie,
            action: "edit",
            window: null,
            EditCookie: EditCookie,
            Firebug: Firebug,
            FBTrace: FBTrace,
        };

        var parent = Firebug.currentContext.chrome.window;
        return parent.openDialog("chrome://firebug/content/cookies/editCookie.xul",
            "_blank", "chrome,centerscreen,resizable=yes,modal=yes",
            params);
    },

    onClearValue: function(cookie)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onClearValue;", cookie);

        var newCookie = new Cookie(cookie.cookie);
        newCookie.cookie.rawValue = "";
        Firebug.CookieModule.createCookie(newCookie);
    },

    // Event handlers
    onClickDomain: function(event)
    {
        if (Events.isLeftClick(event))
        {
            var domain = event.target.textContent;
            if (domain)
            {
                Events.cancelEvent(event);
                event.cancelBubble = true;
                //xxxHonza www.google.com (more windows are opened)
                // openNewTab(domain);
            }
        }
    },

    onClickRowHeader: function(event)
    {
        Events.cancelEvent(event);

        var rowHeader = event.target;
        if (!Css.hasClass(rowHeader, "cookieRowHeader"))
            return;

        var row = Dom.getAncestorByClass(event.target, "cookieRow");
        if (!row)
            return;

        var context = Firebug.getElementPanel(row).context;
        Breakpoints.onBreakOnCookie(context, row.repObject);
    },

    onClickRow: function(event)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.Click on cookie row.", event);

        if (Events.isLeftClick(event))
        {
            var row = Dom.getAncestorByClass(event.target, "cookieRow");
            if (row)
            {
                this.toggleRow(row);
                Events.cancelEvent(event);
            }
        }
    },

    toggleRow: function(row, forceOpen)
    {
        var opened = Css.hasClass(row, "opened");
        if (opened && forceOpen)
            return;

        Css.toggleClass(row, "opened");

        if (Css.hasClass(row, "opened"))
        {
            var bodyRow = this.bodyRow.insertRows({}, row)[0];
            var bodyCol = Dom.getElementByClass(bodyRow, "cookieInfoCol");
            var cookieInfo = this.bodyTag.replace({cookie: row.repObject}, bodyCol);

            // If JSON or XML tabs are available select them by default.
            if (this.selectTabByName(cookieInfo, "Json"))
                return;

            if (this.selectTabByName(cookieInfo, "Xml"))
                return;

            this.selectTabByName(cookieInfo, "Value");
        }
        else
        {
            row.parentNode.removeChild(row.nextSibling);
        }
    },

    selectTabByName: function(cookieInfoBody, tabName)
    {
        var tab = Dom.getChildByClass(cookieInfoBody, "cookieInfoTabs",
            "cookieInfo" + tabName + "Tab");

        // Don't select collapsed tabs.
        if (tab && !Css.hasClass(tab, "collapsed"))
            return this.selectTab(tab);

        return false;
    },

    onClickTab: function(event)
    {
        this.selectTab(event.currentTarget);
    },

    selectTab: function(tab)
    {
        var cookieInfoBody = tab.parentNode.parentNode;

        var view = tab.getAttribute("view");
        if (cookieInfoBody.selectedTab)
        {
            cookieInfoBody.selectedTab.removeAttribute("selected");
            cookieInfoBody.selectedText.removeAttribute("selected");
        }

        var textBodyName = "cookieInfo" + view + "Text";

        cookieInfoBody.selectedTab = tab;
        cookieInfoBody.selectedText = Dom.getChildByClass(cookieInfoBody, textBodyName);

        cookieInfoBody.selectedTab.setAttribute("selected", "true");
        cookieInfoBody.selectedText.setAttribute("selected", "true");

        var cookie = Firebug.getRepObject(cookieInfoBody);
        var context = Firebug.getElementPanel(cookieInfoBody).context;
        this.updateInfo(cookieInfoBody, cookie, context);

        return true;
    },

    updateRow: function(cookie, context)
    {
        var panel = context.getPanel(panelName, true);
        if (!panel)
            return;

        var parent = cookie.row.parentNode;
        var nextSibling = cookie.row.nextSibling;
        parent.removeChild(cookie.row);

        var row = CookieReps.CookieRow.cookieTag.insertRows({cookies: [cookie]},
            panel.table.lastChild.lastChild)[0];

        var opened = Css.hasClass(cookie.row, "opened");

        cookie.row = row;
        row.repObject = cookie;

        if (nextSibling && row.nextSibling != nextSibling)
        {
            parent.removeChild(cookie.row);
            parent.insertBefore(row, nextSibling);
        }

        if (opened)
            Css.setClass(row, "opened");

        Breakpoints.updateBreakpoint(context, cookie);
    },

    updateInfo: function(cookieInfoBody, cookie, context)
    {
        var tab = cookieInfoBody.selectedTab;
        if (Css.hasClass(tab, "cookieInfoValueTab"))
        {
            var valueBox = Dom.getChildByClass(cookieInfoBody, "cookieInfoValueText");
            if (!cookieInfoBody.valuePresented)
            {
                cookieInfoBody.valuePresented = true;

                var text = cookie.cookie.value;
                if (text != undefined)
                    Str.insertWrappedText(text, valueBox);
            }
        }
        else if (Css.hasClass(tab, "cookieInfoRawValueTab"))
        {
            var valueBox = Dom.getChildByClass(cookieInfoBody, "cookieInfoRawValueText");
            if (!cookieInfoBody.rawValuePresented)
            {
                cookieInfoBody.rawValuePresented = true;

                var text = cookie.cookie.rawValue;
                if (text != undefined)
                    Str.insertWrappedText(text, valueBox);
            }
        }
        else if (Css.hasClass(tab, "cookieInfoJsonTab"))
        {
            var valueBox = Dom.getChildByClass(cookieInfoBody, "cookieInfoJsonText");
            if (!cookieInfoBody.jsonPresented)
            {
                cookieInfoBody.jsonPresented = true;

                var jsonObject = cookie.getJsonValue();
                if (jsonObject) {
                    Firebug.DOMPanel.DirTable.tag.replace(
                        {object: jsonObject, toggles: this.toggles}, valueBox);
                }
            }
        }
        else if (Css.hasClass(tab, "cookieInfoXmlTab"))
        {
            var valueBox = Dom.getChildByClass(cookieInfoBody, "cookieInfoXmlText");
            if (!cookieInfoBody.xmlPresented)
            {
                cookieInfoBody.xmlPresented = true;

                var docElem = cookie.getXmlValue();
                if (docElem) {
                    var tag = Firebug.HTMLPanel.CompleteElement.getNodeTag(docElem);
                    tag.replace({object: docElem}, valueBox);
                }
            }
        }
    },

    updateTabs: function(cookieInfoBody, cookie, context)
    {
        // Iterate over all info-tabs and update visibility.
        var cookieInfoTabs = Dom.getElementByClass(cookieInfoBody, "cookieInfoTabs");
        var tab = cookieInfoTabs.firstChild;
        while (tab)
        {
            var view = tab.getAttribute("view");
            var hideTabCallback = CookieReps.CookieRow["hide" + view + "Tab"];
            if (hideTabCallback)
            {
                if (hideTabCallback(cookie))
                    Css.setClass(tab, "collapsed");
                else
                    Css.removeClass(tab, "collapsed");
            }

            tab = tab.nextSibling;
        }

        // If the selected tab was collapsed, make sure another one is selected.
        if (Css.hasClass(cookieInfoBody.selectedTab, "collapsed"))
        {
            if (this.selectTabByName(cookieInfoBody, "Json"))
                return;

            if (this.selectTabByName(cookieInfoBody, "Xml"))
                return;

            this.selectTabByName(cookieInfoBody, "Value");
        }
    }
});

// ********************************************************************************************* //
// Console Event Templates (domplate)

/**
 * @domplate This template is used for displaying cookie-changed events
 * (except of "clear") in the Console tab.
 */
CookieReps.CookieChanged = domplate(CookieReps.Rep,
{
    inspectable: false,

    // Console
    tag:
        DIV({"class": "cookieEvent", _repObject: "$object"},
        	SPAN(Locale.$STR("cookies.console.cookie"), " "),
            SPAN({"class": "cookieNameLabel", onclick: "$onClick"},
                "$object|getName",
                " "),
            SPAN({"class": "cookieActionLabel"},
                "$object|getAction",
                ".&nbsp;&nbsp;"),
            SPAN({"class": "cookieValueLabel"},
                "$object|getValue"),
            DIV({"class": "cookieDomainLabel", onclick: "$onClickDomain",
                title: "$object|getOriginalURI"}, "$object|getDomain")
        ),

    // Event handlers
    onClick: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        var target = event.target;

        // Get associated nsICookie object.
        var cookieEvent = Firebug.getRepObject(target);
        if (!cookieEvent)
            return;

        var cookieWrapper = new Cookie(CookieUtils.makeCookieObject(cookieEvent.cookie));
        var context = Firebug.getElementPanel(target).context;
        context.chrome.select(cookieWrapper, panelName);
    },

    onClickDomain: function(event)
    {
    },

    getOriginalURI: function(cookieEvent)
    {
        var context = cookieEvent.context;
        var strippedHost = cookieEvent.rawHost;

        if (!context.cookies.activeCookies)
            return strippedHost;

        var cookie = cookieEvent.cookie;
        var activeCookies = context.cookies.activeCookies[cookie.host];
        if (!activeCookies)
            return strippedHost;

        var activeCookie = activeCookies[CookieUtils.getCookieId(cookie)];

        var originalURI;
        if (activeCookie)
            originalURI = activeCookie.originalURI.spec;
        else
            originalURI = cookieEvent.rawHost;

        if (FBTrace.DBG_COOKIES)
        {
            FBTrace.sysout("cookies.context.cookies.activeCookies[" + cookie.host + "]",
                activeCookies);

            FBTrace.sysout("cookies.Original URI for: " + CookieUtils.getCookieId(cookie) +
                " is: " + originalURI, activeCookie);
        }

        return originalURI;
    },

    getAction: function(cookieEvent)
    {
        // Return properly localized action.
        switch(cookieEvent.action)
        {
          case "deleted":
              return Locale.$STR("cookies.console.deleted");
          case "added":
              return Locale.$STR("cookies.console.added");
          case "changed":
              return Locale.$STR("cookies.console.changed");
          case "cleared":
              return Locale.$STR("cookies.console.cleared");
        }

        return "";
    },

    getName: function(cookieEvent)
    {
        return cookieEvent.cookie.name;
    },

    getValue: function(cookieEvent)
    {
        return Str.cropString(cookieEvent.cookie.value, 75);
    },

    getDomain: function(cookieEvent)
    {
        return cookieEvent.cookie.host;
    },

    // Firebug rep support
    supportsObject: function(cookieEvent)
    {
        return cookieEvent instanceof CookieEvents.CookieChangedEvent;
    },

    browseObject: function(cookieEvent, context)
    {
        return false;
    },

    getRealObject: function(cookieEvent, context)
    {
        return cookieEvent;
    },

    // Context menu
    getContextMenuItems: function(cookieEvent, target, context)
    {
        CookieReps.Rep.getContextMenuItems.apply(this, arguments);
    }
});

// ********************************************************************************************* //

/**
 * @domplate Represents a domplate template for displaying rejected cookies.
 */
CookieReps.CookieRejected = domplate(CookieReps.Rep,
/** @lends CookieReps.CookieRejected */
{
    inspectable: false,

    tag:
        DIV({"class": "cookieEvent", _repObject: "$object"},
            TABLE({cellpadding: 0, cellspacing: 0},
                TBODY(
                    TR(
                        TD({width: "100%"},
                            SPAN({"class": "cookieRejectedLabel"},
                                Locale.$STR("cookies.console.cookiesrejected")),
                            " ",
                            SPAN({"class": "cookieRejectedList"},
                                "$object|getCookieList")
                        ),
                        TD(
                            SPAN({"class": "cookieDomainLabel", onclick: "$onClickDomain"},
                                "$object|getDomain"),
                            SPAN("&nbsp;")
                        )
                    )
                )
            )
        ),

    supportsObject: function(object)
    {
        return object instanceof CookieEvents.CookieRejectedEvent;
    },

    getDomain: function(cookieEvent)
    {
        return cookieEvent.uri.host;
    },

    getCookieList: function(cookieEvent)
    {
        var context = cookieEvent.context;
        var activeHost = context.cookies.activeHosts[cookieEvent.uri.host];
        var cookies = activeHost.receivedCookies;
        if (!cookies)
            return Locale.$STR("cookies.console.nocookiesreceived");

        var label = "";
        for (var i=0; i<cookies.length; i++)
            label += cookies[i].cookie.name + ((i<cookies.length-1) ? ", " : "");

        return Str.cropString(label, 75);
    },

    onClickDomain: function(event)
    {
    },

    // Context menu
    getContextMenuItems: function(cookie, target, context)
    {
        CookieReps.Rep.getContextMenuItems.apply(this, arguments);
    }
});

// ********************************************************************************************* //

/**
 * @domplate Represents a domplate template for cookie cleared event that is
 * visualised in Firebug Console panel.
 */
CookieReps.CookieCleared = domplate(CookieReps.Rep,
/** @lends CookieReps.CookieCleared */
{
    inspectable: false,

    tag:
        DIV({_repObject: "$object"},
            DIV("$object|getLabel")
        ),

    supportsObject: function(object)
    {
        return object instanceof CookieEvents.CookieClearedEvent;
    },

    getLabel: function()
    {
        return Locale.$STR("cookies.console.cookiescleared");
    },

    // Context menu
    getContextMenuItems: function(cookie, target, context)
    {
        CookieReps.Rep.getContextMenuItems.apply(this, arguments);
    }
});


CookieReps.SizeInfoTip = domplate(Rep,
{
    tag:
        TABLE({"class": "sizeInfoTip", "id": "cookiesSizeInfoTip", role:"presentation"},
            TBODY(
                FOR("size", "$sizeInfo",
                    TAG("$size|sizeTag", {size: "$size"})
                )
            )
        ),

    sizeTag:
        TR({"class": "sizeInfoRow"},
            TD({"class": "sizeInfoLabelCol"}, "$size.label"),
            TD({"class": "sizeInfoSizeCol"}, "$size|formatSize"),
            TD({"class": "sizeInfoDetailCol"}, "$size|formatNumber")
        ),

    formatSize: function(size)
    {
        return Str.formatSize(size.size);
    },

    formatNumber: function(size)
    {
        return size.size && size.size >= 1024 ? "(" + size.size.toLocaleString() + " B)" : "";
    },

    render: function(cookie, parentNode)
    {
        var size = cookie.getSize();
        var rawSize = cookie.getRawSize();
        var sizeInfo = [];

        sizeInfo.push({label: Locale.$STR("cookie.sizeinfo.Size"), size: size});

        if (size != rawSize)
            sizeInfo.push({label: Locale.$STR("cookie.sizeinfo.Raw_Size"), size: rawSize});

        this.tag.replace({sizeInfo: sizeInfo}, parentNode);
    },
});

// ********************************************************************************************* //
// Header Template (domplate)

/**
 * @domplate Represents a template for basic cookie list layout. This
 * template also includes a header and related functionality (such as sorting).
 */
CookieReps.CookieTable = domplate(CookieReps.Rep,
/** @lends CookieReps.CookieTable */
{
    inspectable: false,

    tableTag:
        TABLE({"class": "cookieTable", cellpadding: 0, cellspacing: 0, hiddenCols: ""},
            TBODY(
                TR({"class": "cookieHeaderRow", onclick: "$onClickHeader"},
                    TD({id: "cookieBreakpointBar", width: "1%", "class": "cookieHeaderCell"},
                        "&nbsp;"
                    ),
                    TD({id: "colName", role: "columnheader",
                        "class": "cookieHeaderCell alphaValue a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.name.tooltip")},
                        Locale.$STR("cookies.header.name"))
                    ),
                    TD({id: "colValue", role: "columnheader",
                        "class": "cookieHeaderCell alphaValue a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.value.tooltip")},
                        Locale.$STR("cookies.header.value"))
                    ),
                    TD({id: "colRawValue", role: "columnheader",
                        "class": "cookieHeaderCell alphaValue a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.rawValue.tooltip")},
                            Locale.$STR("cookies.header.rawValue"))
                    ),
                    TD({id: "colDomain", role: "columnheader",
                        "class": "cookieHeaderCell alphaValue a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.domain.tooltip")},
                        Locale.$STR("cookies.header.domain"))
                    ),
                    TD({id: "colRawSize", role: "columnheader",
                        "class": "cookieHeaderCell a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.rawSize.tooltip")},
                        Locale.$STR("cookies.header.rawSize"))
                    ),
                    TD({id: "colSize", role: "columnheader",
                        "class": "cookieHeaderCell a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.size.tooltip")},
                        Locale.$STR("cookies.header.size"))
                    ),
                    TD({id: "colPath", role: "columnheader",
                        "class": "cookieHeaderCell alphaValue a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.path.tooltip")},
                        Locale.$STR("cookies.header.path"))
                    ),
                    TD({id: "colExpires", role: "columnheader",
                        "class": "cookieHeaderCell a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.expires.tooltip")},
                        Locale.$STR("cookies.header.expires"))
                    ),
                    TD({id: "colMaxAge", role: "columnheader",
                        "class": "cookieHeaderCell a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.maxAge.tooltip")},
                        Locale.$STR("cookies.header.maxAge"))
                    ),
                    TD({id: "colHttpOnly", role: "columnheader",
                        "class": "cookieHeaderCell alphaValue a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.httponly.tooltip")},
                        Locale.$STR("cookies.header.httponly"))
                    ),
                    TD({id: "colSecurity", role: "columnheader",
                        "class": "cookieHeaderCell alphaValue a11yFocus"},
                        DIV({"class": "cookieHeaderCellBox",
                            title: Locale.$STR("cookies.header.security.tooltip")},
                        Locale.$STR("cookies.header.security"))
                    )
                )
            )
        ),

    onClickHeader: function(event)
    {
        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onClickHeader");

        if (!Events.isLeftClick(event))
            return;

        var table = Dom.getAncestorByClass(event.target, "cookieTable");
        var column = Dom.getAncestorByClass(event.target, "cookieHeaderCell");
        this.sortColumn(table, column);
    },

    sortColumn: function(table, col, direction)
    {
        if (!col)
            return;

        if (typeof(col) == "string")
        {
            var doc = table.ownerDocument;
            col = doc.getElementById(col);
        }

        if (!col)
            return;

        var numerical = !Css.hasClass(col, "alphaValue");

        var colIndex = 0;
        for (col = col.previousSibling; col; col = col.previousSibling)
            ++colIndex;

        this.sort(table, colIndex, numerical, direction);
    },

    sort: function(table, colIndex, numerical, direction)
    {
        var tbody = table.lastChild;
        var headerRow = tbody.firstChild;

        // Remove class from the currently sorted column
        var headerSorted = Dom.getChildByClass(headerRow, "cookieHeaderSorted");
        Css.removeClass(headerSorted, "cookieHeaderSorted");

        // Mark new column as sorted.
        var header = headerRow.childNodes[colIndex];
        Css.setClass(header, "cookieHeaderSorted");

        // If the column is already using required sort direction, bubble out.
        if ((direction == "desc" && header.sorted == 1) ||
            (direction == "asc" && header.sorted == -1))
            return;

        var values = [];
        for (var row = tbody.childNodes[1]; row; row = row.nextSibling)
        {
            var cell = row.childNodes[colIndex];
            var value = numerical ? parseFloat(cell.textContent) : cell.textContent;

            // Issue 43, expires date is formatted in the UI, so use the original cookie
            // value instead.
            if (Css.hasClass(cell, "cookieExpiresCol"))
                value = row.repObject.cookie.expires;

            if (Css.hasClass(row, "opened"))
            {
                var cookieInfoRow = row.nextSibling;
                values.push({row: row, value: value, info: cookieInfoRow});
                row = cookieInfoRow;
            }
            else
            {
                values.push({row: row, value: value});
            }
        }

        values.sort(function(a, b) { return a.value < b.value ? -1 : 1; });

        if ((header.sorted && header.sorted == 1) || (!header.sorted && direction == "asc"))
        {
            Css.removeClass(header, "sortedDescending");
            Css.setClass(header, "sortedAscending");

            header.sorted = -1;

            for (var i = 0; i < values.length; ++i)
            {
                tbody.appendChild(values[i].row);
                if (values[i].info)
                    tbody.appendChild(values[i].info);
            }
        }
        else
        {
            Css.removeClass(header, "sortedAscending");
            Css.setClass(header, "sortedDescending");

            header.sorted = 1;

            for (var i = values.length-1; i >= 0; --i)
            {
                tbody.appendChild(values[i].row);
                if (values[i].info)
                    tbody.appendChild(values[i].info);
            }
        }

        // Remember last sorted column & direction in preferences.
        var prefValue = header.getAttribute("id") + " " + (header.sorted > 0 ? "desc" : "asc");
        Options.set(lastSortedColumn, prefValue);
    },

    supportsObject: function(object)
    {
        return (object == this);
    },

    /**
     * Provides menu items for header context menu.
     */
    getContextMenuItems: function(object, target, context)
    {
        CookieReps.Rep.getContextMenuItems.apply(this, arguments);

        var items = [];

        // Iterate over all columns and create a menu item for each.
        var table = context.getPanel(panelName, true).table;
        var hiddenCols = table.getAttribute("hiddenCols");
        var removedCols = table.getAttribute("removedCols");

        var lastVisibleIndex;
        var visibleColCount = 0;

        var header = Dom.getAncestorByClass(target, "cookieHeaderRow");

        // Skip the first column for breakpoints.
        var columns = Arr.cloneArray(header.childNodes);
        columns.shift();

        for (var i=0; i<columns.length; i++)
        {
            var column = columns[i];

            if (removedCols.indexOf(column.id) != -1)
                continue;

            var visible = (hiddenCols.indexOf(column.id) == -1);

            items.push({
                label: column.textContent,
                type: "checkbox",
                checked: visible,
                nol10n: true,
                command: Obj.bindFixed(this.onShowColumn, this, context, column.id)
            });

            if (visible)
            {
                lastVisibleIndex = i;
                visibleColCount++;
            }
        }

        // If the last column is visible, disable its menu item.
        if (visibleColCount == 1)
            items[lastVisibleIndex].disabled = true;

        items.push("-");
        items.push({
            label: Locale.$STR("net.header.Reset Header"),
            nol10n: true,
            command: Obj.bindFixed(this.onResetColumns, this, context)
        });

        return items;
    },

    onShowColumn: function(context, colId)
    {
        var table = context.getPanel(panelName, true).table;
        var hiddenCols = table.getAttribute("hiddenCols");

        // If the column is already presented in the list of hidden columns,
        // remove it, otherwise append.
        var index = hiddenCols.indexOf(colId);
        if (index >= 0)
        {
            table.setAttribute("hiddenCols", hiddenCols.substr(0,index-1) +
                hiddenCols.substr(index+colId.length));
        }
        else
        {
            table.setAttribute("hiddenCols", hiddenCols + " " + colId);
        }

        // Store current state into the preferences.
        Options.set(hiddenColsPref, table.getAttribute("hiddenCols"));
    },

    onResetColumns: function(context)
    {
        var panel = context.getPanel(panelName, true);
        var header = Dom.getElementByClass(panel.panelNode, "cookieHeaderRow");

        // Reset widths
        var columns = header.childNodes;
        for (var i=0; i<columns.length; i++)
        {
            var col = columns[i];
            if (col.style)
                col.style.width = "";
        }

        // Reset visibility.
        Options.clear(hiddenColsPref);
        panel.table.setAttribute("hiddenCols", Options.get(hiddenColsPref));

        // Reset also sorting (no sorting by default)
        var headerRow = panel.table.getElementsByClassName("cookieHeaderRow")[0];
        var headerSorted = Dom.getChildByClass(headerRow, "cookieHeaderSorted");
        Css.removeClass(headerSorted, "cookieHeaderSorted");
        Options.set(lastSortedColumn, "");
        panel.refresh();
    },

    createTable: function(parentNode)
    {
        // Create cookie table UI.
        var table = this.tableTag.replace({}, parentNode, this);

        // Update columns width according to the preferences.
        var header = Dom.getElementByClass(table, "cookieHeaderRow");
        var columns = header.getElementsByTagName("td");
        for (var i=0; i<columns.length; i++)
        {
            var col = columns[i];
            var colId = col.getAttribute("id");
            if (!colId || !col.style)
                continue;

            var width = Options.get("cookies." + colId + ".width");
            if (width)
                col.style.width = width + "px";
        }

        return table;
    },

    render: function(cookies, parentNode)
    {
        // Create basic cookie-list structure.
        var table = this.createTable(parentNode);
        var header = Dom.getElementByClass(table, "cookieHeaderRow");

        var tag = CookieReps.CookieRow.cookieTag;
        return tag.insertRows({cookies: cookies}, header);
    }
});

// ********************************************************************************************* //

var OBJECTLINK = FirebugReps.OBJECTLINK;

// xxxHonza: TODO
CookieReps.CookieRep = domplate(CookieReps.Rep,
{
    tag:
        OBJECTLINK(
            SPAN({"class": "objectTitle"}, "$object|getTitle")
        ),

    className: "cookie",

    supportsObject: function(cookie)
    {
        return cookie instanceof Cookie;
    },

    getTitle: function(cookie)
    {
        return cookie.cookie.name;
    },

    getTooltip: function(cookie)
    {
        return cookie.cookie.value;
    }
});

// ********************************************************************************************* //
// Debug helpers

function checkList(panel)
{
    if (!FBTrace.DBG_COOKIES)
        return;

    if (!panel || !this.panelNode)
        return;

    var row = this.panelNode.getElementsByClassName("cookieRow")[0];
    while (row)
    {
        var rep = row.repObject;
        var displayedCookieName = row.getElementsByClassName("cookieNameLabel")[0].textContent;
        var displayedCookiePath = row.getElementsByClassName("cookiePathLabel")[0].textContent;
        if (rep.cookie.name != displayedCookieName || rep.cookie.path != displayedCookiePath)
        {
            FBTrace.sysout("---> Check failed!");
            FBTrace.sysout("--->" + rep.rawHost + ", " + rep.cookie.name + ", " + rep.cookie.path);
            FBTrace.sysout("    " + displayedCookieName + ", " + displayedCookiePath);
        }

        row = row.nextSibling;
    }

    return null;
}

// ********************************************************************************************* //
// Firebug Registration

Firebug.registerRep(
    //CookieReps.CookieRep,          // Cookie
    CookieReps.CookieTable,          // Cookie table with list of cookies
    CookieReps.CookieRow,            // Entry in the cookie table
    CookieReps.CookieChanged,        // Console: "cookie-changed" event
    CookieReps.CookieRejected,       // Console: "cookie-rejected" event
    CookieReps.CookieCleared         // Console: cookies "cleared" event
);

return CookieReps;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/cookies/cookieUtils",
[
    "firebug/cookies/cookie",
    "firebug/lib/wrapper",
    "firebug/lib/string"
],
function(Cookie, Wrapper, Str) {

// ********************************************************************************************* //
// Constants

var Cu = Components.utils;

// ********************************************************************************************* //
// CookieUtils Implementation

var CookieUtils = 
{
    isDeletedCookie: function(cookie)
    {
        if (cookie.maxAge)
            return cookie.maxAge <= 0;

        if (cookie.expires)
        {
            var expiresDate = new Date(cookie.expires * 1000);

            return expiresDate.getTime() <= Date.now();
        }

        return false;
    },

    isSessionCookie: function(cookie)
    {
        // maxAge is string value, "0" will not register as session.
        return (!cookie.expires && !cookie.maxAge)
    },

    getCookieId: function(cookie)
    {
        return cookie.host + cookie.path + cookie.name;
    },

    makeStrippedHost: function(aHost)
    {
        if (!aHost)
            return aHost;

        var formattedHost = aHost.charAt(0) == "." ? aHost.substring(1, aHost.length) : aHost;
        return formattedHost.substring(0, 4) == "www." ? formattedHost.substring(4, formattedHost.length) : formattedHost;
    },

    makeCookieObject: function(cookie)
    {
        // Remember the raw value.
        var rawValue = cookie.value;

        // Unescape '+' characters that are used to encode a space.
        // This isn't done by unescape method.
        var value = cookie.value;
        if (value)
            value = value.replace(/\+/g, " ");

        value = unescape(value);

        try
        {
            value = Str.convertToUnicode(value);
        }
        catch (exc) { }

        return {
            name        : cookie.name,
            value       : value,
            isDomain    : cookie.isDomain,
            host        : cookie.host,
            path        : cookie.path,
            isSecure    : cookie.isSecure,
            expires     : cookie.expires,
            maxAge      : cookie.maxAge,
            isHttpOnly  : cookie.isHttpOnly,
            rawValue    : rawValue,
            rawCookie   : cookie,
        };
    },

    parseFromString: function(string)
    {
        var cookie = new Object();
        var pairs = string.split("; ");

        for (var i=0; i<pairs.length; i++)
        {
            var option = pairs[i].split("=");
            if (i == 0)
            {
                cookie.name = option[0];
                cookie.value = option[1];
            } 
            else
            {
                var name = option[0].toLowerCase();
                name = (name == "domain") ? "host" : name;
                switch(name)
                {
                    case "httponly":
                        cookie.isHttpOnly = true;
                        break;

                    case "secure":
                        cookie.isSecure = true;
                        break;

                    case "max-age":
                        //Remove dash from variable name
                        cookie.maxAge = option[1];
                        break;

                    case "expires":
                        var value = option[1];
                        value = value.replace(/-/g, " ");
                        cookie[name] = Date.parse(value) / 1000;

                        // Log error if the date isn't correctly parsed.
                        if (FBTrace.DBG_COOKIES)
                        {
                            var tempDate = new Date(cookie[name] * 1000);
                            if (value != tempDate.toGMTString())
                            {
                                FBTrace.sysout("cookies.parseFromString: ERROR, " + 
                                    "from: " + value + 
                                    ", to: " + tempDate.toGMTString() + 
                                    ", cookie: " + string);
                            }
                        }
                        break;

                    default:
                        cookie[name] = option[1];
                }
            }
        }

        return cookie;
    },

    parseSentCookiesFromString: function(header)
    {
        var cookies = [];

        if (!header)
            return cookies;

        var pairs = header.split("; ");
        for (var i=0; i<pairs.length; i++)
        {
            var pair = pairs[i];
            var index = pair.indexOf("=");
            if (index > 0) {
                var name = pair.substring(0, index);
                var value = pair.substr(index+1);
                if (name.length && value.length)
                    cookies.push(new Cookie(this.makeCookieObject({name: name, value: value})));
            }
        }

        return cookies;
    },

    getRealObject: function(cookie, context)
    {
        cookie = this.makeCookieObject(cookie);
        delete cookie.rawCookie;

        var global = context.getCurrentGlobal();
        return Wrapper.cloneIntoContentScope(global, cookie);
    }
};

// ********************************************************************************************* //

return CookieUtils;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/cookies/editCookie",
[
    "firebug/lib/locale",
    "firebug/lib/xpcom",
    "firebug/cookies/cookie",
],
function(Locale, Xpcom, Cookie) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const windowMediator = Cc["@mozilla.org/appshell/window-mediator;1"].getService(Ci.nsIWindowMediator);

// ********************************************************************************************* //

const ioService = Xpcom.CCSV("@mozilla.org/network/io-service;1", "nsIIOService");
const prompts = Xpcom.CCSV("@mozilla.org/embedcomp/prompt-service;1", "nsIPromptService");

// ********************************************************************************************* //

/**
 * @dialog Edit cookie dialog implementation. This dialog is used to create a new cookie
 * and edit an existing cookies.
 */
function EditCookie(win)
{
    this.window = win;
}

EditCookie.prototype =
{
    cookie: null,

    onLoad: function()
    {
        this.createDateTimeField();

        var params = this.window.arguments[0];
        this.params = params;
        this.cookie = params.cookie;

        this.nameNode = $("fcName", this.window);
        this.valueNode = $("fcValue", this.window);
        this.domainNode = $("fcDomain", this.window);
        this.pathNode = $("fcPath", this.window);
        this.expireNode = $("fcExpire", this.window);
        this.sessionNode = $("fcSession", this.window);
        this.secureNode = $("fcSecure", this.window);
        this.httpOnly = $("fcHttpOnly", this.window);
        this.URLEncodeValue = $("fbURLEncodeValue", this.window);

        // Fix for issue 39: decode cookie name and value for usage in the dialog.
        // It'll be encoded again when OK is pressed.
        // Don't escape using encodeURIComponent, since "+" would be changed, but
        // it's a valid replacement for a space.
        // This is also necessary for issue 45.
        // Cookie name should not be encoded, see Issue 6653
        this.nameNode.value = this.cookie.name;
        this.valueNode.value = unescape(this.cookie.rawValue);

        this.domainNode.value = this.cookie.host;
        this.pathNode.value = this.cookie.path;
        this.secureNode.checked = this.cookie.isSecure;
        this.httpOnly.checked = this.cookie.isHttpOnly;
        this.URLEncodeValue.checked = this.cookie.rawValue != unescape(this.cookie.rawValue);

        if (this.cookie.expires)
        {
            var expires = new Date(this.cookie.expires * 1000);
            this.expireNode.value = expires.toGMTString();
        }
        else
        {
            this.sessionNode.checked = true;

            // Set default value for expire time (current time + some time span, see prefs
            // defaultInterval) so, the cookie doesn't disappear if the session box
            // is just unchecked.

            // xxxHonza: the default time is always set to the current time.
            //if (!this.expireNode.value)
            {
                var expireTime = Firebug.CookieModule.getDefaultCookieExpireTime();
                var expires = new Date(expireTime * 1000);
                this.expireNode.value = expires.toGMTString();
            }
        }

        // Update expire date-time picker.
        this.onSession();

        // Translate all string in the UI.
        this.fcInternationalizeUI();
    },

    fcInternationalizeUI: function()
    {
        var elements = ["fcEditCookieDlg", "fcNameLabel", "fcIsDomainLabel", "fcPathLabel",
            "fcExpireLabel", "fcSession", "fcValueLabel", "fcSecure", "fcHttpOnly",
            "fbURLEncodeValue"];

        for (var i=0; i<elements.length; i++)
        {
            var element = $(elements[i], this.window);
            if (element.hasAttribute("title"))
                Locale.internationalize(element, "title");

            if (element.hasAttribute("label"))
                Locale.internationalize(element, "label");

            if (element.hasAttribute("value"))
                Locale.internationalize(element, "value");
        }
    },

    onOK: function()
    {
        if (!this.checkValues())
            return false;

        var isSession = this.sessionNode.checked;
        var host = this.domainNode.value;

        var cookieName = this.nameNode.value;
        var cookieValue = this.valueNode.value;

        // Fix for issue 39: Can't create cookies with ';' in the name
        // But do not escape all,see issue 60: "[" and "]" characters get badly encoded
        // on cookie name upon editing
        cookieName = cookieName.replace(/\;/g, "%3B");

        // According to RFC 6265 (http://tools.ietf.org/html/rfc6265)
        // the cookie value should be encoded
        if (this.URLEncodeValue.checked)
        {
            cookieValue = escape(cookieValue);

            // Issue 45: When I copy and paste or edit a cookie contents + (plus) signs
            // get converted to spaces.
            cookieValue = cookieValue.replace(/\+/g, "%2B");
        }

        // Create a helper cookie object from the provided data.
        var values = {
            name: cookieName,
            rawValue: cookieValue,
            path: this.pathNode.value,
            host: host,
            isSecure: this.secureNode.checked,
            isHttpOnly: this.httpOnly.checked,
            isDomain: (host.charAt(0) == "."),
            expires: null // is computed below
        };

        // will be immediately removed.
        if (!isSession)
        {
            // If it isn't a session cookie set the proper expire time.
            var expires = new Date();
            expires.setTime(Date.parse(this.expireNode.value));
            values.expires = Math.floor(expires.valueOf() / 1000);
        }

        // Create/modify cookie.
        var cookie = new Cookie(values);
        Firebug.CookieModule.createCookie(cookie);

        // Close dialog.
        this.window.close();

        return true;
    },

    /**
     * Verify values before the OK button is pressed.
     */
    checkValues: function()
    {
        var name = this.nameNode.value;
        if (!name)
        {
            prompts.alert(this.window, Locale.$STR("Firebug"),
                Locale.$STR("cookies.edit.invalidname"));
            return false;
        }

        var domain = this.domainNode.value;
        if (!this.checkHost(domain))
        {
            prompts.alert(this.window, Locale.$STR("Firebug"),
                Locale.$STR("cookies.edit.invalidhost"));
            return false;
        }

        var path = this.pathNode.value;
        if (!this.checkPath(domain, path))
        {
            prompts.alert(this.window, Locale.$STR("Firebug"),
                Locale.$STR("cookies.edit.invalidpath"));
            return false;
        }

        return true;
    },

    onCancel: function()
    {
        window.close();
    },

    onSession: function()
    {
        this.expireNode.disabled = this.sessionNode.checked;
    },

    checkHost: function(host)
    {
        if (!host)
            return false;

        try
        {
            var uri = "http://" + host + "/";
            return ioService.newURI(uri, null, null) ? true : false;
        }
        catch (err) {
        }

        return false;
    },

    checkPath: function(host, path)
    {
        if (!path)
            return false;

        try {
            var uri = "http://" + host + "/" + path;
            return ioService.newURI(uri, null, null) ? true : false;
        }
        catch(err) {
        }

        return false;
    },

    createDateTimeField: function()
    {
        // Get the box element where the dateTime field should be located.
        var expireBox = this.window.document.getElementById("fcExpireBox");

        // Append a new field into the UI.
        var dateTimeField = this.window.document.createElement("dateTimePicker");
        dateTimeField.id = "fcExpire";
        expireBox.appendChild(dateTimeField);
    },

    getChromeWindow: function()
    {
        return windowMediator.getMostRecentWindow("navigator:browser");
    }
};

// ********************************************************************************************* //
// Helpers

function $(id, win)
{
    return win.document.getElementById(id);
}

// ********************************************************************************************* //
// Registration

return EditCookie;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/cookies/headerResizer",
[
    "firebug/lib/xpcom",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/domplate",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/lib/persist",
    "firebug/lib/string",
    "firebug/lib/http",
    "firebug/lib/css",
    "firebug/lib/events",
    "firebug/cookies/baseObserver",
    "firebug/cookies/menuUtils",
],
function(Xpcom, Obj, Locale, Domplate, Dom, Options, Persist, Str, Http, Css, Events,
    BaseObserver, MenuUtils) {

// ********************************************************************************************* //
// Resizable column helper (helper for Templates.CookieTable)

var HeaderResizer =
{
    resizing: false,
    currColumn: null,
    startX: 0,
    startWidth: 0,
    lastMouseUp: 0,

    onMouseClick: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        // Avoid click event for sorting, if the resizing has been just finished.
        var rightNow = now();
        if ((rightNow - this.lastMouseUp) < 1000)
            Events.cancelEvent(event);
    },

    onMouseDown: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        var target = event.target;
        if (!Css.hasClass(target, "cookieHeaderCellBox"))
            return;

        var header = Dom.getAncestorByClass(target, "cookieHeaderRow");
        if (!header)
            return;

        if (!this.isBetweenColumns(event))
            return;

        this.onStartResizing(event);

        Events.cancelEvent(event);
    },

    onMouseMove: function(event)
    {
        if (this.resizing)
        {
            if (Css.hasClass(target, "cookieHeaderCellBox"))
                target.style.cursor = "e-resize";

            this.onResizing(event);
            return;
        }

        var target = event.target;
        if (!Css.hasClass(target, "cookieHeaderCellBox"))
            return;

        if (target)
            target.style.cursor = "";

        if (!this.isBetweenColumns(event))
            return;

        // Update cursor if the mouse is located between two columns.
        target.style.cursor = "e-resize";
    },

    onMouseUp: function(event)
    {
        if (!this.resizing)
            return;

        this.lastMouseUp = now();

        this.onEndResizing(event);
        Events.cancelEvent(event);
    },

    onMouseOut: function(event)
    {
        if (!this.resizing)
            return;

        if (FBTrace.DBG_COOKIES)
        {
            FBTrace.sysout("cookies.Mouse out, target: " + event.target.localName +
                ", " + event.target.className);
            FBTrace.sysout("      explicitOriginalTarget: " + event.explicitOriginalTarget.localName +
                ", " + event.explicitOriginalTarget.className);
        }

        var target = event.target;
        if (target == event.explicitOriginalTarget)
            this.onEndResizing(event);

        Events.cancelEvent(event);
    },

    isBetweenColumns: function(event)
    {
        var target = event.target;
        var x = event.clientX;

        var column = Dom.getAncestorByClass(target, "cookieHeaderCell");
        var offset = Dom.getClientOffset(column);
        var size = Dom.getOffsetSize(column);

        if (column.previousSibling)
        {
            if (x < offset.x + 4)
                return 1;   // Mouse is close to the left side of the column (target).
        }

        if (column.nextSibling)
        {
            if (x > offset.x + size.width - 6)
                return 2;  // Mouse is close to the right side.
        }

        return 0;
    },

    onStartResizing: function(event)
    {
        var location = this.isBetweenColumns(event);
        if (!location)
            return;

        var target = event.target;

        this.resizing = true;
        this.startX = event.clientX;

        // Currently resizing column.
        var column = Dom.getAncestorByClass(target, "cookieHeaderCell");
        this.currColumn = (location == 1) ? column.previousSibling : column;

        // Last column width.
        var size = Dom.getOffsetSize(this.currColumn);
        this.startWidth = size.width;

        if (FBTrace.DBG_COOKIES)
        {
            var colId = this.currColumn.getAttribute("id");
            FBTrace.sysout("cookies.Start resizing column (id): " + colId +
                ", start width: " + this.startWidth);
        }
    },

    onResizing: function(event)
    {
        if (!this.resizing)
            return;

        var newWidth = this.startWidth + (event.clientX - this.startX);
        this.currColumn.style.width = newWidth + "px";

        if (FBTrace.DBG_COOKIES)
        {
            var colId = this.currColumn.getAttribute("id");
            FBTrace.sysout("cookies.Resizing column (id): " + colId +
                ", new width: " + newWidth);
        }
    },

    onEndResizing: function(event)
    {
        if (!this.resizing)
            return;

        this.resizing = false;

        var newWidth = this.startWidth + (event.clientX - this.startX);
        this.currColumn.style.width = newWidth + "px";

        // Store width into the preferences.
        var colId = this.currColumn.getAttribute("id");
        if (colId)
        {
            // Use directly nsIPrefBranch interface as the pref
            // doesn't have to exist yet.
            Options.setPref(Firebug.prefDomain, ".cookies." + colId + ".width", newWidth);
        }

        if (FBTrace.DBG_COOKIES)
        {
            var colId = this.currColumn.getAttribute("id");
            FBTrace.sysout("cookies.End resizing column (id): " + colId +
                ", new width: " + newWidth);
        }
    }
};

// ********************************************************************************************* //
// Time Helpers

function now()
{
    return (new Date()).getTime();
}

// ********************************************************************************************* //

return HeaderResizer;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/cookies/httpObserver",
[
    "firebug/lib/object",
    "firebug/lib/xpcom",
    "firebug/cookies/baseObserver",
    "firebug/lib/http",
    "firebug/chrome/tabWatcher",
    "firebug/cookies/cookie",
    "firebug/lib/options",
    "firebug/cookies/cookieUtils",
    "firebug/lib/array",
    "firebug/chrome/firefox",
],
function(Obj, Xpcom, BaseObserver, Http, TabWatcher, Cookie, Options, CookieUtils, Arr, Firefox) {

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

const cookieService = Xpcom.CCSV("@mozilla.org/cookieService;1", "nsICookieService");

const panelName = "cookies";

// ********************************************************************************************* //
// HTTP observer

/**
 * @class Represents an observer for http-on-modify-request and
 * http-on-examine-response events that are dispatched
 * by Firefox when network request is executed and returned. 
 */
var HttpObserver = Obj.extend(BaseObserver,
/** @lends HttpObserver */
{
    // nsIObserver
    observe: function(aSubject, aTopic, aData) 
    {
        try {
            aSubject = aSubject.QueryInterface(Ci.nsIHttpChannel);
            if (aTopic == "http-on-modify-request") {
                this.onModifyRequest(aSubject);
            } else if (aTopic == "http-on-examine-response") {
                this.onExamineResponse(aSubject);
            }
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("cookies.HttpObserver.observe; EXCEPTION " + err, err);
        }
    },

    onModifyRequest: function(request) 
    {
        var name = request.URI.spec;
        var origName = request.originalURI.spec;
        var win = Http.getWindowForRequest(request);
        var tabId = Firebug.getTabIdForWindow(win);

        // Firebus's natures is to display information for a tab. So, if there
        // is no tab associated then end.
        if (!tabId)
            return;

        // Dump debug information to the console.
        if (FBTrace.DBG_COOKIES)
        {
            FBTrace.sysout("cookies.onModifyRequest: " + request.name);
            FBTrace.sysout("cookies.Cookies sent: " +
                cookieService.getCookieString(request.URI, request));
        }

        // At this moment (specified by all the conditions) FB context doesn't exists yet.
        // But the page already started loading and there are things to monitor.
        // This is why the temporary context is created. It's used as a place where to 
        // store information (cookie events and hosts). All this info will be copied into
        // the real FB context when it's created (see initContext).
        if ((request.loadFlags & Ci.nsIHttpChannel.LOAD_DOCUMENT_URI) &&
            (request.loadGroup && request.loadGroup.groupObserver) &&
            (name == origName) && (win && win == win.parent))
        {
            var browser = Firefox.getBrowserForWindow(win);

            if (!Firebug.TabWatcher.shouldCreateContext(browser, name, null))
            {
                if (FBTrace.DBG_COOKIES)
                    FBTrace.sysout("cookies.onModifyRequest; Activation logic says don't create " +
                        "temp context for: " + name);
                return;
            }

            if (FBTrace.DBG_COOKIES && Firebug.CookieModule.contexts[tabId])
                FBTrace.sysout("cookies.!!! Temporary context exists for: " + tabId);

            // Create temporary context
            if (!Firebug.CookieModule.contexts[tabId])
            {
                var tempContext = new TempContext(tabId);
                Firebug.CookieModule.contexts[tabId] = tempContext;

                if (FBTrace.DBG_COOKIES)
                    FBTrace.sysout("cookies.INIT temporary context for: " + tempContext.tabId);

                tempContext.href = name;
                Firebug.CookieModule.initTempContext(tempContext);
            }
        }

        // Use the temporary context first, if it exists. There could be an old
        // context (associated with this tab) for the previous URL.
        var context = Firebug.CookieModule.contexts[tabId];
        context = context ? context : TabWatcher.getContextByWindow(win);

        // The context doesn't have to exist due to the activation support.
        if (!context)
        {
            if (FBTrace.DBG_COOKIES) 
                FBTrace.sysout("cookies.onModifyRequest: context is NOT available for:" +
                    request.URI.host + ", tabId: " + tabId);
            return;
        }

        // Collect all the host (redirects, iframes) as cookies for all of them
        // will be displayed.
        var activeHosts = context.cookies.activeHosts;
        var host = request.URI.host;
        if (!activeHosts[host])
        {
            activeHosts[host] = {host: host, path: request.URI.path};

            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.New host (on-modify-request): " +
                    request.URI.host + ", tabId: " + tabId, activeHosts);

            // Refresh the panel asynchronously.
            if (context instanceof Firebug.TabContext)
                context.invalidatePanels(panelName);
        }
    },

    onExamineResponse: function(request)
    {
        var win = Http.getWindowForRequest(request);
        var tabId = Firebug.getTabIdForWindow(win);
        if (!tabId)
            return;

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.onExamineResponse: " + request.name);

        // Do not collect received cookies if they are not necessary.
        if (!Options.get("cookies.logEvents") && !Options.get("cookies.showRejectedCookies"))
            return;

        // If logging to console is on, remember the set-cookie string, so
        // these cookies can be displayed together e.g. with rejected message.
        var setCookie;
        request.visitResponseHeaders({
            visitHeader: function(header, value) {
                if (header == "Set-Cookie")
                    setCookie = value;
            }
        });

        // Bail out if no cookies is received.
        if (!setCookie)
            return;

        // Try to get the context from the contexts array first. The TabWatacher
        // could return context for the previous page in this tab.
        var context = Firebug.CookieModule.contexts[tabId];
        context = context ? context : TabWatcher.getContextByWindow(win);

        // The context doesn't have to exist due to the activation support.
        if (!context)
        {
            if (FBTrace.DBG_COOKIES) 
                FBTrace.sysout("cookies.onExamineResponse: context is NOT available for:" +
                    request.URI.host + ", tabId: " + tabId);
            return;
        }

        // Associate the setCookie string with proper active host (active
        // host can be the page itself or an embedded iframe or a XHR).
        // Also remember originalURI so, the info where the cookies comes
        // from can be displayed to the user.
        var activeHosts = context.cookies.activeHosts;
        var host = request.URI.host;
        var activeHost = activeHosts[host];

        // Map of all received cookies. The key is cookie-host the value is
        // an array with all cookies with the same host.
        if (!context.cookies.activeCookies)
            context.cookies.activeCookies = [];

        if (!activeHost)
            return;

        var activeCookies = context.cookies.activeCookies;

        // xxxHonza
        // 1)the activeHost.receivedCookies array shouldn't be recreated
        // if it's already there.
        // 2) There can be more responses from the same domain (XHRs) and so,
        // more received cookies within the page life.
        // 3) The list should make sure that received cookies aren't duplicated.
        // (the same cookie can be received multiple time).
        // 4) Also, rejected cookies, are displayed in the cookie-list too and
        // these shouldn't be duplicated.
        // 5) This should be a map (key == the original host)
        //if (!activeHost.receivedCookies)
            activeHost.receivedCookies = [];

        // Parse all received cookies and store them into activeHost info.
        var cookies = setCookie.split("\n");
        for (var i=0; i<cookies.length; i++)
        {
            var cookie = CookieUtils.parseFromString(cookies[i]);
            cookie.originalURI = request.originalURI;
            if (!cookie.host)
                cookie.host = host;

            // Push into activeHosts
            var cookieWrapper = new Cookie(CookieUtils.makeCookieObject(cookie));
            activeHost.receivedCookies.push(cookieWrapper);

            // Push into activeCookies
            if (!activeCookies[cookie.host])
                activeCookies[cookie.host] = [];

            var activeCookiesForHost = activeCookies[cookie.host];
            activeCookiesForHost[CookieUtils.getCookieId(cookie)] = cookie;

            if (FBTrace.DBG_COOKIES)
                FBTrace.sysout("cookies.Cookie received: " +
                    cookie.host + ", cookie: " + cookie.name, cookie);
        }

        if (FBTrace.DBG_COOKIES)
            FBTrace.sysout("cookies.Set-Cookie: " + setCookie, activeCookies);
    }
});

// ********************************************************************************************* //
// Temporary context

function TempContext(tabId)
{
    this.tabId = tabId;
    this.events = [];
}

TempContext.prototype.appendCookieEvent = function(subject, topic, data)
{
    this.events.push({subject:subject, topic:topic, data:data});
};

// ********************************************************************************************* //

return HttpObserver;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/cookies/legacy",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/lib/xpcom",
    "firebug/lib/locale",
    "firebug/chrome/window",
],
function(Module, Obj, Xpcom, Locale, Win) {

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;

Components.utils.import("resource://gre/modules/AddonManager.jsm");

var prompts = Xpcom.CCSV("@mozilla.org/embedcomp/prompt-service;1", "nsIPromptService");
var app = Xpcom.CCSV("@mozilla.org/toolkit/app-startup;1", "nsIAppStartup");

// ********************************************************************************************* //
// Module

var CookieLegacy = Obj.extend(Module,
{
    initialize: function(prefDomain, prefNames)
    {
        Module.initialize.apply(this, arguments);

        setTimeout(Obj.bind(this.onAlert, this), 1000);
    },

    onAlert: function()
    {
        // Detect whether Firecookie is installed. This extension has been integrated
        // with Firebug and so, should not be installed together with Firebug 1.10+
        if (!Firebug.FireCookieModel)
            return;

        // See https://developer.mozilla.org/en/nsIPromptService#confirmEx%28%29
        // for configuration details.
        var check = {value: false};
        var flags = prompts.BUTTON_POS_0 * prompts.BUTTON_TITLE_IS_STRING +
            prompts.BUTTON_POS_1 * prompts.BUTTON_TITLE_CANCEL +
            prompts.BUTTON_POS_2 * prompts.BUTTON_TITLE_IS_STRING +
            prompts.BUTTON_POS_0_DEFAULT;

        var index = prompts.confirmEx(null, Locale.$STR("Firebug"),
            Locale.$STR("cookies.legacy.firecookie_detected"), flags,
            Locale.$STR("cookies.legacy.uninstall_and_restart"),
            "",
            Locale.$STR("cookies.legacy.uninstall"), null, check);

        // Bail out if the user presses Cancel.
        if (index == 2)
            return;

        // Let's uninstall, restart will follow if button #0 has been clicked.
        this.uninstallAddon(index == 0);
    },

    uninstallAddon: function(restart)
    {
        AddonManager.getAddonByID("firecookie@janodvarko.cz", function(addon)
        {
            // Uninstall is synchronous.
            addon.uninstall();

            if (restart)
                app.quit(Ci.nsIAppStartup.eRestart | Ci.nsIAppStartup.eAttemptQuit);
        });
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(CookieLegacy);

return CookieLegacy;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/cookies/menuUtils",
[
    "firebug/lib/object",
    "firebug/lib/options",
],
function(Obj, Options) {

// ********************************************************************************************* //
// Menu Utils

var MenuUtils = 
{
    optionMenu: function(context, label, tooltiptext, domain, option)
    {
        var value = Options.getPref(domain, option), self = this;
        return {
            label: label,
            tooltiptext: tooltiptext,
            type: "checkbox",
            checked: value,
            command: function()
            {
                var checked = this.hasAttribute("checked");
                self.setPref(domain, option, checked);
            }
        };
    },

    optionAllowGlobally: function(context, label, tooltiptext, domain, option)
    {
        var value = Options.getPref(domain, option) == 0;
        return {
            label: label,
            tooltiptext: tooltiptext,
            type: "checkbox",
            checked: value,
            command: Obj.bindFixed(this.onAllowCookie, this, domain, option)
        };
    },

    // Command handlers
    onAllowCookie: function(domain, option)
    {
        var value = Options.getPref(domain, option);
        switch (value)
        {
            case 0: // accept all cookies by default
            Options.setPref(domain, option, 2);
            return;

            case 1: // only accept from the originating site (block third party cookies)
            case 2: // block all cookies by default;
            case 3: // use p3p settings
            Options.setPref(domain, option, 0);
            return;
        } 
    },

    onBlockCurrent: function()
    {
    },

    setPref: function(domain, name, value)
    {
        Options.setPref(domain, name, value);
    }
};

// ********************************************************************************************* //

return MenuUtils;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */

define("firebug/css/computedPanel",
[
    "firebug/chrome/panel",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/xml",
    "firebug/lib/url",
    "firebug/lib/array",
    "firebug/js/sourceLink",
    "firebug/chrome/menu",
    "firebug/lib/options",
    "firebug/lib/string",
    "firebug/lib/persist",
    "firebug/css/cssModule",
    "firebug/css/cssReps",
    "firebug/css/loadHandler",
],
function(Panel, Obj, Firebug, Domplate, Locale, Events, Css, Dom, Xml, Url, Arr, SourceLink, Menu,
    Options, Str, Persist, CSSModule, CSSInfoTip, LoadHandler) {

"use strict";

// ********************************************************************************************* //
// Constants

var Cu = Components.utils;

var statusClasses = ["cssUnmatched", "cssParentMatch", "cssOverridden", "cssBestMatch"];

var {domplate, FOR, TAG, DIV, H1, SPAN, TABLE, TBODY, TR, TD} = Domplate;

//********************************************************************************************* //
//Module Implementation

try
{
    // Firefox 24
    // waiting for: https://bugzilla.mozilla.org/show_bug.cgi?id=867595
    var scope = {}
    Cu.import("resource://gre/modules/devtools/Loader.jsm", scope);
    var {CssLogic} = scope.devtools.require("devtools/styleinspector/css-logic");
}
catch (e)
{
    if (FBTrace.DBG_ERRORS)
        FBTrace.sysout("cssComputedPanel: EXCEPTION CssLogic is not available! " + e, e);
}

// ********************************************************************************************* //
// CSS Computed panel (HTML side panel)

function CSSComputedPanel() {}

CSSComputedPanel.prototype = Obj.extend(Panel,
{
    template: domplate(
    {
        computedStylesTag:
            DIV({"class": "a11yCSSView", role: "list", "aria-label":
                Locale.$STR("aria.labels.computed styles")}),

        groupedStylesTag:
            FOR("group", "$groups",
                DIV({"class": "computedStylesGroup", $opened: "$group.opened", role: "list",
                        $hidden: "$group.props|hasNoStyles", _repObject: "$group"},
                    H1({"class": "cssComputedHeader groupHeader focusRow", role: "listitem"},
                        DIV({"class": "twisty", role: "presentation"}),
                        SPAN({"class": "cssComputedLabel"}, "$group.title")
                    ),
                    TAG("$stylesTag", {props: "$group.props"})
                )
            ),

        stylesTag:
            TABLE({"class": "computedStyleTable", role: "list"},
                TBODY({role: "presentation"},
                    FOR("prop", "$props",
                        TR({"class": "focusRow computedStyleRow computedStyle",
                                $opened: "$prop.opened", role: "listitem",
                                $hasSelectors: "$prop|hasSelectors", _repObject: "$prop"},
                            TD({"class": "stylePropName", role: "presentation"},
                                "$prop.property"
                            ),
                            TD({role: "presentation"},
                                SPAN({"class": "stylePropValue"}, "$prop.value|formatValue"))
                        ),
                        TR({"class": "focusRow computedStyleRow matchedSelectors", _repObject: "$prop"},
                            TD({colspan: 2},
                                TAG("$selectorsTag", {prop: "$prop"})
                            )
                        )
                    )
                )
            ),

        selectorsTag:
            TABLE({"class": "matchedSelectorsTable", role: "list"},
                TBODY({role: "presentation"},
                    FOR("selector", "$prop.matchedSelectors",
                        TR({"class": "focusRow computedStyleRow styleSelector "+
                            "$selector.status|getStatusClass", role: "listitem",
                                _repObject: "$selector"},
                            TD({"class": "selectorName", role: "presentation"},
                                "$selector.selector.text"),
                            TD({"class": "propValue", role: "presentation"},
                                SPAN({"class": "stylePropValue"}, "$selector.value|formatValue")),
                            TD({"class": "styleSourceLink", role: "presentation"},
                                TAG(FirebugReps.SourceLink.tag, {object: "$selector|getSourceLink"})
                            )
                        )
                    )
                )
            ),

        getStatusClass: function(status)
        {
            return statusClasses[status];
        },

        hasNoStyles: function(props)
        {
            return props.length == 0;
        },

        hasSelectors: function(prop)
        {
            return prop.matchedRuleCount != 0;
        },

        getSourceLink: function(selector)
        {
            var href = selector.href.href || selector.href;
            var line = selector.ruleLine;
            var selectorDef = selector.selector;
            // Dev tools API starting from FF 26.0 renamed the "_cssRule" property to "cssRule"
            // (see issue 6609)
            // TODO: This check can be removed as soon as FF 26.0 is the minimum supported version
            var rule = selectorDef.cssRule ?
                selectorDef.cssRule.domRule : selectorDef._cssRule._domRule;

            var instance = Css.getInstanceForStyleSheet(rule.parentStyleSheet);
            var sourceLink = line != -1 ? new SourceLink.SourceLink(href, line, "css",
                rule, instance) : null;

            return sourceLink;
        },

        formatValue: function(value)
        {
            value = formatColor(value);

            var limit = Options.get("stringCropLength");
            if (limit > 0)
                value = Str.cropString(value, limit);

            // Add a zero-width space after a comma to allow line breaking
            return value.replace(/,/g, ",\u200B");
        }
    }),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    updateComputedView: function(element)
    {
        // The current selection can be null.
        if (!element)
            return;

        // Update now if the document is loaded, otherwise wait for "load" event.
        var loadHandler = new LoadHandler();
        loadHandler.handle(this.context, Obj.bindFixed(this.doUpdateComputedView, this, element));
    },

    doUpdateComputedView: function(element)
    {
        function isUnwantedProp(propName)
        {
            return !Firebug.showMozillaSpecificStyles && Str.hasPrefix(propName, "-moz");
        }

        var win = element.ownerDocument.defaultView;
        var computedStyle = win.getComputedStyle(element);

        try
        {
            if (this.cssLogic)
                this.cssLogic.highlight(element);
        }
        catch (e)
        {
            // An exception is thrown if the document is not fully loaded yet
            // The cssLogic API needs to be used after "load" has been fired.
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("computedPanel.doUpdateComputedView; EXCEPTION " + e, e);
        }

        var props = [];
        for (var i = 0; i < computedStyle.length; ++i)
        {
            var prop = this.cssLogic ? this.cssLogic.getPropertyInfo(computedStyle[i]) :
                Firebug.CSSModule.getPropertyInfo(computedStyle, computedStyle[i]);

            if (isUnwantedProp(prop.property) ||
                (this.cssLogic && !Firebug.showUserAgentCSS && prop.matchedRuleCount == 0))
            {
                continue;
            }

            props.push(prop);
        }

        var parentNode = this.template.computedStylesTag.replace({}, this.panelNode);

        if (props.length != 0)
        {
            if (Firebug.computedStylesDisplay == "alphabetical")
            {
                this.sortProperties(props);

                for (var i = 0; i < props.length; ++i)
                    props[i].opened = this.styleOpened[props[i].property];

                var result = this.template.stylesTag.replace({props: props}, parentNode);
            }
            else
            {
                var groups = [];
                for (var groupName in styleGroups)
                {
                    var title = Locale.$STR("StyleGroup-" + groupName);
                    var group = {name: groupName, title: title, props: []};

                    var groupProps = styleGroups[groupName];
                    for (var i = 0; i < groupProps.length; ++i)
                    {
                        var propName = groupProps[i];
                        if (isUnwantedProp(propName))
                            continue;

                        var prop = this.cssLogic ? this.cssLogic.getPropertyInfo(propName) :
                            Firebug.CSSModule.getPropertyInfo(computedStyle, propName);

                        if (!Firebug.showUserAgentCSS && prop.matchedRuleCount == 0)
                            continue;

                        prop.opened = this.styleOpened[propName];

                        group.props.push(prop);

                        for (var j = 0; j < props.length; ++j)
                        {
                            if (props[j].property == propName)
                            {
                                props.splice(j, 1);
                                break;
                            }
                        }
                    }

                    group.opened = this.groupOpened[groupName];

                    groups.push(group);
                }

                if (props.length > 0)
                {
                    var group = groups[groups.length-1];
                    for (var i = 0; i < props.length; ++i)
                    {
                        var propName = props[i].property;
                        if (isUnwantedProp(propName))
                            continue;

                        var prop = this.cssLogic ? this.cssLogic.getPropertyInfo(propName) :
                            Firebug.CSSModule.getPropertyInfo(computedStyle, propName);

                        prop.opened = this.styleOpened[propName];

                        group.props.push(prop);
                    }

                    group.opened = this.groupOpened[group.name];
                }

                var result = this.template.groupedStylesTag.replace({groups: groups}, parentNode);
            }
        }
        else
        {
            FirebugReps.Warning.tag.replace({object: "computed.No_User-Defined_Styles"},
                this.panelNode);
        }

        if (this.scrollTop)
        {
            this.panelNode.scrollTop = this.scrollTop;
            delete this.scrollTop;
        }

        Events.dispatch(this.fbListeners, "onCSSRulesAdded", [this, result]);
    },

    toggleGroup: function(node)
    {
        var groupNode = Dom.getAncestorByClass(node, "computedStylesGroup");
        var group = Firebug.getRepObject(groupNode);

        Css.toggleClass(groupNode, "opened");
        var opened = Css.hasClass(groupNode, "opened");
        this.groupOpened[group.name] = opened;

        if (opened)
        {
            var offset = Dom.getClientOffset(node);
            var titleAtTop = offset.y < this.panelNode.scrollTop;

            Dom.scrollTo(groupNode, this.panelNode, null,
                groupNode.offsetHeight > this.panelNode.clientHeight || titleAtTop ? "top" : "bottom");
        }
    },

    toggleAllStyles: function(event, expand)
    {
        var computedStyles = this.panelNode.getElementsByClassName("computedStyle");

        for (var i = 0; i < computedStyles.length; ++i)
        {
            if (!Css.hasClass(computedStyles[i], "hasSelectors"))
                continue;

            var isOpened = Css.hasClass(computedStyles[i], "opened");
            if ((expand && !isOpened) || (!expand && isOpened))
                this.toggleStyle(computedStyles[i], false);
        }
    },

    toggleStyle: function(node, scroll)
    {
        var styleNode = Dom.getAncestorByClass(node, "computedStyle");
        var style = Firebug.getRepObject(styleNode);

        Css.toggleClass(styleNode, "opened");
        var opened = Css.hasClass(styleNode, "opened");
        this.styleOpened[style.property] = Css.hasClass(styleNode, "opened");

        if (opened && scroll)
        {
            var selectorsNode = styleNode.nextSibling;
            var offset = Dom.getClientOffset(styleNode);
            var titleAtTop = offset.y < this.panelNode.scrollTop;
            var totalHeight = styleNode.offsetHeight + selectorsNode.offsetHeight;
            var alignAtTop = totalHeight > this.panelNode.clientHeight || titleAtTop;

            Dom.scrollTo(alignAtTop ? styleNode : selectorsNode, this.panelNode, null,
                alignAtTop ? "top" : "bottom", alignAtTop);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Events

    onClick: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        var cssComputedHeader = Dom.getAncestorByClass(event.target, "cssComputedHeader");
        if (cssComputedHeader)
        {
            this.toggleGroup(event.target);
            return;
        }

        var computedStyle = Dom.getAncestorByClass(event.target, "computedStyle");
        if (computedStyle && Css.hasClass(computedStyle, "hasSelectors"))
        {
            this.toggleStyle(event.target, true);
            return;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    name: "computed",
    parentPanel: "html",
    order: 1,

    initialize: function()
    {
        if (typeof CssLogic != "undefined")
            this.cssLogic = new CssLogic();

        this.groupOpened = [];
        for (var groupName in styleGroups)
            this.groupOpened[groupName] = true;

        this.styleOpened = [];

        // Listen for CSS changes so the Computed panel is properly updated when needed.
        Firebug.CSSModule.addListener(this);

        this.onClick = Obj.bind(this.onClick, this);

        Panel.initialize.apply(this, arguments);
    },

    destroy: function(state)
    {
        state.scrollTop = this.panelNode.scrollTop ? this.panelNode.scrollTop : this.lastScrollTop;
        state.groupOpened = this.groupOpened;
        state.styleOpened = this.styleOpened;

        Persist.persistObjects(this, state);

        Firebug.CSSModule.removeListener(this);

        Panel.destroyNode.apply(this, arguments);
    },

    initializeNode: function(oldPanelNode)
    {
        Events.addEventListener(this.panelNode, "click", this.onClick, false);

        Panel.initializeNode.apply(this, arguments);
    },

    destroyNode: function()
    {
        Events.removeEventListener(this.panelNode, "click", this.onClick, false);

        Panel.destroyNode.apply(this, arguments);
    },

    show: function(state)
    {
        // Wait for loadedContext to restore the panel
        if (this.context.loaded)
        {
            Persist.restoreObjects(this, state);

            if (state)
            {
                if (state.scrollTop)
                    this.scrollTop = state.scrollTop;

                if (state.groupOpened)
                    this.groupOpened = state.groupOpened;

                if (state.styleOpened)
                    this.styleOpened = state.styleOpened;
            }
        }

        if (this.selection)
            this.refresh();
    },

    hide: function()
    {
        this.lastScrollTop = this.panelNode.scrollTop;
    },

    updateView: function(element)
    {
        this.updateComputedView(element);
    },

    supportsObject: function(object, type)
    {
        return object instanceof window.Element ? 1 : 0;
    },

    refresh: function()
    {
        this.updateSelection(this.selection);
    },

    updateSelection: function(element)
    {
        this.updateComputedView(element);
    },

    updateOption: function(name, value)
    {
        var options = new Set();
        options.add("showUserAgentCSS");
        options.add("computedStylesDisplay");
        options.add("colorDisplay");
        options.add("showMozillaSpecificStyles");

        if (options.has(name))
            this.refresh();
    },

    getOptionsMenuItems: function()
    {
        var items = [];

        if (this.cssLogic)
        {
            items.push(
                Menu.optionMenu("Show_User_Agent_CSS", "showUserAgentCSS",
                "style.option.tip.Show_User_Agent_CSS")
            );
        }

        items.push(
            {
                label: "Sort_alphabetically",
                type: "checkbox",
                checked: Firebug.computedStylesDisplay == "alphabetical",
                tooltiptext: "computed.option.tip.Sort_Alphabetically",
                command: Obj.bind(this.toggleDisplay, this)
            },
            Menu.optionMenu("Show_Mozilla_specific_styles",
                "showMozillaSpecificStyles",
                "computed.option.tip.Show_Mozilla_Specific_Styles")
        );

        items = Arr.extendArray(items, CSSModule.getColorDisplayOptionMenuItems());

        return items;
    },

    getContextMenuItems: function(style, target)
    {
        var items = [];
        var computedStyles = this.panelNode.getElementsByClassName("computedStyle");
        var expandAll = false;
        var collapseAll = false;
        for (var i = 0; i < computedStyles.length; ++i)
        {
            if (!Css.hasClass(computedStyles[i], "hasSelectors"))
                continue;

            if (!expandAll && !Css.hasClass(computedStyles[i], "opened"))
                expandAll = true;
            if (!collapseAll && Css.hasClass(computedStyles[i], "opened"))
                collapseAll = true;
        }

        if (expandAll)
        {
            items.push(
                {
                    label: "computed.option.label.Expand_All_Styles",
                    command: Obj.bind(this.toggleAllStyles, this, true),
                    tooltiptext: "computed.option.tip.Expand_All_Styles"
                }
            );
        }

        if (collapseAll)
        {
            items.push(
                {
                    label: "computed.option.label.Collapse_All_Styles",
                    command: Obj.bind(this.toggleAllStyles, this, false),
                    tooltiptext: "computed.option.tip.Collapse_All_Styles"
                }
            );
        }

        return items;
    },

    onMouseDown: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        var cssComputedHeader = Dom.getAncestorByClass(event.target, "cssComputedHeader");
        if (cssComputedHeader)
            this.toggleNode(event);
    },

    toggleNode: function(event)
    {
        var group = Dom.getAncestorByClass(event.target, "computedStylesGroup");
        var groupName = group.getElementsByClassName("cssComputedLabel")[0].textContent;

        Css.toggleClass(group, "opened");
        this.groupOpened[groupName] = Css.hasClass(group, "opened");
    },

    toggleDisplay: function()
    {
        var display = Firebug.computedStylesDisplay == "alphabetical" ? "grouped" : "alphabetical";
        Options.set("computedStylesDisplay", display);
    },

    sortProperties: function(props)
    {
        props.sort(function(a, b)
        {
            return a.property > b.property ? 1 : -1;
        });
    },

    getStylesheetURL: function(rule, getBaseUri)
    {
        // If parentStyleSheet.href is null, then per the CSS standard this is an inline style.
        if (rule && rule.parentStyleSheet && rule.parentStyleSheet.href)
            return rule.parentStyleSheet.href;
        else if (getBaseUri)
            return this.selection.ownerDocument.baseURI;
        else
            return this.selection.ownerDocument.location.href;
    },

    showInfoTip: function(infoTip, target, x, y, rangeParent, rangeOffset)
    {
        var propValue = Dom.getAncestorByClass(target, "stylePropValue");
        if (propValue)
        {
            var propInfo = Firebug.getRepObject(target);

            var prop = propInfo.property;
            var value = formatColor(propInfo.value);
            var cssValue;

            if (prop == "font" || prop == "font-family")
            {
                if (value.charAt(rangeOffset) == ",")
                    return;

                cssValue = Firebug.CSSModule.parseCSSFontFamilyValue(value, rangeOffset, prop);
            }
            else
            {
                cssValue = Firebug.CSSModule.parseCSSValue(value, rangeOffset);
            }

            if (!cssValue)
                return false;

            if (cssValue.value == this.infoTipValue)
                return true;

            this.infoTipValue = cssValue.value;

            switch (cssValue.type)
            {
                case "rgb":
                case "hsl":
                case "gradient":
                case "colorKeyword":
                    this.infoTipType = "color";
                    this.infoTipObject = cssValue.value;
                    return CSSInfoTip.populateColorInfoTip(infoTip, cssValue.value);

                case "url":
                    if (Css.isImageRule(Xml.getElementSimpleType(propInfo), prop))
                    {
                        var baseURL = typeof propInfo.href == "object" ? propInfo.href.href : propInfo.href;
                        if (!baseURL)
                            baseURL = propInfo.matchedSelectors[0].href;
                        var relURL = Firebug.CSSModule.parseURLValue(cssValue.value);
                        var absURL = Url.isDataURL(relURL) ? relURL : Url.absoluteURL(relURL, baseURL);
                        var repeat = Firebug.CSSModule.parseRepeatValue(value);

                        this.infoTipType = "image";
                        this.infoTipObject = absURL;

                        return CSSInfoTip.populateImageInfoTip(infoTip, absURL, repeat);
                    }
                    break;

                case "fontFamily":
                    return CSSInfoTip.populateFontFamilyInfoTip(infoTip, cssValue.value);
            }

            delete this.infoTipType;
            delete this.infoTipValue;
            delete this.infoTipObject;

            return false;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Change Listener

    onCSSInsertRule: function(styleSheet, cssText, ruleIndex)
    {
        // Force update, this causes updateSelection to be called.
        // See {@link Panel.select}
        this.selection = null;
    },

    onCSSDeleteRule: function(styleSheet, ruleIndex)
    {
        this.selection = null;
    },

    onCSSSetProperty: function(style, propName, propValue, propPriority, prevValue,
        prevPriority, rule, baseText)
    {
        this.selection = null;
    },

    onCSSRemoveProperty: function(style, propName, prevValue, prevPriority, rule, baseText)
    {
        this.selection = null;
    }
});

// ********************************************************************************************* //
// Helpers

function formatColor(color)
{
    switch (Options.get("colorDisplay"))
    {
        case "hex":
            return Css.rgbToHex(color);

        case "hsl":
            return Css.rgbToHSL(color);

        case "rgb":
            return Css.colorNameToRGB(color);

        default:
            return color;
    }
}

const styleGroups =
{
    text: [
        "font-family",
        "font-size",
        "font-weight",
        "font-style",
        "font-size-adjust",
        "color",
        "text-transform",
        "text-decoration",
        "letter-spacing",
        "word-spacing",
        "line-height",
        "text-align",
        "vertical-align",
        "direction",
        "column-count",
        "column-gap",
        "column-width",
        "-moz-tab-size", // FF4.0
        "-moz-font-feature-settings", // FF4.0
        "-moz-font-language-override", // FF4.0
        "-moz-text-blink", // FF6.0
        "-moz-text-decoration-color", // FF6.0
        "-moz-text-decoration-line", // FF6.0
        "-moz-text-decoration-style", // FF6.0
        "hyphens", // FF 6.0
        "text-overflow" // FF7.0
    ],

    background: [
        "background-color",
        "background-image",
        "background-repeat",
        "background-position",
        "background-attachment",
        "opacity",
        "background-clip",
        "-moz-background-inline-policy",
        "background-origin",
        "background-size",
        "-moz-image-region"
    ],

    box: [
        "width",
        "height",
        "top",
        "right",
        "bottom",
        "left",
        "margin-top",
        "margin-right",
        "margin-bottom",
        "margin-left",
        "padding-top",
        "padding-right",
        "padding-bottom",
        "padding-left",
        "-moz-padding-start",
        "-moz-padding-end",
        "border-top-width",
        "border-right-width",
        "border-bottom-width",
        "border-left-width",
        "border-top-color",
        "-moz-border-top-colors",
        "border-right-color",
        "-moz-border-right-colors",
        "border-bottom-color",
        "-moz-border-bottom-colors",
        "border-left-color",
        "-moz-border-left-colors",
        "border-top-style",
        "border-right-style",
        "border-bottom-style",
        "border-left-style",
        "-moz-border-end",
        "-moz-border-end-color",
        "-moz-border-end-style",
        "-moz-border-end-width",
        "border-image",
        "-moz-border-start",
        "-moz-border-start-color",
        "-moz-border-start-style",
        "-moz-border-start-width",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "-moz-outline-radius-bottomleft",
        "-moz-outline-radius-bottomright",
        "-moz-outline-radius-topleft",
        "-moz-outline-radius-topright",
        "box-shadow",
        "outline-color",
        "outline-offset",
        "outline-top-width",
        "outline-right-width",
        "outline-bottom-width",
        "outline-left-width",
        "outline-top-color",
        "outline-right-color",
        "outline-bottom-color",
        "outline-left-color",
        "outline-top-style",
        "outline-right-style",
        "outline-bottom-style",
        "outline-left-style",
        "-moz-box-align",
        "-moz-box-direction",
        "-moz-box-flex",
        "-moz-box-ordinal-group",
        "-moz-box-orient",
        "-moz-box-pack",
        "-moz-box-sizing",
        "-moz-margin-start",
        "-moz-margin-end"
    ],

    layout: [
        "position",
        "display",
        "visibility",
        "z-index",
        "overflow-x",  // http://www.w3.org/TR/2002/WD-css3-box-20021024/#overflow
        "overflow-y",
        "overflow-clip",
        "transform",
        "transform-origin",
        "white-space",
        "clip",
        "float",
        "clear",
        "-moz-appearance",
        "-moz-stack-sizing",
        "-moz-column-count",
        "-moz-column-gap",
        "-moz-column-width",
        "-moz-column-rule",
        "-moz-column-rule-width",
        "-moz-column-rule-style",
        "-moz-column-rule-color",
        "-moz-float-edge",
        "orient"
    ],

    other: []
};

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(CSSComputedPanel);

return CSSComputedPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/cssModule",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/xpcom",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/lib/css",
    "firebug/chrome/window",
    "firebug/lib/xml",
    "firebug/lib/options",
    "firebug/lib/array",
    "firebug/editor/editorSelector"
],
function(Module, Obj, Firebug, Xpcom, Events, Url, Css, Win, Xml, Options, Arr, EditorSelector) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const reSplitCSS = /(url\("?[^"\)]+"?\)?)|(rgba?\([^)]*\)?)|(hsla?\([^)]*\)?)|(#[\dA-Fa-f]+)|(-?\d+(\.\d+)?(%|[a-z]{1,4})?)|"([^"]*)"?|'([^']*)'?|([^,\s\/!\(\)]+)|(!(.*)?)/;
const reURL = /url\("?([^"\)]+)?"?\)/;
const reRepeat = /no-repeat|repeat-x|repeat-y|repeat/;

// ********************************************************************************************* //
// CSS Module

Firebug.CSSModule = Obj.extend(Module, Firebug.EditorSelector,
{
    dispatchName: "cssModule",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module

    initialize: function()
    {
        this.editors = {};
        this.registerEditor("Live",
        {
            startEditing: function(stylesheet, context, panel)
            {
                panel.startLiveEditing(stylesheet, context);
            },
            stopEditing: function()
            {
                Firebug.Editor.stopEditing();
            }
        });

        this.registerEditor("Source",
        {
            startEditing: function(stylesheet, context, panel)
            {
                panel.startSourceEditing(stylesheet, context);
            },
            stopEditing: function()
            {
                Firebug.Editor.stopEditing();
            }
        });
    },

    initContext: function(context)
    {
        context.dirtyListener = new Firebug.CSSDirtyListener(context);
        this.addListener(context.dirtyListener);
    },

    destroyContext: function(context)
    {
        this.removeListener(context.dirtyListener);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    freeEdit: function(styleSheet, value)
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSModule.freeEdit", arguments);

        if (!styleSheet.editStyleSheet)
        {
            var ownerNode = getStyleSheetOwnerNode(styleSheet);
            styleSheet.disabled = true;

            var url = Xpcom.CCSV("@mozilla.org/network/standard-url;1", Ci.nsIURL);
            url.spec = styleSheet.href;

            var editStyleSheet = ownerNode.ownerDocument.createElementNS(
                "http://www.w3.org/1999/xhtml",
                "style");

            Firebug.setIgnored(editStyleSheet);

            editStyleSheet.setAttribute("type", "text/css");
            editStyleSheet.setAttributeNS(
                "http://www.w3.org/XML/1998/namespace",
                "base",
                url.directory);

            if (ownerNode.hasAttribute("media"))
                editStyleSheet.setAttribute("media", ownerNode.getAttribute("media"));

            // Insert the edited stylesheet directly after the old one to ensure the styles
            // cascade properly.
            ownerNode.parentNode.insertBefore(editStyleSheet, ownerNode.nextSibling);

            styleSheet.editStyleSheet = editStyleSheet;
        }

        styleSheet.editStyleSheet.textContent = value;

        if (FBTrace.DBG_CSS)
            FBTrace.sysout("css.saveEdit styleSheet.href:" + styleSheet.href +
                " got innerHTML:" + value);

        Events.dispatch(this.fbListeners, "onCSSFreeEdit", [styleSheet, value]);
    },

    insertRule: function(styleSheet, cssText, ruleIndex)
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("Insert: " + ruleIndex + " " + cssText);

        var insertIndex = styleSheet.insertRule(cssText, ruleIndex);

        Events.dispatch(this.fbListeners, "onCSSInsertRule", [styleSheet, cssText, ruleIndex]);

        return insertIndex;
    },

    deleteRule: function(src, ruleIndex)
    {
        var inlineStyle = (src instanceof window.Element);
        if (FBTrace.DBG_CSS)
        {
            if (inlineStyle)
            {
                FBTrace.sysout("deleteRule: element.style", src);
            }
            else
            {
                FBTrace.sysout("deleteRule: " + ruleIndex + " " + src.cssRules.length,
                    src.cssRules);
            }
        }

        var rule = (inlineStyle ? src : src.cssRules[ruleIndex]);
        var afterParams = [src, rule.style.cssText];
        afterParams.push(inlineStyle ? "" : rule.selectorText);

        Events.dispatch(this.fbListeners, "onCSSDeleteRule", [src, ruleIndex]);

        if (src instanceof window.Element)
            src.removeAttribute("style");
        else
            src.deleteRule(ruleIndex);

        Events.dispatch(this.fbListeners, "onAfterCSSDeleteRule", afterParams);
    },

    setProperty: function(rule, propName, propValue, propPriority)
    {
        var style = rule.style || rule;

        // Record the original CSS text for the inline case so we can reconstruct at a later
        // point for diffing purposes
        var baseText = style.cssText;

        var prevValue = style.getPropertyValue(propName);
        var prevPriority = style.getPropertyPriority(propName);

        // XXXjoe Gecko bug workaround: Just changing priority doesn't have any effect
        // unless we remove the property first
        style.removeProperty(propName);

        style.setProperty(propName, propValue, propPriority);

        if (propName)
        {
            Events.dispatch(this.fbListeners, "onCSSSetProperty", [style, propName, propValue,
                propPriority, prevValue, prevPriority, rule, baseText]);
        }
    },

    removeProperty: function(rule, propName, parent)
    {
        var style = rule.style || rule;

        // Record the original CSS text for the inline case so we can reconstruct at a later
        // point for diffing purposes
        var baseText = style.cssText;

        var prevValue = style.getPropertyValue(propName);
        var prevPriority = style.getPropertyPriority(propName);

        style.removeProperty(propName);

        if (propName)
            Events.dispatch(this.fbListeners, "onCSSRemoveProperty", [style, propName, prevValue,
                prevPriority, rule, baseText]);
    },

    /**
     * Method for atomic property removal, such as through the context menu.
     */
    deleteProperty: function(rule, propName, context)
    {
        Events.dispatch(this.fbListeners, "onBeginFirebugChange", [rule, context]);
        Firebug.CSSModule.removeProperty(rule, propName);
        Events.dispatch(this.fbListeners, "onEndFirebugChange", [rule, context]);
    },

    disableProperty: function(disable, rule, propName, parsedValue, map, context)
    {
        Events.dispatch(this.fbListeners, "onBeginFirebugChange", [rule, context]);

        if (disable)
        {
            Firebug.CSSModule.removeProperty(rule, propName);

            map.push({"name": propName, "value": parsedValue.value,
                "important": parsedValue.priority});
        }
        else
        {
            Firebug.CSSModule.setProperty(rule, propName, parsedValue.value, parsedValue.priority);

            var index = findPropByName(map, propName);
            map.splice(index, 1);
        }

        Events.dispatch(this.fbListeners, "onEndFirebugChange", [rule, context]);
    },

    /**
     * Get a document's temporary stylesheet for storage of user-provided rules.
     * If it doesn't exist yet, create it.
     */
    getDefaultStyleSheet: function(doc)
    {
        // Cache the temporary sheet on an expando of the document.
        var sheet = doc.fbDefaultSheet;
        if (!sheet)
        {
            sheet = Css.appendStylesheet(doc, "chrome://firebug/default-stylesheet.css").sheet;
            sheet.defaultStylesheet = true;
            doc.fbDefaultSheet = sheet;
        }
        return sheet;
    },

    parseCSSValue: function(value, offset)
    {
        var start = 0;
        var m;
        while (true)
        {
            m = reSplitCSS.exec(value);
            if (m && m.index+m[0].length < offset)
            {
                value = value.substr(m.index+m[0].length);
                start += m.index+m[0].length;
                offset -= m.index+m[0].length;
            }
            else
                break;
        }

        if (!m)
            return;

        var type;
        if (m[1])
            type = "url";
        else if (m[2] || m[4])
            type = "rgb";
        else if (m[3])
            type = "hsl";
        else if (m[5])
            type = "int";

        var cssValue = {value: m[0], start: start+m.index, end: start+m.index+m[0].length, type: type};

        if (!type)
        {
            if (m[10] && m[10].indexOf("gradient") != -1)
            {
                var arg = value.substr(m[0].length).match(/\((?:(?:[^\(\)]*)|(?:\(.*?\)))+\)/);
                if (!arg)
                  return;

                cssValue.value += arg[0];
                cssValue.type = "gradient";
            }
            else if (Css.isColorKeyword(cssValue.value))
            {
                cssValue.type = "colorKeyword";
            }
        }

        return cssValue;
    },

    parseCSSFontFamilyValue: function(value, offset, propName)
    {
        var skipped = 0;
        if (propName === "font")
        {
            var rePreFont = new RegExp(
                "^.*" + // anything, then
                "(" +
                    "\\d+(\\.\\d+)?([a-z]*|%)|" + // a number (with possible unit)
                    "(x{1,2}-)?(small|large)|medium|larger|smaller" + // or an named size description
                ") "
            );
            var m = rePreFont.exec(value);
            if (!m || offset < m[0].length)
                return this.parseCSSValue(value, offset);
            skipped = m[0].length;
            value = value.substr(skipped);
            offset -= skipped;
        }

        var matches = /^(.*?)(\s*!.*)?$/.exec(value);
        var fonts = matches[1].split(",");

        var totalLength = 0;
        for (var i = 0; i < fonts.length; ++i)
        {
            totalLength += fonts[i].length;
            if (offset <= totalLength)
            {
                // Give back the value and location of this font, whitespace-trimmed.
                var font = fonts[i].replace(/^\s+/, "");
                var end = totalLength;
                var start = end - font.length;
                return {
                    value: font,
                    start: start + skipped,
                    end: end + skipped,
                    type: "fontFamily"
                };
            }

            // include ","
            ++totalLength;
        }

        // Parse !important.
        var ret = this.parseCSSValue(value, offset);
        if (ret)
        {
            ret.start += skipped;
            ret.end += skipped;
        }
        return ret;
    },

    parseURLValue: function(value)
    {
        var m = reURL.exec(value);
        return m ? m[1] : "";
    },

    parseRepeatValue: function(value)
    {
        var m = reRepeat.exec(value);
        return m ? m[0] : "";
    },

    getPropertyInfo: function(computedStyle, propName)
    {
        var propInfo = {
            property: propName,
            value: computedStyle.getPropertyValue(propName),
            matchedSelectors: [],
            matchedRuleCount: 0
        };

        return propInfo;
    },

    getColorDisplayOptionMenuItems: function()
    {
        return [
            "-",
            {
                label: "computed.option.label.Colors_As_Hex",
                tooltiptext: "computed.option.tip.Colors_As_Hex",
                type: "radio",
                name: "colorDisplay",
                id: "colorDisplayHex",
                command: function() {
                    return Options.set("colorDisplay", "hex");
                },
                checked: Options.get("colorDisplay") == "hex"
            },
            {
                label: "computed.option.label.Colors_As_RGB",
                tooltiptext: "computed.option.tip.Colors_As_RGB",
                type: "radio",
                name: "colorDisplay",
                id: "colorDisplayRGB",
                command: function() {
                    return Options.set("colorDisplay", "rgb");
                },
                checked: Options.get("colorDisplay") == "rgb"
            },
            {
                label: "computed.option.label.Colors_As_HSL",
                tooltiptext: "computed.option.tip.Colors_As_HSL",
                type: "radio",
                name: "colorDisplay",
                id: "colorDisplayHSL",
                command: function() {
                    return Options.set("colorDisplay", "hsl");
                },
                checked: Options.get("colorDisplay") == "hsl"
            }
        ];
    },
});

// ********************************************************************************************* //
// Helpers

function getStyleSheetOwnerNode(sheet)
{
    for (; sheet && !sheet.ownerNode; sheet = sheet.parentStyleSheet);

    return sheet.ownerNode;
}

function findPropByName(props, name)
{
    for (var i = 0; i < props.length; ++i)
    {
        if (props[i].name == name)
            return i;
    }
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.CSSModule);

return Firebug.CSSModule;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/cssPanel",
[
    "firebug/chrome/panel",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/js/sourceLink",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/chrome/window",
    "firebug/lib/search",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/lib/fonts",
    "firebug/lib/xml",
    "firebug/lib/persist",
    "firebug/lib/system",
    "firebug/chrome/menu",
    "firebug/lib/options",
    "firebug/css/cssModule",
    "firebug/css/cssReps",
    "firebug/css/selectorEditor",
    "firebug/lib/trace",
    "firebug/css/cssPanelUpdater",
    "firebug/lib/wrapper",
    "firebug/editor/baseEditor",
    "firebug/editor/editor",
    "firebug/editor/inlineEditor",
    "firebug/chrome/searchBox",
    "firebug/css/cssPanelMutationObserver",
],
function(Panel, Obj, Firebug, Domplate, FirebugReps, Locale, Events, Url, SourceLink, Css, Dom,
    Win, Search, Str, Arr, Fonts, Xml, Persist, System, Menu, Options, CSSModule, CSSInfoTip,
    SelectorEditor, FBTrace, CSSPanelUpdater, Wrapper, BaseEditor, Editor, InlineEditor) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, TAG, DIV, SPAN, TR, P, UL, A, TEXTAREA} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

var CSSDomplateBase =
{
    isEditable: function(rule)
    {
        return !rule.isSystemSheet && !rule.isNotEditable;
    },

    isSelectorEditable: function(rule)
    {
        return rule.isSelectorEditable && this.isEditable(rule);
    },

    getPropertyValue: function(prop)
    {
        // Disabled, see http://code.google.com/p/fbug/issues/detail?id=5880
        /*
        var limit = Options.get("stringCropLength");
        */
        var limit = 0;
        if (limit > 0)
            return Str.cropString(prop.value, limit);
        return prop.value;
    }
};

var CSSPropTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssProp focusRow", $disabledStyle: "$prop.disabled",
            $editGroup: "$rule|isEditable",
            $cssOverridden: "$prop.overridden",
            role: "option"},

            // Use spaces for indent to make "copy to clipboard" nice.
            SPAN({"class": "cssPropIndent"}, "&nbsp;&nbsp;&nbsp;&nbsp;"),
            SPAN({"class": "cssPropName", $editable: "$rule|isEditable"},
                "$prop.name"
            ),

            // Use a space here, so that "copy to clipboard" has it (issue 3266).
            SPAN({"class": "cssColon"}, ": "),
            SPAN({"class": "cssPropValue", $editable: "$rule|isEditable"},
                "$prop|getPropertyValue$prop.important"
            ),
            SPAN({"class": "cssSemi"}, ";")
        )
});

var CSSRuleTag =
    TAG("$rule.tag", {rule: "$rule"});

var CSSImportRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule insertInto focusRow importRule", _repObject: "$rule.rule"},
        "@import &quot;",
        A({"class": "objectLink", _repObject: "$rule.rule.styleSheet"}, "$rule.rule.href"),
        "&quot;",
        SPAN({"class": "separator"}, "$rule.rule|getSeparator"),
        SPAN({"class": "cssMediaQuery", $editable: "$rule|isEditable"},
            "$rule.rule.media.mediaText"),
        ";"
    ),

    getSeparator: function(rule)
    {
        return rule.media.mediaText == "" ? "" : " ";
    }
});

var CSSCharsetRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule focusRow cssCharsetRule", _repObject: "$rule.rule"},
            SPAN({"class": "cssRuleName"}, "@charset"),
            "&nbsp;&quot;",
            SPAN({"class": "cssRuleValue", $editable: "$rule|isEditable"}, "$rule.rule.encoding"),
            "&quot;;"
        )
});

var CSSMediaRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule focusRow cssMediaRule", _repObject: "$rule.rule"},
            DIV({"class": "cssHead focusRow", role : "listitem"},
                SPAN({"class": "cssRuleName"}, "@media"),
                SPAN({"class": "separator"}, " "),
                SPAN({"class": "cssMediaRuleCondition", $editable: "$rule|isEditable"},
                    "$rule.rule.conditionText"),
                SPAN(" {")
            ),
            DIV({"class": "cssRulesListBox", role: "listbox"},
                FOR("subRule", "$rule.subRules",
                    TAG("$subRule.tag", {rule: "$subRule"})
                )
            ),
            DIV({$editable: "$rule|isEditable", $insertBefore:"$rule|isEditable",
                role:"presentation"},
                "}")
        )
});

var CSSSupportsRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule focusRow cssSupportsRule", _repObject: "$rule.rule"},
            DIV({"class": "cssHead focusRow", role : "listitem"},
                SPAN({"class": "cssRuleName"}, "@supports"),
                SPAN({"class": "separator"}, " "),
                SPAN({"class": "cssSupportsRuleCondition", $editable: "$rule|isEditable"},
                "$rule.rule.conditionText"),
                SPAN(" {")
            ),
            DIV({"class": "cssRulesListBox", role: "listbox"},
                FOR("subRule", "$rule.subRules",
                    TAG("$subRule.tag", {rule: "$subRule"})
                )
            ),
            DIV({$editable: "$rule|isEditable", $insertBefore:"$rule|isEditable",
                role:"presentation"},
            "}")
        )
});

var CSSKeyframesRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule focusRow cssKeyframesRule", _repObject: "$rule.rule"},
            DIV({"class": "cssHead focusRow", role : "listitem"},
                SPAN({"class": "cssRuleName"}, "@-moz-keyframes"),
                SPAN({"class": "separator"}, " "),
                SPAN({"class": "cssKeyframesRuleName", $editable: "$rule|isEditable"},
                "$rule.rule.name"),
                SPAN(" {")
            ),
            DIV({"class": "cssRulesListBox", role: "listbox"},
                FOR("subRule", "$rule.subRules",
                    TAG("$subRule.tag", {rule: "$subRule"})
                )
            ),
            DIV({role:"presentation"},
            "}")
        )
});

var CSSKeyframeRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule",
                $cssEditableRule: "$rule|isEditable",
                $insertInto: "$rule|isEditable",
                $editGroup: "$rule|isSelectorEditable",
                _repObject: "$rule.rule",
                role: "presentation"},
            DIV({"class": "cssHead focusRow", role: "listitem"},
                SPAN({"class": "cssKeyText", $editable: "$rule|isEditable"},
                    "$rule.rule.keyText"),
                " {"
            ),
            DIV({role: "group"},
                DIV({"class": "cssPropertyListBox", _rule: "$rule", role: "listbox"},
                    FOR("prop", "$rule.props",
                        TAG(CSSPropTag.tag, {rule: "$rule", prop: "$prop"})
                    )
                )
            ),
            DIV({$editable: "$rule|isEditable", $insertBefore: "$rule|isEditable",
                role:"presentation"},
                "}"
            )
        )
});

var CSSNamespaceRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule focusRow cssNamespaceRule", _repObject: "$rule.rule"},
            SPAN({"class": "cssRuleName"}, "@namespace"),
            SPAN({"class": "separator"}, "$rule.prefix|getSeparator"),
            SPAN({"class": "cssNamespacePrefix", $editable: "$rule|isEditable"}, "$rule.prefix"),
            "&nbsp;&quot;",
            SPAN({"class": "cssNamespaceName", $editable: "$rule|isEditable"}, "$rule.name"),
            "&quot;;"
        ),

    getSeparator: function(prefix)
    {
        return prefix == "" ? "" : " ";
    }
});

var CSSFontFaceRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule cssFontFaceRule",
            $cssEditableRule: "$rule|isEditable",
            $insertInto: "$rule|isEditable",
            _repObject: "$rule.rule",
            role : 'presentation'},
            DIV({"class": "cssHead focusRow", role : "listitem"}, "@font-face {"),
            DIV({role : "group"},
                DIV({"class": "cssPropertyListBox", role: "listbox"},
                    FOR("prop", "$rule.props",
                        TAG(CSSPropTag.tag, {rule: "$rule", prop: "$prop"})
                    )
                )
            ),
            DIV({$editable: "$rule|isEditable", $insertBefore:"$rule|isEditable",
                role:"presentation"},
                "}"
            )
        )
});

var CSSPageRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule focusRow cssPageRule", _repObject: "$rule.rule"},
            DIV({"class": "cssHead focusRow", role : "listitem"},
                SPAN({"class": "cssRuleName"}, "@page"),
                SPAN({"class": "separator"}, "$rule.selectorText|getSeparator"),
                SPAN({"class": "cssPageRuleSelector", $editable: "$rule|isEditable"},
                    "$rule.selectorText|getSelectorText"),
                SPAN(" {")
            ),
            DIV({role : "group"},
                DIV({"class": "cssPropertyListBox", role: "listbox"},
                    FOR("prop", "$rule.props",
                        TAG(CSSPropTag.tag, {rule: "$rule", prop: "$prop"})
                    )
                )
            ),
            DIV({$editable: "$rule|isEditable", $insertBefore:"$rule|isEditable",
                role:"presentation"},
                "}")
        ),

    getSeparator: function(selector)
    {
        return (!selector || selector == "") ? "" : " ";
    },

    getSelectorText: function(selector)
    {
        return selector || "";
    }
});

var CSSDocumentRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule focusRow cssDocumentRule", _repObject: "$rule.rule"},
            DIV({"class": "cssHead focusRow", role : "listitem"},
                SPAN({"class": "cssRuleName"}, "@-moz-document"),
                SPAN({"class": "separator"}, " "),
                SPAN({"class": "cssDocumentRuleCondition", $editable: "$rule|isEditable"},
                "$rule.rule.conditionText"),
                SPAN(" {")
            ),
            DIV({"class": "cssRulesListBox", role: "listbox"},
                FOR("subRule", "$rule.subRules",
                    TAG("$subRule.tag", {rule: "$subRule"})
                )
            ),
            DIV({$editable: "$rule|isEditable", $insertBefore:"$rule|isEditable",
                role:"presentation"},
            "}")
        )
});

var CSSStyleRuleTag = domplate(CSSDomplateBase,
{
    tag:
        DIV({"class": "cssRule",
            $cssEditableRule: "$rule|isEditable",
            $insertInto: "$rule|isEditable",
            $editGroup: "$rule|isSelectorEditable",
            _repObject: "$rule.rule",
            role: "presentation"},
            DIV({"class": "cssHead focusRow", role: "listitem"},
                SPAN({"class": "cssSelector", $editable: "$rule|isSelectorEditable"},
                    "$rule.selector"),
                " {"
            ),
            DIV({role: "group"},
                DIV({"class": "cssPropertyListBox", _rule: "$rule", role: "listbox"},
                    FOR("prop", "$rule.props",
                        TAG(CSSPropTag.tag, {rule: "$rule", prop: "$prop"})
                    )
                )
            ),
            DIV({$editable: "$rule|isEditable", $insertBefore: "$rule|isEditable",
                role:"presentation"},
                "}"
            )
        )
});

Firebug.CSSStyleRuleTag = CSSStyleRuleTag;

// ********************************************************************************************* //
// CSSStyleSheetPanel (CSS Panel)

/**
 * @panel Represents the CSS panel available in main Firebug UI. This panel is responsible
 * for displaying CSS rules coming from the current page.
 * See more: https://getfirebug.com/wiki/index.php/CSS_Panel
 */
Firebug.CSSStyleSheetPanel = function() {};
Firebug.CSSStyleSheetPanel.prototype = Obj.extend(Panel,
/** @lends Firebug.CSSStyleSheetPanel */
{
    name: "stylesheet",
    parentPanel: null,
    searchable: true,
    dependents: ["css", "stylesheet", "dom", "domSide", "layout"],
    enableA11y: true,
    deriveA11yFrom: "css",
    order: 30,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    template: domplate(
    {
        tag:
            DIV({"class": "cssSheet insertInto a11yCSSView"},
                FOR("rule", "$rules",
                    CSSRuleTag
                ),
                DIV({"class": "cssSheet editable insertBefore"}, ""
                )
            )
    }),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function()
    {
        this.onMouseDown = Obj.bind(this.onMouseDown, this);
        this.onMouseUp = Obj.bind(this.onMouseUp, this);
        this.onClick = Obj.bind(this.onClick, this);

        Panel.initialize.apply(this, arguments);

        // Create an updater for asynchronous update (watching embedded iframe loads).
        var callback = this.updateDefaultLocation.bind(this);
        this.updater = new CSSPanelUpdater(this.context, callback);
    },

    destroy: function(state)
    {
        state.scrollTop = this.panelNode.scrollTop ? this.panelNode.scrollTop : this.lastScrollTop;

        Persist.persistObjects(this, state);

        this.stopEditing();

        if (this.updater)
            this.updater.destroy();

        Panel.destroy.apply(this, arguments);
    },

    initializeNode: function(oldPanelNode)
    {
        Events.addEventListener(this.panelNode, "mousedown", this.onMouseDown, false);
        Events.addEventListener(this.panelNode, "mouseup", this.onMouseUp, false);
        Events.addEventListener(this.panelNode, "click", this.onClick, false);

        Panel.initializeNode.apply(this, arguments);
    },

    destroyNode: function()
    {
        Events.removeEventListener(this.panelNode, "mousedown", this.onMouseDown, false);
        Events.removeEventListener(this.panelNode, "mouseup", this.onMouseUp, false);
        Events.removeEventListener(this.panelNode, "click", this.onClick, false);

        Panel.destroyNode.apply(this, arguments);
    },

    show: function(state)
    {
        Firebug.Inspector.stopInspecting(true);

        this.showToolbarButtons("fbCSSButtons", true);
        this.showToolbarButtons("fbLocationSeparator", true);
        this.showToolbarButtons("fbLocationButtons", true);
        this.showToolbarButtons("fbLocationList", true);

        CSSModule.updateEditButton();

        // wait for loadedContext to restore the panel
        if (this.context.loaded && !this.location)
        {
            Persist.restoreObjects(this, state);

            if (!this.location)
                this.location = this.getDefaultLocation();

            if (state && state.scrollTop)
                this.panelNode.scrollTop = state.scrollTop;
        }

        // Solves the problem when the current stylesheet (i.e. the current panel location)
        // has been removed from the page (or the parent window/iframe has been removed).
        // In such case we need to update the panel content.
        if (!this.isValidStyleSheet(this.location))
            this.navigate(null);
    },

    hide: function()
    {
        this.lastScrollTop = this.panelNode.scrollTop;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    isValidStyleSheet: function(styleSheet)
    {
        if (!styleSheet)
            return false;

        if (Wrapper.isDeadWrapper(styleSheet))
            return false;

        if (!styleSheet.ownerNode)
            return false;

        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // TabWatcher

    unwatchWindow: function(context, win)
    {
        // The update happens only if the CSS panel is selected. If the current location
        // style sheet is removed while the panel is not selected, the content will be
        // updated when 'show' method is executed by the framework.
        var panel = Firebug.chrome.getSelectedPanel();
        if (!panel || panel.name != "stylesheet")
            return;

        // We need to check whether the current location (a stylesheet) has been
        // unloaded together with the window.
        if (this.location)
        {
            var ownerNode = this.location.ownerNode;
            var styleSheetDoc = ownerNode ? ownerNode.ownerDocument : null;
            if (styleSheetDoc == win.document)
            {
                this.location = null;
                this.updateDefaultLocation();
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Default Location Update

    /**
     * Executed automatically by {@CSSPanelUpdater} object that is watching window/iframe load.
     */
    updateDefaultLocation: function()
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("cssPanel.updateDefaultLocation; " + this.location, this.location);

        // Try to update the default location if it doesn't exist yet.
        if (!this.location)
        {
            var defaultLocation = this.getDefaultLocation();

            // Still no default location so, keep the updater running.
            if (!defaultLocation)
                return;

            if (FBTrace.DBG_CSS)
                FBTrace.sysout("cssPanel.updateDefaultLocation; DONE", defaultLocation);

            // Use navigate so, the location button visibility is properly updated.
            this.navigate(defaultLocation);
        }
        else
        {
            // The location is set so just make sure to update the content.
            this.updateLocation(this.location);
        }

        if (this.updater)
        {
            // Default location exists so destroy the updater.
            this.updater.destroy();
            this.updater = null;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    refresh: function()
    {
        if (this.location)
            this.updateLocation(this.location);
        else if (this.selection)
            this.updateSelection(this.selection);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // CSS Editing

    startBuiltInEditing: function(css)
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSStyleSheetPanel.startBuiltInEditing", css);

        if (!this.stylesheetEditor)
            this.stylesheetEditor = new StyleSheetEditor(this.document);

        var styleSheet = this.location.editStyleSheet
            ? this.location.editStyleSheet.sheet
            : this.location;

        this.stylesheetEditor.styleSheet = this.location;
        Editor.startEditing(this.panelNode, css, this.stylesheetEditor);

        //this.stylesheetEditor.scrollToLine(topmost.line, topmost.offset);
        this.stylesheetEditor.input.scrollTop = this.panelNode.scrollTop;
    },

    startLiveEditing: function(styleSheet, context)
    {
        var css = getStyleSheetCSS(styleSheet, context);
        this.startBuiltInEditing(css);
    },

    startSourceEditing: function(styleSheet, context)
    {
        if (Firebug.CSSDirtyListener.isDirty(styleSheet, context))
        {
            var prompts = Cc["@mozilla.org/embedcomp/prompt-service;1"].
                getService(Ci.nsIPromptService);

            var proceedToEdit = prompts.confirm(null, Locale.$STR("Firebug"),
                Locale.$STR("confirmation.Edit_CSS_Source"));

            if (!proceedToEdit)
            {
                this.stopEditing();
                return;
            }
        }

        var css = getOriginalStyleSheetCSS(styleSheet, context);
        this.startBuiltInEditing(css);
    },

    stopEditing: function()
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSStyleSheetPanel.stopEditing");

        if (this.currentCSSEditor)
        {
            this.currentCSSEditor.stopEditing();
            delete this.currentCSSEditor;
        }
        else
        {
            Editor.stopEditing();
        }
    },

    toggleEditing: function()
    {
        if (this.editing)
        {
            this.stopEditing();
            Events.dispatch(this.fbListeners, "onStopCSSEditing", [this.context]);
        }
        else
        {
            if (!this.location)
                return;

            var styleSheet = this.location.editStyleSheet
                ? this.location.editStyleSheet.sheet
                : this.location;

            this.currentCSSEditor = CSSModule.getCurrentEditor();
            try
            {
                this.currentCSSEditor.startEditing(styleSheet, this.context, this);
                Events.dispatch(this.fbListeners, "onStartCSSEditing", [styleSheet, this.context]);
            }
            catch(exc)
            {
                var mode = CSSModule.getCurrentEditorName();
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("editor.startEditing ERROR "+exc, {exc: exc, name: mode,
                        currentEditor: this.currentCSSEditor, styleSheet: styleSheet,
                        CSSModule: CSSModule});
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    loadOriginalSource: function()
    {
        if (!this.location)
            return;

        var styleSheet = this.location;

        var css = getOriginalStyleSheetCSS(styleSheet, this.context);

        this.stylesheetEditor.setValue(css);
        this.stylesheetEditor.saveEdit(null, css);
        //styleSheet.editStyleSheet.showUnformated = true;
    },

    getStylesheetURL: function(rule, getBaseUri)
    {
        if (this.location.href)
            return this.location.href;
        else if (getBaseUri)
            return this.context.window.document.baseURI;
        else
            return this.context.window.location.href;
    },

    getRuleByLine: function(styleSheet, line)
    {
        if (!Dom.domUtils)
            return null;

        var cssRules = styleSheet.cssRules;
        for (var i = 0; i < cssRules.length; ++i)
        {
            var rule = cssRules[i];
            var previousRule;
            if (rule instanceof window.CSSStyleRule)
            {
                var selectorLine = Dom.domUtils.getRuleLine(rule);
                // The declarations are on lines equal or greater than the selectorLine
                if (selectorLine === line) // then the line requested is a selector line
                    return rule;
                if (selectorLine > line) // then we passed the rule for the requested line
                    return previousRule;
                // else the requested line is still ahead
                previousRule = rule;
            }
        }
    },

    highlightRule: function(rule)
    {
        var ruleElement = Firebug.getElementByRepObject(this.panelNode.firstChild, rule);
        if (ruleElement)
        {
            Dom.scrollIntoCenterView(ruleElement, this.panelNode);
            Css.setClassTimed(ruleElement, "jumpHighlight", this.context);
        }
    },

    getStyleSheetRules: function(context, styleSheet)
    {
        if (!styleSheet)
            return [];

        var isSystemSheet = Url.isSystemStyleSheet(styleSheet);

        var createRules = function(cssRules)
        {
            var i;
            var props;
            var rules = [];

            if (!cssRules)
                return;

            for (i=0; i<cssRules.length; ++i)
            {
                var rule = cssRules[i];
                if (rule instanceof window.CSSStyleRule)
                {
                    props = this.getRuleProperties(context, rule);
                    rules.push({
                        tag: CSSStyleRuleTag.tag,
                        rule: rule,
                        selector: rule.selectorText.replace(/ :/g, " *:"), // (issue 3683)
                        props: props,
                        isSystemSheet: isSystemSheet,
                        isSelectorEditable: true
                    });
                }
                else if (window.CSSSupportsRule && rule instanceof window.CSSSupportsRule)
                {
                    rules.push({
                        tag: CSSSupportsRuleTag.tag,
                        rule: rule,
                        subRules: createRules(Css.safeGetCSSRules(rule)),
                        isSystemSheet: isSystemSheet
                    });
                }
                else if (rule instanceof window.CSSImportRule)
                {
                    rules.push({tag: CSSImportRuleTag.tag, rule: rule});
                }
                else if (rule instanceof window.CSSCharsetRule)
                {
                    rules.push({tag: CSSCharsetRuleTag.tag, rule: rule});
                }
                else if (rule instanceof window.CSSMediaRule)
                {
                    rules.push({
                        tag: CSSMediaRuleTag.tag,
                        rule: rule,
                        subRules: createRules(Css.safeGetCSSRules(rule)),
                        isSystemSheet: isSystemSheet
                    });
                }
                else if (rule instanceof window.CSSMozDocumentRule)
                {
                    rules.push({
                        tag: CSSDocumentRuleTag.tag,
                        rule: rule,
                        subRules: createRules(Css.safeGetCSSRules(rule)),
                        isSystemSheet: isSystemSheet
                    });
                }
                else if (rule instanceof window.CSSFontFaceRule)
                {
                    props = this.parseCSSProps(rule.style);
                    this.sortProperties(props);
                    rules.push({
                        tag: CSSFontFaceRuleTag.tag,
                        rule: rule,
                        props: props,
                        isSystemSheet: isSystemSheet,
                        isNotEditable: true
                    });
                }
                else if (window.CSSPageRule && rule instanceof window.CSSPageRule)
                {
                    props = this.parseCSSProps(rule.style);
                    this.sortProperties(props);
                    rules.push({
                        tag: CSSPageRuleTag.tag,
                        rule: rule,
                        props: props,
                        isSystemSheet: isSystemSheet,
                        isNotEditable: true
                    });
                }
                else if ((window.CSSKeyframesRule && rule instanceof window.CSSKeyframesRule) ||
                    rule instanceof window.MozCSSKeyframesRule)
                {
                    rules.push({
                        tag: CSSKeyframesRuleTag.tag,
                        rule: rule,
                        subRules: createRules(Css.safeGetCSSRules(rule)),
                        isSystemSheet: isSystemSheet
                    });
                }
                else if ((window.CSSKeyframeRule && rule instanceof window.CSSKeyframeRule) ||
                    rule instanceof window.MozCSSKeyframeRule)
                {
                    props = this.parseCSSProps(rule.style);
                    this.sortProperties(props);
                    rules.push({
                        tag: CSSKeyframeRuleTag.tag,
                        rule: rule,
                        props: props,
                        isSystemSheet: isSystemSheet
                    });
                }
                else if (rule instanceof window.CSSNameSpaceRule)
                {
                    // Workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=754772
                    // MozCSSKeyframesRules, MozCSSKeyframeRules and CSSPageRules are recognized
                    // as CSSNameSpaceRules, so explicitly check whether the rule is not a
                    // MozCSSKeyframesRule, a MozCSSKeyframeRule or a CSSPageRule

                    var reNamespace = /^@namespace ((.+) )?url\("(.*?)"\);$/;
                    var namespace = rule.cssText.match(reNamespace);
                    var prefix = namespace[2] || "";
                    var name = namespace[3];
                    rules.push({tag: CSSNamespaceRuleTag.tag, rule: rule, prefix: prefix,
                        name: name, isNotEditable: true});
                }
                else
                {
                    if (FBTrace.DBG_ERRORS && FBTrace.DBG_CSS)
                        FBTrace.sysout("css getStyleSheetRules failed to classify a rule ", rule);
                }
            }

            return rules;
        }.bind(this);

        return createRules(Css.safeGetCSSRules(styleSheet));
    },

    parseCSSProps: function(style, inheritMode)
    {
        var m;
        var props = [];

        if (Firebug.expandShorthandProps)
        {
            var count = style.length-1;
            var index = style.length;

            while (index--)
            {
                var propName = style.item(count - index);
                this.addProperty(propName, style.getPropertyValue(propName),
                    !!style.getPropertyPriority(propName), false, inheritMode, props);
            }
        }
        else
        {
            var lines = style.cssText.match(/(?:[^;\(]*(?:\([^\)]*?\))?[^;\(]*)*;?/g);
            var propRE = /\s*([^:\s]*)\s*:\s*(.*?)\s*(! important)?;?$/;
            var line;
            var i=0;
            while(line = lines[i++])
            {
                m = propRE.exec(line);
                if(!m)
                    continue;

                //var name = m[1], value = m[2], important = !!m[3];
                if (m[2])
                    this.addProperty(m[1], m[2], !!m[3], false, inheritMode, props);
            }
        }

        return props;
    },

    sortProperties: function(props)
    {
        props.sort(function(a, b)
        {
            return a.name > b.name ? 1 : -1;
        });
    },

    getRuleProperties: function(context, rule, inheritMode)
    {
        var props = this.parseCSSProps(rule.style, inheritMode);

        this.addDisabledProperties(context, rule, inheritMode, props);
        this.sortProperties(props);

        return props;
    },

    addDisabledProperties: function(context, rule, inheritMode, props)
    {
        var disabledMap = this.getDisabledMap(context);
        var moreProps = disabledMap.get(rule);
        if (moreProps)
        {
            var propMap = {};
            for (var i = 0; i < props.length; ++i)
                propMap[props[i].name] = true;

            for (var i = 0; i < moreProps.length; ++i)
            {
                var prop = moreProps[i];
                if (propMap.hasOwnProperty(prop.name))
                {
                    // A (probably enabled) property with the same name as this
                    // disabled one has appeared - remove this one entirely.
                    moreProps.splice(i, 1);
                    --i;
                    continue;
                }
                propMap[prop.name] = true;
                this.addProperty(prop.name, prop.value, prop.important, true, inheritMode, props);
            }
        }
    },

    addProperty: function(name, value, important, disabled, inheritMode, props)
    {
        if (inheritMode && !Dom.domUtils.isInheritedProperty(name))
            return;

        name = this.translateName(name, value);
        if (name)
        {
            value = Css.stripUnits(formatColor(value));
            important = important ? " !important" : "";

            var prop = {name: name, value: value, important: important, disabled: disabled};
            props.push(prop);
        }
    },

    translateName: function(name, value)
    {
        // Don't show these proprietary Mozilla properties
        if ((value == "-moz-initial"
            && (name == "-moz-background-clip" || name == "-moz-background-origin"
                || name == "-moz-background-inline-policy"))
        || (value == "physical"
            && (name == "margin-left-ltr-source" || name == "margin-left-rtl-source"
                || name == "margin-right-ltr-source" || name == "margin-right-rtl-source"))
        || (value == "physical"
            && (name == "padding-left-ltr-source" || name == "padding-left-rtl-source"
                || name == "padding-right-ltr-source" || name == "padding-right-rtl-source")))
            return null;

        // Translate these back to the form the user probably expects
        if (name == "margin-left-value")
            return "margin-left";
        else if (name == "margin-right-value")
            return "margin-right";
        else if (name == "margin-top-value")
            return "margin-top";
        else if (name == "margin-bottom-value")
            return "margin-bottom";
        else if (name == "padding-left-value")
            return "padding-left";
        else if (name == "padding-right-value")
            return "padding-right";
        else if (name == "padding-top-value")
            return "padding-top";
        else if (name == "padding-bottom-value")
            return "padding-bottom";
        // XXXjoe What about border!
        else
            return name;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getDisabledMap: function(context)
    {
        // Ideally, we'd use a WeakMap here, but WeakMaps don't allow CSS rules
        // as keys before Firefox 17. A Map is used instead. (cf. bug 777373.)
        if (!context.cssDisabledMap)
            context.cssDisabledMap = new Map();
        return context.cssDisabledMap;
    },

    remapRule: function(context, oldRule, newRule)
    {
        var map = this.getDisabledMap(context);
        if (map.has(oldRule))
            map.set(newRule, map.get(oldRule));
    },

    editElementStyle: function()
    {
        var rulesBox = this.panelNode.getElementsByClassName("cssElementRuleContainer")[0];
        var styleRuleBox = rulesBox && Firebug.getElementByRepObject(rulesBox, this.selection);
        if (!styleRuleBox)
        {
            var rule = {
                rule: this.selection,
                inherited: false,
                selector: "element.style",
                props: []
            };

            if (!rulesBox)
            {
                // The element did not have any displayed styles. We need to create the
                // whole tree and remove the no styles message
                styleRuleBox = this.template.cascadedTag.replace({
                    rules: [rule], inherited: [], inheritLabel: Locale.$STR("InheritedFrom")
                }, this.panelNode);

                styleRuleBox = styleRuleBox.getElementsByClassName("cssElementRuleContainer")[0];
            }
            else
            {
                styleRuleBox = this.template.ruleTag.insertBefore({rule: rule}, rulesBox);
            }

            styleRuleBox = styleRuleBox.getElementsByClassName("insertInto")[0];
        }

        Editor.insertRowForObject(styleRuleBox);
    },

    addRelatedRule: function()
    {
        if (!this.panelNode.getElementsByClassName("cssElementRuleContainer")[0])
        {
            // The element did not have any displayed styles - create the whole
            // tree and remove the no styles message.
            this.template.cascadedTag.replace({
                rules: [], inherited: [],
                inheritLabel: Locale.$STR("InheritedFrom")
            }, this.panelNode);
        }

        // Insert the new rule at the top, or after the style rules if there
        // are any.
        var container = this.panelNode.getElementsByClassName("cssNonInherited")[0];
        var ruleBox = container.getElementsByClassName("cssElementRuleContainer")[0];
        var styleRuleBox = ruleBox && Firebug.getElementByRepObject(ruleBox, this.selection);
        if (styleRuleBox)
            ruleBox = this.template.newRuleTag.insertAfter({}, ruleBox);
        else if (ruleBox)
            ruleBox = this.template.newRuleTag.insertBefore({}, ruleBox);
        else
            ruleBox = this.template.newRuleTag.append({}, container);

        var before = ruleBox.getElementsByClassName("insertBefore")[0];
        Editor.insertRow(before, "before");

        // Auto-fill the selector field with something reasonable, like
        // ".some-class" or "#table td".
        var el = this.selection, doc = el.ownerDocument;
        var base = Xml.getNodeName(el), autofill;
        if (el.className)
        {
            autofill = "." + Arr.cloneArray(el.classList).join(".");
        }
        else
        {
            var level = 0;
            el = el.parentNode;
            while (!autofill && el !== doc)
            {
                ++level;
                if (el.id !== "")
                    autofill = "#" + el.id;
                else if (el.className !== "")
                    autofill = "." + Arr.cloneArray(el.classList).join(".");
                el = el.parentNode;
            }
            if (autofill)
            {
                if (level === 1)
                    autofill += " >";
                autofill += " " + base;
            }
        }

        if (!autofill ||
            doc.querySelectorAll(autofill).length === doc.querySelectorAll(base).length)
        {
            autofill = base;
        }

        this.ruleEditor.setValue(autofill);
        this.ruleEditor.input.select();
        Editor.update(true);
    },

    editMediaQuery: function(target)
    {
        var row = Dom.getAncestorByClass(target, "cssRule");
        var mediaQueryBox = Dom.getChildByClass(row, "cssMediaQuery");
        Editor.startEditing(mediaQueryBox);
    },

    insertPropertyRow: function(row)
    {
        Editor.insertRowForObject(row);
    },

    insertRule: function(row)
    {
        var location = Dom.getAncestorByClass(row, "cssRule");
        if (!location)
        {
            location = Dom.getChildByClass(this.panelNode, "cssSheet");

            // Stylesheet has no rules
            if (!location)
                this.template.tag.replace({rules: []}, this.panelNode);

            location = Dom.getChildByClass(this.panelNode, "cssSheet");
            Editor.insertRowForObject(location);
        }
        else
        {
            Editor.insertRow(location, "before");
        }
    },

    editPropertyRow: function(row)
    {
        var propValueBox = Dom.getChildByClass(row, "cssPropValue");
        Editor.startEditing(propValueBox);
    },

    deletePropertyRow: function(row)
    {
        var rule = Firebug.getRepObject(row);
        var propName = Dom.getChildByClass(row, "cssPropName").textContent;

        // Try removing the property from the "disabled" map.
        var wasDisabled = this.removeDisabledProperty(rule, propName);

        // If that fails, remove the actual property instead.
        if (!wasDisabled)
            CSSModule.deleteProperty(rule, propName, this.context);

        if (this.name == "stylesheet")
            Events.dispatch(this.fbListeners, "onInlineEditorClose", [this, row.firstChild, true]);

        row.parentNode.removeChild(row);

        this.markChange(this.name == "stylesheet");
    },

    removeDisabledProperty: function(rule, propName)
    {
        var disabledMap = this.getDisabledMap(this.context);
        var map = disabledMap.get(rule);
        if (!map)
            return false;
        for (var i = 0; i < map.length; ++i)
        {
            if (map[i].name === propName)
            {
                map.splice(i, 1);
                return true;
            }
        }
        return false;
    },

    disablePropertyRow: function(row)
    {
        Css.toggleClass(row, "disabledStyle");

        var rule = Firebug.getRepObject(row);
        var propName = Dom.getChildByClass(row, "cssPropName").textContent;

        var disabledMap = this.getDisabledMap(this.context);
        if (!disabledMap.has(rule))
            disabledMap.set(rule, []);
        var map = disabledMap.get(rule);

        var propValue = Dom.getChildByClass(row, "cssPropValue").textContent;
        var parsedValue = parsePriority(propValue);

        CSSModule.disableProperty(Css.hasClass(row, "disabledStyle"), rule,
            propName, parsedValue, map, this.context);

        this.markChange(this.name == "stylesheet");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    // When handling disable button clicks, we cannot simply use a 'click'
    // event, because refresh() may be (and often is) called in between
    // mousedown and mouseup, replacing the DOM structure. Instead, a
    // description of the moused-down disable button's property is saved
    // and explicitly checked on mouseup (issue 5500).
    clickedPropTag: null,

    getPropTag: function(event)
    {
        var row = Dom.getAncestorByClass(event.target, "cssProp");
        var rule = Firebug.getRepObject(row);
        var propName = Dom.getChildByClass(row, "cssPropName").textContent;
        return {
            a: rule, b: propName,
            equals: function(other)
            {
                return (other && this.a === other.a && this.b === other.b);
            }
        };
    },

    clickedDisableButton: function(event)
    {
        if (!Css.hasClass(event.target, "cssPropIndent"))
            return false;

        // XXX hack
        var clientOffset = Dom.getClientOffset(event.target);
        if (event.clientX - clientOffset.x > 20)
            return false;
        if (Css.hasClass(event.target, "textEditor inlineExpander"))
            return false;
        var row = Dom.getAncestorByClass(event.target, "cssProp");
        return (row && Css.hasClass(row, "editGroup"));
    },

    onMouseDown: function(event)
    {
        this.clickedPropTag = null;
        if (Events.isLeftClick(event) && this.clickedDisableButton(event))
        {
            this.clickedPropTag = this.getPropTag(event);

            // Don't select text when double-clicking the disable button.
            Events.cancelEvent(event);
        }
    },

    onMouseUp: function(event)
    {
        if (Events.isLeftClick(event) && this.clickedDisableButton(event) &&
            this.getPropTag(event).equals(this.clickedPropTag))
        {
            var row = Dom.getAncestorByClass(event.target, "cssProp");
            this.disablePropertyRow(row);
            Events.cancelEvent(event);
        }
        this.clickedPropTag = null;
    },

    onClick: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        if (Events.isDoubleClick(event) && !this.clickedDisableButton(event))
        {
            var row = Dom.getAncestorByClass(event.target, "cssRule");
            if (row && !Dom.getAncestorByClass(event.target, "cssPropName")
                && !Dom.getAncestorByClass(event.target, "cssPropValue"))
            {
                this.insertPropertyRow(row);
                Events.cancelEvent(event);
            }
        }
    },

    supportsObject: function(object, type)
    {
        if (object instanceof window.CSSStyleSheet)
        {
            return 1;
        }
        else if (object instanceof window.CSSRule ||
            (object instanceof window.CSSStyleDeclaration && object.parentRule) ||
            (object instanceof SourceLink.SourceLink && object.type == "css" &&
                Url.reCSS.test(object.href)))
        {
            return 2;
        }
        else
        {
            return 0;
        }
    },

    updateLocation: function(styleSheet)
    {
        if (FBTrace.DBG_CSS)
        {
            FBTrace.sysout("css.updateLocation; " + (styleSheet ? styleSheet.href :
                "no stylesheet"));
        }

        this.doUpdateLocation(styleSheet);
    },

    doUpdateLocation: function(styleSheet)
    {
        if (FBTrace.DBG_CSS)
        {
            FBTrace.sysout("css.doUpdateLocation; " + (styleSheet ? styleSheet.href :
                "no stylesheet"));
        }

        var rules = [];
        if (styleSheet)
        {
            if (!Css.shouldIgnoreSheet(styleSheet))
            {
                if (styleSheet.editStyleSheet)
                    styleSheet = styleSheet.editStyleSheet.sheet;

                rules = this.getStyleSheetRules(this.context, styleSheet);
            }
        }

        if (rules && rules.length)
        {
            this.template.tag.replace({rules: rules}, this.panelNode);
        }
        else
        {
            // If there are no rules on the page display a description that also
            // contains a link "create a rule".
            var warning = FirebugReps.Warning.tag.replace({object: ""}, this.panelNode);
            FirebugReps.Description.render(Locale.$STR("css.EmptyStyleSheet"),
                warning, Obj.bind(this.insertRule, this));
        }

        // Show CSS buttons only if there is a stylesheet and it isn't a system stylesheet.
        // Displaying panel's buttons must happens only if the panel is actually visible
        // otherwise the button could appear on another panel's toolbar.
        var showButtons = this.location && !Url.isSystemStyleSheet(this.location);
        this.showToolbarButtons("fbCSSButtons", showButtons);

        Events.dispatch(this.fbListeners, "onCSSRulesAdded", [this, this.panelNode]);

        // If the full editing mode (not the inline) is on while the location changes,
        // open the editor again for another file.
        if (this.editing && this.stylesheetEditor && this.stylesheetEditor.editing)
        {
            // Remove the editing flag to avoid recursion. The StylesheetEditor.endEditing
            // calls refresh and consequently updateLocation of the CSS panel.
            this.editing = null;

            // Stop the current editing.
            this.stopEditing();

            // ... and open the editor again.
            this.toggleEditing();
        }
    },

    updateSelection: function(object)
    {
        this.selection = null;

        if (object instanceof window.CSSStyleDeclaration)
        {
            object = object.parentRule;
        }

        if (object instanceof window.CSSRule)
        {
            this.navigate(object.parentStyleSheet);
            this.highlightRule(object);
        }
        else if (object instanceof window.CSSStyleSheet)
        {
            this.navigate(object);
        }
        else if (object instanceof SourceLink.SourceLink)
        {
            try
            {
                var sourceLink = object;

                var sourceFile = Firebug.SourceFile.getSourceFileByHref(
                    sourceLink.href, this.context);

                if (sourceFile)
                {
                    Dom.clearNode(this.panelNode);  // replace rendered stylesheets

                    // xxxHonza: huh, this method doesn't even exist?
                    this.showSourceFile(sourceFile);

                    var lineNo = object.line;
                    if (lineNo)
                        this.scrollToLine(lineNo, this.jumpHighlightFactory(lineNo, this.context));
                }
                else // XXXjjb we should not be taking this path
                {
                    var stylesheet = Css.getStyleSheetByHref(sourceLink.href, this.context);
                    if (stylesheet)
                    {
                        this.navigate(stylesheet);
                    }
                    else
                    {
                        if (FBTrace.DBG_CSS)
                            FBTrace.sysout("css.updateSelection no sourceFile for " +
                                sourceLink.href, sourceLink);
                    }
                }
            }
            catch(exc)
            {
                if (FBTrace.DBG_CSS)
                    FBTrace.sysout("css.upDateSelection FAILS "+exc, exc);
            }
        }
    },

    updateOption: function(name, value)
    {
        if (name == "expandShorthandProps" || name == "colorDisplay")
            this.refresh();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getLocationList: function()
    {
        var styleSheets = Css.getAllStyleSheets(this.context);
        return styleSheets;
    },

    getOptionsMenuItems: function()
    {
        items = [
             Menu.optionMenu("Expand_Shorthand_Properties", "expandShorthandProps",
             "css.option.tip.Expand_Shorthand_Properties")
        ];

        items = Arr.extendArray(items, CSSModule.getColorDisplayOptionMenuItems());

        items.push(
            "-",
            {
                label: "Refresh",
                tooltiptext: "panel.tip.Refresh",
                command: Obj.bind(this.refresh, this)
            }
        );

        return items;
    },

    getContextMenuItems: function(style, target)
    {
        var items = [];

        if (target.nodeName == "TEXTAREA")
        {
            items = BaseEditor.getContextMenuItems();
            items.push(
                "-",
                {
                    id: "fbLoadOriginalSource",
                    label: "Load_Original_Source",
                    tooltiptext: "css.tip.Load_Original_Source",
                    command: Obj.bindFixed(this.loadOriginalSource, this)
                }
            );
            return items;
        }

        if (Css.hasClass(target, "cssSelector"))
        {
            items.push(
                {
                    id: "fbCopyRuleDeclaration",
                    label: "Copy_Rule_Declaration",
                    tooltiptext: "css.tip.Copy_Rule_Declaration",
                    command: Obj.bindFixed(this.copyRuleDeclaration, this, target)
                },
                {
                    id: "fbCopyStyleDeclaration",
                    label: "Copy_Style_Declaration",
                    tooltiptext: "css.tip.Copy_Style_Declaration",
                    command: Obj.bindFixed(this.copyStyleDeclaration, this, target)
                }
            );
        }

        var prop = Dom.getAncestorByClass(target, "cssProp");
        if (prop)
        {
            items.push(
                {
                    id: "fbCopyPropertyDeclaration",
                    label: "css.label.Copy_Property_Declaration",
                    tooltiptext: "css.tip.Copy_Property_Declaration",
                    command: Obj.bindFixed(this.copyPropertyDeclaration, this, prop)
                },
                {
                    id: "fbCopyPropertyName",
                    label: "css.label.Copy_Property_Name",
                    tooltiptext: "css.tip.Copy_Property_Name",
                    command: Obj.bindFixed(this.copyPropertyName, this, prop)
                },
                {
                    id: "fbCopyPropertyValue",
                    label: "css.label.Copy_Property_Value",
                    tooltiptext: "css.tip.Copy_Property_Value",
                    command: Obj.bindFixed(this.copyPropertyValue, this, prop)
                }
            );
        }

        var propValue = Dom.getAncestorByClass(target, "cssPropValue");
        if (propValue)
        {
            if (this.infoTipType == "color")
            {
                items.push(
                    {
                        id: "fbCopyColor",
                        label: "CopyColor",
                        tooltiptext: "css.tip.Copy_Color",
                        command: Obj.bindFixed(System.copyToClipboard, System, this.infoTipObject)
                    }
                );
            }
            else if (this.infoTipType == "image")
            {
                items.push(
                    {
                        id: "fbCopyImageLocation",
                        label: "CopyImageLocation",
                        tooltiptext: "css.tip.Copy_Image_Location",
                        command: Obj.bindFixed(System.copyToClipboard, System, this.infoTipObject)
                    },
                    {
                        id: "fbOpenImageInNewTab",
                        label: "OpenImageInNewTab",
                        tooltiptext: "css.tip.Open_Image_In_New_Tab",
                        command: Obj.bindFixed(Win.openNewTab, Win, this.infoTipObject)
                    }
                );
            }
        }

        // Make sure this item always get appended for the Style panel (name == "css");
        // it acts as a placeholder and gets replaced by other menu items.
        // This is a bit of a hack.
        if (this.name == "css" || !Url.isSystemStyleSheet(this.selection))
        {
            items.push(
                "-",
                {
                    id: "fbNewCSSRule",
                    label: "NewRule",
                    tooltiptext: "css.tip.New_Rule",
                    command: Obj.bindFixed(this.insertRule, this, target)
                }
            );
        }

        if (Css.hasClass(target, "cssSelector"))
        {
            var selector = Str.cropString(target.textContent, 30);
            items.push(
                {
                    id: "fbDeleteRuleDeclaration",
                    label: Locale.$STRF("css.Delete_Rule", [selector]),
                    tooltiptext: Locale.$STRF("css.tip.Delete_Rule", [selector]),
                    nol10n: true,
                    command: Obj.bindFixed(this.deleteRuleDeclaration, this, target)
                }
            );
        }

        var cssRule = Dom.getAncestorByClass(target, "cssRule");
        if (cssRule)
        {
            if(Css.hasClass(cssRule, "cssEditableRule"))
            {
                items.push(
                    "-",
                    {
                        id: "fbNewCSSProp",
                        label: "NewProp",
                        tooltiptext: "css.tip.New_Prop",
                        command: Obj.bindFixed(this.insertPropertyRow, this, target)
                    }
                );

                var propRow = Dom.getAncestorByClass(target, "cssProp");
                if (propRow)
                {
                    var propName = Dom.getChildByClass(propRow, "cssPropName").textContent;
                    var isDisabled = Css.hasClass(propRow, "disabledStyle");

                    items.push(
                        {
                            id: "fbEditCSSProp",
                            label: Locale.$STRF("EditProp", [propName]),
                            tooltiptext: Locale.$STRF("css.tip.Edit_Prop", [propName]),
                            nol10n: true,
                            command: Obj.bindFixed(this.editPropertyRow, this, propRow)
                        },
                        {
                            id: "fbDeleteCSSProp",
                            label: Locale.$STRF("DeleteProp", [propName]),
                            tooltiptext: Locale.$STRF("css.tip.Delete_Prop", [propName]),
                            nol10n: true,
                            command: Obj.bindFixed(this.deletePropertyRow, this, propRow)
                        },
                        {
                            id: "fbDisableCSSProp",
                            label: Locale.$STRF("DisableProp", [propName]),
                            tooltiptext: Locale.$STRF("css.tip.Disable_Prop", [propName]),
                            nol10n: true,
                            type: "checkbox",
                            checked: isDisabled,
                            command: Obj.bindFixed(this.disablePropertyRow, this, propRow)
                        }
                    );
                }
            }

            if (Css.hasClass(cssRule, "importRule"))
            {
                items.push(
                    {
                        id: "fbEditMediaQuery",
                        label: "css.menu.Edit_Media_Query",
                        tooltiptext: "css.menu.tip.Edit_Media_Query",
                        command: Obj.bindFixed(this.editMediaQuery, this, target)
                    }
                );
            }
        }

        items.push(
            "-",
            {
                id: "fbRefresh",
                label: "Refresh",
                command: Obj.bind(this.refresh, this),
                tooltiptext: "panel.tip.Refresh"
            }
        );

        return items;
    },

    browseObject: function(object)
    {
        if (this.infoTipType == "image")
        {
            Win.openNewTab(this.infoTipObject);
            return true;
        }
    },

    showInfoTip: function(infoTip, target, x, y, rangeParent, rangeOffset)
    {
        var propValue = Dom.getAncestorByClass(target, "cssPropValue");
        if (propValue)
        {
            var prop = Dom.getAncestorByClass(target, "cssProp");
            var styleRule = Firebug.getRepObject(prop);
            var propNameNode = prop.getElementsByClassName("cssPropName").item(0);
            var propName = propNameNode.textContent.toLowerCase();
            var priority = styleRule.style.getPropertyPriority(propName);
            var text = styleRule.style.getPropertyValue(propName) +
                (priority ? " !" + priority : "");

            if (text != "")
            {
                text = formatColor(text);
            }
            else
            {
                var disabledMap = this.getDisabledMap(this.context);
                var disabledProps = disabledMap.get(styleRule);
                if (disabledProps)
                {
                    for (var i = 0, len = disabledProps.length; i < len; ++i)
                    {
                        if (disabledProps[i].name == propName)
                        {
                            priority = disabledProps[i].important;
                            text = disabledProps[i].value + (priority ? " !" + priority : "");
                            break;
                        }
                    }
                }
            }

            var cssValue;
            if (propName == "font" || propName == "font-family")
            {
                if (text.charAt(rangeOffset) == ",")
                    return;

                cssValue = CSSModule.parseCSSFontFamilyValue(text, rangeOffset, propName);
            }
            else
            {
                cssValue = CSSModule.parseCSSValue(text, rangeOffset);
            }

            if (!cssValue)
                return false;

            if (cssValue.value === "currentcolor")
            {
                cssValue.value = this.getCurrentColor();
                if (cssValue.value === "")
                    return false;
            }

            if (cssValue.value == this.infoTipValue)
                return true;

            this.infoTipValue = cssValue.value;

            switch (cssValue.type)
            {
                case "rgb":
                case "hsl":
                case "gradient":
                case "colorKeyword":
                    this.infoTipType = "color";
                    this.infoTipObject = cssValue.value;
                    return CSSInfoTip.populateColorInfoTip(infoTip, cssValue.value);

                case "url":
                    if (Css.isImageRule(Xml.getElementSimpleType(Firebug.getRepObject(target)),
                        propNameNode.textContent))
                    {
                        var prop = Dom.getAncestorByClass(target, "cssProp");
                        var rule = Firebug.getRepObject(prop);
                        var baseURL = this.getStylesheetURL(rule, true);
                        var relURL = CSSModule.parseURLValue(cssValue.value);
                        var absURL = Url.isDataURL(relURL) ? relURL : Url.absoluteURL(relURL, baseURL);
                        var repeat = CSSModule.parseRepeatValue(text);

                        this.infoTipType = "image";
                        this.infoTipObject = absURL;

                        return CSSInfoTip.populateImageInfoTip(infoTip, absURL, repeat);
                    }
                    break;

                case "fontFamily":
                    return CSSInfoTip.populateFontFamilyInfoTip(infoTip, cssValue.value);
            }

            delete this.infoTipType;
            delete this.infoTipValue;
            delete this.infoTipObject;

            return false;
        }
    },

    getCurrentColor: function()
    {
        return "";
    },

    getEditor: function(target, value)
    {
        if (target == this.panelNode
            || Css.hasClass(target, "cssSelector") || Css.hasClass(target, "cssRule")
            || Css.hasClass(target, "cssSheet"))
        {
            if (!this.ruleEditor)
                this.ruleEditor = new CSSRuleEditor(this.document);

            return this.ruleEditor;
        }
        else
        {
            if (!this.editor)
                this.editor = new CSSEditor(this.document);

            return this.editor;
        }
    },

    getDefaultLocation: function()
    {
        // Note: We can't do makeDefaultStyleSheet here, because that could be
        // damaging for special pages (see e.g. issues 2440, 3688).
        try
        {
            var styleSheets = this.getLocationList();
            if (styleSheets.length)
            {
                var sheet = styleSheets[0];
                return (Firebug.filterSystemURLs &&
                    Url.isSystemURL(Css.getURLForStyleSheet(sheet))) ? null : sheet;
            }
        }
        catch (exc)
        {
            if (FBTrace.DBG_LOCATIONS)
                FBTrace.sysout("css.getDefaultLocation FAILS "+exc, exc);
        }
    },

    getObjectLocation: function(styleSheet)
    {
        return Css.getURLForStyleSheet(styleSheet);
    },

    getObjectDescription: function(styleSheet)
    {
        var url = Css.getURLForStyleSheet(styleSheet);
        var instance = Css.getInstanceForStyleSheet(styleSheet);

        var baseDescription = Url.splitURLBase(url);
        if (instance) {
          baseDescription.name = baseDescription.name + " #" + (instance + 1);
        }
        return baseDescription;
    },

    getSourceLink: function(target, rule)
    {
        var element = rule.parentStyleSheet.ownerNode;
        var href = rule.parentStyleSheet.href;  // Null means inline

        // http://code.google.com/p/fbug/issues/detail?id=452
        if (!href)
            href = element.ownerDocument.location.href;

        var line = getRuleLine(rule);
        var instance = Css.getInstanceForStyleSheet(rule.parentStyleSheet);
        var sourceLink = new SourceLink.SourceLink(href, line, "css", rule, instance);

        return sourceLink;
    },

    getTopmostRuleLine: function()
    {
        var panelNode = this.panelNode;
        for (var child = panelNode.firstChild; child; child = child.nextSibling)
        {
            if (child.offsetTop+child.offsetHeight > panelNode.scrollTop)
            {
                var rule = child.repObject;
                if (rule)
                {
                    return {
                        line: getRuleLine(rule),
                        offset: panelNode.scrollTop-child.offsetTop
                    };
                }
            }
        }
        return 0;
    },

    getCurrentLineNumber: function()
    {
        var ruleLine = this.getTopMostRuleLine();
        if (ruleLine)
            return ruleLine.line;
    },

    search: function(text, reverse)
    {
        var curDoc = this.searchCurrentDoc(!Firebug.searchGlobal, text, reverse);
        if (!curDoc && Firebug.searchGlobal)
        {
            return this.searchOtherDocs(text, reverse) ||
                this.searchCurrentDoc(true, text, reverse);
        }
        return curDoc;
    },

    searchOtherDocs: function(text, reverse)
    {
        var scanRE = Firebug.Search.getTestingRegex(text);
        function scanDoc(styleSheet) {
            // we don't care about reverse here as we are just looking for existence,
            // if we do have a result we will handle the reverse logic on display
            for (var i = 0; i < styleSheet.cssRules.length; i++)
            {
                if (scanRE.test(styleSheet.cssRules[i].cssText))
                {
                    return true;
                }
            }
        }

        if (this.navigateToNextDocument(scanDoc, reverse))
        {
            // firefox findService can't find nodes immediatly after insertion
            // xxxHonza: the timeout has been increased to 100 since search across
            // multiple documents didn't work sometimes.
            // Of course, it would be great to get rid of the timeout.
            setTimeout(Obj.bind(this.searchCurrentDoc, this), 100, true, text, reverse);
            return "wraparound";
        }
    },

    searchCurrentDoc: function(wrapSearch, text, reverse)
    {
        var row, sel;

        if (!text)
        {
            delete this.currentSearch;
            this.highlightNode(null);
            this.document.defaultView.getSelection().removeAllRanges();
            return false;
        }

        if (this.currentSearch && text == this.currentSearch.text)
        {
            row = this.currentSearch.findNext(wrapSearch, false, reverse,
                Firebug.Search.isCaseSensitive(text));
        }
        else
        {
            if (this.editing)
            {
                this.currentSearch = new Search.TextSearch(this.stylesheetEditor.box);
                row = this.currentSearch.find(text, reverse, Firebug.Search.isCaseSensitive(text));

                if (row)
                {
                    sel = this.document.defaultView.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(this.currentSearch.range);

                    scrollSelectionIntoView(this);
                    this.highlightNode(row);

                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                function findRow(node) {
                    return node.nodeType == Node.ELEMENT_NODE ? node : node.parentNode;
                }

                this.currentSearch = new Search.TextSearch(this.panelNode, findRow);
                row = this.currentSearch.find(text, reverse, Firebug.Search.isCaseSensitive(text));
            }
        }

        if (row)
        {
            sel = this.document.defaultView.getSelection();
            sel.removeAllRanges();
            sel.addRange(this.currentSearch.range);

            // Should be replaced by scrollToLine() of sourceBox,
            // though first jumpHighlightFactory() has to be adjusted to
            // remove the current highlighting when called again
            Dom.scrollIntoCenterView(row, this.panelNode);
            this.highlightNode(row.parentNode);

            Events.dispatch(this.fbListeners, "onCSSSearchMatchFound", [this, text, row]);
            return this.currentSearch.wrapped ? "wraparound" : true;
        }
        else
        {
            this.document.defaultView.getSelection().removeAllRanges();
            Events.dispatch(this.fbListeners, "onCSSSearchMatchFound", [this, text, null]);
            return false;
        }
    },

    getSearchOptionsMenuItems: function()
    {
        return [
            Firebug.Search.searchOptionMenu("search.Case_Sensitive", "searchCaseSensitive",
                "search.tip.Case_Sensitive"),
            Firebug.Search.searchOptionMenu("search.Multiple_Files", "searchGlobal",
                "search.tip.Multiple_Files"),
            Firebug.Search.searchOptionMenu("search.Use_Regular_Expression",
                "searchUseRegularExpression", "search.tip.Use_Regular_Expression")
        ];
    },

    getStyleDeclaration: function(cssSelector)
    {
        var cssRule = Dom.getAncestorByClass(cssSelector, "cssRule");
        var propRows = cssRule.getElementsByClassName("cssProp");

        var lines = [];
        for (var i = 0; i < propRows.length; ++i)
        {
            var row = propRows[i];
            if (row.classList.contains("disabledStyle"))
                continue;

            var name = Dom.getChildByClass(row, "cssPropName").textContent;
            var value = Dom.getChildByClass(row, "cssPropValue").textContent;
            lines.push(name + ": " + value + ";");
        }

        return lines;
    },

    copyRuleDeclaration: function(cssSelector)
    {
        var props = this.getStyleDeclaration(cssSelector);
        System.copyToClipboard(cssSelector.textContent + " {" + Str.lineBreak() + "  " +
            props.join(Str.lineBreak() + "  ") + Str.lineBreak() + "}");
    },

    deleteRuleDeclaration: function(cssSelector)
    {
        var searchRule = Firebug.getRepObject(cssSelector) ||
            Firebug.getRepObject(cssSelector.nextSibling);
        var styleSheet = searchRule.parentRule || searchRule.parentStyleSheet;
        var ruleIndex = 0;
        var cssRules = styleSheet.cssRules;
        while (ruleIndex < cssRules.length && searchRule != cssRules[ruleIndex])
            ruleIndex++;

        if (FBTrace.DBG_CSS)
        {
            FBTrace.sysout("css.deleteRuleDeclaration; selector: "+
                Str.cropString(cssSelector.textContent, 100),
                {styleSheet: styleSheet, ruleIndex: ruleIndex});
        }

        CSSModule.deleteRule(styleSheet, ruleIndex);

        var rule = Dom.getAncestorByClass(cssSelector, "cssRule");
        if (rule)
            rule.parentNode.removeChild(rule);
    },

    copyStyleDeclaration: function(cssSelector)
    {
        var props = this.getStyleDeclaration(cssSelector);
        System.copyToClipboard(props.join(Str.lineBreak()));
    },

    copyPropertyDeclaration: function(prop)
    {
        // xxxsz: repObject should be used instead
        System.copyToClipboard(Str.trim(prop.textContent));
    },

    copyPropertyName: function(prop)
    {
        // xxxsz: repObject should be used instead
        var propName = prop.getElementsByClassName("cssPropName")[0];
        System.copyToClipboard(propName.textContent);
    },

    copyPropertyValue: function(prop)
    {
        // xxxsz: repObject should be used instead
        var propValue = prop.getElementsByClassName("cssPropValue")[0];
        System.copyToClipboard(propValue.textContent);
    }
});

// ********************************************************************************************* //
// CSSEditor

function CSSEditor(doc)
{
    this.initializeInline(doc);
}

CSSEditor.prototype = domplate(InlineEditor.prototype,
{
    insertNewRow: function(target, insertWhere)
    {
        var rule = Firebug.getRepObject(target);
        if (!rule)
        {
            if (FBTrace.DBG_CSS)
                FBTrace.sysout("CSSEditor.insertNewRow; ERROR There is no CSS rule", target);
            return;
        }

        var emptyProp = {name: "", value: "", important: ""};

        if (insertWhere == "before")
            return CSSPropTag.tag.insertBefore({prop: emptyProp, rule: rule}, target);
        else
            return CSSPropTag.tag.insertAfter({prop: emptyProp, rule: rule}, target);
    },

    saveEdit: function(target, value, previousValue)
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSEditor.saveEdit", arguments);

        var cssRule = Dom.getAncestorByClass(target, "cssRule");
        var rule = Firebug.getRepObject(cssRule);

        if (rule instanceof window.CSSStyleRule ||
                ((window.CSSKeyframeRule && rule instanceof window.CSSKeyframeRule) ||
                    rule instanceof window.MozCSSKeyframeRule) &&
                !Css.hasClass(target, "cssKeyText") ||
            rule instanceof window.Element)
        {
            var prop = Dom.getAncestorByClass(target, "cssProp");

            if (prop)
            {
                var propName = Dom.getChildByClass(prop, "cssPropName").textContent;
                // If the property was previously disabled, remove it from the "disabled"
                // map. (We will then proceed to enable the property.)
                if (prop && prop.classList.contains("disabledStyle"))
                {
                    prop.classList.remove("disabledStyle");

                    this.panel.removeDisabledProperty(rule, propName);
                }

                if (Css.hasClass(target, "cssPropName"))
                {
                    // Actual saving is done in endEditing, see the comment there.
                    target.textContent = value;
                }
                else if (Dom.getAncestorByClass(target, "cssPropValue"))
                {
                    target.textContent = CSSDomplateBase.getPropertyValue({value: value});

                    propName = Dom.getChildByClass(prop, "cssPropName").textContent;

                    if (FBTrace.DBG_CSS)
                    {
                        FBTrace.sysout("CSSEditor.saveEdit \"" + propName + "\" = \"" +
                            value + "\"");
                       // FBTrace.sysout("CSSEditor.saveEdit BEFORE style:",style);
                    }

                    if (value && value != "null")
                    {
                        var parsedValue = parsePriority(value);
                        CSSModule.setProperty(rule, propName, parsedValue.value,
                            parsedValue.priority);
                    }
                    else if (previousValue && previousValue != "null")
                    {
                        CSSModule.removeProperty(rule, propName);
                    }
                }

                if (value)
                {
                    var saveSuccess = false;
                    if (Css.hasClass(target, "cssPropName"))
                    {
                        var propName = value.replace(/-./g, function(match)
                        {
                            return match[1].toUpperCase();
                        });

                        if (propName in rule.style || propName == "float")
                            saveSuccess = "almost";
                    }
                    else
                    {
                        saveSuccess = !!rule.style.getPropertyValue(propName);
                    }

                    this.box.setAttribute("saveSuccess", saveSuccess);
                }
                else
                {
                    this.box.removeAttribute("saveSuccess");
                }
            }
        }
        else if (window.CSSSupportsRule && rule instanceof window.CSSSupportsRule &&
            Css.hasClass(target, "cssSupportsRuleCondition"))
        {
            target.textContent = value;

            if (FBTrace.DBG_CSS)
            {
                FBTrace.sysout("CSSEditor.saveEdit: @supports rule condition: " +
                    previousValue + "->" + value);
            }

            try
            {
                rule.conditionText = value;
            }
            catch (e)
            {
            }

            var saveSuccess = (rule.conditionText == value);
            this.box.setAttribute("saveSuccess", saveSuccess);
        }
        else if (((window.CSSKeyframeRule && rule instanceof window.CSSKeyframeRule) ||
            rule instanceof window.MozCSSKeyframeRule) &&
            Css.hasClass(target, "cssKeyText"))
        {
            target.textContent = value;

            if (FBTrace.DBG_CSS)
            {
                FBTrace.sysout("CSSEditor.saveEdit: @-moz-keyframe rule key: " +
                    previousValue + "->" + value);
            }

            rule.keyText = value;

            var saveSuccess = (rule.keyText == value || rule.keyText == Css.keyframeKeys[value]);
            this.box.setAttribute("saveSuccess", saveSuccess);
        }
        else if (rule instanceof window.CSSMozDocumentRule &&
                Css.hasClass(target, "cssDocumentRuleCondition"))
        {
            target.textContent = value;

            if (FBTrace.DBG_CSS)
            {
                FBTrace.sysout("CSSEditor.saveEdit: @-moz-document rule condition: " +
                        previousValue + "->" + value);
            }

            try
            {
                rule.conditionText = value;
            }
            catch (e)
            {
            }

            var saveSuccess = (rule.conditionText == value);
            this.box.setAttribute("saveSuccess", saveSuccess);
        }
        else if (rule instanceof window.CSSImportRule && Css.hasClass(target, "cssMediaQuery"))
        {
            target.textContent = value;

            if (FBTrace.DBG_CSS)
            {
                FBTrace.sysout("CSSEditor.saveEdit: @import media query: " +
                    previousValue + "->" + value);
            }

            rule.media.mediaText = value;

            // Workaround to apply the media query changes
            rule.parentStyleSheet.disabled = true;
            rule.parentStyleSheet.disabled = false;

            var row = Dom.getAncestorByClass(target, "importRule");
            row.getElementsByClassName("separator").item(0).textContent =
                value == "" ? "" : String.fromCharCode(160);

            var saveSuccess = rule.media.mediaText != "not all" || value == "not all";
            this.box.setAttribute("saveSuccess", saveSuccess);
        }
        else if (rule instanceof window.CSSMediaRule &&
            Css.hasClass(target, "cssMediaRuleCondition"))
        {
            target.textContent = value;

            if (FBTrace.DBG_CSS)
            {
                FBTrace.sysout("CSSEditor.saveEdit: @media rule condition: " +
                    previousValue + "->" + value);
            }

            rule.conditionText = value;

            var saveSuccess = (rule.conditionText == value);
            this.box.setAttribute("saveSuccess", saveSuccess);
        }
        else if (rule instanceof window.CSSCharsetRule)
        {
            target.textContent = value;

            if (FBTrace.DBG_CSS)
                FBTrace.sysout("CSSEditor.saveEdit: @charset: " + previousValue + "->" + value);

            rule.encoding = value;
        }

        Firebug.Inspector.repaint();

        this.panel.markChange(this.panel.name == "stylesheet");

        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSEditor.saveEdit (ending) " + this.panel.name, value);
    },

    beginEditing: function(target, value)
    {
        var row = Dom.getAncestorByClass(target, "cssProp");
        this.initialValue = value;
        this.initiallyDisabled = (row && row.classList.contains("disabledStyle"));
    },

    endEditing: function(target, value, cancel)
    {
        if (!cancel && target.classList.contains("cssPropName"))
        {
            // Save changed property names here instead of in saveEdit, because otherwise
            // unrelated properties might get discarded (see issue 5204).
            var previous = this.initialValue;
            if (FBTrace.DBG_CSS)
            {
                FBTrace.sysout("CSSEditor.endEditing: renaming property " + previous + " -> " +
                    value);
            }

            var cssRule = Dom.getAncestorByClass(target, "cssRule");
            var rule = Firebug.getRepObject(cssRule);
            var baseText = rule.style ? rule.style.cssText : rule.cssText;
            var prop = Dom.getAncestorByClass(target, "cssProp");
            var propValue = Dom.getChildByClass(prop, "cssPropValue").textContent;
            var parsedValue = parsePriority(propValue);

            if (previous)
                CSSModule.removeProperty(rule, previous);
            if (propValue)
                CSSModule.setProperty(rule, value, parsedValue.value, parsedValue.priority);

            Events.dispatch(CSSModule.fbListeners, "onCSSPropertyNameChanged", [rule, value,
                    previous, baseText]);

            Firebug.Inspector.repaint();
            this.panel.markChange(this.panel.name == "stylesheet");
        }
        return true;
    },

    cancelEditing: function(target, value)
    {
        if (this.initiallyDisabled)
        {
            // Disable the property again.
            var row = Dom.getAncestorByClass(target, "cssProp");
            if (row && !row.classList.contains("disabledStyle"))
                this.panel.disablePropertyRow(row);
        }
    },

    advanceToNext: function(target, charCode)
    {
        if (charCode == 58 /*":"*/ && Css.hasClass(target, "cssPropName"))
        {
            return true;
        }
        else if (charCode == 59 /*";"*/ && Css.hasClass(target, "cssPropValue"))
        {
            var cssValue = CSSModule.parseCSSValue(this.input.value, this.input.selectionStart);
            // Simple test, if we are inside a string (see issue 4543)
            var isValueInString = (cssValue.value.indexOf("\"") != -1);

            return !isValueInString;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getAutoCompleteRange: function(value, offset)
    {
        if (!Css.hasClass(this.target, "cssPropValue"))
            return {start: 0, end: value.length};

        var propRow = Dom.getAncestorByClass(this.target, "cssProp");
        var propName = Dom.getChildByClass(propRow, "cssPropName").textContent.toLowerCase();

        if (propName == "font" || propName == "font-family")
            return CSSModule.parseCSSFontFamilyValue(value, offset, propName);
        else
            return CSSModule.parseCSSValue(value, offset);
    },

    getAutoCompleteList: function(preExpr, expr, postExpr, range, cycle, context, out)
    {
        if (Dom.getAncestorByClass(this.target, "importRule"))
        {
            return [];
        }
        else if (Dom.getAncestorByClass(this.target, "cssCharsetRule"))
        {
            return Css.charsets;
        }
        else if (Css.hasClass(this.target, "cssPropName"))
        {
            var nodeType = Xml.getElementSimpleType(Firebug.getRepObject(this.target));
            var ret = Css.getCSSPropertyNames(nodeType);

            if (!cycle && expr)
            {
                // Make some good default suggestions.
                var list = ["color", "clear", "display", "float", "overflow"];
                for (var i = 0; i < list.length; ++i)
                {
                    if (Str.hasPrefix(list[i], expr) && ret.indexOf(list[i]) !== -1)
                    {
                        out.suggestion = list[i];
                        break;
                    }
                }
            }

            return ret;
        }
        else if (Dom.getAncestorByClass(this.target, "cssDocumentRule") &&
                !Css.hasClass(this.target, "cssPropValue"))
        {
            return Css.documentConditions;
        }
        else if (Dom.getAncestorByClass(this.target, "cssKeyframesRule") &&
            !Css.hasClass(this.target, "cssPropValue"))
        {
            return Object.getOwnPropertyNames(Css.keyframeKeys);
        }
        else if (Dom.getAncestorByClass(this.target, "cssMediaRule") &&
            !Css.hasClass(this.target, "cssPropValue"))
        {
            return Css.mediaTypes;
        }
        else
        {
            if (expr.charAt(0) === "!")
                return ["!important"];

            var row = Dom.getAncestorByClass(this.target, "cssProp");
            var propName = Dom.getChildByClass(row, "cssPropName").textContent;
            var nodeType = Xml.getElementSimpleType(Firebug.getRepObject(this.target));

            var keywords;
            if (range.type === "url")
            {
                // We can't complete urls yet.
                return [];
            }
            else if (range.type === "fontFamily")
            {
                keywords = Css.cssKeywords["fontFamily"].slice();
                if (this.panel && this.panel.context)
                {
                    // Add the fonts used in this context (they might be inaccessible
                    // for this element, but probably aren't).
                    var fonts = Fonts.getFontsUsedInContext(this.panel.context), ar = [];
                    for (var i = 0; i < fonts.length; i++)
                        ar.push(fonts[i].CSSFamilyName);
                    keywords = Arr.sortUnique(keywords.concat(ar));
                }

                var q = expr.charAt(0), isQuoted = (q === '"' || q === "'");
                if (!isQuoted)
                {
                    // Default to ' quotes, unless " occurs somewhere.
                    q = (/"/.test(preExpr + postExpr) ? '"' : "'");
                }

                // Don't complete '.
                if (expr.length <= 1 && isQuoted)
                    return [];

                // When completing, quote fonts if the input is quoted; when
                // cycling, quote them instead in the way the user seems to
                // expect to have them quoted.
                var reSimple = /^[a-z][a-z0-9-]*$/i;
                var isComplex = !reSimple.test(expr.replace(/^['"]?|['"]?$/g, ""));
                var quote = function(str)
                {
                    if (!cycle || isComplex !== isQuoted)
                        return (isQuoted ? q + str + q : str);
                    else
                        return (reSimple.test(str) ? str : q + str + q);
                };

                keywords = keywords.slice();
                for (var i = 0; i < keywords.length; ++i)
                {
                    // Treat values starting with capital letters as font names
                    // that can be quoted.
                    var k = keywords[i];
                    if (k.charAt(0).toLowerCase() !== k.charAt(0))
                        keywords[i] = quote(k);
                }
            }
            else
            {
                var lowerProp = propName.toLowerCase(), avoid;
                if (["background", "border", "font"].indexOf(lowerProp) !== -1)
                {
                    if (cycle)
                    {
                        // Cycle only within the same category, if possible.
                        var cat = Css.getCSSShorthandCategory(nodeType, lowerProp, expr);
                        if (cat)
                            return (cat in Css.cssKeywords ? Css.cssKeywords[cat] : [cat]);
                    }
                    else
                    {
                        // Avoid repeated properties. We assume the values to be solely
                        // space-separated tokens, within a comma-separated part (like
                        // for CSS3 multiple backgrounds). This is absolutely wrong, but
                        // good enough in practice because non-tokens for which it fails
                        // likely aren't in any category.
                        // "background-position" and "background-repeat" values can occur
                        // twice, so they are special-cased.
                        avoid = [];
                        var preTokens = preExpr.split(",").reverse()[0].split(" ");
                        var postTokens = postExpr.split(",")[0].split(" ");
                        var tokens = preTokens.concat(postTokens);
                        for (var i = 0; i < tokens.length; ++i)
                        {
                            var cat = Css.getCSSShorthandCategory(nodeType, lowerProp, tokens[i]);
                            if (cat && cat !== "position" && cat !== "bgRepeat")
                                avoid.push(cat);
                        }
                    }
                }
                keywords = Css.getCSSKeywordsByProperty(nodeType, propName, avoid);
            }

            // Add the magic inherit property, if it's sufficiently alone.
            // XXX Firefox 19 also has "initial"
            if (!preExpr)
                keywords = keywords.concat(["inherit"]);

            if (!cycle)
            {
                // Make some good default suggestions.
                var list = ["white", "black", "solid", "outset", "repeat"];
                for (var i = 0; i < list.length; ++i)
                {
                    if (Str.hasPrefix(list[i], expr) && keywords.indexOf(list[i]) !== -1)
                    {
                        out.suggestion = list[i];
                        break;
                    }
                }
            }

            return SelectorEditor.stripCompletedParens(keywords, postExpr);
        }
    },

    getAutoCompletePropSeparator: function(range, expr, prefixOf)
    {
        if (!Css.hasClass(this.target, "cssPropValue"))
            return null;

        // For non-multi-valued properties, fail (pre-completions don't make sense,
        // and it's less risky).
        var row = Dom.getAncestorByClass(this.target, "cssProp");
        var propName = Dom.getChildByClass(row, "cssPropName").textContent;
        if (!Css.multiValuedProperties.hasOwnProperty(propName))
            return null;

        if (range.type === "fontFamily")
            return ",";
        return " ";
    },

    autoCompleteAdjustSelection: function(value, offset)
    {
        if (offset >= 2 && value.substr(offset-2, 2) === "()")
            return offset-1;
        return offset;
    },

    doIncrementValue: function(value, amt, offset, offsetEnd)
    {
        var propName = null;
        if (Css.hasClass(this.target, "cssPropValue"))
        {
            var propRow = Dom.getAncestorByClass(this.target, "cssProp");
            propName = Dom.getChildByClass(propRow, "cssPropName").textContent;
        }

        var range = CSSModule.parseCSSValue(value, offset);
        var type = (range && range.type) || "";
        var expr = (range ? value.substring(range.start, range.end) : "");

        var completion = null, selection, info;
        if (type === "int")
        {
            if (propName === "opacity")
            {
                info = {minValue: 0, maxValue: 1};
                amt /= 100;
            }

            if (expr === "0" && value.lastIndexOf("(", offset) === -1 &&
                !Css.unitlessProperties.hasOwnProperty(propName))
            {
                // 0 is a length, and incrementing it normally will result in an
                // invalid value 1 or -1.  Thus, guess at a unit to add.
                var unitM = /\d([a-z]{1,4})/.exec(value);
                expr += (unitM ? unitM[1] : "px");
            }

            var newValue = this.incrementExpr(expr, amt, info);
            if (newValue !== null)
            {
                completion = newValue;
                selection = [0, completion.length];
            }
        }
        else if (type === "rgb" && expr.charAt(0) === "#")
        {
            var offsetIntoExpr = offset - range.start;
            var offsetEndIntoExpr = offsetEnd - range.start;

            // Increment a hex color.
            var res = this.incrementHexColor(expr, amt, offsetIntoExpr, offsetEndIntoExpr);
            if (res)
            {
                completion = res.value;
                selection = res.selection;
            }
        }
        else
        {
            if (type === "rgb" || type === "hsl")
            {
                info = {};
                var part = value.substring(range.start, offset).split(",").length - 1;
                if (part === 3) // alpha
                {
                    info.minValue = 0;
                    info.maxValue = 1;
                    amt /= 100;
                }
                else if (type === "rgb") // rgb color
                {
                    info.minValue = 0;
                    info.maxValue = 255;
                    if (Math.abs(amt) < 1)
                        amt = (amt < 0 ? -1 : 1);
                }
                else if (part !== 0) // hsl percentage
                {
                    info.minValue = 0;
                    info.maxValue = 100;

                    // If the selection is at the end of a percentage sign, select
                    // the previous number. This would have been less hacky if
                    // parseCSSValue parsed functions recursively.
                    if (value.charAt(offset-1) === "%")
                        --offset;
                }
            }

            return InlineEditor.prototype.doIncrementValue
                .call(this, value, amt, offset, offsetEnd, info);
        }

        if (completion === null)
            return;

        var preExpr = value.substr(0, range.start);
        var postExpr = value.substr(range.end);

        return {
            value: preExpr + completion + postExpr,
            start: range.start + selection[0],
            end: range.start + selection[1]
        };
    },

    incrementHexColor: function(expr, amt, offset, offsetEnd)
    {
        // Return early if no part of the expression is selected.
        if (offsetEnd > expr.length && offset >= expr.length)
            return;
        if (offset < 1 && offsetEnd <= 1)
            return;

        // Ignore the leading #.
        expr = expr.substr(1);
        --offset;
        --offsetEnd;

        // Clamp the selection to within the actual value.
        offset = Math.max(offset, 0);
        offsetEnd = Math.min(offsetEnd, expr.length);
        offsetEnd = Math.max(offsetEnd, offset);

        // Normalize #ABC -> #AABBCC.
        if (expr.length === 3)
        {
            expr = expr.charAt(0) + expr.charAt(0) +
                   expr.charAt(1) + expr.charAt(1) +
                   expr.charAt(2) + expr.charAt(2);
            offset *= 2;
            offsetEnd *= 2;
        }
        if (expr.length !== 6)
            return;

        if (offset === offsetEnd)
        {
            // There is only a single cursor position. Increment an adjacent
            // color, preferably one to the left.
            if (offset === 0)
                offsetEnd = 1;
            else
                offset = offsetEnd - 1;
        }

        // Make the selection cover entire parts.
        offset -= offset%2;
        offsetEnd += offsetEnd%2;

        // Remap the increments from [0.1, 1, 10, 100] to [1, 1, 16, 64].
        if (-1 < amt && amt < 1)
            amt = (amt < 0 ? -1 : 1);
        if (Math.abs(amt) === 10)
            amt = (amt < 0 ? -16 : 16);
        if (Math.abs(amt) === 100)
            amt = (amt < 0 ? -64 : 64);

        var isUpper = (expr.toUpperCase() === expr);

        for (var pos = offset; pos < offsetEnd; pos += 2)
        {
            // Increment the part in [pos, pos+2).
            var mid = expr.substr(pos, 2);
            var value = parseInt(mid, 16);
            if (isNaN(value))
                return;

            mid = Math.min(Math.max(value - amt, 0), 255).toString(16);
            while (mid.length < 2)
                mid = "0" + mid;

            // Make the incremented part upper-case if the original value can be
            // seen as such (this should happen even for, say, #444444, because
            // upper-case hex-colors are the default). Otherwise, the lower-case
            // result from .toString is used.
            if (isUpper)
                mid = mid.toUpperCase();

            expr = expr.substr(0, pos) + mid + expr.substr(pos+2);
        }

        return {value: "#" + expr, selection: [offset+1, offsetEnd+1]};
    }
});

// ********************************************************************************************* //
// CSSRuleEditor

function CSSRuleEditor(doc)
{
    this.initializeInline(doc);
}

CSSRuleEditor.prototype = domplate(SelectorEditor.prototype,
{
    insertNewRow: function(target, insertWhere)
    {
        var emptyRule = {
            selector: "",
            id: "",
            props: [],
            isSelectorEditable: true
        };

        if (insertWhere == "before")
            return CSSStyleRuleTag.tag.insertBefore({rule: emptyRule}, target);
        else
            return CSSStyleRuleTag.tag.insertAfter({rule: emptyRule}, target);
    },

    beginEditing: function()
    {
        if (this.panel.name === "stylesheet" && this.panel.location)
        {
            this.doc = Css.getDocumentForStyleSheet(this.panel.location);
        }
        else if (this.panel.name === "css" && this.panel.selection)
        {
            this.doc = this.panel.selection.ownerDocument;
        }
        else
        {
            this.doc = this.panel.context.window.document;
        }
    },

    endEditing: function()
    {
        this.doc = null;
        return true;
    },

    saveEdit: function(target, value, previousValue)
    {
        var context = this.panel.context;

        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSRuleEditor.saveEdit: '" + value + "'  '" + previousValue +
                "'", target);

        target.textContent = value;
        if (value === previousValue)
            return;

        var row = Dom.getAncestorByClass(target, "cssRule");
        var rule = Firebug.getRepObject(target);

        var searchRule = rule || Firebug.getRepObject(row.nextSibling);
        var oldRule, ruleIndex;

        if (searchRule)
        {
            // take care of media rules
            var styleSheet = searchRule.parentRule || searchRule.parentStyleSheet;
            if (!styleSheet)
                return;

            var cssRules = styleSheet.cssRules;
            ruleIndex = 0;
            while (ruleIndex < cssRules.length && searchRule != cssRules[ruleIndex])
                ruleIndex++;

            if (rule)
                oldRule = searchRule;
            else
                ruleIndex++;
        }
        else
        {
            var styleSheet;
            if (this.panel.name === "stylesheet")
            {
                styleSheet = this.panel.location;
                if (!styleSheet)
                {
                    var doc = context.window.document;
                    this.panel.location = styleSheet =
                        CSSModule.getDefaultStyleSheet(doc);
                }
            }
            else
            {
                if (this.panel.name !== "css")
                    return;

                var doc = this.panel.selection.ownerDocument;
                styleSheet = CSSModule.getDefaultStyleSheet(doc);
            }

            styleSheet = styleSheet.editStyleSheet ? styleSheet.editStyleSheet.sheet : styleSheet;
            cssRules = styleSheet.cssRules;
            ruleIndex = cssRules.length;
        }

        // Delete in all cases except for new add
        // We want to do this before the insert to ease change tracking
        if (oldRule)
        {
            CSSModule.deleteRule(styleSheet, ruleIndex);
        }

        var doMarkChange = true;

        // Firefox does not follow the spec for the update selector text case.
        // When attempting to update the value, firefox will silently fail.
        // See https://bugzilla.mozilla.org/show_bug.cgi?id=37468 for the quite
        // old discussion of this bug.
        // As a result we need to recreate the style every time the selector
        // changes.
        if (value)
        {
            var cssText = [ value, "{" ];
            var props = row.getElementsByClassName("cssProp");
            for (var i = 0; i < props.length; i++)
            {

                var propEl = props[i];
                if (!Css.hasClass(propEl, "disabledStyle"))
                {
                    var propName = Dom.getChildByClass(propEl, "cssPropName").textContent;
                    var propValue = Dom.getChildByClass(propEl, "cssPropValue").textContent;
                    cssText.push(propName + ":" + propValue + ";");
                }
            }

            cssText.push("}");
            cssText = cssText.join("");

            try
            {
                var insertLoc = CSSModule.insertRule(styleSheet, cssText, ruleIndex);

                rule = cssRules[insertLoc];

                ruleIndex++;

                var saveSuccess = (this.panel.name != "css");
                if (!saveSuccess)
                {
                    saveSuccess = (this.panel.selection &&
                        this.panel.selection.mozMatchesSelector(value)) ? true : 'almost';
                }

                this.box.setAttribute('saveSuccess', saveSuccess);
            }
            catch (err)
            {
                if (FBTrace.DBG_CSS || FBTrace.DBG_ERRORS)
                    FBTrace.sysout("CSS Insert Error: "+err, err);

                target.textContent = previousValue;
                // create dummy rule to be able to recover from error
                var insertLoc = CSSModule.insertRule(styleSheet,
                    'selectorSavingError{}', ruleIndex);
                rule = cssRules[insertLoc];

                this.box.setAttribute('saveSuccess', false);

                doMarkChange = false;
            }
        }
        else
        {
            // XXX There is currently no way to re-add the rule after this happens.
            rule = undefined;
        }

        // Update the rep object
        row.repObject = rule;
        if (oldRule && rule)
            this.panel.remapRule(context, oldRule, rule);

        if (doMarkChange)
            this.panel.markChange(this.panel.name == "stylesheet");
    },

    getAutoCompleteRange: function(value, offset)
    {
        if (!Css.hasClass(this.target, "cssSelector"))
            return;
        return SelectorEditor.prototype.getAutoCompleteRange.apply(this, arguments);
    },

    getAutoCompleteList: function(preExpr, expr, postExpr, range, cycle, context, out)
    {
        if (!Css.hasClass(this.target, "cssSelector"))
            return [];
        return SelectorEditor.prototype.getAutoCompleteList.apply(this, arguments);
    },

    getAutoCompletePropSeparator: function(range, expr, prefixOf)
    {
        if (!Css.hasClass(this.target, "cssSelector"))
            return null;
        return SelectorEditor.prototype.getAutoCompletePropSeparator.apply(this, arguments);
    },

    advanceToNext: function(target, charCode)
    {
        if (charCode == 123 /* "{" */)
        {
            return true;
        }
    }
});

// ********************************************************************************************* //
// StyleSheetEditor

/**
 * StyleSheetEditor represents the full-sized editor used for Source/Live Edit
 * within the CSS panel.
 */
function StyleSheetEditor(doc)
{
    this.box = this.tag.replace({}, doc, this);
    this.input = this.box.firstChild;
}

StyleSheetEditor.prototype = domplate(BaseEditor,
{
    multiLine: true,

    tag: DIV(
        TEXTAREA({"class": "styleSheetEditor fullPanelEditor", oninput: "$onInput"})
    ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getValue: function()
    {
        return this.input.value;
    },

    setValue: function(value)
    {
        return this.input.value = value;
    },

    show: function(target, panel, value, textSize)
    {
        this.target = target;
        this.panel = panel;

        this.panel.panelNode.appendChild(this.box);

        this.input.value = value;
        this.input.focus();

        // match CSSModule.getEditorOptionKey
        var command = Firebug.chrome.$("cmd_firebug_togglecssEditMode");
        command.setAttribute("checked", true);
    },

    hide: function()
    {
        var command = Firebug.chrome.$("cmd_firebug_togglecssEditMode");
        command.setAttribute("checked", false);

        if (this.box.parentNode == this.panel.panelNode)
            this.panel.panelNode.removeChild(this.box);

        delete this.target;
        delete this.panel;
        delete this.styleSheet;
    },

    saveEdit: function(target, value, previousValue)
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("StyleSheetEditor.saveEdit", arguments);

        CSSModule.freeEdit(this.styleSheet, value);
    },

    beginEditing: function()
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("StyleSheetEditor.beginEditing", arguments);

        this.editing = true;
    },

    endEditing: function()
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("StyleSheetEditor.endEditing", arguments);

        this.editing = false;
        this.panel.refresh();
        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onInput: function()
    {
        Editor.update();
    },

    scrollToLine: function(line, offset)
    {
        this.startMeasuring(this.input);
        var lineHeight = this.measureText().height;
        this.stopMeasuring();

        this.input.scrollTop = (line * lineHeight) + offset;
    }
});

Firebug.StyleSheetEditor = StyleSheetEditor;

// ********************************************************************************************* //

Firebug.CSSDirtyListener = function(context)
{
};

Firebug.CSSDirtyListener.isDirty = function(styleSheet, context)
{
    return (styleSheet.fbDirty == true);
};

Firebug.CSSDirtyListener.prototype =
{
    markSheetDirty: function(styleSheet)
    {
        if (!styleSheet && FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("css; CSSDirtyListener markSheetDirty; styleSheet == NULL");
            return;
        }

        styleSheet.fbDirty = true;

        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSDirtyListener markSheetDirty " + styleSheet.href, styleSheet);
    },

    onCSSInsertRule: function(styleSheet, cssText, ruleIndex)
    {
        this.markSheetDirty(styleSheet);
    },

    onCSSDeleteRule: function(styleSheet, ruleIndex)
    {
        this.markSheetDirty(styleSheet);
    },

    onCSSSetProperty: function(style, propName, propValue, propPriority, prevValue,
        prevPriority, rule, baseText)
    {
        var styleSheet = rule.parentStyleSheet;
        if (styleSheet)
            this.markSheetDirty(styleSheet);
    },

    onCSSRemoveProperty: function(style, propName, prevValue, prevPriority, rule, baseText)
    {
        var styleSheet = rule.parentStyleSheet;
        if (styleSheet)
            this.markSheetDirty(styleSheet);
    }
};

// ********************************************************************************************* //
// Local Helpers

function parsePriority(value)
{
    var rePriority = /(.*?)\s*(!important)?$/;
    var m = rePriority.exec(value);
    var propValue = m ? m[1] : "";
    var priority = m && m[2] ? "important" : "";
    return {value: propValue, priority: priority};
}

function formatColor(color)
{
    switch (Options.get("colorDisplay"))
    {
        case "hex":
            return Css.rgbToHex(color);

        case "hsl":
            return Css.rgbToHSL(color);

        case "rgb":
            return Css.colorNameToRGB(color);

        default:
            return color;
    }
}

function getRuleLine(rule)
{
    // TODO return closest guess if rule isn't CSSStyleRule
    // and keep track of edited rule lines
    try
    {
        return Dom.domUtils.getRuleLine(rule);
    }
    catch (e) {}
    return 0;
}

function getOriginalStyleSheetCSS(sheet, context)
{
    if (sheet.ownerNode instanceof window.HTMLStyleElement)
    {
        return sheet.ownerNode.textContent;
    }
    else
    {
        // In the case, that there are no rules, the cache will return a message
        // to reload the source (see issue 4251)
        return sheet.cssRules.length != 0 ? context.sourceCache.load(sheet.href).join("") : "";
    }
}

function getStyleSheetCSS(sheet, context)
{
    function beautify(css, indent)
    {
        var indent='\n'+Array(indent+1).join(' ');
        var i=css.indexOf('{');
        var match=css.substr(i+1).match(/(?:[^;\(]*(?:\([^\)]*?\))?[^;\(]*)*;?/g);
        match.pop();
        match.pop();
        return css.substring(0, i+1) + indent
                + match.sort().join(indent) + '\n}';
    }

    var cssRules = sheet.cssRules, css=[];
    for(var i = 0; i < cssRules.length; i++)
    {
        var rule = cssRules[i];
        if (rule instanceof window.CSSStyleRule)
            css.push(beautify(rule.cssText, 4));
        else
            css.push(rule.cssText);
    }

    return Css.rgbToHex(css.join('\n\n')) + '\n';
}

function scrollSelectionIntoView(panel)
{
    var selCon = getSelectionController(panel);
    selCon.scrollSelectionIntoView(
        Ci.nsISelectionController.SELECTION_NORMAL,
        Ci.nsISelectionController.SELECTION_FOCUS_REGION, true);
}

function getSelectionController(panel)
{
    var browser = Firebug.chrome.getPanelBrowser(panel);
    return browser.docShell.QueryInterface(Ci.nsIInterfaceRequestor)
        .getInterface(Ci.nsISelectionDisplay)
        .QueryInterface(Ci.nsISelectionController);
}

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(Firebug.CSSStyleSheetPanel);

return Firebug.CSSStyleSheetPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/cssPanelMutationObserver",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/lib/trace",
    "firebug/lib/object",
],
function(Firebug, Module, FBTrace, Obj) {

"use strict"

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

// ********************************************************************************************* //
// CSSPanelMutationObserver

/**
 * @module This module is responsible for updating the CSS panel (name='stylesheet')
 * when the currently displayed CSS stylesheet is removed from the page.
 *
 * The module uses Mutation Observer API to watch elements removal (STYLE and LINK)
 * from the page.
 *
 * The observer activity is optimized, so it observes the document only if
 * the panel is actually visible (the optimization is based on Firebug UI events).
 *
 * See issue 6582 for more details.
 */
var CSSPanelMutationObserver = Obj.extend(Module,
/** @lends CSSPanelMutationObserver */
{
    dispatchName: "CSSPanelMutationObserver",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        // Register UI listeners, so we can get events about when the CSS panel
        // is visible and hidden.
        Firebug.registerUIListener(this);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);
        Firebug.unregisterUIListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Listener

    onShowPanel: function(panel)
    {
        if (panel.name != "stylesheet" || panel.location == null)
            return;

        // The CSS panel is visible let's observe mutations. 
        this.startObserveMutations(panel);
    },

    onHidePanel: function(panel)
    {
        if (panel.name != "stylesheet")
            return;

        this.stopObserveMutations(panel);
    },

    onPanelNavigate: function(object, panel)
    {
        if (panel.name != "stylesheet" || panel.location == null)
            return;

        // Different stylesheet is displayed in the panel, restart mutation
        // observer since the stylesheet can come from different window (an iframe).
        this.startObserveMutations(panel);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Mutation Observer

    startObserveMutations: function(panel)
    {
        if (panel.mutationObserver)
            this.stopObserveMutations(panel);

        var styleSheet = panel.location;
        if (!styleSheet.ownerNode)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("CSSPanelMutationObserver.startObserveMutations ERROR no owner!");
            return;
        }

        // Start observing mutation events. The CSS panel needs to be updated
        // if the current stylesheet's node is removed from the document
        var doc = styleSheet.ownerNode.ownerDocument;
        var callback = this.onMutationObserve.bind(this, panel, styleSheet.ownerNode);
        var observer = new MutationObserver(callback);
        observer.observe(doc, {
            childList: true,
            subtree: true,
        });

        panel.mutationObserver = observer;

        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSPanelMutationObserver.startObserveMutations;");
    },

    stopObserveMutations: function(panel)
    {
        if (!panel.mutationObserver)
            return;

        panel.mutationObserver.disconnect();
        panel.mutationObserver = null;

        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSPanelMutationObserver.stopObserveMutations;");
    },

    onMutationObserve: function(panel, styleSheetNode, records, observer)
    {
        var refresh = false;

        for (var i=0; i<records.length; i++)
        {
            var record = records[i];
            switch (record.type)
            {
                case "childList":
                    var nodes = record.removedNodes;
                    for (var j=0; j<nodes.length; j++)
                    {
                        // If the current stylesheet's owner node has been removed
                        // update the panel. The stylesheet must not be displayed
                        // since it's not part of the page anymore.
                        var node = nodes[j];
                        if (node == styleSheetNode)
                        {
                            refresh = true;
                            break;
                        }
                    }
            }

            if (refresh)
                break;
        }

        if (refresh)
        {
            if (FBTrace.DBG_CSS)
                FBTrace.sysout("CSSPanelMutationObserver.onMutationObserve; refresh");

            panel.location = null;
            panel.navigate(null);
        }
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(CSSPanelMutationObserver);

return CSSPanelMutationObserver;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/cssPanelUpdater",
[
    "firebug/chrome/module",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/array",
    "firebug/chrome/window",
],
function(Module, FBTrace, Obj, Arr, Win) {

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

var updateTimeout = 200;

var updaters = [];

// ********************************************************************************************* //
// CSSPanelUpdater Implementation

/**
 * @object The object is responsible for regular update of the {@Firebug.CSSStyleSheetPanel}
 * panel to make sure the default stylesheet is displayed to the user as soon as possible.
 * Note that the only stylesheet can come from an iframe that is dynamically appended/loaded
 * onto the current page. Introduced to fix issue 6550.
 *
 * xxxHonza: this object could replace {@LoadHandler} in the future (see issue 4893).
 *
 * The update is based on the following logic.
 * - Start regular timeout (interval) if top level window or an iframe is watched.
 * - Execute passed callback in timeout handler
 * - Clear the timeout if all watched windows are loaded.
 * - The updater can be explicitly canceled with destroy() method
 *   (in case the update has been successful)
 */
function CSSPanelUpdater(context, callback)
{
    this.context = context;
    this.callback = callback;
    this.winMap = new Map();
    this.timeout = null;
    this.canceled = false;

    updaters.push(this);
}

CSSPanelUpdater.prototype =
/** @lends CSSPanelUpdater */
{
    watchWindow: function(win)
    {
        if (this.canceled)
            return;

        this.winMap.set(win, true);

        if (this.timeout)
            return;

        this.timeout = this.context.setInterval(this.onTimeout.bind(this), updateTimeout);

        if (FBTrace.DBG_CSS)
        {
            FBTrace.sysout("CSSPanelUpdater.watchWindow; " + Win.safeGetWindowLocation(win) +
                ", " + this.timeout);
        }
    },

    unwatchWindow: function(win)
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSPanelUpdater.unwatchWindow; " + Win.safeGetWindowLocation(win));

        if (this.canceled)
            return;

        this.winMap.delete(win);

        if (!this.winMap.size && this.timeout)
        {
            this.context.clearInterval(this.timeout);
            this.timeout = null;
        }
    },

    loadWindow: function(win)
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("CSSPanelUpdater.loadWindow; " + Win.safeGetWindowLocation(win));

        if (this.canceled)
            return;

        this.winMap.delete(win);

        if (!this.winMap.size && this.timeout)
        {
            this.context.clearInterval(this.timeout);
            this.timeout = null;
        }

        this.onTimeout();
    },

    destroy: function()
    {
        if (FBTrace.DBG_CSS)
        {
            FBTrace.sysout("CSSPanelUpdater.destroy; " + this.context.getName() +
                ", " + this.timeout);
        }

        if (this.timeout)
            this.context.clearInterval(this.timeout);

        this.winMap.clear();
        this.timeout = null;
        this.canceled = true;

        Arr.remove(updaters, this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onTimeout: function()
    {
        if (FBTrace.DBG_CSS)
        {
            FBTrace.sysout("CSSPanelUpdater.onTimeout; " + this.context.getName() +
                ", " + this.timeout);
        }

        try
        {
            this.callback();
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("CSSPanelUpdater.onTimeout; EXCEPTION " + err, err);
        }
    }
}

// ********************************************************************************************* //
// CSSPanelUpdaterModule

/**
 * @module Helper Module object for observing {@Firebug.TabWatcher} events.
 */
var CSSPanelUpdaterModule = Obj.extend(Module,
/** @lends CSSPanelUpdater */
{
    dispatchName: "CSSPanelUpdaterModule",

    watchWindow: function(context, win)
    {
        // The updater works only if the CSS panel is selected (optimization and also avoid
        // updating panel's toolbar when the panel is not visible).
        if (!this.isSelected())
            return;

        for (var i=0; i<updaters.length; i++)
        {
            var updater = updaters[i];
            if (updater.context == context)
                updater.watchWindow(win);
        }
    },

    unwatchWindow: function(context, win)
    {
        if (!this.isSelected())
            return;

        for (var i=0; i<updaters.length; i++)
        {
            var updater = updaters[i];
            if (updater.context == context)
                updater.unwatchWindow(win);
        }
    },

    loadWindow: function(context, win)
    {
        if (!this.isSelected())
            return;

        for (var i=0; i<updaters.length; i++)
        {
            var updater = updaters[i];
            if (updater.context == context)
                updater.loadWindow(win);
        }
    },

    isSelected: function()
    {
        var panel = Firebug.chrome.getSelectedPanel();
        return (panel && panel.name == "stylesheet");
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(CSSPanelUpdaterModule);

return CSSPanelUpdater;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/cssReps",
[
    "firebug/lib/object",
    "firebug/chrome/infotip",
    "firebug/lib/domplate",
    "firebug/js/sourceLink",
    "firebug/lib/locale",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/string",
    "firebug/lib/fonts"
],
function(Obj, InfoTip, Domplate, SourceLink, Locale, Dom, Css, Str, Fonts) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, DIV, TR, P, IMG, STYLE} = Domplate;

const maxWidth = 100;
const maxHeight = 80;

// ********************************************************************************************* //

var CSSInfoTip = Obj.extend(InfoTip,
{
    dispatchName: "cssInfoTip",

    tags: domplate(
    {
        infoTipTag: DIV({"class": "infoTip"}),

        colorTag:
            DIV({"class": "infoTipColorBox"},
                DIV({style: "background: $rgbValue; width: 100px; height: 40px;"})
            ),

        imgTag:
            DIV({"class": "infoTipImageBox infoTipLoading"},
                IMG({"class": "infoTipImage", src: "$urlValue", "data-repeat": "$repeat",
                    onload: "$onLoadImage", onerror: "$onErrorImage"}),
                DIV({"class": "infoTipBgImage", collapsed: true}),
                DIV({"class": "infoTipCaption"})
            ),

        fontFamilyTag:
            DIV({"class": "infoTipFontFamilyBox"},
                STYLE({"class": "infoTipFontFamilyStyle"}),
                DIV({"class": "infoTipFontFamilySample"},
                    FOR("fontStyle", "$fontStyles",
                        DIV({"class": "infoTipFontFace", style: "$fontStyle"},
                            Locale.$STR("css.fontFamilyPreview"))
                    )
                )
            ),

        onLoadImage: function(event)
        {
            var img = event.currentTarget;
            var bgImg = img.nextSibling;
            if (!bgImg)
                return; // Sometimes gets called after element is dead

            var caption = bgImg.nextSibling;
            var innerBox = img.parentNode;

            var w = img.naturalWidth;
            var h = img.naturalHeight;
            var repeat = img.dataset.repeat;

            if (repeat == "repeat-x" || (w == 1 && h > 1))
            {
                Dom.collapse(img, true);
                Dom.collapse(bgImg, false);
                bgImg.style.background = "url(" + img.src + ") repeat-x";
                bgImg.style.width = maxWidth + "px";
                if (h > maxHeight)
                    bgImg.style.height = maxHeight + "px";
                else
                    bgImg.style.height = h + "px";
            }
            else if (repeat == "repeat-y" || (h == 1 && w > 1))
            {
                Dom.collapse(img, true);
                Dom.collapse(bgImg, false);
                bgImg.style.background = "url(" + img.src + ") repeat-y";
                bgImg.style.height = maxHeight + "px";
                if (w > maxWidth)
                    bgImg.style.width = maxWidth + "px";
                else
                    bgImg.style.width = w + "px";
            }
            else if (repeat == "repeat" || (w == 1 && h == 1))
            {
                Dom.collapse(img, true);
                Dom.collapse(bgImg, false);
                bgImg.style.background = "url(" + img.src + ") repeat";
                bgImg.style.width = maxWidth + "px";
                bgImg.style.height = maxHeight + "px";
            }
            else
            {
                if (w > maxWidth || h > maxHeight)
                {
                    if (w > h)
                    {
                        img.style.width = maxWidth + "px";
                        img.style.height = Math.round((h / w) * maxWidth) + "px";
                    }
                    else
                    {
                        img.style.width = Math.round((w / h) * maxHeight) + "px";
                        img.style.height = maxHeight + "px";
                    }
                }
            }

            caption.textContent = Locale.$STRF("Dimensions", [w, h]);

            Css.removeClass(innerBox, "infoTipLoading");
        },

        onErrorImage: function(event)
        {
            var img = event.currentTarget;
            var bgImg = img.nextSibling;
            if (!bgImg)
                return;

            var caption = bgImg.nextSibling;

            // Display an error in the caption (instead of dimensions).
            if (Str.hasPrefix(img.src, "moz-filedata"))
                caption.textContent = Locale.$STR("firebug.failedToPreviewObjectURL");
            else
                caption.textContent = Locale.$STR("firebug.failedToPreviewImageURL");

            var innerBox = img.parentNode;
            Css.removeClass(innerBox, "infoTipLoading");
        }
    }),

    populateFontFamilyInfoTip: function(infoTip, fontName)
    {
        var fontStyles = [
           "font-size:12px;",
           "font-weight:bold; font-size:12px;",
           "font-style:italic; font-size:12px;",
           "font-size:14px;",
           "font-size:18px;"
        ];

        var fontObject = Fonts.getFontInfo(null, null,
            fontName.replace(/^(["'])?(.*?)\1$/g, "$2"));

        if (FBTrace.DBG_INFOTIP)
        {
            FBTrace.sysout("infotip.populateFontFamilyInfoTip;", {fontName: fontName,
                fontObject: fontObject});
        }

        var node = this.tags.fontFamilyTag.replace({fontStyles: fontStyles, fontName: fontName,
            fontObject: fontObject}, infoTip);
        var styleNode = node.getElementsByClassName("infoTipFontFamilyStyle").item(0);

        styleNode.textContent = getFontFaceCSS(fontObject ? fontObject : fontName);
        return true;
    },

    populateColorInfoTip: function(infoTip, color)
    {
        this.tags.colorTag.replace({rgbValue: color}, infoTip);
        return true;
    },

    populateImageInfoTip: function(infoTip, url, repeat)
    {
        if (!repeat)
            repeat = "no-repeat";

        this.tags.imgTag.replace({urlValue: url, repeat: repeat}, infoTip);

        return true;
    }
});

// ********************************************************************************************* //
// Local Helpers

/**
* Returns the CSS for the infotip @font-face CSS
*
* @param fontObject: Font related information
* @return @font-face CSS
*/
function getFontFaceCSS(font)
{
    var fontFaceCSS = "";
    var fontName = "";

    if (typeof font == "object")
    {
        if (font.rule)
            fontFaceCSS = font.rule.cssText.replace(/url\(.*?\)/g, "url(" + font.URI + ")");
        fontName = font.CSSFamilyName;
    }
    else
    {
        fontName = font;
    }

    fontFaceCSS += " .infoTipFontFace {font-family: " + fontName + ";}";

    return fontFaceCSS;
}

// ********************************************************************************************* //
// Registration

return CSSInfoTip;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/loadHandler",
[
    "firebug/lib/trace",
],
function(FBTrace) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //
// LoadHandler Implementation

/**
 * @object LoadHandler is a helper objects that automates registering and unregistering
 * 'load' listener and executes passed callback. This object is used by CSS panels that
 * need to populate theirs content after document (window) is fully loaded.
 *
 * xxxHonza: instead of waiting for window 'load' event (and so wait till all images are
 * loaded), we should wait for 'load' event fired by the stylesheet itself (see issue 4893).
 */
function LoadHandler()
{
    this.inProgress = false;
}

LoadHandler.prototype =
/** @lends LoadHandler */
{
    handle: function(context, handler)
    {
        var win = context.window;
        var doc = win.document;

        // Execute the handler now if the document is loaded, otherwise wait for "load" event.
        if (doc.readyState == "complete")
            return handler();

        if (this.inProgress)
            return;

        var self = this;
        var onLoadHandler = function()
        {
            context.removeEventListener(win, "load", onLoadHandler, true);
            self.inProgress = false;
            handler();
        };

        context.addEventListener(win, "load", onLoadHandler, true);
        this.inProgress = true;
    }
}

// ********************************************************************************************* //
// Registration

return LoadHandler;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/selectorEditor",
[
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/css",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/chrome/window",
    "firebug/editor/inlineEditor",
],
function(Firebug, Domplate, Css, Str, Arr, Win, InlineEditor) {

"use strict";

// ********************************************************************************************* //
// Constants

const reSelectorChar = /[-_0-9a-zA-Z]/;

// ********************************************************************************************* //
// CSS Selector Editor

function SelectorEditor() {}

SelectorEditor.prototype = Domplate.domplate(InlineEditor.prototype,
{
    // 'null' means every document in the context.
    doc: null,

    getAutoCompleteRange: function(value, offset)
    {
        // Find the word part of an identifier.
        var reIdent = /[-_a-zA-Z0-9]*/;
        var rbefore = Str.reverseString(value.substr(0, offset));
        var after = value.substr(offset);
        var start = offset - reIdent.exec(rbefore)[0].length;
        var end = offset + reIdent.exec(after)[0].length;

        // Expand it to include '.', '#', ':', or '::'.
        if (start > 0 && ".#:".indexOf(value.charAt(start-1)) !== -1)
        {
            --start;
            if (start > 0 && value.substr(start-1, 2) === "::")
                --start;
        }
        return {start: start, end: end};
    },

    getAutoCompleteList: function(preExpr, expr, postExpr, range, cycle, context, out)
    {
        // Don't support attribute selectors, for now.
        if (preExpr.lastIndexOf("[") > preExpr.lastIndexOf("]"))
            return [];

        if (preExpr.lastIndexOf("(") > preExpr.lastIndexOf(")"))
        {
            // We are in an parenthesized expression, where we can only complete
            // for a few particular pseudo-classes that take selector-like arguments.
            var par = preExpr.lastIndexOf("("), colon = preExpr.lastIndexOf(":", par);
            if (colon === -1)
                return;
            var allowed = ["-moz-any", "not", "-moz-empty-except-children-with-localname"];
            var name = preExpr.substring(colon+1, par);
            if (allowed.indexOf(name) === -1)
                return [];
        }

        var preSelector = preExpr.split(",").reverse()[0].trimLeft();
        var hasCombinator = (preSelector && " >+~".indexOf(preSelector.slice(-1)) !== -1);

        var includeTagNames = true;
        var includeIds = true;
        var includeClasses = true;
        var includePseudoClasses = true;
        var includePseudoElements = true;

        if (expr.length > 0)
        {
            includeTagNames = includeClasses = includeIds =
                includePseudoClasses = includePseudoElements = false;
            if (Str.hasPrefix(expr, "::"))
                includePseudoElements = true;
            else if (expr.charAt(0) === ":")
                includePseudoClasses = true;
            else if (expr.charAt(0) === "#")
                includeIds = true;
            else if (expr.charAt(0) === ".")
                includeClasses = true;
            else
                includeTagNames = true;
        }
        if (preExpr.length > 0 && reSelectorChar.test(preExpr.slice(-1)))
            includeTagNames = false;

        var ret = [];
        var hasAnyElements = false;
        var traverseDom = function(doc)
        {
            // Traverse the DOM to get the used ids/classes/tag names that
            // are relevant as continuations.
            // (Tag names could be hard-coded, but finding which ones are
            // actually used hides annoying things like 'b'/'i' when they
            // are not used, and works in other contexts than HTML.)
            // This isn't actually that bad, performance-wise.
            var els = null;
            if (preSelector)
                els = doc.querySelectorAll(preSelector + (hasCombinator ? "*" : ""));
            else
                els = doc.getElementsByTagName("*");
            els = [].slice.call(els);
            hasAnyElements = hasAnyElements || (els.length > 0);

            if (includeTagNames)
            {
                var tagMap = {};
                els.forEach(function(e)
                {
                    tagMap[e.localName] = 1;
                });
                ret.push.apply(ret, Object.keys(tagMap));
            }

            if (includeIds)
            {
                var ids = [];
                els.forEach(function(e)
                {
                    if (e.id)
                        ids.push(e.id);
                });
                ret.push.apply(ret, ids.map(function(cl)
                {
                    return "#" + cl;
                }));
            }

            if (includeClasses)
            {
                var clCombinationMap = Object.create(null), classes = [];
                els.forEach(function(e)
                {
                    var cl = e.className;
                    if (cl && !(cl in clCombinationMap))
                    {
                        clCombinationMap[cl] = 1;
                        classes.push.apply(classes, e.classList);
                    }
                });
                ret.push.apply(ret, classes.map(function(cl)
                {
                    return "." + cl;
                }));
            }
        };

        try
        {
            if (this.doc)
            {
                traverseDom(this.doc);
            }
            else
            {
                Win.iterateWindows(context.window, function(win)
                {
                    traverseDom(win.document);
                });
            }
        }
        catch (exc)
        {
            if (FBTrace.DBG_CSS)
                FBTrace.sysout("Invalid previous selector part \"" + preSelector + "\"", exc);
            return [];
        }

        if (includePseudoClasses && hasAnyElements)
        {
            // Add the pseudo-class-looking :before, :after.
            ret.push(
                ":after",
                ":before"
            );

            ret.push.apply(ret, SelectorEditor.stripCompletedParens(Css.pseudoClasses, postExpr));
        }

        if (includePseudoElements && hasAnyElements)
        {
            ret.push.apply(ret, Css.pseudoElements);
        }

        // Don't suggest things that are already included (by way of totally-
        // incorrect-but-probably-good-enough logic).
        var rev = Str.reverseString(preExpr);
        var partInd = rev.search(/[, >+~]/);
        var lastPart = (partInd === -1 ? rev : rev.substr(0, partInd));
        lastPart = Str.reverseString(lastPart);
        if (lastPart !== "")
        {
            ret = ret.filter(function(str)
            {
                var ind = lastPart.indexOf(str);
                if (ind === -1)
                    return true;
                var before = ind-1, after = ind+str.length;
                var re = reSelectorChar;
                if (before >= 0 && re.test(str.charAt(0)) && re.test(lastPart.charAt(before)))
                    return true;
                if (after < lastPart.length && re.test(lastPart.charAt(after)))
                    return true;
                return false;
            });
        }

        // Don't suggest internal Firebug things.
        var reInternal = /^[.#]firebug[A-Z]/;
        ret = ret.filter(function(str)
        {
            return !reInternal.test(str);
        });

        if (ret.indexOf(":hover") !== -1)
            out.suggestion = ":hover";

        return Arr.sortUnique(ret);
    },

    getAutoCompletePropSeparator: function(range, expr, prefixOf)
    {
        // For e.g. 'd|span', expand to a descendant selector; otherwise assume
        // that this is part of the same selector part.
        return (reSelectorChar.test(prefixOf.charAt(0)) ? " " : "");
    },

    autoCompleteAdjustSelection: function(value, offset)
    {
        if (offset >= 2 && value.substr(offset-2, 2) === "()")
            return offset-1;
        return offset;
    }
});


// Transform completions so that they don't add additional parentheses when
// ones already exist.
SelectorEditor.stripCompletedParens = function(list, postExpr)
{
    var c = postExpr.charAt(0), rem = 0;
    if (c === "(")
        rem = 2;
    else if (c === ")")
        rem = 1;
    else
        return list;
    return list.map(function(cl)
    {
        return (cl.slice(-2) === "()" ? cl.slice(0, -rem) : cl);
    });
};

// ********************************************************************************************* //
// Registration

return SelectorEditor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/selectorModule",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/lib/dom",
    "firebug/lib/locale",
    "firebug/chrome/menu"
],
function(Firebug, Module, Obj, Dom, Locale, Menu) {

// ********************************************************************************************* //
// Module implementation

var CSSSelectorsModule = Obj.extend(Module,
{
    dispatchName: "CSSSelectorsModule",

    initialize: function()
    {
        Firebug.registerUIListener(this);
    },

    shutdown: function()
    {
        Firebug.unregisterUIListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Context Menu

    onContextMenu: function(items, object, target, context, panel, popup)
    {
        if (panel.name != "stylesheet")
            return;

        var cssRule = Dom.getAncestorByClass(target, "cssRule");
        if (!cssRule)
            return;

        var rule = cssRule.repObject;
        if (!rule || !rule.selectorText)
            return;

        var panel = context.getPanel("selectors");
        if (!panel)
            return;

        var item = {
           id: "fbGetMatchingElements",
           nol10n: true,
           label: Locale.$STR("css.selector.cmd.getMatchingElements"),
           command: Obj.bindFixed(panel.addGroup, panel, rule.selectorText)
        };

        var refreshMenuItem = popup.querySelector("#fbRefresh");
        Menu.createMenuItem(popup, item, refreshMenuItem);

        return [];
    },

    matchElements: function(windows, selector)
    {
        if (selector == "")
            return;

        var elements = [];

        // Execute the query also in all iframes (see issue 5962)
        for (var i=0; i<windows.length; ++i)
        {
            var win = windows[i];
            var selections = win.document.querySelectorAll(selector);

            // For some reason the return value of querySelectorAll()
            // is not recognized as a NodeList anymore since Firefox 10.0.
            // See issue 5442.
            // But since there can be more iframes we need to collect all matching
            // elements in an extra array anyway.
            if (selections)
            {
                for (var j=0; j<selections.length; j++)
                {
                    if (!Firebug.shouldIgnore(selections[j]))
                        elements.push(selections[j]);
                }
            }
            else
            {
                throw new Error("Selection Failed: " + selections);
            }
        }

        return elements;
    }
});

//********************************************************************************************* //
//Registration

Firebug.registerModule(CSSSelectorsModule);

return CSSSelectorsModule;

//********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/selectorPanel",
[
    "firebug/chrome/panel",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/chrome/window",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/events",
    "firebug/lib/persist",
    "firebug/css/selectorModule",
    "firebug/css/selectorEditor",
    "firebug/editor/editor",
],
function(Panel, Rep, FBTrace, Obj, Domplate, Locale, Win, Dom, Css, Events, Persist,
    CSSSelectorsModule, SelectorEditor, Editor) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, TAG, DIV, SPAN, TD, TR, TABLE, TBODY, H1, P, A, BR, INPUT} = Domplate;

// ********************************************************************************************* //
// CSS Computed panel (HTML side panel)

function CSSSelectorsPanel() {}

CSSSelectorsPanel.prototype = Obj.extend(Panel,
{
    template: domplate(
    {
        selectorsTag:
            DIV({"class": "selectorTrials a11yCSSView", role: "list", "aria-label":
                Locale.$STR("aria.labels.Selectors")},
                TAG("$selectorEditorRow"),
                DIV({"class": "elementsGroups"})
            ),

        selectorEditorRow:
            DIV({"class": "selectorEditorContainer editorContainer a11yFocusNoTab",
                role: "button", "tabindex" : "0",
                "aria-label": Locale.$STR("a11y.labels.press_enter_to_add_new_selector"),
                onclick: "$onClickEditor"},
                Locale.$STR("css.selector.TryASelector")
            ),

        elementsGroupTag:
            DIV({"class": "elementsGroup foldableGroup", $opened: "$group.opened",
                role: "list", _repObject: "$group"},
                H1({"class": "cssElementsHeader groupHeader focusRow", role: "listitem"},
                    DIV({"class": "twisty", role: "presentation"}),
                    SPAN({"class": "cssElementsLabel groupLabel"}, "$group.selector"),
                    DIV({"class": "closeButton selectorGroupRemoveButton"})
                )
            ),

        elementsTag:
            TABLE({"class": "cssElementsTable groupContent", role: "list"},
                TBODY({role: "presentation"},
                    FOR("element", "$elements",
                        TR({"class": "focusRow cssElementsRow cssElements",
                                role: "listitem", _repObject: "$element"},
                            TD({"class": "cssElement", role: "presentation"},
                                TAG("$element|getElementTag", {object: "$element"})
                            )
                        )
                    )
                )
            ),

        getElementTag: function(value)
        {
            var rep = Firebug.getRep(value);
            var tag = rep.shortTag ? rep.shortTag : rep.tag;
            return tag;
        },

        onClickEditor: function(event)
        {
            var target = event.currentTarget;
            var panel = Firebug.getElementPanel(target);
            Editor.startEditing(target, "");
        }
    }),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Events

    onClick: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        var header = Dom.getAncestorByClass(event.target, "groupHeader");
        if (header)
        {
            var removeButton = Dom.getAncestorByClass(event.target, "selectorGroupRemoveButton");
            if (removeButton)
            {
                var group = Firebug.getRepObject(event.target);
                this.removeGroup(group.selector);
            }
            else
            {
                this.toggleGroup(event.target);
            }
        }
    },

    onMutationObserve: function(records)
    {
        var refresh = false;

        // To refresh the panel check whether there's at least one element, that isn't ignored
        for (var i=0, recordsLen=records.length; i<recordsLen; ++i)
        {
            var record = records[i];
            switch(record.type)
            {
                case "childList":
                    var nodes = record.addedNodes;
                    for (var j=0, nodesLen=nodes.length; j<nodesLen; ++j)
                    {
                        if (!Firebug.shouldIgnore(nodes[j]))
                        {
                            refresh = true;
                            break;
                        }
                    }

                    if (!refresh)
                    {
                        nodes = record.removedNodes;
                        for (var j=0, nodesLen=nodes.length; j<nodesLen; ++j)
                        {
                            if (!Firebug.shouldIgnore(nodes[j]))
                            {
                                refresh = true;
                                break;
                            }
                        }
                    }
                    break;

                case "attributes":
                    if (!Firebug.shouldIgnore(record.target))
                        refresh = true;
                    break;

                case "characterData":
                    if (!Firebug.shouldIgnore(record.target.parentElement))
                        refresh = true;
                    break;
            }

            if (refresh)
                break;
        }

        if (refresh)
        {
            this.scrollTop = this.panelNode.getElementsByClassName("elementsGroups")[0].scrollTop;
            this.refresh();
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Extends Panel

    name: "selectors",
    parentPanel: "stylesheet",
    order: 0,

    initialize: function()
    {
        this.groups = [];
        this.onClick = Obj.bind(this.onClick, this);
        this.onMutationObserve = this.onMutationObserve.bind(this);

        Panel.initialize.apply(this, arguments);
    },

    destroy: function(state)
    {
        var scrollContainer = this.panelNode.getElementsByClassName("elementsGroups")[0];
        state.scrollTop = scrollContainer.scrollTop ?
            scrollContainer.scrollTop : this.lastScrollTop;
        state.groups = this.groups;
        Persist.persistObjects(this, state);

        Panel.destroyNode.apply(this, arguments);
    },

    initializeNode: function(oldPanelNode)
    {
        Panel.initializeNode.apply(this, arguments);

        Events.addEventListener(this.panelNode, "click", this.onClick, false);
    },

    destroyNode: function()
    {
        Panel.destroyNode.apply(this, arguments);

        Events.removeEventListener(this.panelNode, "click", this.onClick, false);
    },

    supportsObject: function(object)
    {
        return 0;
    },

    show: function(state)
    {
        Persist.restoreObjects(this, state);

        if (state)
        {
            if (state.scrollTop)
                this.scrollTop = state.scrollTop;

            if (state.groups)
                this.groups = state.groups;
        }

        this.refresh();

        this.observeMutations();
    },

    hide: function()
    {
        this.mutationObserver.disconnect();
        this.mutationObserver = null;
        this.lastScrollTop = this.panelNode.getElementsByClassName("elementsGroups")[0].scrollTop;
    },

    watchWindow: function(context, win)
    {
        this.observeMutations(win);
    },

    getEditor: function(target, value)
    {
        if (!this.editor)
            this.editor = new CSSSelectorsPanelEditor(this.document);

        return this.editor;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // General

    observeMutations: function(win)
    {
        var self = this;
        if (!self.mutationObserver)
            self.mutationObserver = new MutationObserver(this.onMutationObserve);

        function addObserver(win)
        {
            var doc = win.document;
            self.mutationObserver.observe(doc, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }

        // If a window is specified, use it, otherwise register observers for all
        // context windows (including the main window and all embedded iframes).
        if (win)
            addObserver(win);
        else
            Win.iterateWindows(this.context.window, addObserver);
    },

    refresh: function()
    {
        var parentNode = this.template.selectorsTag.replace(
                {groups: this.groups, windows: this.context.windows}, this.panelNode);

        if (this.groups.length == 0)
        {
            var elementsGroups = parentNode.getElementsByClassName("elementsGroups")[0];
            var box = WarningTemplate.noSelectionTag.replace({}, elementsGroups);

            var readMore = box.getElementsByClassName("readMore")[0];
            FirebugReps.Description.render(Locale.$STR("css.selector.readMore"),
                readMore, Obj.bind(this.onReadMore, this));
        }
        else
        {
            for (var i=0, len=this.groups.length; i<len; ++i)
                this.displayGroup(this.groups[i]);
        }

        if (this.scrollTop)
        {
            this.panelNode.getElementsByClassName("elementsGroups")[0].scrollTop = this.scrollTop;
            delete this.scrollTop;
        }
    },

    onReadMore: function()
    {
        Win.openNewTab("https://getfirebug.com/wiki/index.php/Selectors_Side_Panel");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Groups

    addGroup: function(selector)
    {
        var group = {
            selector: selector,
            opened: true
        }
        this.groups.push(group);

        this.displayGroup(group);
    },

    displayGroup: function(group)
    {
        var elementsGroups = this.panelNode.getElementsByClassName("elementsGroups")[0];
        var action = elementsGroups.getElementsByClassName("noSelection")[0] ?
            "replace" : "append";
        var elementsGroup = this.template.elementsGroupTag[action](
            {group: group, windows: this.context.windows}, elementsGroups);

        try
        {
            var elements = CSSSelectorsModule.matchElements(this.context.windows, group.selector);
            if (elements.length != 0)
            {
                this.template.elementsTag.append({elements: elements}, elementsGroup);
            }
            else
            {
                WarningTemplate.noSelectionResultsTag.append({}, elementsGroup);
            }
        }
        catch(e)
        {
            WarningTemplate.invalidSelectorTag.append({}, elementsGroup);
        }
    },

    toggleGroup: function(node)
    {
        var groupsNode = Dom.getAncestorByClass(node, "elementsGroups");
        var groupNode = Dom.getAncestorByClass(node, "elementsGroup");
        var group = Firebug.getRepObject(groupNode);

        Css.toggleClass(groupNode, "opened");
        var opened = Css.hasClass(groupNode, "opened");
        group.opened = opened;

        if (opened)
        {
            var offset = Dom.getClientOffset(node);
            var titleAtTop = offset.y < groupsNode.scrollTop;

            Dom.scrollTo(groupNode, groupsNode, null,
                groupNode.offsetHeight > groupsNode.clientHeight || titleAtTop ? "top" : "bottom");
        }
    },

    removeGroup: function(selector)
    {
        for (var i=0, len=this.groups.length; i<len; ++i)
        {
            if (this.groups[i].selector == selector)
            {
                this.groups.splice(i, 1);

                // Remove elements group from display
                var elementsGroup = this.panelNode.getElementsByClassName("elementsGroup")[i];
                elementsGroup.parentNode.removeChild(elementsGroup);
                break;
            }
        }
    }
});

function CSSSelectorsPanelEditor(doc)
{
    this.box = this.tag.replace({}, doc, this);
    this.input = this.box;

    SelectorEditor.prototype.initialize.call(this);
    this.tabNavigation = false;
    this.fixedWidth = true;
}

CSSSelectorsPanelEditor.prototype = domplate(SelectorEditor.prototype,
{
    tag:
        INPUT({"class": "fixedWidthEditor selectorsPanelEditor a11yFocusNoTab",
            type: "text",
            title: Locale.$STR("Selector"),
            oninput: "$onInput",
            onkeypress: "$onKeyPress"}
        ),

    saveEdit: function(target, value, previousValue)
    {
        var saveSuccess = this.isValidSelector(value);
        this.box.setAttribute("saveSuccess", saveSuccess);
    },

    endEditing: function(target, value, cancel)
    {
        if (cancel || value == "")
            return;

        this.panel.addGroup(value);
    },

    isValidSelector: function(value)
    {
        try
        {
            this.panel.panelNode.querySelector(value);
            return true;
        }
        catch (e)
        {
            return false;
        }
    }
});

// ********************************************************************************************* //

var WarningTemplate = domplate(Rep,
{
    noSelectionTag:
        DIV({"class": "selectorWarning noSelection"},
            DIV(Locale.$STR("css.selector.noSelection")),
            BR(),
            DIV({"class": "readMore"})
        ),

    noSelectionResultsTag:
        DIV({"class": "selectorWarning noSelectionResults"},
            SPAN(Locale.$STR("css.selector.noSelectionResults"))
        ),

    invalidSelectorTag:
        DIV({"class": "selectorWarning invalidSelector"},
            SPAN(Locale.$STR("css.selector.invalidSelector"))
        )
});

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(CSSSelectorsPanel);

return CSSSelectorsPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/css/stylePanel",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/lib/xpcom",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/lib/array",
    "firebug/js/sourceLink",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/xpath",
    "firebug/lib/string",
    "firebug/lib/fonts",
    "firebug/lib/options",
    "firebug/css/cssModule",
    "firebug/css/cssPanel",
    "firebug/chrome/menu",
    "firebug/css/loadHandler",
],
function(Obj, Firebug, Firefox, Domplate, FirebugReps, Xpcom, Locale, Events, Url, Arr,
    SourceLink, Dom, Css, Xpath, Str, Fonts, Options, CSSModule, CSSStyleSheetPanel, Menu,
    LoadHandler) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, TAG, DIV, SPAN, TR, H1, P, UL, A} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;
const nsIDOMCSSStyleRule = Ci.nsIDOMCSSStyleRule;

// See: http://mxr.mozilla.org/mozilla1.9.2/source/content/events/public/nsIEventStateManager.h#153
const STATE_ACTIVE  = 0x01;
const STATE_FOCUS   = 0x02;
const STATE_HOVER   = 0x04;

// ********************************************************************************************* //
// CSSStylePanel Panel (HTML side panel)

/**
 * @panel Represents the Style side panel available within HTML panel. This panel is responsible
 * for displaying CSS rules associated with the currently selected element in the HTML panel.
 * See more: https://getfirebug.com/wiki/index.php/Style_Side_Panel
 */
function CSSStylePanel() {}
CSSStylePanel.prototype = Obj.extend(CSSStyleSheetPanel.prototype,
/** @lends CSSStylePanel */
{
    name: "css",
    parentPanel: "html",
    order: 0,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function()
    {
        this.onStateChange = Obj.bindFixed(this.contentStateCheck, this);
        this.onHoverChange = Obj.bindFixed(this.contentStateCheck, this, STATE_HOVER);
        this.onActiveChange = Obj.bindFixed(this.contentStateCheck, this, STATE_ACTIVE);

        CSSStyleSheetPanel.prototype.initialize.apply(this, arguments);

        // Destroy derived updater for now.
        // xxxHonza: the Style panel could use it too?
        this.updater.destroy();
        this.updater = null;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Domplate

    template: domplate(
    {
        cascadedTag:
            DIV({"class": "a11yCSSView", role: "presentation"},
                DIV({"class": "cssNonInherited", role: "list",
                        "aria-label": Locale.$STR("a11y.labels.style rules") },
                    FOR("rule", "$rules",
                        TAG("$ruleTag", {rule: "$rule"})
                    )
                ),
                DIV({role: "list", "aria-label": Locale.$STR("aria.labels.inherited style rules")},
                    FOR("section", "$inherited",
                        H1({"class": "cssInheritHeader groupHeader focusRow", role: "listitem" },
                            SPAN({"class": "cssInheritLabel"}, "$inheritLabel"),
                            TAG(FirebugReps.Element.shortTag, {object: "$section.element"})
                        ),
                        DIV({role: "group"},
                            FOR("rule", "$section.rules",
                                TAG("$ruleTag", {rule: "$rule"})
                            )
                        )
                    )
                 )
            ),

        ruleTag:
            DIV({"class": "cssElementRuleContainer"},
                TAG(Firebug.CSSStyleRuleTag.tag, {rule: "$rule"}),
                TAG(FirebugReps.SourceLink.tag, {object: "$rule.sourceLink"})
            ),

        newRuleTag:
            DIV({"class": "cssElementRuleContainer"},
                DIV({"class": "cssRule insertBefore", style: "display: none"}, "")
            ),

        CSSFontPropValueTag:
                FOR("part", "$propValueParts",
                    SPAN({"class": "$part.type|getClass", _repObject: "$part"}, "$part.value"),
                    SPAN({"class": "cssFontPropSeparator"}, "$part|getSeparator")
                ),

        getSeparator: function(part)
        {
            if (part.lastFont || part.type == "important")
                return "";

            if (part.type == "otherProps")
                return " ";

            return ",";
        },

        getClass: function(type)
        {
            switch (type)
            {
                case "used":
                    return "cssPropValueUsed";

                case "unused":
                    return "cssPropValueUnused";

                default:
                    return "";
            }
        }
    }),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    updateCascadeView: function(element)
    {
        Events.dispatch(this.fbListeners, "onBeforeCSSRulesAdded", [this]);

        var result, warning, inheritLabel;
        var rules = [], sections = [], usedProps = {};

        this.getInheritedRules(element, sections, usedProps);
        this.getElementRules(element, rules, usedProps);

        if (rules.length || sections.length)
        {
            // This removes overridden properties.
            if (Firebug.onlyShowAppliedStyles)
                this.removeOverriddenProps(rules, sections);

            // This removes user agent rules
            if (!Firebug.showUserAgentCSS)
                this.removeSystemRules(rules, sections);
        }

        // Reset the selection, so that clicking that starts before the view
        // update still result in proper mouseup events (issue 5500).
        this.document.defaultView.getSelection().removeAllRanges();

        if (rules.length || sections.length)
        {
            inheritLabel = Locale.$STR("InheritedFrom");
            result = this.template.cascadedTag.replace({rules: rules, inherited: sections,
                inheritLabel: inheritLabel}, this.panelNode);

            var props = result.getElementsByClassName("cssProp");

            for (var i = 0; i < props.length; i++)
            {
                var prop = props[i];
                var propName = prop.getElementsByClassName("cssPropName").item(0).textContent;
                if (propName == "font-family" || propName == "font")
                {
                    var propValueElem = prop.getElementsByClassName("cssPropValue").item(0);
                    var propValue = propValueElem.textContent;
                    var fontPropValueParts = getFontPropValueParts(element, propValue, propName);

                    Css.setClass(propValueElem, "cssFontPropValue");

                    // xxxsz: Web fonts not being loaded at display time
                    // won't be marked as used. See issue 5420.
                    this.template.CSSFontPropValueTag.replace({propValueParts: fontPropValueParts},
                        propValueElem);
                }
            }

            Events.dispatch(this.fbListeners, "onCSSRulesAdded", [this, result]);
        }
        else
        {
            warning = FirebugReps.Warning.tag.replace({object: ""}, this.panelNode);
            result = FirebugReps.Description.render(Locale.$STR("css.EmptyElementCSS"),
                warning, Obj.bind(this.editElementStyle, this));

            Events.dispatch([Firebug.A11yModel], "onCSSRulesAdded", [this, result]);
        }

        // Avoid a flickering "disable" icon by forcing a reflow (issue 5500).
        this.panelNode.offsetHeight;
    },

    getStylesheetURL: function(rule, getBaseUri)
    {
        // If parentStyleSheet.href is null, then per the CSS standard this is an inline style.
        if (rule && rule.parentStyleSheet && rule.parentStyleSheet.href)
            return rule.parentStyleSheet.href;
        else if (getBaseUri)
            return this.selection.ownerDocument.baseURI;
        else
            return this.selection.ownerDocument.location.href;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getInheritedRules: function(element, sections, usedProps)
    {
        var parent = element.parentNode;
        if (parent && parent.nodeType == Node.ELEMENT_NODE)
        {
            this.getInheritedRules(parent, sections, usedProps);

            var rules = [];
            this.getElementRules(parent, rules, usedProps, true);

            if (rules.length)
                sections.unshift({element: parent, rules: rules});
        }
    },

    getElementRules: function(element, rules, usedProps, inheritMode)
    {
        function filterMozPseudoElements(pseudoElement)
        {
            return !Str.hasPrefix(pseudoElement, "::-moz");
        }

        var pseudoElements = [""];
        var inspectedRules, displayedRules = {};

        // Add pseudo-elements
        if (!inheritMode)
        {
            pseudoElements = Arr.extendArray(pseudoElements, Css.pseudoElements);

            // xxxsz: Do not show Mozilla-specific pseudo-elements for now (see issue 6451)
            // Pseudo-element rules just apply to specific elements, so we need a way to find out
            // which elements that are
            pseudoElements = pseudoElements.filter(filterMozPseudoElements);

            // XXXsimon: these are too nice to ignore, but stash them to the bottom of the
            // section for now so that e.g. a rule with selector "*::-moz-selection" doesn't
            // get in the way of more element-specific ones (see issue 6480). This should
            // be improved in the future when we do issue 6457 and/or add the ability to figure
            // out which pseudo-elements are actually applicable. (see https://bugzil.la/874227)
            pseudoElements.unshift("::-moz-placeholder");
            pseudoElements.unshift("::-moz-selection");
        }

        // The domUtils API requires the pseudo-element selectors to be prefixed by only one colon
        pseudoElements.forEach(function(pseudoElement, i)
        {
            if (Str.hasPrefix(pseudoElement, "::"))
                pseudoElements[i] = pseudoElement.substr(1);
        });

        for (var p in pseudoElements)
        {
            try
            {
                inspectedRules = Dom.domUtils.getCSSStyleRules(element, pseudoElements[p]);
            }
            catch (exc)
            {
                continue;
            }

            if (!inspectedRules)
                continue;

            for (var i = 0; i < inspectedRules.Count(); ++i)
            {
                var rule = Xpcom.QI(inspectedRules.GetElementAt(i), nsIDOMCSSStyleRule);
                var isSystemSheet = Url.isSystemStyleSheet(rule.parentStyleSheet);

                var props = this.getRuleProperties(this.context, rule, inheritMode);
                if (inheritMode && !props.length)
                    continue;

                var isPseudoElementSheet = (pseudoElements[p] != "");
                var sourceLink = this.getSourceLink(null, rule);

                if (!isPseudoElementSheet)
                    this.markOverriddenProps(element, props, usedProps, inheritMode);

                rules.unshift({
                    rule: rule,
                    selector: rule.selectorText.replace(/ :/g, " *:"), // (issue 3683)
                    sourceLink: sourceLink,
                    props: props, inherited: inheritMode,
                    isSystemSheet: isSystemSheet,
                    isPseudoElementSheet: isPseudoElementSheet,
                    isSelectorEditable: true
                });
            }
        }

        if (element.style)
            this.getStyleProperties(element, rules, usedProps, inheritMode);

        if (FBTrace.DBG_CSS)
            FBTrace.sysout("getElementRules " + rules.length + " rules for " +
                Xpath.getElementXPath(element), rules);
    },

    markOverriddenProps: function(element, props, usedProps, inheritMode)
    {
        // Element can contain an invalid name (see issue 5303)
        try
        {
            var dummyElement = element.ownerDocument.createElementNS(
                element.namespaceURI, element.tagName);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("css.markOverriddenProps:", err);
            return;
        }

        for (var i=0; i<props.length; i++)
        {
            var prop = props[i];

            // Helper array for all shorthand properties for the current property.
            prop.computed = {};

            // Get all shorthand propertis.
            var dummyStyle = dummyElement.style;

            // xxxHonza: Not sure why this happens.
            if (!dummyStyle)
            {
                if (FBTrace.DBG_ERRORS)
                {
                    FBTrace.sysout("css.markOverridenProps; ERROR dummyStyle is NULL for clone " +
                        "of " + element, dummyElement);
                }
                return;
            }

            dummyStyle.cssText = "";
            dummyStyle.setProperty(prop.name, prop.value, prop.important);

            var length = dummyStyle.length;
            for (var k=0; k<length; k++)
            {
                var name = dummyStyle.item(k);

                prop.computed[name] = {
                    overridden: false
                };

                if (usedProps.hasOwnProperty(name))
                {
                    var deadProps = usedProps[name];

                    // all previous occurrences of this property
                    for (var j=0; j<deadProps.length; j++)
                    {
                        var deadProp = deadProps[j];

                        // xxxHonza: fix for issue 3009, cross out even inherited properties
                        //if (deadProp.wasInherited)
                        //    continue;

                        if (!deadProp.disabled && deadProp.important && !prop.important)
                        {
                            // new occurrence overridden
                            prop.overridden = true;

                            // Remember what exact shorthand property has been overridden.
                            // This should help when we want to cross out only specific
                            // part of the property value.
                            if (prop.computed.hasOwnProperty(name))
                                prop.computed[name].overridden = true;
                        }
                        else if (!prop.disabled)
                        {
                            // previous occurrences overridden
                            deadProp.overridden = true;

                            if (deadProp.computed.hasOwnProperty(name))
                                deadProp.computed[name].overridden = true;
                        }
                    }
                }
                else
                {
                    usedProps[name] = [];
                }

                // all occurrences of a property seen so far, by name
                usedProps[name].push(prop);
            }

            prop.wasInherited = inheritMode ? true : false;
        }
    },

    removeOverriddenProps: function(rules, sections)
    {
        function removeProps(rules)
        {
            var i=0;
            while (i<rules.length)
            {
                var props = rules[i].props;

                var j=0;
                while (j<props.length)
                {
                    if (props[j].overridden)
                        props.splice(j, 1);
                    else
                        ++j;
                }

                if (props.length == 0)
                    rules.splice(i, 1);
                else
                    ++i;
            }
        }

        removeProps(rules);

        var i=0;
        while (i < sections.length)
        {
            var section = sections[i];
            removeProps(section.rules);

            if (section.rules.length == 0)
                sections.splice(i, 1);
            else
                ++i;
        }
    },

    removeSystemRules: function(rules, sections)
    {
        function removeSystem(rules)
        {
            var i=0;
            while (i<rules.length)
            {
                if (rules[i].isSystemSheet)
                    rules.splice(i, 1);
                else
                    ++i;
            }
        }

        removeSystem(rules);

        var i=0;
        while (i<sections.length)
        {
            var section = sections[i];
            removeSystem(section.rules);

            if (section.rules.length == 0)
                sections.splice(i, 1);
            else
                ++i;
        }
    },

    getStyleProperties: function(element, rules, usedProps, inheritMode)
    {
        var props = this.parseCSSProps(element.style, inheritMode);
        this.addDisabledProperties(this.context, element, inheritMode, props);

        this.sortProperties(props);

        this.markOverriddenProps(element, props, usedProps, inheritMode);

        if (props.length)
        {
            rules.unshift({rule: element, selector: "element.style",
                props: props, inherited: inheritMode});
        }
    },

    inspectDeclaration: function(rule)
    {
        Firebug.chrome.select(rule, "stylesheet");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    show: function(state)
    {
        if (this.selection)
            this.refresh();
    },

    watchWindow: function(context, win)
    {
        if (Dom.domUtils)
        {
            // Normally these would not be required, but in order to update after the state is set
            // using the options menu we need to monitor these global events as well
            context.addEventListener(win, "mouseover", this.onHoverChange, false);
            context.addEventListener(win, "mousedown", this.onActiveChange, false);
        }
    },

    unwatchWindow: function(context, win)
    {
        context.removeEventListener(win, "mouseover", this.onHoverChange, false);
        context.removeEventListener(win, "mousedown", this.onActiveChange, false);

        var doc = win.document;
        if (Dom.isAncestor(this.stateChangeEl, doc))
            this.removeStateChangeHandlers();
    },

    supportsObject: function(object, type)
    {
        return object instanceof window.Element ? 1 : 0;
    },

    updateView: function(element)
    {
        // We can properly update the view only if the page is fully loaded (see issue 5654).
        var loadHandler = new LoadHandler();
        loadHandler.handle(this.context, Obj.bindFixed(this.doUpdateView, this, element));
    },

    doUpdateView: function(element)
    {
        // All stylesheets should be ready now, update the view.
        this.updateCascadeView(element);

        if (Dom.domUtils)
        {
            this.contentState = safeGetContentState(element);
            this.addStateChangeHandlers(element);
        }
    },

    updateSelection: function(element)
    {
        if (!(element instanceof window.Element)) // html supports SourceLink
            return;

        var sothinkInstalled = !!Firefox.getElementById("swfcatcherKey_sidebar");
        if (sothinkInstalled)
        {
            var div = FirebugReps.Warning.tag.replace({object: "SothinkWarning"}, this.panelNode);
            div.textContent = Locale.$STR("SothinkWarning");
            return;
        }

        this.updateView(element);
    },

    updateOption: function(name, value)
    {
        var options = new Set();
        options.add("onlyShowAppliedStyles");
        options.add("showUserAgentCSS");
        options.add("expandShorthandProps");
        options.add("colorDisplay");
        options.add("showMozillaSpecificStyles");

        if (options.has(name))
            this.refresh();
    },

    getOptionsMenuItems: function()
    {
        var items = [
            Menu.optionMenu("Only_Show_Applied_Styles", "onlyShowAppliedStyles",
                "style.option.tip.Only_Show_Applied_Styles"),
            Menu.optionMenu("Show_User_Agent_CSS", "showUserAgentCSS",
                "style.option.tip.Show_User_Agent_CSS"),
            Menu.optionMenu("Expand_Shorthand_Properties", "expandShorthandProps",
                "css.option.tip.Expand_Shorthand_Properties")
        ];

        items = Arr.extendArray(items, CSSModule.getColorDisplayOptionMenuItems());

        if (Dom.domUtils && this.selection)
        {
            var self = this;

            items.push(
                "-",
                {
                    label: "style.option.label.hover",
                    type: "checkbox",
                    checked: self.hasPseudoClassLock(":hover"),
                    tooltiptext: "style.option.tip.hover",
                    command: function()
                    {
                        self.togglePseudoClassLock(":hover");
                    }
                },
                {
                    label: "style.option.label.active",
                    type: "checkbox",
                    checked: self.hasPseudoClassLock(":active"),
                    tooltiptext: "style.option.tip.active",
                    command: function()
                    {
                        self.togglePseudoClassLock(":active");
                    }
                }
            );

            if (Dom.domUtils.hasPseudoClassLock)
            {
                items.push(
                    {
                        label: "style.option.label.focus",
                        type: "checkbox",
                        checked: self.hasPseudoClassLock(":focus"),
                        tooltiptext: "style.option.tip.focus",
                        command: function()
                        {
                            self.togglePseudoClassLock(":focus");
                        }
                    }
                );
            }
        }

        return items;
    },

    getContextMenuItems: function(style, target)
    {
        var items = CSSStyleSheetPanel.prototype.getContextMenuItems.apply(this, [style, target]);
        var insertIndex = 0;

        for (var i = 0; i < items.length; ++i)
        {
            if (items[i].id == "fbNewCSSRule")
            {
                items.splice(i, 1);
                insertIndex = i;
                break;
            }
        }

        items.splice(insertIndex, 0, {
            label: "EditStyle",
            tooltiptext: "style.tip.Edit_Style",
            command: Obj.bindFixed(this.editElementStyle, this)
        },
        {
            label: "AddRule",
            tooltiptext: "css.tip.AddRule",
            command: Obj.bindFixed(this.addRelatedRule, this)
        });

        if (style && style.font && style.font.rule)
        {
            items.push(
                "-",
                {
                    label: "css.label.Inspect_Declaration",
                    tooltiptext: "css.tip.Inspect_Declaration",
                    id: "fbInspectDeclaration",
                    command: Obj.bindFixed(this.inspectDeclaration, this, style.font.rule)
                }
            );
        }

        return items;
    },

    showInfoTip: function(infoTip, target, x, y, rangeParent, rangeOffset)
    {
        var prop = Dom.getAncestorByClass(target, "cssProp");
        if (prop)
            var propNameNode = prop.getElementsByClassName("cssPropName").item(0);

        if (propNameNode && (propNameNode.textContent.toLowerCase() == "font" ||
            propNameNode.textContent.toLowerCase() == "font-family"))
        {
            var prevSibling = target.previousElementSibling;
            while (prevSibling)
            {
                rangeOffset += prevSibling.textContent.length;
                prevSibling = prevSibling.previousElementSibling;
            }
        }

        return CSSStyleSheetPanel.prototype.showInfoTip.call(
            this, infoTip, target, x, y, rangeParent, rangeOffset);
    },

    getCurrentColor: function()
    {
        var cs = this.selection.ownerDocument.defaultView.getComputedStyle(this.selection);
        return cs.getPropertyValue("color");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Extends stylesheet (CSS Panel)

    deleteRuleDeclaration: function(cssSelector)
    {
        var repObject = Firebug.getRepObject(cssSelector);

        if (repObject instanceof window.Element)
            CSSModule.deleteRule(repObject);
        else
            CSSStyleSheetPanel.prototype.deleteRuleDeclaration(cssSelector);

        this.refresh();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    hasPseudoClassLock: function(pseudoClass)
    {
        if (Dom.domUtils.hasPseudoClassLock)
        {
            return Dom.domUtils.hasPseudoClassLock(this.selection, pseudoClass);
        }
        else
        {
            // Fallback in case the new pseudo-class lock API isn't available
            var state = safeGetContentState(this.selection);
            switch(pseudoClass)
            {
                case ":active":
                    return state & STATE_ACTIVE;

                case ":hover":
                    return state & STATE_HOVER;
            }
        }
    },

    togglePseudoClassLock: function(pseudoClass)
    {
        if (FBTrace.DBG_CSS)
            FBTrace.sysout("css.togglePseudoClassLock; pseudo-class: " + pseudoClass);

        if (Dom.domUtils.hasPseudoClassLock)
        {
            if (Dom.domUtils.hasPseudoClassLock(this.selection, pseudoClass))
                Dom.domUtils.removePseudoClassLock(this.selection, pseudoClass);
            else
                Dom.domUtils.addPseudoClassLock(this.selection, pseudoClass);
        }
        else
        {
            // Fallback in case the new pseudo-class lock API isn't available
            var currentState = safeGetContentState(this.selection);
            var remove = false;
            switch(pseudoClass)
            {
                case ":active":
                    state = STATE_ACTIVE;
                    break;

                case ":hover":
                    state = STATE_HOVER;
                    break;
            }
            remove = currentState & state;

            Dom.domUtils.setContentState(remove ? this.selection.ownerDocument.documentElement :
                this.selection, state);
        }

        this.refresh();
    },

    clearPseudoClassLocks: function()
    {
        if (Dom.domUtils.clearPseudoClassLocks)
            Dom.domUtils.clearPseudoClassLocks(this.selection);
    },

    addStateChangeHandlers: function(el)
    {
        this.removeStateChangeHandlers();

        Events.addEventListener(el, "focus", this.onStateChange, true);
        Events.addEventListener(el, "blur", this.onStateChange, true);
        Events.addEventListener(el, "mouseup", this.onStateChange, false);
        Events.addEventListener(el, "mousedown", this.onStateChange, false);
        Events.addEventListener(el, "mouseover", this.onStateChange, false);
        Events.addEventListener(el, "mouseout", this.onStateChange, false);

        this.stateChangeEl = el;
    },

    removeStateChangeHandlers: function()
    {
        var sel = this.stateChangeEl;
        if (sel)
        {
            Events.removeEventListener(sel, "focus", this.onStateChange, true);
            Events.removeEventListener(sel, "blur", this.onStateChange, true);
            Events.removeEventListener(sel, "mouseup", this.onStateChange, false);
            Events.removeEventListener(sel, "mousedown", this.onStateChange, false);
            Events.removeEventListener(sel, "mouseover", this.onStateChange, false);
            Events.removeEventListener(sel, "mouseout", this.onStateChange, false);
        }

        this.stateChangeEl = null;
    },

    contentStateCheck: function(state)
    {
        if (!state || this.contentState & state)
        {
            var timeoutRunner = Obj.bindFixed(function()
            {
                var newState = safeGetContentState(this.selection);
                if (newState != this.contentState)
                {
                    this.context.invalidatePanels(this.name);
                }
            }, this);

            // Delay exec until after the event has processed and the state has been updated
            setTimeout(timeoutRunner, 0);
      }
    }
});

// ********************************************************************************************* //
// Helpers

function safeGetContentState(selection)
{
    try
    {
        if (selection && selection.ownerDocument)
            return Dom.domUtils.getContentState(selection);
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS && FBTrace.DBG_CSS)
            FBTrace.sysout("css.safeGetContentState; EXCEPTION "+e, e);
    }
}

function getFontPropValueParts(element, value, propName)
{
    const genericFontFamilies =
    {
        "serif": 1,
        "sans-serif": 1,
        "cursive": 1,
        "fantasy": 1,
        "monospace": 1,
    };

    var parts = [], origValue = value;

    // (Mirroring CSSModule.parseCSSFontFamilyValue)
    if (propName === "font")
    {
        var rePreFont = new RegExp(
            "^.*" + // anything, then
            "(" +
                "\\d+(\\.\\d+)?([a-z]*|%)|" + // a number (with possible unit)
                "(x{1,2}-)?(small|large)|medium|larger|smaller" + // or an named size description
            ") "
        );
        var matches = rePreFont.exec(value);
        if (!matches)
        {
            // Non-simple font value, like "inherit", "status-bar" or
            // "calc(12px) Arial" - just return the whole text.
            return [{type: "otherProps", value: value, lastFont: true}];
        }
        var preProps = matches[0].slice(0, -1);
        parts.push({type: "otherProps", value: preProps});
        value = value.substr(matches[0].length);
    }

    var matches = /^(.*?)( !important)?$/.exec(value);
    var fonts = matches[1].split(",");

    // What we want to know is what the specified "font-family" property means
    // for the selected element's text, not what the element actually uses (that
    // depends on font styles of its descendants). Thus, we just check the direct
    // child text nodes of the element.
    // Do not create a temporary element for testing to avoid problems like in
    // issue 5905 and 6048
    var usedFonts = [];
    var child = element.firstChild;
    do
    {
        if (!child)
            break;

        if (child.nodeType == Node.TEXT_NODE)
            usedFonts = Arr.extendArray(usedFonts, Fonts.getFonts(child));
    }
    while (child = child.nextSibling);

    var genericFontUsed = false;
    for (var i = 0; i < fonts.length; ++i)
    {
        var font = fonts[i].replace(/^["'](.*)["']$/, "$1").toLowerCase();
        var isGeneric = genericFontFamilies.hasOwnProperty(font);
        var isUsedFont = false;

        for (var j = 0; j < usedFonts.length; ++j)
        {
            var usedFont = usedFonts[j].CSSFamilyName.toLowerCase();
            if (font == usedFont || (isGeneric && !genericFontUsed))
            {
                parts.push({type: "used", value: fonts[i], font: usedFonts[j]});
                usedFonts.splice(j, 1);

                isUsedFont = true;
                if (isGeneric)
                    genericFontUsed = true;
                break;
            }
        }

        if (!isUsedFont)
            parts.push({type: "unused", value: fonts[i]});
    }

    // xxxsz: Domplate doesn't allow to check for the last element in an array yet,
    // so use this as hack
    parts[parts.length-1].lastFont = true;

    if (matches[2])
        parts.push({type: "important", value: " !important"});

    return parts;
}

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(CSSStylePanel);

return CSSStylePanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*global define:1, Components:1*/

define("firebug/debugger/debuggerLib",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/wrapper",
    "firebug/lib/xpcom",
    "firebug/chrome/panelActivation",
],
function(Firebug, FBTrace, Wrapper, Xpcom, PanelActivation) {

"use strict";

// ********************************************************************************************* //
// Constants

var Cu = Components.utils;

var comparator = Xpcom.CCSV("@mozilla.org/xpcom/version-comparator;1", "nsIVersionComparator");
var appInfo = Xpcom.CCSV("@mozilla.org/xre/app-info;1", "nsIXULAppInfo");
var pre27 = (comparator.compare(appInfo.version, "27.0*") < 0);

// Debuggees
var dbgGlobalWeakMap = new WeakMap();

// Module object
var DebuggerLib = {};

// ********************************************************************************************* //
// Implementation

/**
 * Unwraps the value of a debuggee object. Primitive values are also allowed
 * and are let through unharmed.
 *
 * @param obj {Debugger.Object} The debuggee object to unwrap, or a primitive
 *
 * @return {object} the unwrapped object, or the same primitive
 */
DebuggerLib.unwrapDebuggeeValue = function(obj)
{
    // If not a debuggee object, return it immediately.
    if (typeof obj !== "object" || obj === null)
        return obj;

    return Wrapper.unwrapObject(obj.unsafeDereference());
};

/**
 * Gets or creates the debuggee global for the given global object
 *
 * @param {*} context The Firebug context
 * @param {Window} global The global object
 *
 * @return {Debuggee Window} The debuggee global
 */
DebuggerLib.getDebuggeeGlobal = function(context, global)
{
    global = global || context.getCurrentGlobal();

    var dbgGlobal = dbgGlobalWeakMap.get(global.document);
    if (!dbgGlobal)
    {
        var dbg = getInactiveDebuggerForContext(context);
        if (!dbg)
            return;

        // xxxFlorent: For a reason I ignore, there are some conflicts with the ShareMeNot addon.
        //   As a workaround, we unwrap the global object.
        //   TODO see what cause that behaviour, why, and if there are no other addons in that case.
        var contentView = Wrapper.getContentView(global);
        if (dbg.makeGlobalObjectReference)
        {
            dbgGlobal = dbg.makeGlobalObjectReference(contentView);
        }
        else
        {
            dbgGlobal = dbg.addDebuggee(contentView);
            dbg.removeDebuggee(contentView);
        }
        dbgGlobalWeakMap.set(global.document, dbgGlobal);

        if (FBTrace.DBG_DEBUGGER)
            FBTrace.sysout("new debuggee global instance created", dbgGlobal);
    }
    return dbgGlobal;
};

// temporary version-dependent check, should be removed when minVersion = 27
DebuggerLib._closureInspectionRequiresDebugger = function()
{
    return !pre27;
};

/**
 * Runs a callback with a debugger for a global temporarily enabled.
 *
 * Currently this throws an exception unless the Script panel is enabled, because
 * otherwise debug GCs kill us.
 */
DebuggerLib.withTemporaryDebugger = function(context, global, callback)
{
    // Pre Fx27, cheat and pass a disabled debugger, because closure inspection
    // works with disabled debuggers, and that's all we need this API for.
    if (!DebuggerLib._closureInspectionRequiresDebugger())
        return callback(DebuggerLib.getDebuggeeGlobal(context, global));

    if (!PanelActivation.isPanelEnabled(Firebug.getPanelType("script")))
        throw new Error("Script panel must be enabled");

    var dbg = getInactiveDebuggerForContext(context);
    var dbgGlobal = dbg.addDebuggee(global);
    try
    {
        return callback(dbgGlobal);
    }
    finally
    {
        dbg.removeDebuggee(dbgGlobal);
    }
};

/**
 * Returns true if the frame location refers to the command entered by the user
 * through the command line.
 *
 * @param {string} frameLocation
 *
 * @return {boolean}
 */
// xxxHonza: should be renamed. It's not only related to the CommandLine, but
// to all bogus scripts, e.g. generated from 'clientEvaluate' packets.
DebuggerLib.isFrameLocationEval = function(frameFilename)
{
    return frameFilename === "debugger eval code" || frameFilename === "self-hosted";
};

// ********************************************************************************************* //
// Local helpers

/**
 * Gets or creates the Inactive Debugger instance for the given context (singleton).
 *
 * @param context {*}
 *
 * @return {Debugger} The Debugger instance
 */
var getInactiveDebuggerForContext = function(context)
{
    var DebuggerClass;
    var scope = {};

    if (context.inactiveDebugger)
        return context.inactiveDebugger;

    try
    {
        Cu.import("resource://gre/modules/jsdebugger.jsm", scope);
        scope.addDebuggerToGlobal(window);
        DebuggerClass = window.Debugger;
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERROR)
            FBTrace.sysout("DebuggerLib.getInactiveDebuggerForContext; Debugger not found", exc);
    }

    // If the Debugger Class was not found, make this function no-op.
    if (!DebuggerClass)
        getInactiveDebuggerForContext = function() {};

    var dbg = new DebuggerClass();
    dbg.enabled = false;
    context.inactiveDebugger = dbg;
    return dbg;
};

// ********************************************************************************************* //
// Registration

return DebuggerLib;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*jshint esnext:true, es5:true, curly:false */
/*global FBTrace:true, XPCNativeWrapper:true, Window:true, define:true */

define("firebug/dom/domBasePanel",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/js/sourceLink",
    "firebug/js/stackFrame",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/search",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/lib/persist",
    "firebug/console/closureInspector",
    "firebug/dom/toggleBranch",
    "firebug/lib/system",
    "firebug/chrome/menu",
    "firebug/dom/domMemberProvider",
    "firebug/dom/domEditor",
    "firebug/dom/domReps",
    "firebug/chrome/panel",
    "firebug/chrome/panelActivation",
    "firebug/debugger/debuggerLib",
    "firebug/editor/editor",
    "firebug/js/breakpoint",
    "firebug/chrome/searchBox",
    "firebug/dom/domModule",
    "firebug/console/autoCompleter",
],
function(Obj, Firebug, FirebugReps, Locale, Events, Wrapper, SourceLink, StackFrame,
    Dom, Css, Search, Str, Arr, Persist, ClosureInspector, ToggleBranch, System, Menu,
    DOMMemberProvider, DOMEditor, DOMReps, Panel, PanelActivation, DebuggerLib) {

"use strict";

// ********************************************************************************************* //
// Constants

const rxIdentifier = /^[$_A-Za-z][$_A-Za-z0-9]*$/;

// ********************************************************************************************* //

/**
 * @panel Base class for panels displaying hierarchy of objects.
 */
Firebug.DOMBasePanel = function()
{
}

Firebug.DOMBasePanel.ToolboxPlate = DOMReps.ToolboxPlate;
Firebug.DOMBasePanel.prototype = Obj.extend(Panel,
/** lends Firebug.DOMBasePanel */
{
    tag: DOMReps.DirTablePlate.tableTag,
    dirTablePlate: DOMReps.DirTablePlate,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    initialize: function()
    {
        this.objectPath = [];
        this.propertyPath = [];
        this.viewPath = [];
        this.pathIndex = -1;
        this.toggles = new ToggleBranch.ToggleBranch();

        Panel.initialize.apply(this, arguments);
    },

    initializeNode: function(node)
    {
        Panel.initializeNode.apply(this, arguments);
    },

    destroyNode: function()
    {
        Panel.destroyNode.apply(this, arguments);
    },

    destroy: function(state)
    {
        var view = this.viewPath[this.pathIndex];
        if (view && this.panelNode.scrollTop)
            view.scrollTop = this.panelNode.scrollTop;

        if (this.pathIndex > -1)
            state.pathIndex = this.pathIndex;
        if (this.viewPath)
            state.viewPath = this.viewPath;
        if (this.propertyPath)
            state.propertyPath = this.propertyPath;

        if (this.propertyPath.length > 0 && !this.propertyPath[1])
            state.firstSelection = Persist.persistObject(this.getPathObject(1), this.context);

        if (FBTrace.DBG_DOM)
            FBTrace.sysout("dom.destroy; state:", state);

        Panel.destroy.apply(this, arguments);
    },

    show: function(state)
    {
        this.showToolbarButtons("fbStatusButtons", true);

        if (!this.selection)
        {
            if (!state)
            {
                this.select(null);
                return;
            }
            if (state.pathIndex > -1)
                this.pathIndex = state.pathIndex;
            if (state.viewPath)
                this.viewPath = state.viewPath;
            if (state.propertyPath)
                this.propertyPath = state.propertyPath;

            var defaultObject = this.getDefaultSelection();
            var selectObject = defaultObject;

            if (state.firstSelection)
            {
                var restored = state.firstSelection(this.context);
                if (restored)
                {
                    selectObject = restored;
                    this.objectPath = [defaultObject, restored];
                }
                else
                    this.objectPath = [defaultObject];
            }
            else
            {
                this.objectPath = [defaultObject];
            }

            if (this.propertyPath.length > 1)
            {
                selectObject = this.resetPaths(selectObject);
            }
            else
            {
                // Sync with objectPath always containing a default object.
                this.propertyPath.push(null);
            }

            var selection = (state.pathIndex < this.objectPath.length ?
                this.getPathObject(state.pathIndex) :
                this.getPathObject(this.objectPath.length-1));

            if (FBTrace.DBG_DOM)
                FBTrace.sysout("dom.show; selection:", selection);

            this.select(selection);
        }
    },

    resetPaths: function(selectObject)
    {
        for (var i = 1; i < this.propertyPath.length; ++i)
        {
            var name = this.propertyPath[i];
            if (!name)
                continue;

            var object = selectObject;
            try
            {
                selectObject = object[name];
            }
            catch (exc)
            {
                selectObject = null;
            }

            if (selectObject)
            {
                this.objectPath.push(new FirebugReps.PropertyObj(object, name));
            }
            else
            {
                // If we can't access a property, just stop
                this.viewPath.splice(i);
                this.propertyPath.splice(i);
                this.objectPath.splice(i);
                selectObject = this.getPathObject(this.objectPath.length-1);
                break;
            }
        }
    },

    hide: function()
    {
        var view = this.viewPath[this.pathIndex];
        if (view && this.panelNode.scrollTop)
            view.scrollTop = this.panelNode.scrollTop;
    },

    getBreakOnNextTooltip: function(enabled)
    {
        return (enabled ? Locale.$STR("dom.disableBreakOnPropertyChange") :
            Locale.$STR("dom.label.breakOnPropertyChange"));
    },

    supportsObject: function(object, type)
    {
        if (type == "number" || type == "string" || type == "boolean")
            return 0;
        if (object == null)
            return 1000;
        else if (object instanceof SourceLink.SourceLink)
            return 0;
        else
            return 1; // just agree to support everything but not aggressively.
    },

    refresh: function()
    {
        this.rebuild(true);
    },

    updateSelection: function(object)
    {
        if (FBTrace.DBG_DOM)
            FBTrace.sysout("dom.updateSelection", object);

        var previousIndex = this.pathIndex;
        var previousView = (previousIndex === -1 ? null : this.viewPath[previousIndex]);

        var newPath = this.pathToAppend;
        delete this.pathToAppend;

        var pathIndex = this.findPathIndex(object);
        if (newPath || pathIndex === -1)
        {
            this.toggles = new ToggleBranch.ToggleBranch();

            if (newPath)
            {
                // Remove everything after the point where we are inserting, so we
                // essentially replace it with the new path
                if (previousView)
                {
                    if (this.panelNode.scrollTop)
                        previousView.scrollTop = this.panelNode.scrollTop;

                    this.objectPath.splice(previousIndex+1);
                    this.propertyPath.splice(previousIndex+1);
                    this.viewPath.splice(previousIndex+1);
                }

                var value = this.getPathObject(previousIndex);
                if (!value)
                {
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("dom.updateSelection no pathObject for " + previousIndex);
                    return;
                }

                // XXX This is wrong with closures, but I haven't noticed anything
                // break and I don't know how to fix, so let's just leave it...
                for (var i = 0; i < newPath.length; ++i)
                {
                    var name = newPath[i];
                    object = value;
                    try
                    {
                        value = value[name];
                    }
                    catch(exc)
                    {
                        if (FBTrace.DBG_ERRORS)
                        {
                            FBTrace.sysout("dom.updateSelection FAILS at path_i=" + i +
                                " for name:" + name);
                        }
                        return;
                    }

                    ++this.pathIndex;
                    this.objectPath.push(new FirebugReps.PropertyObj(object, name));
                    this.propertyPath.push(name);
                    this.viewPath.push({toggles: this.toggles, scrollTop: 0});
                }
            }
            else
            {
                this.toggles = new ToggleBranch.ToggleBranch();

                var win = this.getDefaultSelection();
                if (object === win)
                {
                    this.pathIndex = 0;
                    this.objectPath = [win];
                    this.propertyPath = [null];
                    this.viewPath = [{toggles: this.toggles, scrollTop: 0}];
                }
                else
                {
                    this.pathIndex = 1;
                    this.objectPath = [win, object];
                    this.propertyPath = [null, null];
                    this.viewPath = [
                        {toggles: new ToggleBranch.ToggleBranch(), scrollTop: 0},
                        {toggles: this.toggles, scrollTop: 0}
                    ];
                }
            }

            this.panelNode.scrollTop = 0;
            this.rebuild(false);
        }
        else
        {
            this.pathIndex = pathIndex;

            var view = this.viewPath[pathIndex];
            this.toggles = view ? view.toggles : new ToggleBranch.ToggleBranch();

            // Persist the current scroll location
            if (previousView && this.panelNode.scrollTop)
                previousView.scrollTop = this.panelNode.scrollTop;

            this.rebuild(false, view ? view.scrollTop : 0);
        }
    },

    getObjectPath: function(object)
    {
        return this.objectPath;
    },

    getDefaultSelection: function()
    {
        // Default to showing the top window.
        return this.getObjectView(this.context.window);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Options

    updateOption: function(name, value)
    {
        var options = new Set();
        options.add("showUserProps");
        options.add("showUserFuncs");
        options.add("showDOMProps");
        options.add("showDOMFuncs");
        options.add("showDOMConstants");
        options.add("showInlineEventHandlers");
        options.add("showClosures");
        options.add("showOwnProperties");
        options.add("showEnumerableProperties");

        if (options.has(name))
            this.rebuild(true);
    },

    getShowClosuresMenuItem: function()
    {
        var requireScriptPanel = DebuggerLib._closureInspectionRequiresDebugger();
        var label = Locale.$STR("ShowClosures");
        var tooltip = Locale.$STR("dom.option.tip.Show_Closures2");
        if (requireScriptPanel)
            tooltip = Locale.$STRF("script.Script_panel_must_be_enabled", [tooltip]);
        var menuItem = Menu.optionMenu(label, "showClosures", tooltip);
        menuItem.nol10n = true;
        if (requireScriptPanel && !PanelActivation.isPanelEnabled(Firebug.getPanelType("script")))
            menuItem.disabled = true;
        return menuItem;
    },

    getOptionsMenuItems: function()
    {
        return [
            Menu.optionMenu("ShowUserProps", "showUserProps",
                "dom.option.tip.Show_User_Props"),
            Menu.optionMenu("ShowUserFuncs", "showUserFuncs",
                "dom.option.tip.Show_User_Funcs"),
            Menu.optionMenu("ShowDOMProps", "showDOMProps",
                "dom.option.tip.Show_DOM_Props"),
            Menu.optionMenu("ShowDOMFuncs", "showDOMFuncs",
                "dom.option.tip.Show_DOM_Funcs"),
            Menu.optionMenu("ShowDOMConstants", "showDOMConstants",
                "dom.option.tip.Show_DOM_Constants"),
            Menu.optionMenu("ShowInlineEventHandlers", "showInlineEventHandlers",
                "ShowInlineEventHandlersTooltip"),
            this.getShowClosuresMenuItem(),
            "-",
            Menu.optionMenu("ShowOwnProperties", "showOwnProperties",
                "ShowOwnPropertiesTooltip"),
            Menu.optionMenu("ShowEnumerableProperties",
                "showEnumerableProperties", "ShowEnumerablePropertiesTooltip"),
            "-",
            {label: "Refresh", command: Obj.bindFixed(this.rebuild, this, true),
                tooltiptext: "panel.tip.Refresh"}
        ];
    },

    getContextMenuItems: function(object, target)
    {
        if (FBTrace.DBG_DOM)
            FBTrace.sysout("dom.getContextMenuItems;", object);

        var row = Dom.getAncestorByClass(target, "memberRow");

        var items = [];

        if (row && row.domObject && !row.domObject.ignoredPath)
        {
            var member = row.domObject;
            var rowName = member.name;
            var rowObject = member.object;
            var rowValue = member.value;

            var isWatch = Css.hasClass(row, "watchRow");
            var isStackFrame = rowObject instanceof StackFrame.StackFrame;
            var label, tooltiptext;

            items.push(
                "-",
                {
                    label: "Copy_Name",
                    tooltiptext: "dom.tip.Copy_Name",
                    command: Obj.bindFixed(this.copyName, this, row)
                },
                {
                    label: "Copy_Path",
                    tooltiptext: "dom.tip.Copy_Path",
                    command: Obj.bindFixed(this.copyPath, this, row)
                }
            );

            if (typeof rowValue === "string" || typeof rowValue === "number")
            {
                // Functions already have a copy item in their context menu
                items.push(
                    {
                        label: "CopyValue",
                        tooltiptext: "dom.tip.Copy_Value",
                        command: Obj.bindFixed(this.copyProperty, this, row)
                    }
                );
            }

            if (isWatch)
            {
                label = "EditWatch";
                tooltiptext = "watch.tip.Edit_Watch";
            }
            else if (isStackFrame)
            {
                label = "EditVariable";
                tooltiptext = "stack.tip.Edit_Variable";
            }
            else
            {
                label = "EditProperty";
                tooltiptext = "dom.tip.Edit_Property";
            }

            var readOnly = (!isWatch && !isStackFrame && member.readOnly);
            if (!readOnly)
            {
                items.push(
                    "-",
                    {
                        label: label,
                        tooltiptext: tooltiptext,
                        command: Obj.bindFixed(this.editProperty, this, row)
                    }
                );
            }

            if (isWatch ||
                (member.deletable && !isStackFrame && !Dom.isDOMMember(rowObject, rowName)))
            {
                items.push(
                    {
                        label: isWatch ? "DeleteWatch" : "DeleteProperty",
                        id: "DeleteProperty",
                        tooltiptext: isWatch ? "watch.tip.Delete_Watch" :
                            "dom.tip.Delete_Property",
                        command: Obj.bindFixed(this.deleteProperty, this, row)
                    }
                );
            }

            if (!Dom.isDOMMember(rowObject, rowName) && member && member.breakable)
            {
                items.push(
                    "-",
                    {
                        label: "dom.label.breakOnPropertyChange",
                        tooltiptext: "dom.tip.Break_On_Property_Change",
                        type: "checkbox",
                        checked: this.context.dom.breakpoints.findBreakpoint(rowObject, rowName),
                        command: Obj.bindFixed(this.breakOnProperty, this, row)
                    }
                );
            }
        }

        items.push(
            "-",
            {
                label: "Refresh",
                tooltiptext: "panel.tip.Refresh",
                command: Obj.bindFixed(this.rebuild, this, true)
            }
        );

        return items;
    },

    getEditor: function(target, value)
    {
        if (!this.editor)
            this.editor = new DOMEditor(this.document);

        return this.editor;
    },

    getObjectView: function(object)
    {
        if (!Firebug.viewChrome)
        {
            // Unwrap native, wrapped objects.
            var contentView = Wrapper.getContentView(object);
            if (contentView)
                return contentView;
        }
        return object;
    },

    rebuild: function(update, scrollTop)
    {
        Events.dispatch(this.fbListeners, "onBeforeDomUpdateSelection", [this]);

        var members = this.getMembers(this.selection, 0);
        this.expandMembers(members, this.toggles, 0, 0);
        this.showMembers(members, update, scrollTop);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Members

    /**
     * @param object a user-level object wrapped in security blanket
     * @param level for a.b.c, level is 2
     */
    getMembers: function(object, level)
    {
        if (!this.memberProvider)
            this.memberProvider = new DOMMemberProvider(this.context);

        return this.memberProvider.getMembers(object, level);
    },

    // For backward compatibility
    addMember: function()
    {
        if (!this.memberProvider)
            this.memberProvider = new DOMMemberProvider(this.context);

        return this.memberProvider.addMember.apply(this.memberProvider, arguments);
    },

    // recursion starts with offset=0, level=0
    expandMembers: function(members, toggles, offset, level)
    {
        var expanded = 0;
        for (var i = offset; i < members.length; ++i)
        {
            var member = members[i];
            if (member.level < level)
                break;

            if (toggles.get(member.name))
            {
                // member.level <= level && member.name in toggles.
                member.open = "opened";

                // Don't expand if the member doesn't have children any more.
                if (!member.hasChildren)
                    continue;

                // sets newMembers.level to level+1
                var newMembers = this.getMembers(member.value, level+1);

                // Insert 'newMembers' into 'members'
                Arr.arrayInsert(members, i+1, newMembers);

                if (FBTrace.DBG_DOM)
                {
                    FBTrace.sysout("expandMembers member.name "+member.name+" member "+member);
                    FBTrace.sysout("expandMembers toggles "+toggles, toggles);
                    FBTrace.sysout("expandMembers toggles.get(member.name) " +
                        toggles.get(member.name), toggles.get(member.name));
                    FBTrace.sysout("dom.expandedMembers level: "+level+" member.level " +
                        member.level, member);
                }

                var moreExpanded = newMembers.length +
                    this.expandMembers(members, toggles.get(member.name), i+1, level+1);
                i += moreExpanded;
                expanded += moreExpanded;
            }
        }

        return expanded;
    },

    showMembers: function(members, update, scrollTop)
    {
        // If we are still in the midst of inserting rows, cancel all pending
        // insertions here - this is a big speedup when stepping in the debugger
        if (this.timeouts)
        {
            for (var i = 0; i < this.timeouts.length; ++i)
                this.context.clearTimeout(this.timeouts[i]);
            delete this.timeouts;
        }

        if (!members.length)
            return this.showEmptyMembers();

        var panelNode = this.panelNode;
        var priorScrollTop = (scrollTop === undefined ? panelNode.scrollTop : scrollTop);

        // If we are asked to "update" the current view, then build the new table
        // offscreen and swap it in when it's done
        var offscreen = update && panelNode.firstChild;
        var dest = offscreen ? this.document : panelNode;

        var table = this.tag.replace({domPanel: this, toggles: this.toggles}, dest);
        var tbody = table.lastChild;
        var rowTag = this.dirTablePlate.rowTag;

        // Insert the first slice immediately
        var setSize = members.length;
        var slice = members.splice(0, DOMReps.insertSliceSize);
        var result = rowTag.insertRows({members: slice}, tbody.lastChild);
        var rowCount = 1;
        var panel = this;

        Events.dispatch(this.fbListeners, "onMemberRowSliceAdded",
            [panel, result, rowCount, setSize]);

        var timeouts = [];

        var delay = 0;
        while (members.length)
        {
            let slice = members.splice(0, DOMReps.insertSliceSize);
            timeouts.push(this.context.setTimeout(function addMemberRowSlice()
            {
                result = rowTag.insertRows({members: slice}, tbody.lastChild);
                rowCount += DOMReps.insertSliceSize;

                Events.dispatch(Firebug.DOMModule.fbListeners, "onMemberRowSliceAdded",
                    [panel, result, rowCount, setSize]);

                if ((panelNode.scrollHeight+panelNode.offsetHeight) >= priorScrollTop)
                    panelNode.scrollTop = priorScrollTop;

            }, delay));

            delay += DOMReps.insertInterval;
        }

        if (offscreen)
        {
            timeouts.push(this.context.setTimeout(function()
            {
                if (panelNode.firstChild)
                    panelNode.replaceChild(table, panelNode.firstChild);
                else
                    panelNode.appendChild(table);

                // Scroll back to where we were before
                panelNode.scrollTop = priorScrollTop;
            }, delay));
        }
        else
        {
            timeouts.push(this.context.setTimeout(function()
            {
                panelNode.scrollTop = (scrollTop === undefined ? 0 : scrollTop);
            }, delay));
        }
        this.timeouts = timeouts;
    },

    showEmptyMembers: function()
    {
        FirebugReps.Warning.tag.replace({object: "NoMembersWarning"}, this.panelNode);
    },

    findPathIndex: function(object)
    {
        var pathIndex = -1;
        for (var i = 0; i < this.objectPath.length; ++i)
        {
            if (this.getPathObject(i) === object)
                return i;
        }

        return -1;
    },

    getPathObject: function(index)
    {
        var object = this.objectPath[index];
        if (object instanceof FirebugReps.PropertyObj)
            return object.getObject();
        else
            return object;
    },

    getRowObject: function(row)
    {
        var object = getRowOwnerObject(row);
        return object ? object : this.selection;
    },

    getRealRowObject: function(row)
    {
        var object = this.getRowObject(row);
        return this.getObjectView(object);
    },

    getRowPropertyValue: function(row)
    {
        var object = this.getRealRowObject(row);
        return this.getObjectPropertyValue(object, row.domObject.name);
    },

    getObjectPropertyValue: function(object, propName)
    {
        if (!object)
            return;

        // Get the value with try-catch statement. This method is used also within
        // getContextMenuItems where the exception would break the context menu.
        // 1) The Firebug.Debugger.evaluate can throw
        // 2) object[propName] can also throws in case of e.g. non existing "abc.abc" prop name.
        try
        {
            if (object instanceof StackFrame.StackFrame)
                return Firebug.Debugger.evaluate(propName, this.context);
            else
                return object[propName];
        }
        catch (err)
        {
            if (FBTrace.DBG_DOM || FBTrace.DBG_ERRORS)
                FBTrace.sysout("dom.getObjectPropertyValue; EXCEPTION " + propName, object);
        }
    },

    getRowPathName: function(row)
    {
        var member = row.domObject, name = member.name;

        // Fake "(closure)" properties.
        if (member.ignoredPath)
            return ["", ""];

        // Closure variables.
        if (ClosureInspector.isScopeWrapper(member.object))
            return [".%", name];

        // Ordinals.
        if (name.match(/^[\d]+$/))
            return ["", "["+name+"]"];

        // Identifiers.
        if (name.match(rxIdentifier))
            return [".", name];

        // Other, weird, names.
        return ["", "[\""+name.replace(/\\/g, "\\\\").replace(/"/g,"\\\"") + "\"]"];
    },

    copyName: function(row)
    {
        var value = this.getRowPathName(row);
        value = value[1]; //don't want the separator
        System.copyToClipboard(value);
    },

    copyPath: function(row)
    {
        var path = this.getPropertyPath(row);
        System.copyToClipboard(path.join(""));
    },

    /**
     * Walk from the current row up to the most ancient parent, building an array.
     * @return array of property names and separators, eg ['foo','.','bar'].
     */
    getPropertyPath: function(row)
    {
        var path = [];
        for (var current = row; current ; current = getParentRow(current))
            path = this.getRowPathName(current).concat(path);
        path.shift(); //don't want the first separator
        return path;
    },

    copyProperty: function(row)
    {
        var value = this.getRowPropertyValue(row);
        System.copyToClipboard(value);
    },

    editProperty: function(row, editValue)
    {
        var member = row.domObject;
        if (member && member.readOnly)
            return;

        if (Css.hasClass(row, "watchNewRow"))
        {
            Firebug.Editor.startEditing(row, "");
        }
        else if (Css.hasClass(row, "watchRow"))
        {
            Firebug.Editor.startEditing(row, getRowName(row));
        }
        else
        {
            var object = this.getRowObject(row);
            this.context.thisValue = object;

            if (!editValue)
            {
                var propValue = this.getRowPropertyValue(row);

                var type = typeof propValue;
                if (type === "undefined" || type === "number" || type === "boolean")
                    editValue = "" + propValue;
                else if (type === "string")
                    editValue = "\"" + Str.escapeJS(propValue) + "\"";
                else if (propValue === null)
                    editValue = "null";
                else if (object instanceof window.Window || object instanceof StackFrame.StackFrame)
                    editValue = getRowName(row);
                else
                    editValue = "this." + getRowName(row); // XXX "this." doesn't actually work
            }

            var selectionData = null;
            if (type === "string")
                selectionData = {start: 1, end: editValue.length-1};

            Firebug.Editor.startEditing(row, editValue, null, selectionData);
        }
    },

    deleteProperty: function(row)
    {
        if (Css.hasClass(row, "watchRow"))
        {
            this.deleteWatch(row);
        }
        else
        {
            var member = row.domObject;
            var object = this.getObjectView(member.object);

            if (member.deletable)
            {
                try
                {
                    delete object[member.name];
                }
                catch (exc)
                {
                    return;
                }

                this.rebuild(true);
                this.markChange();
            }
        }
    },

    setPropertyValue: function(row, value)  // value must be string
    {
        var member = row.domObject;
        var name = member.name;

        if (FBTrace.DBG_DOM)
        {
            FBTrace.sysout("setPropertyValue: " + name + " set to " +
                (typeof value === "string" ? "\"" + value + "\"" : "non-string!?!?"), row);
        }

        if (name === "this")
            return;

        var object = this.getRealRowObject(row);
        if (object && !(object instanceof StackFrame.StackFrame))
        {
            Firebug.CommandLine.evaluate(value, this.context, object, this.context.getCurrentGlobal(),
                function success(result, context)
                {
                    if (FBTrace.DBG_DOM)
                    {
                        FBTrace.sysout("setPropertyValue evaluate success object[" + name + "]" +
                            " set to type " + typeof result, result);
                    }
                    object[name] = result;
                },
                function failed(exc, context)
                {
                    try
                    {
                        if (FBTrace.DBG_DOM)
                        {
                            FBTrace.sysout("setPropertyValue evaluate FAILED", exc);
                        }

                        // If the value doesn't parse, then just store it as a string.
                        // Some users will not realize they're supposed to enter a JavaScript
                        // expression and just type literal text
                        object[name] = value;
                    }
                    catch (exc) {}
                }
            );
        }
        else if (this.context.stopped)
        {
            try
            {
                Firebug.CommandLine.evaluate(name + "=" + value, this.context);
            }
            catch (exc)
            {
                try
                {
                    // See catch block above...
                    object[name] = value;
                }
                catch (exc)
                {
                    return;
                }
            }

            // Clear cached scope chain (it'll be regenerated the next time the getScopes
            // is executed). This forces the watch window to update in case a closer scope
            // variables have been changed during a debugging session.
            if (object instanceof StackFrame.StackFrame)
                object.clearScopes();
        }

        this.rebuild(true);
        this.markChange();
    },

    breakOnProperty: function(row)
    {
        var member = row.domObject;
        if (!member)
            return;

        // Bail out if this property is not breakable.
        if (!member.breakable)
            return;

        var name = member.name;
        if (name === "this")
            return;

        var object = this.getRowObject(row);
        object = this.getObjectView(object);
        if (!object)
            return;

        // Create new or remove an existing breakpoint.
        var breakpoints = this.context.dom.breakpoints;
        var bp = breakpoints.findBreakpoint(object, name);
        if (bp)
        {
            row.removeAttribute("breakpoint");
            breakpoints.removeBreakpoint(object, name);
        }
        else
        {
            breakpoints.addBreakpoint(object, name, this, row);
            row.setAttribute("breakpoint", "true");
        }
    },
});

// ********************************************************************************************* //
// Local Helpers

function getRowName(row)
{
    // XXX This can return not only property names but also just descriptive ones,
    // like "(closure)", and indeed the collapse remembering logic relies on that.
    var labelNode = row.getElementsByClassName("memberLabelCell").item(0);
    return labelNode.textContent;
}

function getRowValue(row)
{
    var valueNode = row.getElementsByClassName("memberValueCell").item(0);
    return valueNode.firstChild.repObject;
}

function getRowOwnerObject(row)
{
    var parentRow = getParentRow(row);
    if (parentRow)
        return getRowValue(parentRow);
}

function getParentRow(row)
{
    var level = "" + (parseInt(row.getAttribute("level"), 10) - 1);
    if (level === "-1")
        return;
    for (row = row.previousSibling; row; row = row.previousSibling)
    {
        if (row.getAttribute("level") === level)
            return row;
    }
}

/**
 * Returns an array of parts that uniquely identifies a row (not always all JavaScript)
 */
function getPath(row)
{
    var name = getRowName(row);
    var path = [name];

    var level = parseInt(row.getAttribute("level"), 10) - 1;
    for (row = row.previousSibling; row && level >= 0; row = row.previousSibling)
    {
        if (parseInt(row.getAttribute("level"), 10) === level)
        {
            name = getRowName(row);
            path.splice(0, 0, name);

            --level;
        }
    }

    return path;
}

// ********************************************************************************************* //
// Registration

// Expose so, it can be used by derived objects.
Firebug.DOMBasePanel.getPath = getPath;

return Firebug.DOMBasePanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/dom/domBreakpointGroup",
[
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/lib/persist",
],
function(Rep, Obj, Firebug, Domplate, Locale, Events, Wrapper, Dom, Css, Str, Arr, Persist) {

// ********************************************************************************************* //
// Constants

var {domplate, TAG, DIV, SPAN, TR, P, A, INPUT} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //
// Breakpoint Group

function DOMBreakpointGroup()
{
    this.breakpoints = [];
}

DOMBreakpointGroup.prototype = Obj.extend(new Firebug.Breakpoint.BreakpointGroup(),
{
    name: "domBreakpoints",
    title: Locale.$STR("dom.label.DOM Breakpoints"),

    addBreakpoint: function(object, propName, panel, row)
    {
        var path = panel.getPropertyPath(row);
        path.pop();

        // We don't want the last dot.
        if (path.length > 0 && path[path.length-1] == ".")
            path.pop();

        var objectPath = path.join("");
        if (FBTrace.DBG_DOM)
            FBTrace.sysout("dom.addBreakpoint; " + objectPath, path);

        var bp = new Breakpoint(object, propName, objectPath, panel.context);
        if (bp.watchProperty());
            this.breakpoints.push(bp);
    },

    removeBreakpoint: function(object, propName)
    {
        var bp = this.findBreakpoint(object, propName);
        if (bp)
        {
            bp.unwatchProperty();
            Arr.remove(this.breakpoints, bp);
        }
    },

    matchBreakpoint: function(bp, args)
    {
        var object = args[0];
        var propName = args[1];
        return bp.object == object && bp.propName == propName;
    },

    // Persistence
    load: function(context)
    {
        var panelState = Persist.getPersistedState(context, "dom");
        if (panelState.breakpoints)
            this.breakpoints = panelState.breakpoints;

        this.enumerateBreakpoints(function(bp)
        {
            try
            {
                var contentView = Wrapper.getContentView(context.window);
                bp.object = contentView[bp.objectPath];
                bp.context = context;
                bp.watchProperty();

                if (FBTrace.DBG_DOM)
                    FBTrace.sysout("dom.DOMBreakpointGroup.load; " + bp.objectPath, bp);
            }
            catch (err)
            {
                if (FBTrace.DBG_ERROR || FBTrace.DBG_DOM)
                    FBTrace.sysout("dom.DOMBreakpointGroup.load; ERROR " + bp.objectPath, err);
            }
        });
    },

    store: function(context)
    {
        this.enumerateBreakpoints(function(bp)
        {
            bp.object = null;
        });

        var panelState = Persist.getPersistedState(context, "dom");
        panelState.breakpoints = this.breakpoints;
    },
});

// ********************************************************************************************* //

function Breakpoint(object, propName, objectPath, context)
{
    this.context = context;
    this.propName = propName;
    this.objectPath = objectPath;
    this.object = object;
    this.checked = true;
}

Breakpoint.prototype =
{
    watchProperty: function()
    {
        if (FBTrace.DBG_DOM)
            FBTrace.sysout("dom.watch; property: " + this.propName);

        if (!this.object)
            return;

        try
        {
            var self = this;
            this.object.watch(this.propName, function handler(prop, oldval, newval)
            {
                // XXXjjb Beware: in playing with this feature I hit too much recursion
                // multiple times with console.log
                // TODO Do something cute in the UI with the error bubble thing
                if (self.checked)
                {
                    self.context.breakingCause = {
                        title: Locale.$STR("dom.Break On Property"),
                        message: Str.cropString(prop, 200),
                        prevValue: oldval,
                        newValue: newval
                    };

                    Firebug.Breakpoint.breakNow(self.context.getPanel("dom"));
                }
                return newval;
            });
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("dom.watch; object FAILS " + exc, exc);
            return false;
        }

        return true;
    },

    unwatchProperty: function()
    {
        if (FBTrace.DBG_DOM)
            FBTrace.sysout("dom.unwatch; property: " + this.propName, this.object);

        if (!this.object)
            return;

        try
        {
            this.object.unwatch(this.propName);
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("dom.unwatch; object FAILS " + exc, exc);
        }
    }
};

// ********************************************************************************************* //

var BreakpointRep = domplate(Rep,
{
    inspectable: false,

    tag:
        DIV({"class": "breakpointRow focusRow", $disabled: "$bp|isDisabled", _repObject: "$bp",
            role: "option", "aria-checked": "$bp.checked"},
            DIV({"class": "breakpointBlockHead"},
                INPUT({"class": "breakpointCheckbox", type: "checkbox",
                    _checked: "$bp.checked", tabindex: "-1", onclick: "$onEnable"}),
                SPAN({"class": "breakpointName"}, "$bp.propName"),
                SPAN({"class": "closeButton", onclick: "$onRemove"})
            ),
            DIV({"class": "breakpointCode"},
                TAG("$bp.object|getObjectTag", {object: "$bp.object"})
            )
        ),

    getObjectTag: function(object)
    {
        // I am uncertain about the Firebug.currentContext but I think we are
        // only here in panel code.
        var rep = Firebug.getRep(object, Firebug.currentContext);
        return rep.shortTag ? rep.shortTag : rep.tag;
    },

    isDisabled: function(bp)
    {
        return !bp.checked;
    },

    onRemove: function(event)
    {
        Events.cancelEvent(event);

        if (!Css.hasClass(event.target, "closeButton"))
            return;

        var bpPanel = Firebug.getElementPanel(event.target);
        var context = bpPanel.context;

        // Remove from list of breakpoints.
        var row = Dom.getAncestorByClass(event.target, "breakpointRow");
        var bp = row.repObject;
        context.dom.breakpoints.removeBreakpoint(bp.object, bp.propName);

        bpPanel.refresh();

        var domPanel = context.getPanel("dom", true);
        if (domPanel)
        {
            var domRow = findRow(domPanel.panelNode, bp.object, bp.propName);
            if (domRow)
            {
                domRow.removeAttribute("breakpoint");
                domRow.removeAttribute("disabledBreakpoint");
            }
        }
    },

    onEnable: function(event)
    {
        var checkBox = event.target;
        var bpRow = Dom.getAncestorByClass(checkBox, "breakpointRow");

        if (checkBox.checked)
        {
            Css.removeClass(bpRow, "disabled");
            bpRow.setAttribute("aria-checked", "true");
        }
        else
        {
            Css.setClass(bpRow, "disabled");
            bpRow.setAttribute("aria-checked", "false");
        }

        var bp = bpRow.repObject;
        bp.checked = checkBox.checked;

        var bpPanel = Firebug.getElementPanel(event.target);
        var context = bpPanel.context;

        var domPanel = context.getPanel("dom", true);
        if (domPanel)
        {
            var row = findRow(domPanel.panelNode, bp.object, bp.propName);
            if (row)
                row.setAttribute("disabledBreakpoint", bp.checked ? "false" : "true");
        }
    },

    supportsObject: function(object, type)
    {
        return object instanceof Breakpoint;
    }
});

// ********************************************************************************************* //
// Helpers

function findRow(parentNode, object, propName)
{
    var rows = parentNode.getElementsByClassName("memberRow");
    for (var i=0; i<rows.length; i++)
    {
        var row = rows[i];
        if (object == row.domObject.object && propName == row.domObject.name)
            return row;
    }

    return row;
}

// ********************************************************************************************* //
// Registration

Firebug.registerRep(BreakpointRep);

return DOMBreakpointGroup;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/dom/domEditor",
[
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/events",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/console/autoCompleter",    // Firebug.JSEditor
],
function(Firebug, Domplate, Events, Dom, Css) {

"use strict";

// ********************************************************************************************* //
// Constants

var {domplate, DIV, INPUT} = Domplate;

// ********************************************************************************************* //
// DOM Inline Editor

function DOMEditor(doc)
{
    this.box = this.tag.replace({}, doc, this);
    this.input = this.box.childNodes[1];

    var completionBox = this.box.childNodes[0];
    var options = {
        includeCurrentScope: true
    };

    this.setupCompleter(completionBox, options);
}

DOMEditor.prototype = domplate(Firebug.JSEditor.prototype,
{
    tag:
        DIV({style: "position: absolute;"},
            INPUT({"class": "fixedWidthEditor completionBox", type: "text",
                tabindex: "-1"}),
            INPUT({"class": "fixedWidthEditor completionInput", type: "text",
                oninput: "$onInput", onkeypress: "$onKeyPress"})),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    endEditing: function(target, value, cancel)
    {
        // XXXjoe Kind of hackish - fix me
        delete this.panel.context.thisValue;

        if (cancel || value === "")
            return;

        var row = Dom.getAncestorByClass(target, "memberRow");

        Events.dispatch(this.panel.fbListeners, "onWatchEndEditing", [this.panel]);

        if (!row)
            this.panel.addWatch(value);
        else if (Css.hasClass(row, "watchRow"))
            this.panel.setWatchValue(row, value);
        else
            this.panel.setPropertyValue(row, value);
    }
});

// ********************************************************************************************* //
// Registration

return DOMEditor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*jshint esnext:true, es5:true, curly:false */
/*global FBTrace:true, XPCNativeWrapper:true, Window:true, define:true */

define("firebug/dom/domMemberProvider",
[
    "firebug/firebug",
    "firebug/lib/object",
    "firebug/lib/array",
    "firebug/lib/wrapper",
    "firebug/lib/dom",
    "firebug/lib/trace",
    "firebug/lib/locale",
    "firebug/console/closureInspector",
    "firebug/chrome/reps",
],
function(Firebug, Obj, Arr, Wrapper, Dom, FBTrace, Locale, ClosureInspector, FirebugReps) {

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// DOM Member Provider

function DOMMemberProvider(context)
{
    this.context = context;
}

DOMMemberProvider.prototype =
{
    /**
     * @param object a user-level object wrapped in security blanket
     * @param level for a.b.c, level is 2
     */
    getMembers: function(object, level)
    {
        if (!level)
            level = 0;

        var ordinals = [];
        var userProps = [];
        var userClasses = [];
        var userFuncs = [];
        var domProps = [];
        var domClasses = [];
        var domFuncs = [];
        var domConstants = [];
        var proto = [];
        var domHandlers = [];

        var isScope = ClosureInspector.isScopeWrapper(object);

        try
        {
            // Special case for "arguments", which is not enumerable by for...in statement.
            if (isArguments(object))
                object = Arr.cloneArray(object);

            var properties;
            var contentView = this.getObjectView(object);
            try
            {
                // Make sure not to touch the prototype chain of the magic scope objects.
                var ownOnly = Firebug.showOwnProperties || isScope;
                var enumerableOnly = Firebug.showEnumerableProperties;

                properties = this.getObjectProperties(contentView, enumerableOnly, ownOnly);
                properties = Arr.sortUnique(properties);

                var addOwn = function(prop)
                {
                    // Apparently, Object.prototype.hasOwnProperty.call(contentView, p) lies
                    // when 'contentView' is content and 'Object' is chrome... Bug 658909?
                    if (Object.getOwnPropertyDescriptor(contentView, prop) &&
                        properties.indexOf(prop) === -1)
                    {
                        properties.push(prop);
                    }
                };
                addOwn("constructor");
                addOwn("prototype");
                addOwn("wrappedJSObject");

                // __proto__ never shows in enumerations, so add it here. We currently
                // we don't want it when only showing own properties.
                if (contentView.__proto__ && Obj.hasProperties(contentView.__proto__) &&
                    properties.indexOf("__proto__") === -1 && !ownOnly)
                {
                    properties.push("__proto__");
                }
            }
            catch (exc)
            {
                if (FBTrace.DBG_ERRORS || FBTrace.DBG_DOM)
                    FBTrace.sysout("dom.getMembers: property lookups failed", exc);
            }

            var name, val;
            var add = function(type, where)
            {
                this.addMember(object, type, where, name, val, level, isScope);
            }.bind(this);

            for (var i=0; i<properties.length; i++)
            {
                name = properties[i];

                // Ignore only global variables (properties of the |window| object).
                if (Wrapper.shouldIgnore(name) && (object instanceof Window))
                {
                    if (FBTrace.DBG_DOM)
                    {
                        FBTrace.sysout("dom.getMembers: Wrapper.ignoreVars: " + name + ", " +
                            level, object);
                    }
                    continue;
                }

                try
                {
                    val = contentView[name];
                }
                catch (exc)
                {
                    // Sometimes we get exceptions trying to access certain members
                    if (FBTrace.DBG_ERRORS && FBTrace.DBG_DOM)
                        FBTrace.sysout("dom.getMembers cannot access "+name, exc);

                    val = undefined;
                }

                if (!isNaN(parseInt(name, 10)))
                {
                    add("ordinal", ordinals);
                }
                else if (typeof val === "function")
                {
                    var classFunc = isClassFunction(val);
                    var domMember = Dom.isDOMMember(object, name);
                    if (domMember && classFunc)
                    {
                        add("domClass", domClasses);
                    }
                    else if (domMember)
                    {
                        add("domFunction", domFuncs);
                    }
                    else if (classFunc)
                    {
                        add("userClass", userClasses);
                    }
                    else if (!Firebug.showUserFuncs && Firebug.showInlineEventHandlers &&
                        Dom.isInlineEventHandler(name))
                    {
                        add("userFunction", domHandlers);
                    }
                    else
                    {
                        add("userFunction", userFuncs);
                    }
                }
                else
                {
                    if (isPrototype(name))
                    {
                        add("proto", proto);
                    }
                    else if (Dom.isDOMMember(object, name))
                    {
                        add("dom", domProps);
                    }
                    else if (Dom.isDOMConstant(object, name))
                    {
                        add("dom", domConstants);
                    }
                    else if (val === null && object instanceof EventTarget &&
                        Dom.isInlineEventHandler(name))
                    {
                        add("user", domHandlers);
                    }
                    else
                    {
                        add("user", userProps);
                    }
                }
            }

            if (isScope || (typeof object === "function" && Firebug.showClosures && this.context))
            {
                this.maybeAddClosureMember(object, "proto", proto, level, isScope);
            }
        }
        catch (exc)
        {
            // Sometimes we get exceptions just from trying to iterate the members
            // of certain objects, like StorageList, but don't let that gum up the works
            if (FBTrace.DBG_DOM)
                FBTrace.sysout("dom.getMembers FAILS: ", exc);
        }

        function sortName(a, b) { return a.name > b.name ? 1 : -1; }
        function sortOrdinal(a, b) { return a.name - b.name; }

        var members = [];

        ordinals.sort(sortOrdinal);
        members.push.apply(members, ordinals);

        if (Firebug.showUserProps)
        {
            userProps.sort(sortName);
            members.push.apply(members, userProps);
        }

        if (Firebug.showUserFuncs)
        {
            userClasses.sort(sortName);
            members.push.apply(members, userClasses);

            userFuncs.sort(sortName);
            members.push.apply(members, userFuncs);
        }

        if (Firebug.showDOMProps)
        {
            domProps.sort(sortName);
            members.push.apply(members, domProps);
        }

        if (Firebug.showDOMFuncs)
        {
            domClasses.sort(sortName);
            members.push.apply(members, domClasses);

            domFuncs.sort(sortName);
            members.push.apply(members, domFuncs);
        }

        if (Firebug.showDOMConstants)
            members.push.apply(members, domConstants);

        members.push.apply(members, proto);

        if (Firebug.showInlineEventHandlers)
        {
            domHandlers.sort(sortName);
            members.push.apply(members, domHandlers);
        }

        if (FBTrace.DBG_DOM)
        {
            var showEnum = Firebug.showEnumerableProperties;
            var showOwn = Firebug.showOwnProperties;
            FBTrace.sysout("dom.getMembers; Report: enum-only: " + showEnum +
                ", own-only: " + showOwn,
            {
                object: object,
                ordinals: ordinals,
                userProps: userProps,
                userFuncs: userFuncs,
                userClasses: userClasses,
                domProps: domProps,
                domFuncs: domFuncs,
                domConstants: domConstants,
                domHandlers: domHandlers,
                proto: proto
            });
        }

        return members;
    },

    addMember: function()
    {
        try
        {
            return this.addMemberInternal.apply(this, arguments);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("domPanel.addMember; EXCEPTION " + err, err);
        }
    },

    addMemberInternal: function(object, type, props, name, value, level, parentIsScope)
    {
        // Do this first in case a call to instanceof (= QI, for XPCOM things) reveals contents.
        var rep = Firebug.getRep(value);
        var tag = rep.shortTag ? rep.shortTag : rep.tag;

        var hasProperties = Obj.hasProperties(value, !Firebug.showEnumerableProperties,
            Firebug.showOwnProperties);

        var valueType = typeof value;
        var hasChildren = hasProperties && !(value instanceof FirebugReps.ErrorCopy) &&
            ((valueType === "function") ||
             (valueType === "object" && value !== null));

        // Special case for closure inspection.
        if (!hasChildren && valueType === "function" && Firebug.showClosures && this.context)
        {
            try
            {
                var win = this.context.getCurrentGlobal();
                ClosureInspector.withEnvironmentForObject(win, value, this.context, function(env)
                {
                    hasChildren = true;
                });
            }
            catch (e) {}
        }

        // Special case for "arguments", which is not enumerable by for...in statement
        // and so, Obj.hasProperties always returns false.
        hasChildren = hasChildren || (!!value && isArguments(value) && value.length > 0);

        if (valueType === "function" && !hasChildren)
        {
            try
            {
                // Special case for functions with a prototype that has values
                var proto = value.prototype;
                if (proto)
                {
                    hasChildren = Obj.hasProperties(proto, !Firebug.showEnumerableProperties,
                        Firebug.showOwnProperties);
                }
            }
            catch (exc) {}
        }

        var descriptor = getPropertyDescriptor(object, name);

        var member = {
            object: object,
            name: name,
            value: value,
            type: type,
            rowClass: "memberRow-" + type,
            open: "",
            level: level,
            indent: level * 16,
            hasChildren: hasChildren,
            tag: tag,
            prefix: "",
            readOnly: (descriptor && !descriptor.writable && !descriptor.set),
            // XXX should probably move the tests from getContextMenuItems here
            deletable: (!parentIsScope && !(descriptor && !descriptor.configurable))
        };

        // The context doesn't have to be specified (e.g. in case of Watch panel that is based
        // on the same template as the DOM panel, but doesn't show any breakpoints).
        if (this.context)
        {
            // xxxHonza: Support for object change not implemented yet.
            member.breakable = !hasChildren && !parentIsScope;

            var breakpoints = this.context.dom.breakpoints;
            var bp = breakpoints.findBreakpoint(object, name);
            if (bp)
            {
                member.breakpoint = true;
                member.disabledBreakpoint = !bp.checked;
            }
        }

        if (parentIsScope)
            member.scopeNameTooltip = Locale.$STRF("dom.tip.scopeMemberName", ["%" + name]);

        // Set prefix for user defined properties. This prefix help the user to distinguish
        // among simple properties and those defined using getter and/or (only a) setter.
        // XXX This should be rewritten to use 'descriptor', and I believe the unwrapping
        // test is wrong (see issue 5377).
        var o = this.getObjectView(object);
        if (o && !Dom.isDOMMember(object, name) && (XPCNativeWrapper.unwrap(object) !== object))
        {
            var getter = (o.__lookupGetter__) ? o.__lookupGetter__(name) : null;
            var setter = (o.__lookupSetter__) ? o.__lookupSetter__(name) : null;

            // both, getter and setter
            if (getter && setter)
                member.type = "userFunction";

            // only getter
            if (getter && !setter)
            {
                member.readOnly = true;
                member.prefix = "get";
            }

            // only setter
            if (!getter && setter)
            {
                member.prefix = "set";
            }
        }

        props.push(member);
        return member;
    },

    // Add the magic "(closure)" property.
    maybeAddClosureMember: function(object, type, props, level, isScope)
    {
        var win = this.context.getCurrentGlobal();
        var wrapper = ClosureInspector.getScopeWrapper(object, win, this.context, isScope);
        if (!wrapper)
            return;

        var name = (isScope ? Locale.$STR("dom.scopeParentName") : Locale.$STR("dom.scopeName"));
        var title = (isScope ? undefined : Locale.$STR("dom.tip.scopeName"));
        var rep = Firebug.getRep(wrapper);
        var tag = rep.shortTag ? rep.shortTag : rep.tag;

        var member = {
            object: object,
            name: name,
            value: wrapper,
            type: type,
            rowClass: "memberRow-" + type,
            open: "",
            level: level,
            indent: level*16,
            hasChildren: true,
            tag: tag,
            prefix: "",
            title: title,
            readOnly: true,
            deletable: false,
            ignoredPath: true
        };
        props.push(member);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Object properties

    /**
     * Returns a list of properties available on an object, filtered on enumerability and prototype
     * chain position. Due to prototype traversal, some property names may appear several times.
     *
     * @param {Object} object The object we want to get the list of properties for.
     * @param {Boolean} enumerableOnly If set to true, only enumerable properties are returned.
     * @param {Boolean} ownOnly If set to true, only own properties (not those from the
     *      prototype chain) are returned.
     */
    getObjectProperties: function(object, enumerableOnly, ownOnly)
    {
        var props = [];

        // Get all enumerable-only or all-properties of the object (but not inherited).
        if (enumerableOnly)
            props = Object.keys(object);
        else
            props = Object.getOwnPropertyNames(object);

        // Not interested in inherited properties, bail out.
        if (ownOnly)
            return props;

        // Climb the prototype chain.
        var inheritedProps = [];
        var parent = Object.getPrototypeOf(object);
        if (parent)
            inheritedProps = this.getObjectProperties(parent, enumerableOnly, ownOnly);

        // Push everything onto the returned array, to avoid O(nm) runtime behavior.
        inheritedProps.push.apply(inheritedProps, props);
        return inheritedProps;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Wrappers

    getObjectView: function(object)
    {
        if (!Firebug.viewChrome)
        {
            // Unwrap native, wrapped objects.
            var contentView = Wrapper.getContentView(object);
            if (contentView)
                return contentView;
        }
        return object;
    },
}

// ********************************************************************************************* //
// Helpers

function isArguments(obj)
{
    return Object.prototype.toString.call(obj) === "[object Arguments]";
}

function isClassFunction(fn)
{
    try
    {
        for (var name in fn.prototype)
            return true;
    }
    catch (exc)
    {
    }

    return false;
}

function isPrototype(name)
{
    return (name === "prototype" || name === "__proto__");
}

function getPropertyDescriptor(object, propName)
{
    try
    {
        var desc;
        while (object)
        {
            desc = Object.getOwnPropertyDescriptor(object, propName);
            if (desc)
                return desc;
            object = Object.getPrototypeOf(object);
        }
    }
    catch (e)
    {
    }
    return undefined;
}

// ********************************************************************************************* //
// Registration

return DOMMemberProvider;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/dom/domModule",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/dom/domBreakpointGroup",
],
function(Module, Obj, Firebug, DOMBreakpointGroup) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //
// DOM Module

Firebug.DOMModule = Obj.extend(Module,
{
    dispatchName: "domModule",

    initialize: function(prefDomain, prefNames)
    {
        Module.initialize.apply(this, arguments);

        if (Firebug.Debugger)
            Firebug.connection.addListener(this.DebuggerListener);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        if (Firebug.Debugger)
            Firebug.connection.removeListener(this.DebuggerListener);
    },

    initContext: function(context, persistedState)
    {
        Firebug.Module.initContext.apply(this, arguments);

        context.dom = {breakpoints: new DOMBreakpointGroup()};
    },

    loadedContext: function(context, persistedState)
    {
        context.dom.breakpoints.load(context);
    },

    destroyContext: function(context, persistedState)
    {
        Firebug.Module.destroyContext.apply(this, arguments);

        context.dom.breakpoints.store(context);
    },
});

// ********************************************************************************************* //

Firebug.DOMModule.DebuggerListener =
{
    getBreakpoints: function(context, groups)
    {
        if (!context.dom.breakpoints.isEmpty())
            groups.push(context.dom.breakpoints);
    }
};

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.DOMModule);

return Firebug.DOMModule;

// ********************************************************************************************* //
});

/* See license.txt for terms of usage */
/*jshint esnext:true, es5:true, curly:false */
/*global FBTrace:true, XPCNativeWrapper:true, Window:true, define:true */

define("firebug/dom/domPanel",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/reps",
    "firebug/lib/events",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/search",
    "firebug/dom/domBasePanel",
],
function(Obj, Firebug, FirebugReps, Events, Dom, Css, Search, DOMBasePanel) {

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// DOM Panel

/**
 * @panel This object represents a DOM panel in the main Firebug UI.
 */
Firebug.DOMPanel = function()
{
}

Firebug.DOMPanel.DirTable = DOMBasePanel.prototype.dirTablePlate;
Firebug.DOMPanel.prototype = Obj.extend(DOMBasePanel.prototype,
/** lends Firebug.DOMPanel */
{
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    name: "dom",
    searchable: true,
    statusSeparator: ">",
    enableA11y: true,
    deriveA11yFrom: "console",
    searchType : "dom",
    order: 50,
    inspectable: true,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function()
    {
        this.onClick = Obj.bind(this.onClick, this);

        DOMBasePanel.prototype.initialize.apply(this, arguments);
    },

    initializeNode: function(oldPanelNode)
    {
        Events.addEventListener(this.panelNode, "click", this.onClick, false);

        DOMBasePanel.prototype.initializeNode.apply(this, arguments);
    },

    destroyNode: function()
    {
        Events.removeEventListener(this.panelNode, "click", this.onClick, false);

        DOMBasePanel.prototype.destroyNode.apply(this, arguments);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Search

    search: function(text, reverse)
    {
        if (!text)
        {
            delete this.currentSearch;
            this.highlightNode(null);
            this.document.defaultView.getSelection().removeAllRanges();
            return false;
        }

        var row;
        if (this.currentSearch && text === this.currentSearch.text)
        {
            // xxxsz: 'Firebug.Search' is used here instead of 'Search' because we need to refer to
            // 'firebug/chrome/searchBox' and not to 'firebug/lib/search'
            // TODO: Rework 'searchBox.js', so it doesn't inject itself into the global 'Firebug'
            // scope anymore
            row = this.currentSearch.findNext(true, undefined, reverse,
                Firebug.Search.isCaseSensitive(text));
        }
        else
        {
            var findRow = function(node)
            {
                return Dom.getAncestorByClass(node, "memberRow");
            };

            this.currentSearch = new Search.TextSearch(this.panelNode, findRow);

            // xxxsz: 'Firebug.Search' is used here instead of 'Search' because we need to refer to
            // 'firebug/chrome/searchBox' and not to 'firebug/lib/search'
            row = this.currentSearch.find(text, reverse, Firebug.Search.isCaseSensitive(text));
        }

        if (row)
        {
            var sel = this.document.defaultView.getSelection();
            sel.removeAllRanges();
            sel.addRange(this.currentSearch.range);

            Dom.scrollIntoCenterView(row, this.panelNode);

            this.highlightNode(row);
            Events.dispatch(this.fbListeners, "onDomSearchMatchFound", [this, text, row]);
            return true;
        }
        else
        {
            this.document.defaultView.getSelection().removeAllRanges();
            Events.dispatch(this.fbListeners, "onDomSearchMatchFound", [this, text, null]);
            return false;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    selectRow: function(row, target)
    {
        if (!target)
            target = row.lastChild.firstChild;

        var object = target && target.repObject, type = typeof object;
        if (!object || !this.supportsObject(object, type))
            return;

        this.pathToAppend = DOMBasePanel.getPath(row);

        // If the object is inside an array, look up its index
        var valueBox = row.lastChild.firstChild;
        if (Css.hasClass(valueBox, "objectBox-array"))
        {
            var arrayIndex = FirebugReps.Arr.getItemIndex(target);
            this.pathToAppend.push(arrayIndex);
        }

        // Make sure we get a fresh status path for the object, since otherwise
        // it might find the object in the existing path and not refresh it
        Firebug.chrome.clearStatusPath();

        this.select(object, true);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onClick: function(event)
    {
        var repNode = Firebug.getRepNode(event.target);
        if (repNode)
        {
            var row = Dom.getAncestorByClass(event.target, "memberRow");
            if (row)
            {
                this.selectRow(row, repNode);
                Events.cancelEvent(event);
            }
        }
    },
});

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(Firebug.DOMPanel);

return Firebug.DOMPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*jshint esnext:true, es5:true, curly:false */
/*global FBTrace:true, XPCNativeWrapper:true, Window:true, define:true */

define("firebug/dom/domReps",
[
    "firebug/firebug",
    "firebug/chrome/rep",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/options",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/lib/string",
    "firebug/dom/toggleBranch",
    "firebug/dom/domModule",
    "firebug/dom/domMemberProvider",
],
function(Firebug, Rep, Domplate, FirebugReps, Locale, Events, Options, Dom, Css, Str,
    ToggleBranch, DOMModule, DOMMemberProvider) {

"use strict";

// ********************************************************************************************* //
// Constants

const insertSliceSize = 18;
const insertInterval = 40;

var {domplate, TABLE, TBODY, TR, TD, DIV, SPAN, TAG, FOR} = Domplate;

// ********************************************************************************************* //

var WatchRowTag =
    TR({"class": "watchNewRow", level: 0},
        TD({"class": "watchEditCell", colspan: 3},
            DIV({"class": "watchEditBox a11yFocusNoTab", role: "button", tabindex: "0",
                "aria-label": Locale.$STR("a11y.labels.press enter to add new watch expression")},
                    Locale.$STR("NewWatch")
            )
        )
    );

var SizerRow =
    TR({role: "presentation"},
        TD(),
        TD({width: "30%"}),
        TD({width: "70%"})
    );

var DirTablePlate = domplate(Rep,
{
    memberRowTag:
        TR({"class": "memberRow $member.open $member.type\\Row", _domObject: "$member",
            $hasChildren: "$member.hasChildren",
            $cropped: "$member.value|isCropped",
            role: "presentation",
            level: "$member.level",
            breakable: "$member.breakable",
            breakpoint: "$member.breakpoint",
            disabledBreakpoint: "$member.disabledBreakpoint"},
            TD({"class": "memberHeaderCell"},
                DIV({"class": "sourceLine memberRowHeader", onclick: "$onClickRowHeader"},
                    "&nbsp;"
               )
            ),
            TD({"class": "memberLabelCell", style: "padding-left: $member.indent\\px",
                role: "presentation"},
                DIV({"class": "memberLabel $member.type\\Label", title: "$member.title"},
                    SPAN({"class": "memberLabelPrefix"}, "$member.prefix"),
                    SPAN({title: "$member|getMemberNameTooltip"}, "$member.name")
                )
            ),
            TD({"class": "memberValueCell", $readOnly: "$member.readOnly",
                role: "presentation"},
                TAG("$member.tag", {object: "$member.value"})
            )
        ),

    tag:
        TABLE({"class": "domTable", cellpadding: 0, cellspacing: 0, onclick: "$onClick",
            _repObject: "$object", role: "tree",
            "aria-label": Locale.$STR("aria.labels.dom properties")},
            TBODY({role: "presentation"},
                SizerRow,
                FOR("member", "$object|memberIterator",
                    TAG("$memberRowTag", {member: "$member"})
                )
            )
        ),

    watchTag:
        TABLE({"class": "domTable", cellpadding: 0, cellspacing: 0,
               _toggles: "$toggles", _domPanel: "$domPanel", onclick: "$onClick", role: "tree"},
            TBODY({role: "presentation"},
                SizerRow,
                WatchRowTag
            )
        ),

    tableTag:
        TABLE({"class": "domTable", cellpadding: 0, cellspacing: 0,
            _toggles: "$toggles", _domPanel: "$domPanel", onclick: "$onClick",
            role: "tree", "aria-label": Locale.$STR("a11y.labels.dom_properties")},
            TBODY({role: "presentation"},
                SizerRow
            )
        ),

    rowTag:
        FOR("member", "$members",
            TAG("$memberRowTag", {member: "$member"})
        ),

    memberIterator: function(object)
    {
        var memberProvider = new DOMMemberProvider(null);
        var members = memberProvider.getMembers(object, 0);
        if (members.length)
            return members;

        return [{
            name: Locale.$STR("firebug.dom.noChildren2"),
            type: "string",
            rowClass: "memberRow-string",
            tag: Rep.tag,
            prefix: ""
        }];
    },

    isCropped: function(value)
    {
        return typeof value == "string" && value.length > Options.get("stringCropLength");
    },

    getMemberNameTooltip: function(member)
    {
        return member.title || member.scopeNameTooltip;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onClick: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        var row = Dom.getAncestorByClass(event.target, "memberRow");
        var label = Dom.getAncestorByClass(event.target, "memberLabel");
        var valueCell = row.getElementsByClassName("memberValueCell").item(0);
        var object = Firebug.getRepObject(event.target);
        var target = row.lastChild.firstChild;
        var isString = Css.hasClass(target,"objectBox-string");
        var inValueCell = (event.target === valueCell || event.target === target);

        if (label && (Css.hasClass(row, "hasChildren") || (isString && !inValueCell)))
        {
            row = label.parentNode.parentNode;
            this.toggleRow(row);
            Events.cancelEvent(event);
        }
        else
        {
            if (typeof object === "function")
            {
                Firebug.chrome.select(object, "script");
                Events.cancelEvent(event);
            }
            else if ((!object || typeof object !== "object") && Events.isDoubleClick(event))
            {
                var panel = row.parentNode.parentNode.domPanel;
                if (panel)
                {
                    // XXX this should use member.value
                    var rowValue = panel.getRowPropertyValue(row);
                    if (typeof rowValue === "boolean")
                        panel.setPropertyValue(row, ""+!rowValue);
                    else
                        panel.editProperty(row);

                    Events.cancelEvent(event);
                }
            }
        }
    },

    toggleRow: function(row)
    {
        var level = parseInt(row.getAttribute("level"), 10);
        var table = Dom.getAncestorByClass(row, "domTable");
        var toggles = table.toggles;
        if (!toggles)
            toggles = table.repObject.toggles;

        var domPanel = table.domPanel;
        if (!domPanel)
        {
            var panel = Firebug.getElementPanel(row);
            domPanel = panel.context.getPanel("dom");
        }

        if (!domPanel)
            return;

        var context = domPanel.context;
        var target = row.lastChild.firstChild;
        var isString = Css.hasClass(target, "objectBox-string");

        if (Css.hasClass(row, "opened"))
        {
            Css.removeClass(row, "opened");

            if (isString)
            {
                var rowValue = row.domObject.value;
                row.lastChild.firstChild.textContent = '"' + Str.cropMultipleLines(rowValue) + '"';
            }
            else
            {
                if (toggles)
                {
                    var path = Firebug.DOMBasePanel.getPath(row);

                    // Remove the path from the toggle tree
                    for (var i = 0; i < path.length; ++i)
                    {
                        if (i === path.length-1)
                            toggles.remove(path[i]);
                        else
                            toggles = toggles.get(path[i]);
                    }
                }

                var rowTag = this.rowTag;
                var tbody = row.parentNode;

                setTimeout(function()
                {
                    for (var firstRow = row.nextSibling; firstRow; firstRow = row.nextSibling)
                    {
                        if (parseInt(firstRow.getAttribute("level"), 10) <= level)
                            break;

                        tbody.removeChild(firstRow);
                    }
                }, row.insertTimeout ? row.insertTimeout : 0);
            }
        }
        else
        {
            Css.setClass(row, "opened");
            if (isString)
            {
                var rowValue = row.domObject.value;
                row.lastChild.firstChild.textContent = '"' + rowValue + '"';
            }
            else
            {
                if (toggles)
                {
                    var path = Firebug.DOMBasePanel.getPath(row);

                    // Mark the path in the toggle tree
                    for (var i = 0; i < path.length; ++i)
                    {
                        var name = path[i];
                        if (toggles.get(name))
                            toggles = toggles.get(name);
                        else
                            toggles = toggles.set(name, new ToggleBranch.ToggleBranch());
                    }
                    if (FBTrace.DBG_DOMPLATE)
                        FBTrace.sysout("toggleRow mark path "+toggles);
                }

                var members = domPanel.getMembers(target.repObject, level+1);

                var rowTag = this.rowTag;
                var lastRow = row;

                var delay = 0;
                var setSize = members.length;
                var rowCount = 1;
                while (members.length)
                {
                    let slice = members.splice(0, insertSliceSize);
                    let isLast = !members.length;
                    setTimeout(function()
                    {
                        if (lastRow.parentNode)
                        {
                            var result = rowTag.insertRows({members: slice}, lastRow);
                            lastRow = result[1];

                            Events.dispatch(DOMModule.fbListeners, "onMemberRowSliceAdded",
                                [null, result, rowCount, setSize]);

                            rowCount += insertSliceSize;
                        }

                        if (isLast)
                            delete row.insertTimeout;
                    }, delay);

                    delay += insertInterval;
                }

                row.insertTimeout = delay;
            }
        }
    },

    onClickRowHeader: function(event)
    {
        Events.cancelEvent(event);

        var rowHeader = event.target;
        if (!Css.hasClass(rowHeader, "memberRowHeader"))
            return;

        var row = Dom.getAncestorByClass(event.target, "memberRow");
        if (!row)
            return;

        var panel = row.parentNode.parentNode.domPanel;
        if (panel)
        {
            var scriptPanel = panel.context.getPanel("script", true);
            if (!scriptPanel || !scriptPanel.isEnabled())
                return;     // set the breakpoint only if the script panel will respond.
            panel.breakOnProperty(row);
        }
    }
});

var ToolboxPlate = domplate(
{
    tag:
        DIV({"class": "watchToolbox", _domPanel: "$domPanel", onclick: "$onClick"},
            SPAN({"class": "watchDeleteButton closeButton"})
        ),

    onClick: function(event)
    {
        var toolbox = event.currentTarget;
        toolbox.domPanel.deleteWatch(toolbox.watchRow);
    }
});

// ********************************************************************************************* //
// Registration

return {
    ToolboxPlate: ToolboxPlate,
    DirTablePlate: DirTablePlate,
    insertSliceSize: insertSliceSize,
    insertInterval: insertInterval,
};

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*jshint esnext:true, es5:true, curly:false */
/*global FBTrace:true, XPCNativeWrapper:true, Window:true, define:true */

define("firebug/dom/domSidePanel",
[
    "firebug/lib/object",
    "firebug/dom/domBasePanel",
],
function(Obj, DOMBasePanel) {

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// DOM Side Panel Implementation

/**
 * @panel This object represents a DOM Side panel used inside the HTML panel.
 */
function DOMSidePanel()
{
}

DOMSidePanel.prototype = Obj.extend(DOMBasePanel.prototype,
/** lends Firebug.DOMPanel */
{
    name: "domSide",
    parentPanel: "html",
    order: 3,
    enableA11y: true,
    deriveA11yFrom: "console"
});

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(DOMSidePanel);

return DOMSidePanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/dom/toggleBranch",
[
    "firebug/lib/trace",
],
function(FBTrace) {

// ********************************************************************************************* //
// Constants

var metaNames =
[
    "prototype",
    "constructor",
    "__proto__",
    "toString",
    "toSource",
    "hasOwnProperty",
    "getPrototypeOf",
    "__defineGetter__",
    "__defineSetter__",
    "__lookupGetter__",
    "__lookupSetter__",
    "__noSuchMethod__",
    "propertyIsEnumerable",
    "isPrototypeOf",
    "watch",
    "unwatch",
    "valueOf",
    "toLocaleString"
];

// ********************************************************************************************* //
// ToggleBranch Implementation

function ToggleBranch()
{
    this.normal = {};
    this.meta = {};
}

ToggleBranch.prototype =
{
    // Another implementation could simply prefix all keys with "#".
    getMeta: function(name)
    {
        if (metaNames.indexOf(name) !== -1)
            return "meta_"+name;
    },

    // return the toggle branch at name
    get: function(name)
    {
        var metaName = this.getMeta(name);
        var value = null;

        if (metaName)
            value = this.meta[metaName];
        else if (this.normal.hasOwnProperty(name))
            value = this.normal[name];

        if (FBTrace.DBG_DOMPLATE)
        {
            if (value && !(value instanceof ToggleBranch))
                FBTrace.sysout("ERROR ToggleBranch.get(" + name + ") not set to a ToggleBranch!");
        }

        return value;
    },

    // value will be another toggle branch
    set: function(name, value)
    {
        if (FBTrace.DBG_DOMPLATE)
        {
            if (value && !(value instanceof ToggleBranch))
            {
                FBTrace.sysout("ERROR ToggleBranch.set(" + name + "," + value +
                    ") not set to a ToggleBranch!");
            }
        }

        var metaName = this.getMeta(name);
        if (metaName)
            return this.meta[metaName] = value;
        else
            return this.normal[name] = value;
    },

    // remove the toggle branch at name
    remove: function(name)
    {
        var metaName = this.getMeta(name);
        if (metaName)
            delete this.meta[metaName];
        else
            delete this.normal[name];
    },

    toString: function()
    {
        return "[ToggleBranch]";
    },
};

// ********************************************************************************************* //

return {
    ToggleBranch: ToggleBranch
};

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*jshint unused:false*/
/*global define:1*/

define("firebug/editor/baseEditor",
[
    "firebug/firebug",
    "firebug/lib/object",
    "firebug/chrome/measureBox",
],
function(Firebug, Obj, MeasureBox) {

// ********************************************************************************************* //
// BaseEditor

var BaseEditor = Obj.extend(MeasureBox,
{
    getInitialValue: function(target, value)
    {
        return value;
    },

    getValue: function()
    {
    },

    setValue: function(value)
    {
    },

    show: function(target, panel, value, selectionData)
    {
    },

    hide: function()
    {
    },

    layout: function(forceAll)
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Support for context menus within inline editors.

    getContextMenuItems: function(target)
    {
        var items = [];
        items.push({label: "Cut", command: Obj.bind(this.onCommand, this, "cmd_cut")});
        items.push({label: "Copy", command: Obj.bind(this.onCommand, this, "cmd_copy")});
        items.push({label: "Paste", command: Obj.bind(this.onCommand, this, "cmd_paste")});
        return items;
    },

    onCommand: function(command, cmdId)
    {
        var browserWindow = Firebug.chrome.window;

        // Use the right browser window to get the current command controller (issue 4177).
        var controller = browserWindow.document.commandDispatcher.getControllerForCommand(cmdId);
        var enabled = controller.isCommandEnabled(cmdId);
        if (controller && enabled)
            controller.doCommand(cmdId);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Editor Module listeners will get "onBeginEditing" just before this call

    beginEditing: function(target, value)
    {
    },

    // Editor Module listeners will get "onSaveEdit" just after this call
    saveEdit: function(target, value, previousValue)
    {
    },

    endEditing: function(target, value, cancel)
    {
        // Remove empty groups by default
        return true;
    },

    cancelEditing: function(target, value)
    {
    },

    insertNewRow: function(target, insertWhere)
    {
    },
});


Firebug.BaseEditor = BaseEditor;

return BaseEditor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/editor/editor",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/events",
    "firebug/lib/dom",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/chrome/module",
],
function(Firebug, FBTrace, Obj, Events, Dom, Str, Arr, Module) {

// ********************************************************************************************* //
// Constants

const saveTimeout = 400;
const hugeChangeAmount = 100;
const largeChangeAmount = 10;
const smallChangeAmount = 0.1;

var TraceError = FBTrace.to("DBG_ERRORS");

// ********************************************************************************************* //
// Globals

// xxxHonza: it's bad design to have these globals.
var currentTarget = null;
var currentGroup = null;
var currentPanel = null;
var currentEditor = null;

var defaultEditor = null;

var originalValue = null;
var defaultValue = null;
var previousValue = null;

var invalidEditor = false;

// ********************************************************************************************* //

Firebug.Editor = Obj.extend(Module,
{
    supportsStopEvent: true,

    dispatchName: "editor",
    tabCharacter: "    ",

    setSelection: function(selectionData)
    {
        if (currentEditor && currentEditor.setSelection)
            currentEditor.setSelection(selectionData);
    },

    startEditing: function(target, value, editor, selectionData)
    {
        this.stopEditing();

        if (target.classList.contains("insertBefore") || target.classList.contains("insertAfter"))
            return;

        var panel = Firebug.getElementPanel(target);
        if (!panel.editable)
            return;

        if (FBTrace.DBG_EDITOR)
            FBTrace.sysout("editor.startEditing " + value, target);

        defaultValue = target.getAttribute("defaultValue");
        if (value == undefined)
        {
            value = target.textContent;
            if (value == defaultValue)
                value = "";
        }

        invalidEditor = false;
        currentTarget = target;
        currentPanel = panel;
        currentGroup = Dom.getAncestorByClass(target, "editGroup");

        currentPanel.editing = true;

        var panelEditor = currentPanel.getEditor(target, value);
        currentEditor = editor ? editor : panelEditor;
        if (!currentEditor)
            currentEditor = getDefaultEditor(currentPanel);

        panel.panelNode.classList.add("editing");
        target.classList.add("editing");
        if (currentGroup)
            currentGroup.classList.add("editing");

        originalValue = previousValue = value = currentEditor.getInitialValue(target, value);

        currentEditor.show(target, currentPanel, value, selectionData);
        Events.dispatch(this.fbListeners, "onBeginEditing", [currentPanel, currentEditor, target, value]);
        currentEditor.beginEditing(target, value);

        if (FBTrace.DBG_EDITOR)
            FBTrace.sysout("Editor start panel "+currentPanel.name);

        this.attachListeners(currentEditor, panel.context);
    },

    saveAndClose: function()
    {
        if (!currentTarget)
            return;

        Events.dispatch(currentPanel.fbListeners, "onInlineEditorClose", [currentPanel,
            currentTarget, !originalValue]);

        this.stopEditing();
    },

    stopEditing: function(cancel)
    {
        if (!currentTarget)
            return;

        if (FBTrace.DBG_EDITOR)
        {
            FBTrace.sysout("editor.stopEditing cancel:" + cancel+" saveTimeout: " +
                this.saveTimeout);
        }

        // Make sure the content is save if there is a timeout in progress.
        if (this.saveTimeout)
            this.save();

        clearTimeout(this.saveTimeout);
        delete this.saveTimeout;

        this.detachListeners(currentEditor, currentPanel.context);

        currentPanel.panelNode.classList.remove("editing");
        currentTarget.classList.remove("editing");
        if (currentGroup)
            currentGroup.classList.remove("editing");

        var value = currentEditor.getValue();
        if (value == defaultValue)
            value = "";

        // Reset the editor's value so it isn't accidentally reused the next time
        // the editor instance is reused (see also 3280, 3332).
        currentEditor.setValue("");

        var removeGroup = true;
        try
        {
            removeGroup = currentEditor.endEditing(currentTarget, value, cancel);
        }
        catch (exc)
        {
            TraceError.sysout("editor.endEditing FAILS " + exc, exc);
        }

        try
        {
            if (cancel)
            {
                Events.dispatch(currentPanel.fbListeners, "onInlineEditorClose",
                    [currentPanel, currentTarget, removeGroup && !originalValue]);

                if (value != originalValue)
                    this.saveEditAndNotifyListeners(currentTarget, originalValue, previousValue);

                currentEditor.cancelEditing(currentTarget, originalValue);

                if (removeGroup && !originalValue && currentGroup)
                    currentGroup.parentNode.removeChild(currentGroup);
            }
            else if (!value)
            {
                this.saveEditAndNotifyListeners(currentTarget, "", previousValue);

                if (removeGroup && currentGroup && currentGroup.parentNode)
                    currentGroup.parentNode.removeChild(currentGroup);
            }
            else
            {
                this.save(value);
            }
        }
        catch (exc)
        {
            TraceError.sysout("Editor.stopEditing FAILS", exc);
        }

        currentEditor.hide();
        currentPanel.editing = false;

        Events.dispatch(this.fbListeners, "onStopEdit", [currentPanel, currentEditor,
            currentTarget]);

        if (FBTrace.DBG_EDITOR)
            FBTrace.sysout("Editor stop panel " + currentPanel.name);

        currentTarget = null;
        currentGroup = null;
        currentPanel = null;
        currentEditor = null;
        originalValue = null;
        invalidEditor = false;

        return value;
    },

    cancelEditing: function()
    {
        return this.stopEditing(true);
    },

    update: function(saveNow)
    {
        if (this.saveTimeout)
            clearTimeout(this.saveTimeout);

        invalidEditor = true;

        currentEditor.layout();

        if (saveNow)
        {
            this.save();
        }
        else
        {
            var context = currentPanel.context;
            this.saveTimeout = context.setTimeout(Obj.bindFixed(this.save, this), saveTimeout);

            if (FBTrace.DBG_EDITOR)
                FBTrace.sysout("editor.update saveTimeout: "+this.saveTimeout);
        }
    },

    save: function(value)
    {
        if (!invalidEditor)
            return;

        if (value == undefined)
            value = currentEditor.getValue();

        if (FBTrace.DBG_EDITOR)
            FBTrace.sysout("editor.save saveTimeout: " + this.saveTimeout + " currentPanel: " +
                (currentPanel ? currentPanel.name : "null"));

        try
        {
            this.saveEditAndNotifyListeners(currentTarget, value, previousValue);

            previousValue = value;
            invalidEditor = false;
        }
        catch (exc)
        {
            TraceError.sysout("Editor.save FAILS "+exc, exc);
        }
    },

    saveEditAndNotifyListeners: function(currentTarget, value, previousValue)
    {
        currentEditor.saveEdit(currentTarget, value, previousValue);
        Events.dispatch(this.fbListeners, "onSaveEdit", [currentPanel, currentEditor,
            currentTarget, value, previousValue]);
    },

    setEditTarget: function(element)
    {
        if (!element)
        {
            Events.dispatch(currentPanel.fbListeners, "onInlineEditorClose",
                [currentPanel, currentTarget, true]);
            this.stopEditing();
        }
        else if (element.classList.contains("insertBefore"))
            this.insertRow(element, "before");
        else if (element.classList.contains("insertAfter"))
            this.insertRow(element, "after");
        else
            this.startEditing(element);
    },

    tabNextEditor: function()
    {
        if (!currentTarget)
            return;

        var value = currentEditor.getValue();
        var nextEditable = currentTarget;
        do
        {
            nextEditable = !value && currentGroup
                ? getNextOutsider(nextEditable, currentGroup)
                : Dom.getNextByClass(nextEditable, "editable");
        }
        while (nextEditable && !nextEditable.offsetHeight);

        this.setEditTarget(nextEditable);
    },

    tabPreviousEditor: function()
    {
        if (!currentTarget)
            return;

        var value = currentEditor.getValue();
        var prevEditable = currentTarget;
        do
        {
            prevEditable = !value && currentGroup
                ? getPreviousOutsider(prevEditable, currentGroup)
                : Dom.getPreviousByClass(prevEditable, "editable");
        }
        while (prevEditable && !prevEditable.offsetHeight);

        this.setEditTarget(prevEditable);
    },

    insertRow: function(relative, insertWhere)
    {
        var group =
            relative || Dom.getAncestorByClass(currentTarget, "editGroup") || currentTarget;
        var value = this.stopEditing();

        currentPanel = Firebug.getElementPanel(group);

        currentEditor = currentPanel.getEditor(group, value);
        if (!currentEditor)
            currentEditor = getDefaultEditor(currentPanel);

        currentGroup = currentEditor.insertNewRow(group, insertWhere);
        if (!currentGroup)
            return;

        var editable = currentGroup.classList.contains("editable")
            ? currentGroup
            : Dom.getNextByClass(currentGroup, "editable");

        if (editable)
            this.setEditTarget(editable);
    },

    insertRowForObject: function(relative)
    {
        var container = Dom.getAncestorByClass(relative, "insertInto");
        if (container)
        {
            relative = Dom.getChildByClass(container, "insertBefore");
            if (relative)
                this.insertRow(relative, "before");
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    attachListeners: function(editor, context)
    {
        var win = currentTarget.ownerDocument.defaultView;
        Events.addEventListener(win, "resize", this.onResize, true);
        Events.addEventListener(win, "blur", this.onBlur, true);

        var chrome = Firebug.chrome;

        this.listeners = [
            chrome.keyCodeListen("ESCAPE", null, Obj.bind(this.cancelEditing, this)),
        ];

        if (editor.arrowCompletion)
        {
            this.listeners.push(
                chrome.keyCodeListen("UP", null, Obj.bindFixed(editor.completeValue, editor, -1)),
                chrome.keyCodeListen("DOWN", null, Obj.bindFixed(editor.completeValue, editor, 1)),
                chrome.keyCodeListen("UP", Events.isShift, Obj.bindFixed(editor.completeValue, editor, -largeChangeAmount)),
                chrome.keyCodeListen("DOWN", Events.isShift, Obj.bindFixed(editor.completeValue, editor, largeChangeAmount)),
                chrome.keyCodeListen("UP", Events.isControl, Obj.bindFixed(editor.completeValue, editor, -smallChangeAmount)),
                chrome.keyCodeListen("DOWN", Events.isControl, Obj.bindFixed(editor.completeValue, editor, smallChangeAmount)),
                chrome.keyCodeListen("PAGE_UP", null, Obj.bindFixed(editor.completeValue, editor, -largeChangeAmount)),
                chrome.keyCodeListen("PAGE_DOWN", null, Obj.bindFixed(editor.completeValue, editor, largeChangeAmount)),
                chrome.keyCodeListen("PAGE_UP", Events.isShift, Obj.bindFixed(editor.completeValue, editor, -hugeChangeAmount)),
                chrome.keyCodeListen("PAGE_DOWN", Events.isShift, Obj.bindFixed(editor.completeValue, editor, hugeChangeAmount))
            );
        }

        if (currentEditor.tabNavigation)
        {
            this.listeners.push(
                chrome.keyCodeListen("RETURN", null, Obj.bind(this.tabNextEditor, this)),
                chrome.keyCodeListen("RETURN", Events.isShift, Obj.bind(this.saveAndClose, this)),
                chrome.keyCodeListen("RETURN", Events.isControl, Obj.bind(this.insertRow, this, null, "after")),
                chrome.keyCodeListen("TAB", null, Obj.bind(this.tabNextEditor, this)),
                chrome.keyCodeListen("TAB", Events.isShift, Obj.bind(this.tabPreviousEditor, this))
            );
        }
        else if (currentEditor.multiLine)
        {
            this.listeners.push(
                chrome.keyCodeListen("TAB", null, insertTab)
            );
        }
        else
        {
            this.listeners.push(
                chrome.keyCodeListen("RETURN", null, Obj.bindFixed(this.stopEditing, this))
            );

            if (currentEditor.tabCompletion)
            {
                this.listeners.push(
                    chrome.keyCodeListen("TAB", null, Obj.bind(editor.completeValue, editor, 1)),
                    chrome.keyCodeListen("TAB", Events.isShift, Obj.bind(editor.completeValue, editor, -1)),
                    chrome.keyCodeListen("UP", null, Obj.bindFixed(editor.completeValue, editor, -1, true)),
                    chrome.keyCodeListen("DOWN", null, Obj.bindFixed(editor.completeValue, editor, 1, true)),
                    chrome.keyCodeListen("UP", Events.isShift, Obj.bindFixed(editor.completeValue, editor, -largeChangeAmount)),
                    chrome.keyCodeListen("DOWN", Events.isShift, Obj.bindFixed(editor.completeValue, editor, largeChangeAmount)),
                    chrome.keyCodeListen("UP", Events.isControl, Obj.bindFixed(editor.completeValue, editor, -smallChangeAmount)),
                    chrome.keyCodeListen("DOWN", Events.isControl, Obj.bindFixed(editor.completeValue, editor, smallChangeAmount)),
                    chrome.keyCodeListen("PAGE_UP", null, Obj.bindFixed(editor.completeValue, editor, -largeChangeAmount)),
                    chrome.keyCodeListen("PAGE_DOWN", null, Obj.bindFixed(editor.completeValue, editor, largeChangeAmount)),
                    chrome.keyCodeListen("PAGE_UP", Events.isShift, Obj.bindFixed(editor.completeValue, editor, -hugeChangeAmount)),
                    chrome.keyCodeListen("PAGE_DOWN", Events.isShift, Obj.bindFixed(editor.completeValue, editor, hugeChangeAmount))
                );
            }
        }
    },

    detachListeners: function(editor, context)
    {
        if (!this.listeners)
            return;

        var win = currentTarget.ownerDocument.defaultView;
        Events.removeEventListener(win, "resize", this.onResize, true);
        Events.removeEventListener(win, "blur", this.onBlur, true);
        Events.removeEventListener(win, "input", this.onInput, true);

        var chrome = Firebug.chrome;
        if (chrome)
        {
            for (var i = 0; i < this.listeners.length; ++i)
                chrome.keyIgnore(this.listeners[i]);
        }

        delete this.listeners;
    },

    onResize: function(event)
    {
        currentEditor.layout(true);
    },

    onBlur: function(event)
    {
        if (currentEditor.enterOnBlur && Dom.isAncestor(event.target, currentEditor.box))
            this.stopEditing();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    initialize: function()
    {
        this.onResize = Obj.bindFixed(this.onResize, this);
        this.onBlur = Obj.bind(this.onBlur, this);

        Module.initialize.apply(this, arguments);
    },

    disable: function()
    {
        this.stopEditing();
    },

    showContext: function(browser, context)
    {
        this.stopEditing();
    },

    showPanel: function(browser, panel)
    {
        this.stopEditing();
    }
});

// ********************************************************************************************* //
// Autocompletion

Firebug.AutoCompleter = function(caseSensitive, getRange, evaluator, getNewPropSeparator,
    adjustSelectionOnAccept)
{
    var candidates = null;
    var suggestedDefault = null;
    var lastValue = "";
    var originalOffset = -1;
    var originalValue = null;
    var lastExpr = null;
    var lastOffset = -1;
    var exprOffset = 0;
    var lastIndex = null;
    var preExpr = null;
    var postExpr = null;

    this.revert = function(textBox)
    {
        if (originalOffset != -1)
        {
            textBox.value = lastValue = originalValue;
            textBox.setSelectionRange(originalOffset, originalOffset);

            this.reset();
            return true;
        }
        else
        {
            this.reset();
            return false;
        }
    };

    this.reset = function()
    {
        candidates = null;
        suggestedDefault = null;
        originalOffset = -1;
        originalValue = null;
        lastExpr = null;
        lastOffset = 0;
        exprOffset = 0;
        lastIndex = null;
    };

    this.acceptCompletion = function(textBox)
    {
        if (!adjustSelectionOnAccept)
            return false;

        var value = textBox.value;
        var offset = textBox.selectionStart;
        var offsetEnd = textBox.selectionEnd;
        if (!candidates || value !== lastValue || offset !== lastOffset || offset >= offsetEnd)
            return false;

        var ind = adjustSelectionOnAccept(value, offsetEnd);
        if (ind === null)
            return false;

        textBox.setSelectionRange(ind, ind);
        return true;
    };

    this.complete = function(context, textBox, cycle)
    {
        if (!textBox.value && !cycle)
        {
            // Don't complete an empty field.
            return false;
        }

        var offset = textBox.selectionStart; // defines the cursor position

        var found = this.pickCandidates(textBox, context, cycle);

        if (!found)
            this.reset();

        return found;
    };

    /**
     * returns true if candidate list was created
     */
    this.pickCandidates = function(textBox, context, cycle)
    {
        var value = textBox.value;
        var offset = textBox.selectionStart;

        if (!candidates || !cycle || value != lastValue || offset != lastOffset)
        {
            originalOffset = lastOffset = offset;
            originalValue = lastValue = value;

            // Find the part of the string that is being completed
            var range = getRange(value, lastOffset);
            if (!range)
                range = {start: 0, end: value.length};

            preExpr = value.substr(0, range.start);
            lastExpr = value.substring(range.start, range.end);
            postExpr = value.substr(range.end);
            exprOffset = range.start;

            if (FBTrace.DBG_EDITOR)
            {
                var sep = (value.indexOf("|") > -1) ? "^" : "|";
                FBTrace.sysout(preExpr+sep+lastExpr+sep+postExpr + " offset: " + lastOffset);
            }

            var search = false;

            // Check if the cursor is somewhere in the middle of the expression
            if (lastExpr && offset != range.end)
            {
                if (cycle)
                {
                    // Complete by resetting the completion list to a more complete
                    // list of candidates, finding our current position in it, and
                    // cycling from there.
                    search = true;
                    lastOffset = range.start;
                }
                else if (offset != range.start+1)
                {
                    // Nothing new started, just fail.
                    return false;
                }
                else
                {
                    // Try to parse the typed character as the start of a new
                    // property, moving the rest of lastExpr over into postExpr
                    // (possibly with a separator added). If there is no support
                    // for prefix-completions, fail. If the character could
                    // plausibly be part of a leftwards expansion, fail.
                    // Note that this does not show unless there is a completion.
                    var moveOver = lastExpr.substr(1);
                    lastExpr = lastExpr.charAt(0);
                    range.start = offset - 1;
                    range.end = offset;

                    var cand = evaluator(preExpr, lastExpr, postExpr, range, false, context, {});
                    var imov = (caseSensitive ? moveOver : moveOver.toLowerCase());
                    for (var i = 0; i < cand.length; ++i)
                    {
                        var c = cand[i];
                        if (c.length <= imov.length || c.charAt(0) !== lastExpr)
                            continue;
                        c = (caseSensitive ? c : c.toLowerCase());
                        if (c.substr(-imov.length) === imov)
                            return false;
                    }

                    var sep = getNewPropSeparator(range, lastExpr, moveOver);
                    if (sep === null)
                        return false;
                    if (!Str.hasPrefix(moveOver, sep))
                        moveOver = sep + moveOver;

                    postExpr = moveOver + postExpr;
                }
            }

            // Don't complete globals unless cycling.
            if (!cycle && !lastExpr)
                return false;

            var out = {};
            var values = evaluator(preExpr, lastExpr, postExpr, range, search, context, out);
            suggestedDefault = out.suggestion || null;

            if (search)
                this.setCandidatesBySearchExpr(lastExpr, values);
            else
                this.setCandidatesByExpr(lastExpr, values);
        }

        if (!candidates.length)
            return false;

        this.adjustLastIndex(cycle);
        var completion = candidates[lastIndex];

        // Adjust the case of the completion - when editing colors, 'd' should
        // be completed into 'darkred', not 'darkRed'.
        var userTyped = lastExpr.substr(0, lastOffset-exprOffset);
        completion = this.convertCompletionCase(completion, userTyped);

        var line = preExpr + completion + postExpr;
        var offsetEnd = exprOffset + completion.length;

        // Show the completion
        lastValue = textBox.value = line;
        textBox.setSelectionRange(lastOffset, offsetEnd);

        return true;
    };

    this.setCandidatesByExpr = function(expr, values)
    {
        // Filter the list of values to those which begin with expr. We
        // will then go on to complete the first value in the resulting list.
        candidates = [];

        var findExpr = (caseSensitive ? expr : expr.toLowerCase());
        for (var i = 0; i < values.length; ++i)
        {
            var name = values[i];
            var testName = (caseSensitive ? name : name.toLowerCase());

            if (Str.hasPrefix(testName, findExpr))
                candidates.push(name);
        }

        lastIndex = null;
    };

    this.setCandidatesBySearchExpr = function(expr, values)
    {
        var searchIndex = -1;

        var findExpr = (caseSensitive ? expr : expr.toLowerCase());

        // Find the first instance of expr in the values list. We
        // will then complete the string that is found.
        for (var i = 0; i < values.length; ++i)
        {
            var name = values[i];
            if (!caseSensitive)
                name = name.toLowerCase();

            if (Str.hasPrefix(name, findExpr))
            {
                searchIndex = i;
                break;
            }
        }

        if (searchIndex == -1)
        {
            // Nothing found, so there's nothing to complete to
            candidates = [];
            return;
        }

        candidates = Arr.cloneArray(values);
        lastIndex = searchIndex;
    };

    this.adjustLastIndex = function(cycle)
    {
        if (!cycle)
        {
            // We have a valid lastIndex but we are not cycling, so reset it
            lastIndex = this.pickDefaultCandidate();
        }
        else if (lastIndex === null)
        {
            // There is no old lastIndex, so use the default
            lastIndex = this.pickDefaultCandidate();
        }
        else
        {
            // cycle
            lastIndex += cycle;
            if (lastIndex >= candidates.length)
                lastIndex = 0;
            else if (lastIndex < 0)
                lastIndex = candidates.length - 1;
        }
    };

    this.convertCompletionCase = function(completion, userTyped)
    {
        var preCompletion = completion.substr(0, userTyped.length);
        if (preCompletion === userTyped)
        {
            // Trust the completion to be correct.
            return completion;
        }
        else
        {
            // If the typed string is entirely in one case, use that.
            if (userTyped === userTyped.toLowerCase())
                return completion.toLowerCase();
            if (userTyped === userTyped.toUpperCase())
                return completion.toUpperCase();

            // The typed string mixes case in some odd way; use the rest of
            // the completion as-is.
            return userTyped + completion.substr(userTyped.length);
        }
    };

    this.pickDefaultCandidate = function()
    {
        // If we have a suggestion and it's in the candidate list, use that
        if (suggestedDefault)
        {
            var ind = candidates.indexOf(suggestedDefault);
            if (ind !== -1)
                return ind;
        }

        var userTyped = lastExpr.substr(0, lastOffset-exprOffset);
        var utLen = userTyped.length;

        // Otherwise, default to the shortest candidate that matches the case,
        // or the shortest one that doesn't
        var pick = -1, pcand, pcaseState;
        for (var i = 0; i < candidates.length; i++)
        {
            var cand = candidates[i];
            var caseState = (cand.substr(0, utLen) === userTyped ? 1 : 0);
            if (pick === -1 ||
                caseState > pcaseState ||
                (caseState === pcaseState && cand.length < pcand.length))
            {
                pick = i;
                pcand = cand;
                pcaseState = caseState;
            }
        }
        return pick;
    };
};

// ********************************************************************************************* //
// Local Helpers

function getDefaultEditor(panel)
{
    if (!defaultEditor)
    {
        var doc = panel.document;
        defaultEditor = new Firebug.InlineEditor(doc);
    }

    return defaultEditor;
}

/**
 * An outsider is the first element matching the stepper element that
 * is not an child of group. Elements tagged with insertBefore or insertAfter
 * classes are also excluded from these results unless they are the sibling
 * of group, relative to group's parent editGroup. This allows for the proper insertion
 * rows when groups are nested.
 */
function getOutsider(element, group, stepper)
{
    var parentGroup = Dom.getAncestorByClass(group.parentNode, "editGroup");
    var next;
    do
    {
        next = stepper(next || element);
    }
    while (Dom.isAncestor(next, group) || isGroupInsert(next, parentGroup));

    return next;
}

function isGroupInsert(next, group)
{
    return (!group || Dom.isAncestor(next, group))
        && (next.classList.contains("insertBefore") || next.classList.contains("insertAfter"));
}

function getNextOutsider(element, group)
{
    return getOutsider(element, group, Obj.bind(Dom.getNextByClass, Dom, "editable"));
}

function getPreviousOutsider(element, group)
{
    return getOutsider(element, group, Obj.bind(Dom.getPreviousByClass, Dom, "editable"));
}

function insertTab()
{
    Dom.insertTextIntoElement(currentEditor.input, Firebug.Editor.tabCharacter);
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.Editor);

return Firebug.Editor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/editor/editorSelector",
[
    "firebug/firebug",
    "firebug/lib/events",
],
function(Firebug, Events) {

// ********************************************************************************************* //
// Reusable code for modules that support editing

Firebug.EditorSelector =
{
    // Override for each module
    getEditorOptionKey: function()
    {
        return "cssEditMode";
    },

    editors: {},

    registerEditor: function(name, editor)
    {
        this.editors[name] = editor;
    },

    unregisterEditor: function(name, editor)
    {
        delete this.editors[name];
    },

    getEditorByName: function(name)
    {
        return this.editors[name];
    },

    getEditorsNames: function()
    {
        var names = [];
        for (var p in this.editors)
        {
            if (this.editors.hasOwnProperty(p))
                names.push(p);
        }
        return names;
    },

    setCurrentEditorName: function(name)
    {
        this.currentEditorName = name;
        Firebug.Options.set(this.getEditorOptionKey(), name);
    },

    getCurrentEditorName: function()
    {
        if (!this.currentEditorName)
            this.currentEditorName = Firebug.Options.get(this.getEditorOptionKey());

        return this.currentEditorName;
    },

    getCurrentEditor: function()
    {
        return this.getEditorByName(this.getCurrentEditorName());
    },

    onEditMode: function(event, menuitem)
    {
        var mode = menuitem.getAttribute("mode");
        if (mode)
            this.setCurrentEditorName(mode);

        this.updateEditButton();
        Events.cancelEvent(event);
    },

    updateEditButton: function()
    {
        // Update label and tooltip text of the edit button.
        var mode = this.getCurrentEditorName();
        if (!mode)
            return;

        var menuitem = Firebug.chrome.$("menu_firebug_" + this.getEditorOptionKey() + mode);
        var command = Firebug.chrome.$("cmd_firebug_toggle" + this.getEditorOptionKey());
        command.setAttribute("label", menuitem.label);
        command.setAttribute("tooltiptext", menuitem.tooltipText);
    },

    onOptionsShowing: function(popup)
    {
        var mode = this.getCurrentEditorName();
        if (!mode)
            return;

        for (var child = popup.firstChild; child; child = child.nextSibling)
        {
            if (child.localName == "menuitem")
            {
                if (child.id == "menu_firebug_" + this.getEditorOptionKey()+mode)
                    child.setAttribute("checked", true);
                else
                    child.removeAttribute("checked");
            }
        }
    },
};

// ********************************************************************************************* //
// Registration

return Firebug.EditorSelector;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*jshint unused:false*/
/*global Components:1, define:1, KeyEvent:1*/

define("firebug/editor/inlineEditor",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/domplate",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/string",
    "firebug/chrome/menu",
    "firebug/editor/baseEditor",
    "firebug/editor/editor",
],
function(Firebug, FBTrace, Domplate, Events, Css, Dom, Str, Menu, BaseEditor, Editor) {

// ********************************************************************************************* //
// Constants

var {domplate, DIV, SPAN, INPUT} = Domplate;

var Ci = Components.interfaces;

var Trace = FBTrace.to("DBG_EDITOR");

// ********************************************************************************************* //
// InlineEditor

function InlineEditor(doc)
{
    this.initializeInline(doc);
}

InlineEditor.prototype = domplate(BaseEditor,
{
    enterOnBlur: true,

    tag:
        DIV({"class": "inlineEditor"},
            INPUT({"class": "textEditorInner", type: "text",
                oninput: "$onInput", onkeypress: "$onKeyPress", onoverflow: "$onOverflow",
                oncontextmenu: "$onContextMenu"}
            )
        ),

    inputTag :
        INPUT({"class": "textEditorInner", type: "text",
            oninput: "$onInput", onkeypress: "$onKeyPress", onoverflow: "$onOverflow"}
        ),

    expanderTag:
        SPAN({"class": "inlineExpander", style: "-moz-user-focus:ignore;opacity:0.5"}),

    initialize: function()
    {
        this.fixedWidth = false;
        this.completeAsYouType = true;
        this.tabNavigation = true;
        this.multiLine = false;
        this.tabCompletion = false;
        this.arrowCompletion = true;
        this.noWrap = true;
        this.numeric = false;
    },

    destroy: function()
    {
        this.destroyInput();
    },

    initializeInline: function(doc)
    {
        this.box = this.tag.replace({}, doc, this);
        this.input = this.box.firstChild;
        this.expander = this.expanderTag.replace({}, doc, this);
        this.initialize();
    },

    destroyInput: function()
    {
        // XXXjoe Need to remove input/keypress handlers to avoid leaks
    },

    getValue: function()
    {
        return this.input.value;
    },

    setValue: function(value)
    {
        // It's only a one-line editor, so new lines shouldn't be allowed
        return this.input.value = Str.stripNewLines(value);
    },

    setSelection: function(selectionData)
    {
        this.input.setSelectionRange(selectionData.start, selectionData.end);
        // Ci.nsISelectionController SELECTION_NORMAL SELECTION_ANCHOR_REGION SCROLL_SYNCHRONOUS
        this.input.QueryInterface(Ci.nsIDOMNSEditableElement)
            .editor.selectionController.scrollSelectionIntoView(1, 0, 2);
    },

    show: function(target, panel, value, selectionData)
    {
        Trace.sysout("InlineEditor.show",
            {target: target, panel: panel, value: value, selectionData: selectionData});

        Events.dispatch(panel.fbListeners, "onInlineEditorShow", [panel, this]);
        this.target = target;
        this.panel = panel;

        this.targetOffset = Dom.getClientOffset(target);

        this.originalClassName = this.box.className;

        var classNames = target.className.split(" ");
        for (var i = 0; i < classNames.length; ++i)
            Css.setClass(this.box, "editor-" + classNames[i]);

        // remove error information
        this.box.removeAttribute('saveSuccess');

        // Make the editor match the target's font style
        Css.copyTextStyles(target, this.box);

        this.setValue(value);

        this.getAutoCompleter().reset();

        panel.panelNode.appendChild(this.box);
        this.input.select();
        if (selectionData) // transfer selection to input element
            this.setSelection(selectionData);

        // Insert the "expander" to cover the target element with white space
        if (!this.fixedWidth)
        {
            this.startMeasuring(target);

            Css.copyBoxStyles(target, this.expander);
            target.parentNode.replaceChild(this.expander, target);
            Dom.collapse(target, true);
            this.expander.parentNode.insertBefore(target, this.expander);
            this.textSize = this.measureInputText(value);
        }

        this.updateLayout(true);

        Dom.scrollIntoCenterView(this.box, null, true);
    },

    hide: function()
    {
        Trace.sysout("InlineEditor.hide");

        this.box.className = this.originalClassName;

        if (!this.fixedWidth)
        {
            this.stopMeasuring();

            Dom.collapse(this.target, false);

            if (this.expander.parentNode)
                this.expander.parentNode.removeChild(this.expander);
        }

        if (this.box.parentNode)
        {
            try { this.input.setSelectionRange(0, 0); } catch (exc) {}
            this.box.parentNode.removeChild(this.box);
        }

        this.target = null;
        this.panel = null;
    },

    layout: function(forceAll)
    {
        if (!this.fixedWidth)
            this.textSize = this.measureInputText(this.input.value);

        if (forceAll)
            this.targetOffset = Dom.getClientOffset(this.expander);

        this.updateLayout(false, forceAll);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    beginEditing: function(target, value)
    {
    },

    saveEdit: function(target, value, previousValue)
    {
    },

    endEditing: function(target, value, cancel)
    {
        Trace.sysout("InlineEditor.endEditing",
            {target: target, value: value, cancel: cancel});

        // Remove empty groups by default
        return true;
    },

    insertNewRow: function(target, insertWhere)
    {
    },

    advanceToNext: function(target, charCode)
    {
        return false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getAutoCompleteRange: function(value, offset)
    {
    },

    getAutoCompleteList: function(preExpr, expr, postExpr)
    {
        return [];
    },

    getAutoCompletePropSeparator: function(range, expr, prefixOf)
    {
        return null;
    },

    autoCompleteAdjustSelection: function(value, offset)
    {
        return null;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getAutoCompleter: function()
    {
        if (!this.autoCompleter)
        {
            this.autoCompleter = new Firebug.AutoCompleter(false,
                this.getAutoCompleteRange.bind(this),
                this.getAutoCompleteList.bind(this),
                this.getAutoCompletePropSeparator.bind(this),
                this.autoCompleteAdjustSelection.bind(this));
        }

        return this.autoCompleter;
    },

    completeValue: function(amt)
    {
        if (this.getAutoCompleter().complete(this.panel.context, this.input, amt, true))
            Editor.update(true);
        else
            this.incrementValue(amt);
    },

    incrementValue: function(amt)
    {
        var value = this.input.value;
        var offset = this.input.selectionStart;
        var offsetEnd = this.input.selectionEnd;

        var newValue = this.doIncrementValue(value, amt, offset, offsetEnd);
        if (!newValue)
            return false;

        this.input.value = newValue.value;
        this.input.setSelectionRange(newValue.start, newValue.end);

        Editor.update(true);
        return true;
    },

    incrementExpr: function(expr, amt, info)
    {
        var num = parseFloat(expr);
        if (isNaN(num))
            return null;

        var m = /\d+(\.\d+)?/.exec(expr);
        var digitPost = expr.substr(m.index+m[0].length);
        var newValue = Math.round((num-amt)*1000)/1000; // avoid rounding errors

        if (info && "minValue" in info)
            newValue = Math.max(newValue, info.minValue);
        if (info && "maxValue" in info)
            newValue = Math.min(newValue, info.maxValue);

        newValue = newValue.toString();

        // Preserve trailing zeroes of small increments.
        if (Math.abs(amt) < 1)
        {
            if (newValue.indexOf(".") === -1)
                newValue += ".";
            var dec = newValue.length - newValue.lastIndexOf(".") - 1;
            var incDec = Math.abs(amt).toString().length - 2;
            while (dec < incDec)
            {
                newValue += "0";
                ++dec;
            }
        }

        return newValue + digitPost;
    },

    doIncrementValue: function(value, amt, offset, offsetEnd, info)
    {
        // Try to find a number around the cursor to increment.
        var start, end;
        if (/^-?[0-9.]/.test(value.substring(offset, offsetEnd)) &&
            !(info && /\d/.test(value.charAt(offset-1) + value.charAt(offsetEnd))))
        {
            // We have a number selected, possibly with a suffix, and we are not in
            // the disallowed case of just part of a known number being selected.
            // Use that number.
            start = offset;
            end = offsetEnd;
        }
        else
        {
            // Parse periods as belonging to the number only if we are in a known number
            // context. (This makes incrementing the 1 in 'image1.gif' work.)
            var pattern = "[" + (info ? "0-9." : "0-9") + "]*";

            var before = new RegExp(pattern + "$").exec(value.substr(0, offset))[0].length;
            var after = new RegExp("^" + pattern).exec(value.substr(offset))[0].length;
            start = offset - before;
            end = offset + after;

            // Expand the number to contain an initial minus sign if it seems
            // free-standing.
            if (value.charAt(start-1) === "-" &&
                (start-1 === 0 || /[ (:,='"]/.test(value.charAt(start-2))))
            {
                --start;
            }
        }

        if (start !== end)
        {
            // Include percentages as part of the incremented number (they are
            // common enough).
            if (value.charAt(end) === "%")
                ++end;

            var first = value.substr(0, start);
            var mid = value.substring(start, end);
            var last = value.substr(end);
            mid = this.incrementExpr(mid, amt, info);
            if (mid !== null)
            {
                return {
                    value: first + mid + last,
                    start: start,
                    end: start + mid.length
                };
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onKeyPress: function(event)
    {
        if (event.keyCode == KeyEvent.DOM_VK_ESCAPE && !this.completeAsYouType)
        {
            var reverted = this.getAutoCompleter().revert(this.input);
            if (reverted)
                Events.cancelEvent(event);
        }
        else if (event.keyCode == KeyEvent.DOM_VK_RIGHT && this.completeAsYouType)
        {
            if (this.getAutoCompleter().acceptCompletion(this.input))
                Events.cancelEvent(event);
        }
        else if (event.charCode && this.advanceToNext(this.target, event.charCode))
        {
            Editor.tabNextEditor();
            Events.cancelEvent(event);
        }
        else if (this.numeric && event.charCode &&
            !(event.ctrlKey || event.metaKey || event.altKey) &&
            !(KeyEvent.DOM_VK_0 <= event.charCode && event.charCode <= KeyEvent.DOM_VK_9) &&
            event.charCode !== KeyEvent.DOM_VK_INSERT && event.charCode !== KeyEvent.DOM_VK_DELETE)
        {
            Events.cancelEvent(event);
        }
        else if (event.keyCode == KeyEvent.DOM_VK_BACK_SPACE ||
            event.keyCode == KeyEvent.DOM_VK_DELETE)
        {
            // If the user deletes text, don't autocomplete after the upcoming input event
            this.ignoreNextInput = true;
        }
    },

    onOverflow: function()
    {
        this.updateLayout(false, false, 3);
    },

    onInput: function()
    {
        if (this.ignoreNextInput)
        {
            this.ignoreNextInput = false;
            this.getAutoCompleter().reset();
        }
        else if (this.completeAsYouType)
            this.getAutoCompleter().complete(this.panel.context, this.input, 0, false);
        else
            this.getAutoCompleter().reset();

        Editor.update();
    },

    onContextMenu: function(event)
    {
        Events.cancelEvent(event);

        var popup = Firebug.chrome.$("fbInlineEditorPopup");
        Dom.eraseNode(popup);

        var target = event.target;
        var items = this.getContextMenuItems(target);
        if (items)
            Menu.createMenuItems(popup, items);

        if (!popup.firstChild)
            return false;

        popup.openPopupAtScreen(event.screenX, event.screenY, true);
        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    updateLayout: function(initial, forceAll, extraWidth)
    {
        if (this.fixedWidth)
        {
            this.box.style.left = this.targetOffset.x + "px";
            this.box.style.top = this.targetOffset.y + "px";

            var w = this.target.offsetWidth;
            var h = this.target.offsetHeight;
            this.input.style.width = w + "px";
            this.input.style.height = (h-3) + "px";
        }
        else
        {
            this.expander.textContent = this.input.value;

            var clR = this.expander.getClientRects(),
                wasWrapped = this.wrapped, inputWidth = Infinity;

            if (clR.length <= 1)
            {
                this.wrapped = false;
            }
            else if (clR.length == 2)
            {
                var w1 = clR[0].width;
                var w2 = clR[1].width;

                if (w2 > w1){
                    this.wrapped = true;
                    inputWidth = w2;
                } else
                    this.wrapped = false;
            }
            else if (clR.length == 3)
            {
                this.wrapped = true;
                if (clR[2].width > 50)
                    inputWidth = clR[1].width;
            }
            else if (clR.length > 3)
            {
                this.wrapped = true;
            }

            var fixupL = 0, fixupT = 0;
            if (this.wrapped)
            {
                fixupL = clR[1].left - clR[0].left;
                fixupT = clR[1].top - clR[0].top;
            }
            else
            {
                var approxTextWidth = this.textSize.width;
                // Make the input one character wider than the text value so that
                // typing does not ever cause the textbox to scroll
                var charWidth = this.measureInputText('m').width;

                // Sometimes we need to make the editor a little wider, specifically when
                // an overflow happens, otherwise it will scroll off some text on the left
                if (extraWidth)
                    charWidth *= extraWidth;

                inputWidth = approxTextWidth + charWidth;
            }

            var container = this.panel.panelNode;
            var maxWidth = container.clientWidth - this.targetOffset.x - fixupL +
                container.scrollLeft-6;

            if (inputWidth > maxWidth)
                inputWidth = maxWidth;

            if (forceAll || initial || this.wrapped != wasWrapped)
            {
                this.box.style.left = (this.targetOffset.x + fixupL) + "px";
                this.box.style.top = (this.targetOffset.y + fixupT) + "px";
            }
            this.input.style.width = inputWidth + "px";
        }

        if (forceAll)
            Dom.scrollIntoCenterView(this.box, null, true);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.InlineEditor = InlineEditor;

return InlineEditor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

/**
 * Firebug module can depend only on modules that don't use the 'Firebug' namespace.
 * So, mainly only on library modules from 'firebug/lib/*'
 *
 * So, be careful before you create a new dependency.
 *
 * xxxHonza: dependency the following modules should be removed:
 *     "firebug/chrome/firefox"
 *     "firebug/chrome/chrome"
 *     "firebug/trace/traceListener"
 */
define("firebug/firebug",
[
    "firebug/lib/lib",
    "firebug/chrome/firefox",
    "firebug/chrome/chrome",
    "firebug/lib/domplate",
    "firebug/lib/options",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/lib/css",
    "firebug/lib/array",
    "firebug/lib/http",
    "firebug/trace/traceListener",
],
function(FBL, Firefox, ChromeFactory, Domplate, Options, Locale, Events, Wrapper, Css, Arr, Http,
    TraceListener) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const nsISupports = Ci.nsISupports;

const observerService = Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
const categoryManager = Cc["@mozilla.org/categorymanager;1"].getService(Ci.nsICategoryManager);
const promptService = Cc["@mozilla.org/embedcomp/prompt-service;1"].getService(Ci.nsIPromptService);

const versionURL = "chrome://firebug/content/branch.properties";

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

const scriptBlockSize = 20;

const PLACEMENT_NONE = 0;
const PLACEMENT_INBROWSER = 1;
const PLACEMENT_DETACHED = 2;
const PLACEMENT_MINIMIZED = 3;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

var modules = [];
var activeContexts = [];
var activableModules = [];
var panelTypes = [];
var earlyRegPanelTypes = []; // See Firebug.registerPanelType for more info
var reps = [];
var defaultRep = null;
var defaultFuncRep = null;
var menuItemControllers = [];
var panelTypeMap = {};

// ********************************************************************************************* //

//xxxHonza: we should use the existing Firebug object.
if (window.Firebug)
{
    // Stow the pre-load properties, add them back at the end
    var PreFirebug = {};
    var preFirebugKeys = Object.keys(Firebug);
    preFirebugKeys.forEach(function copyProps(key)
    {
        PreFirebug[key] = Firebug[key];
    });
}

/**
 * @class Represents the main Firebug application object. An instance of this object is
 * created for each browser window (browser.xul).
 */
window.Firebug =
{
    version: "1.13",

    dispatchName: "Firebug",
    modules: modules,
    panelTypes: panelTypes,
    earlyRegPanelTypes: earlyRegPanelTypes,
    uiListeners: [],
    reps: reps,

    stringCropLength: 50,

    isInitialized: false,
    isLoaded: false,

    migrations: {},

    // Custom stylesheets registered by extensions.
    stylesheets: [],

    viewChrome: null,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function(chrome)
    {
        // This says how much time was necessary to load Firebug overlay (+ all script tags).
        FBTrace.timeEnd("SCRIPTTAG_TIME");

        // Measure the entire Firebug initialization time.
        FBTrace.time("INITIALIZATION_TIME");

        Firebug.chrome = chrome;
        Firebug.originalChrome = Firebug.chrome;

        if (FBTrace.sysout && (!FBL || !FBL.initialize))
        {
            FBTrace.sysout("Firebug is broken, FBL incomplete, if the last function is QI, " +
                "check lib.js:", FBL);
        }
        else if (FBTrace.DBG_INITIALIZE)
        {
            FBTrace.sysout("firebug.initialize FBL: " + FBL);
        }

        if (window.FBL.legacyApiPatch)
            window.FBL.legacyApiPatch(FBL, this, Firefox);

        // Till now all registered panels have been inserted into earlyRegPanelTypes.
        var tempPanelTypes = earlyRegPanelTypes;
        earlyRegPanelTypes = null;
        Firebug.completeInitialize(tempPanelTypes);
    },

    completeInitialize: function(tempPanelTypes)
    {
        if (FBL)
            FBL.initialize();  // non require.js modules

        // Append early registered panels at the end.
        panelTypes.push.apply(panelTypes, tempPanelTypes);

        // Firebug is getting option-updates from the connection so,
        // do not register it again here (see issue 6035)
        //Firebug.Options.addListener(this);

        this.isInitialized = true;

        // Distribute Firebug's preference domain as an argument (see issue 6210).
        Events.dispatch(modules, "initialize", [Options.prefDomain]);

        // This is the final of Firebug initialization.
        FBTrace.timeEnd("INITIALIZATION_TIME");
    },

    sendLoadEvent: function()
    {
        this.isLoaded = true;

        var event = document.createEvent("Events");
        event.initEvent("FirebugLoaded", true, false);

        // Send to the current window/scope (firebugFrame.xul)
        window.document.dispatchEvent(event);

        // Send to the top window/scope (browser.xul)
        if (top != window)
            top.document.dispatchEvent(event);
    },

    getVersion: function()
    {
        if (!this.fullVersion)
            this.fullVersion = this.loadVersion(versionURL);

        return this.fullVersion;
    },

    loadVersion: function(versionURL)
    {
        var content = Http.getResource(versionURL);
        if (!content)
            return "no content at "+versionURL;

        var m = /RELEASE=(.*)/.exec(content);
        if (m)
            var release = m[1];
        else
            return "no RELEASE in "+versionURL;

        m = /VERSION=(.*)/.exec(content);
        if (m)
            var version = m[1];
        else
            return "no VERSION in "+versionURL;

        return version+""+release;
    },

    /**
     *  Substitute strings in the UI, with fall back to en-US
     */
    internationalizeUI: function(doc) // TODO chrome.js
    {
        if (!doc)
            return;

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("Firebug.internationalizeUI");

        var elements = doc.getElementsByClassName("fbInternational");
        elements = Arr.cloneArray(elements);
        var attributes = ["label", "tooltiptext", "aria-label"];
        for (var i=0; i<elements.length; i++)
        {
            var element = elements[i];
            Css.removeClass(elements[i], "fbInternational");
            for (var j=0; j<attributes.length; j++)
            {
                if (element.hasAttribute(attributes[j]))
                    Locale.internationalize(element, attributes[j]);
            }
        }

        // Allow other modules to internationalize UI labels (called also for
        // detached Firebug window).
        Events.dispatch(modules, "internationalizeUI", [doc]);
    },

    /**
     * Called when the UI is ready to be initialized, once the panel browsers are loaded,
     * but before any contexts are created.
     */
    initializeUI: function(detachArgs)
    {
        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("firebug.initializeUI detachArgs:", detachArgs);

        Events.dispatch(menuItemControllers, "initialize", []);  // TODO chrome.js

        // In the case that the user opens firebug in a new window but then closes Firefox
        // window, we don't get the quitApplicationGranted event (platform is still running)
        // and we call shutdown (Firebug isDetached).
        window.addEventListener('unload', shutdownFirebug, false);

        // Initial activation of registered panel types. All panel -> module dependencies
        // should be defined now (in onActivationChange). Must be called after
        // Firebug.TabWatcher is ready.
        if (Firebug.PanelActivation)
            Firebug.PanelActivation.activatePanelTypes(panelTypes);

        // Tell the modules the UI is up.
        Events.dispatch(modules, "initializeUI", [detachArgs]);
    },

    /**
     * called in browser when Firefox closes and in externalMode when fbs gets
     * quitApplicationGranted.
     */
    shutdown: function()
    {
        if (this.isShutdown)
            return;

        this.isShutdown = true;

        this.shutdownUI();

        Events.dispatch(modules, "shutdown");

        this.Options.shutdown();
        this.Options.removeListener(this);

        this.connection.disconnect();

        this.PanelActivation.deactivatePanelTypes(panelTypes);

        // Shutdown all registered extensions.
        this.unregisterExtensions();

        if (FBTrace.DBG_OBSERVERS)
        {
            // import fbObserverService
            Components.utils.import("resource://firebug/observer-service.js");
            fbObserverService.traceStacksForTrack();
        }

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("firebug.shutdown exited ");
    },

    shutdownUI: function()  // TODO chrome.js
    {
        window.removeEventListener("unload", shutdownFirebug, false);

        Events.dispatch(modules, "disable", [Firebug.chrome]);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // TODO this entire section to XULWindow

    // TODO XULWindow
    getSuspended: function()
    {
        return Firebug.StartButton.getSuspended();
    },

    // TODO XULWindow
    setSuspended: function(value)
    {
        Firebug.StartButton.setSuspended(value);
    },

    // TODO XULWindow IN detached "Activate Firebug for the current website"
    toggleSuspend: function()
    {
        // getSuspended returns non-null value if Firebug is suspended.
        if (this.getSuspended() || this.isDetached())
        {
            // Firebug is suspended now. Two possible actions have been executed:
            // 1) Firebug UI is closed and the user clicked on the status bar icon in order to
            //    show the UI and resume Firebug.
            // 2) Firebug is detached, but suspended for the current page. The user clicked
            //    either on the status bar icon or on an activation button that is displayed
            //    within detached Firebug window.
            this.toggleBar(true);
        }
        else
        {
            // The users wants to suspend Firebug, let's do it and pull down the visible UI.
            // xxxHonza: the Firebug isn't suspended if detached and the user clicks on the
            // status bar icon (the detached window should becoma blank displaying only
            // the activation button).
            this.suspend();

            // Close detached Firebug or
            // show/hide Firebug UI according to the browser.showFirebug flag.
            if (Firebug.isDetached())
                this.toggleDetachBar(false);
            else
                this.syncBar();
        }
    },

    // dispatch suspendFirebug to all windows
    suspend: function()
    {
        if (Firebug.rerun)
            return;

        Firebug.suspendFirebug();
    },

    // dispatch onSuspendFirebug to all modules
    suspendFirebug: function()
    {
        var cancelSuspend = Events.dispatch2(activableModules, "onSuspendingFirebug", []);
        if (cancelSuspend)
            return;

        this.setSuspended("suspending");

        // TODO no context arg
        var cancelSuspend = Events.dispatch2(activableModules, "onSuspendFirebug",
            [Firebug.currentContext]);

        if (cancelSuspend)
            Firebug.resume();
        else
            this.setSuspended("suspended");
    },

    resume: function()
    {
        Firebug.resumeFirebug();
    },

    resumeFirebug: function()  // dispatch onResumeFirebug to all modules
    {
        this.setSuspended("resuming");

        // TODO no context arg
        Events.dispatch(activableModules, 'onResumeFirebug', [Firebug.currentContext]);
        this.setSuspended(null);
    },

    getURLsForAllActiveContexts: function()
    {
        var contextURLSet = [];

        // create a list of all unique activeContexts
        Firebug.connection.eachContext(function createActiveContextList(context)
        {
            if (FBTrace.DBG_WINDOWS)
                FBTrace.sysout("context " + context.getName());

            try
            {
                var cw = context.window;
                if (cw)
                {
                    var url;
                    if (cw.closed)
                    {
                        url = "about:closed";
                    }
                    else
                    {
                        if ("location" in cw)
                            url = cw.location.toString();
                        else
                            url = context.getName();
                    }

                    if (url)
                    {
                        if (contextURLSet.indexOf(url) == -1)
                            contextURLSet.push(url);
                    }
                }
            }
            catch(e)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("firebug.getURLsForAllActiveContexts could not get " +
                        "window.location for a context", e);
            }
        });

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("active contexts urls " + contextURLSet.length);

        return contextURLSet;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Registration

    /**
     * Set a default value for a preference into the firebug preferences list.
     *
     * @param name preference name, possibly dot segmented, will be stored under
     *      extensions.firebug.<name>
     * @param value default value of preference
     * @return true if default set, else false
     */
    registerPreference: function(name, value)
    {
        Firebug.Options.register(name, value);
    },

    registerModule: function()
    {
        modules.push.apply(modules, arguments);

        // Fire the initialize event for modules that are registered later.
        if (Firebug.isInitialized)
            Events.dispatch(arguments, "initialize", []);

        if (FBTrace.DBG_REGISTRATION)
        {
            for (var i = 0; i < arguments.length; ++i)
                FBTrace.sysout("registerModule "+arguments[i].dispatchName);
        }
    },

    unregisterModule: function()
    {
        for (var i = 0; i < arguments.length; ++i)
            Arr.remove(modules, arguments[i]);

        // Fire shutdown if module was unregistered dynamically (not on Firebug shutdown).
        if (!Firebug.isShutdown)
            Events.dispatch(arguments, "shutdown", []);
    },

    registerActivableModule: function()
    {
        activableModules.push.apply(activableModules, arguments);
        this.registerModule.apply(this, arguments);
    },

    registerUIListener: function()
    {
        for (var j = 0; j < arguments.length; j++)
            Firebug.uiListeners.push(arguments[j]);
    },

    unregisterUIListener: function()
    {
        for (var i = 0; i < arguments.length; ++i)
            Arr.remove(Firebug.uiListeners, arguments[i]);
    },

    registerPanel: function()
    {
        for (var i=0; i<arguments.length; ++i)
        {
            var panelName = arguments[i].prototype.name;
            var panel = panelTypeMap[panelName];
            if (panel)
            {
                if (FBTrace.DBG_ERRORS)
                {
                    FBTrace.sysout("firebug.registerPanel; ERROR a panel with the same " +
                        "ID already registered! " + panelName);
                }
            }
        }

        // In order to keep built in panels (like Console, Script...) be the first one
        // and insert all panels coming from extension at the end, catch any early registered
        // panel (i.e. before FBL.initialize is called, such as YSlow) in a temp array
        // that is appended at the end as soon as FBL.initialize is called.
        if (earlyRegPanelTypes)
            earlyRegPanelTypes.push.apply(earlyRegPanelTypes, arguments);
        else
            panelTypes.push.apply(panelTypes, arguments);

        for (var i=0; i<arguments.length; ++i)
            panelTypeMap[arguments[i].prototype.name] = arguments[i];

        if (FBTrace.DBG_REGISTRATION)
        {
            for (var i=0; i<arguments.length; ++i)
                FBTrace.sysout("registerPanel " + arguments[i].prototype.name);
        }

        // If Firebug is not initialized yet the UI will be updated automatically soon.
        if (!this.isInitialized)
            return;

        Firebug.chrome.syncMainPanels();
        Firebug.chrome.syncSidePanels();
    },

    unregisterPanel: function(panelType)
    {
        var panelName = panelType ? panelType.prototype.name : null;

        if (FBTrace.DBG_REGISTRATION)
        {
            FBTrace.sysout("firebug.unregisterPanel: " +
                (panelName ? panelName : "Undefined panelType"));
        }

        // Remove all instance of the panel.
        Firebug.connection.eachContext(function (context)
        {
            // An empty state can be probably used at this moment since
            // we are unregistering the panel anyway.
            var state = {}; //context.browser.persistedState;
            context.removePanel(panelType, state);
        });

        // Now remove panel-type itself.
        for (var i=0; i<panelTypes.length; i++)
        {
            if (panelTypes[i] == panelType)
            {
                panelTypes.splice(i, 1);
                break;
            }
        }

        delete panelTypeMap[panelType.prototype.name];

        // We don't have to update Firebug UI if it's just closing.
        if (this.isShutdown)
            return;

        // Make sure another panel is selected if the current one is has been removed.
        var panel = this.chrome.getSelectedPanel();
        if (panel && panel.name == panelName)
            Firebug.chrome.selectPanel("html");

        // The panel tab must be removed from the UI.
        Firebug.chrome.syncMainPanels();
        Firebug.chrome.syncSidePanels();
    },

    registerRep: function()
    {
        reps.push.apply(reps, arguments);
    },

    unregisterRep: function()
    {
        for (var i = 0; i < arguments.length; ++i)
            Arr.remove(reps, arguments[i]);
    },

    setDefaultReps: function(funcRep, rep)
    {
        defaultRep = rep;
        defaultFuncRep = funcRep;
    },

    registerStringBundle: function(bundleURI)
    {
        Locale.registerStringBundle(bundleURI);
    },

    unregisterStringBundle: function(bundleURI)
    {
        // xxxHonza: TODO:
    },

    /**
     * Allows registering of custom stylesheet coming from extension. The stylesheet is then
     * used automatially thorough Firebug UI.
     * @param {Object} styleURI URI of the stylesheet.
     */
    registerStylesheet: function(styleURI)
    {
        this.stylesheets.push(styleURI);

        // Append the stylesheet into the UI if Firebug is already loaded
        if (this.isLoaded)
            Firebug.chrome.appendStylesheet(styleURI);

        if (FBTrace.DBG_REGISTRATION)
            FBTrace.sysout("registerStylesheet " + styleURI);
    },

    unregisterStylesheet: function(styleURI)
    {
        // xxxHonza: TODO
    },

    registerMenuItem: function(menuItemController)
    {
        FBTrace.sysout("Firebug.registerMenuItem");
        menuItemControllers.push(menuItemController);
    },

    registerTracePrefix: function(prefix, type, removePrefix, styleURI)
    {
        // xxxHonza: we should fire an event to avoid dependency on
        // TraceModule and TraceListener
        var listener = Firebug.TraceModule.getListenerByPrefix(prefix);
        if (listener && FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("firebug.registerTracePrefix; ERROR " +
                "there is already such prefix registered!");
            return;
        }

        listener = new TraceListener(prefix, type, removePrefix, styleURI);
        Firebug.TraceModule.addListener(listener);
    },

    unregisterTracePrefix: function(prefix)
    {
        var listener = Firebug.TraceModule.getListenerByPrefix(prefix);
        if (listener)
            Firebug.TraceModule.removeListener(listener);
    },

    registerCommand: function(name, config)
    {
        // xxxHonza: we should fire an event to avoid dependency on CommandLineExposed module.
        // Fix as soon as issue 6855 is done
        return Firebug.CommandLineExposed.registerCommand(name, config);
    },

    unregisterCommand: function(name)
    {
        // xxxHonza: we should fire an event to avoid dependency on CommandLineExposed module.
        // Fix as soon as issue 6855 is done
        return Firebug.CommandLineExposed.unregisterCommand(name);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Options

    getPref: function()
    {
        // TODO deprecated
        return Options.getPref.apply(Firebug.Options, arguments);
    },

    setPref: function()
    {
        // TODO deprecated
        return Options.setPref.apply(Firebug.Options, arguments);
    },

    clearPref: function()
    {
        // TODO deprecated
        return Options.clearPref.apply(Options, arguments);
    },

    prefDomain: "extensions.firebug",

    updateOption: function(name, value)
    {
        // fbtest changes options which change prefs which trigger updates in fbtrace
        if (!Firebug.chrome)
            return;

        // Distribute to the current chrome.
        Firebug.chrome.updateOption(name, value);

        // If Firebug is detached distribute also into the in-browser chrome.
        if (Firebug.chrome != Firebug.originalChrome)
            Firebug.originalChrome.updateOption(name, value);

        Events.dispatch(Firebug.modules, "updateOption", [name, value]);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    shouldIgnore: function(objectChromeView)
    {
        if (objectChromeView)
        {
            var contentView = Wrapper.unwrapObject(objectChromeView);
            return (contentView && contentView.firebugIgnore);
        }
        // else don't ignore things we don't understand
    },

    setIgnored: function(objectChromeView)
    {
        if (objectChromeView)
        {
            var contentView = Wrapper.unwrapObject(objectChromeView);
            if (contentView)
                contentView.firebugIgnore = true;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Browser Bottom Bar

    // TODO XULWindow
    showBar: function(show)
    {
        var browser = Firefox.getCurrentBrowser();

        if (FBTrace.DBG_WINDOWS || FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("showBar("+show+") for browser "+browser.currentURI.spec+
                " Firebug.currentContext "+Firebug.currentContext);

        Firebug.chrome.toggleOpen(show);

        if (!show)
            Firebug.Inspector.inspectNode(null);

        //xxxHonza: should be removed.
        Events.dispatch(Firebug.uiListeners, show ? "showUI" : "hideUI",
            [browser, Firebug.currentContext]);

        // Sync panel state after the showUI event is dispatched. syncPanel method calls
        // Panel.show method, which expects the active context to be already registered.
        if (show)
            Firebug.chrome.syncPanel();
        else
            Firebug.chrome.selectPanel(); // select null causes hide() on selected

        Firebug.StartButton.resetTooltip();
    },

    closeFirebug: function(userCommands)  // this is really deactivate
    {
        if (!Firebug.currentContext)
            return;

        // It looks like FBTest is calling Firebug.Activation.clearAnnotations()
        // when there is no current context.
        //throw new Error("closeFirebug ERROR: no Firebug.currentContext ");

        // Focus the browser window again
        Firebug.currentContext.window.focus();

        Firebug.connection.closeContext(Firebug.currentContext, userCommands);
        Firebug.StartButton.resetTooltip();
    },

    /**
     * Primary function to activate or minimize firebug. Used by
     * <ol>
     * <li>the status bar icon click action</li>
     * <li>the activation button (within Firebug.xul) click action</li>
     * </ol>
     * @param forceOpen: don't minimize, stay open if open.
     * @param panelName: eg 'script', to select a specific panel.
     */
    toggleBar: function(forceOpen, panelName)
    {
        if (panelName)
            Firebug.chrome.selectPanel(panelName);
        // if is deactivated.
        if (!Firebug.currentContext)
        {
            var context = Firebug.getContext();
            // Be sure the UI is open for a newly created context.
            forceOpen = true;
        }

        if (Firebug.isDetached())
        {
            //in detached mode, two possibilities exist, the firebug windows is
            // the active window of the user or no.
            if ( !Firebug.chrome.hasFocus() || forceOpen)
                Firebug.chrome.focus();
            else
                Firebug.minimizeBar();
        }
        // toggle minimize
        else if (Firebug.isMinimized())
        {
            // be careful, unMinimize func always sets placement to
            // inbrowser first then unminimizes. when we want to
            // unminimize in detached mode must call detachBar func.
            if (Firebug.framePosition == "detached")
                this.detachBar();
            else
                Firebug.unMinimize();
        }
        // else isInBrowser
        else if (!forceOpen)
        {
            Firebug.minimizeBar();
        }

        return true;
    },

    /**
     * Get context for the current website
     */
    getContext: function()
    {
        var webApp = Firebug.connection.getCurrentSelectedWebApp();
        var context = Firebug.connection.getContextByWebApp(webApp);
        // we are not debugging the selected tab.
        if (!context)
        {
            context = Firebug.connection.getOrCreateContextByWebApp(webApp);
        }
        return context;
    },

    /**
     * Primary function to re-show firebug due to visiting active site.
     * Unlike toggleBar, we are trying to obey the current placement, not change it.
     */
    showContext: function(browser, context)
    {
        // user wants detached but we are not yet
        if (Firebug.framePosition == "detached" && !Firebug.isDetached())
        {
            if (context && !Firebug.isMinimized()) // don't detach if it's minimized 2067
                this.detachBar();  //   the placement will be set once the external window opens
            else  // just make sure we are not showing
                this.showBar(false);
        }
        else if (Firebug.openMinimized() && !Firebug.isMinimized())
            this.minimizeBar();
        else if (Firebug.isMinimized())
            this.showBar(false);  // don't show, we are minimized
        else if (Firebug.isDetached())
            Firebug.chrome.syncResumeBox(context);
        else  // inBrowser
            this.showBar(context?true:false);
    },

    minimizeBar: function()  // just pull down the UI, but don't deactivate the context
    {
        if (Firebug.isDetached())
        {
            // TODO reattach

            // window is closing in detached mode
            var parent = this.getFirebugFrameParent();
            if (parent)
            {
                parent.exportFirebug();
                parent.close();
            }

            Firebug.setPlacement("minimized");
            this.showBar(false);
            Firebug.chrome.focus();
        }
        else // inBrowser -> minimized
        {
            Firebug.setPlacement("minimized");
            this.showBar(false);

            // Focus the browser window again
            if (Firebug.currentContext)
                Firebug.currentContext.window.focus();
        }
    },

    unMinimize: function()
    {
        Firebug.setPlacement("inBrowser");
        Firebug.showBar(true);
    },

    onShowDetachTooltip: function(tooltip)
    {
        tooltip.label = Firebug.isDetached() ? Locale.$STR("firebug.AttachFirebug") :
            Locale.$STR("firebug.DetachFirebug");
        return true;
    },

    /**
     * function to switch between detached and inbrowser modes.
     * @param forceOpen: should not be closed, stay open if open or open it.
     * @param reopenInBrowser: switch from detahced to inbrowser mode.
     */
    toggleDetachBar: function(forceOpen, reopenInBrowser)
    {
        //detached -> inbrowser
        if (!forceOpen && Firebug.isDetached())
        {
            var parent = this.getFirebugFrameParent();
            parent.exportFirebug();
            parent.close();

            if (reopenInBrowser)
            {
                // Is Firebug deactivated ? if yes, should be
                // activated at first, then unminimize.
                if (!Firebug.currentContext)
                {
                    var context = Firebug.getContext();
                }
                Firebug.unMinimize();
            }
            else
            {
                Firebug.minimizeBar();
            }

            Firebug.chrome.syncPositionPref();
        }
        // is minimized now but the last time that has been closed, was in detached mode,
        // so it should be returned to in browser mode because the user has pressed CTRL+F12.
        else if (Firebug.framePosition == "detached" && Firebug.isMinimized())
        {
            Firebug.unMinimize();
            Firebug.chrome.syncPositionPref();
        }
        // else is in browser mode, then switch to detached mode.
        else
        {
            this.detachBar();
        }
    },

    closeDetachedWindow: function(userCommands)
    {
        Firebug.showBar(false);

        if (Firebug.currentContext)
            ToolInterface.browser.closeContext(Firebug.currentContext, userCommands);

        // else the user closed Firebug external window while not looking at
        // a debugged web page.
        Firebug.StartButton.resetTooltip();
    },

    detachBar: function()
    {
        if (Firebug.isDetached())  // can be set true attachBrowser
        {
            Firebug.chrome.focus();
            return null;
        }

        if (Firebug.chrome.waitingForDetach)
            return null;

        Firebug.chrome.waitingForDetach = true;
        Firebug.chrome.toggleOpen(false);  // don't show in browser.xul now

        if (FBTrace.DBG_ACTIVATION)
        {
            FBTrace.sysout("Firebug.detachBar opening firebug.xul for context " +
                Firebug.currentContext.getName() );
        }

        Firebug.chrome.syncPositionPref("detached");

        return Firefox.openWindow("Firebug",
            "chrome://firebug/content/firefox/firebug.xul",
            "", {});
    },

    // show firebug if we should
    syncBar: function()
    {
        var browser = Firefox.getCurrentBrowser();

        // implicitly this is operating in the chrome of browser.xul
        this.showBar(browser && browser.showFirebug);
    },

    toggleCommandLine: function(showCommandEditor)
    {
        Options.set("commandEditor", showCommandEditor);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Returns parent of the firebugFrame.xul frame. The actual parent depends on whether
     * Firebug is attached or detached.
     *
     * attached -> browser.xul
     * detached -> firebug.xul
     */
    getFirebugFrameParent: function()
    {
        // We need firebug.xul in case of detached state. So, don't use 'top' since
        // it references browser.xul
        return Firebug.chrome.window.parent;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // deprecated

    resetAllOptions: function(confirm)
    {
        if (confirm)
        {
            var promptService = Cc["@mozilla.org/embedcomp/prompt-service;1"].
                getService(Ci.nsIPromptService);

            // Do not reset options if the user changed its mind.
            if (!promptService.confirm(null, Locale.$STR("Firebug"),
                Locale.$STR("confirmation.Reset_All_Firebug_Options")))
            {
                return;
            }
        }

        // Dispatch to non-module objects.
        Options.resetAllOptions(confirm);

        // Dispatch to all modules so that additional settings can be reset.
        Events.dispatch(modules, "resetAllOptions", []);

        // Dispatch to all modules so 'after' actions can be executed.
        Events.dispatch(modules, "afterResetAllOptions", []);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Panels

    getPanelType: function(panelName)
    {
        if (panelTypeMap.hasOwnProperty(panelName))
            return panelTypeMap[panelName];
        else
            return null;
    },

    getPanelTitle: function(panelType)
    {
        if (!panelType)
            return null;

        return panelType.prototype.title ? panelType.prototype.title
            : Locale.$STR("Panel-"+panelType.prototype.name);
    },

    getPanelTooltip: function(panelType)
    {
        var tooltip = panelType.prototype.tooltip ? panelType.prototype.tooltip
            : Locale.$STR("panel.tip."+panelType.prototype.name);
        return tooltip != panelType.prototype.name ? tooltip : this.getPanelTitle(panelType);
    },

    getPanelTab: function(panelName)
    {
        var chrome = Firebug.chrome;

        var tab = chrome.$("fbPanelBar2").getTab(panelName);
        if (!tab)
            tab = chrome.$("fbPanelBar1").getTab(panelName);

        return tab;
    },

    getMainPanelTypes: function(context)
    {
        var resultTypes = [];

        for (var i = 0; i < panelTypes.length; ++i)
        {
            var panelType = panelTypes[i];
            if (!panelType.prototype.parentPanel)
                resultTypes.push(panelType);
        }

        if (context.panelTypes)
        {
            for (var i = 0; i < context.panelTypes.length; ++i)
            {
                var panelType = context.panelTypes[i];
                if (!panelType.prototype.parentPanel)
                    resultTypes.push(panelType);
            }
        }

        resultTypes.sort(function(a, b)
        {
            return a.prototype.order < b.prototype.order ? -1 : 1;
        });

        return resultTypes;
    },

    getSidePanelTypes: function(context, mainPanel)
    {
        if (!mainPanel)
            return [];

        var resultTypes = [];

        for (var i = 0; i < panelTypes.length; ++i)
        {
            var panelType = panelTypes[i];

            if (panelType.prototype.parentPanel &&
                (panelType.prototype.parentPanel == mainPanel.name))
            {
                resultTypes.push(panelType);
            }
        }

        if (context.panelTypes)
        {
            for (var i = 0; i < context.panelTypes.length; ++i)
            {
                var panelType = context.panelTypes[i];
                if (panelType.prototype.parentPanel == mainPanel.name)
                    resultTypes.push(panelType);
            }
        }

        resultTypes.sort(function(a, b)
        {
            return a.prototype.order < b.prototype.order ? -1 : 1;
        });

        return resultTypes;
    },

    /**
     * Returns all panel types, whose activation can be toggled
     * @returns {Object} Activable panel types
     */
    getActivablePanelTypes: function()
    {
        var activablePanelTypes = [];
        for (var i = 0; i < panelTypes.length; ++i)
        {
            if (this.PanelActivation.isPanelActivable(panelTypes[i]))
                activablePanelTypes.push(panelTypes[i]);
        }

        return activablePanelTypes;
    },

    /**
     * Gets an object containing the state of the panel from the last time
     * it was displayed before one or more page reloads.
     * The 'null' return here is a too-subtle signal to the panel code in bindings.xml.
     * Note that panel.context may not have a persistedState, but in addition the persisted
     * state for panel.name may be null.
     *
     * xxxHonza: the method should never return null. The implementation should
     * just use: Persist.getPersistedState() method.
     */
    getPanelState: function(panel)
    {
        var persistedState = panel.context.persistedState;
        if (!persistedState || !persistedState.panelState)
            return null;

        return persistedState.panelState[panel.name];
    },

    showPanel: function(browser, panel)
    {
        // The panel may be null
        Events.dispatch(modules, "showPanel", [browser, panel]);
    },

    showSidePanel: function(browser, sidePanel)
    {
        Events.dispatch(modules, "showSidePanel", [browser, sidePanel]);
    },

    eachPanel: function(callback)
    {
        Firebug.connection.eachContext(function iteratePanels(context)
        {
            var rc = context.eachPanelInContext(callback);
            if (rc)
                return rc;
        });
    },

    dispatchToPanels: function(fName, args)
    {
        Firebug.eachPanel( function dispatchToPanel(panel)
        {
            if (panel[fName])
                return panel[fName].apply(panel,args);
        });
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    dispatch: function(listeners, eventId, args)
    {
        Events.dispatch(listeners, eventId, args);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // URL mapping

    getObjectByURL: function(context, url)
    {
        for (var i = 0; i < modules.length; ++i)
        {
            var object = modules[i].getObjectByURL(context, url);
            if (object)
                return object;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Reps

    getRep: function(object, context)
    {
        var type = typeof(object);
        if (type == 'object' && object instanceof String)
            type = 'string';

        for (var i = 0; i < reps.length; ++i)
        {
            var rep = reps[i];
            try
            {
                if (rep.supportsObject(object, type, (context?context:Firebug.currentContext) ))
                {
                    //if (FBTrace.DBG_DOM)
                    //    FBTrace.sysout("getRep type: "+type+" object: "+object, rep);
                    return rep;
                }
            }
            catch (exc)
            {
                if (FBTrace.DBG_ERRORS)
                {
                    FBTrace.sysout("firebug.getRep FAILS: "+ exc, exc);
                    FBTrace.sysout("firebug.getRep reps["+i+"/"+reps.length+"]: "+
                        (typeof(reps[i])), reps[i]);
                }
            }
        }

        //if (FBTrace.DBG_DOM)
        //    FBTrace.sysout("getRep default type: "+type+" object: "+object, rep);

        return (type == "function") ? defaultFuncRep : defaultRep;
    },

    getRepObject: function(node)
    {
        var target = null;
        for (var child = node; child; child = child.parentNode)
        {
            if (Css.hasClass(child, "repTarget"))
                target = child;

            if (child.repObject != null)
            {
                if (!target && Css.hasClass(child, "repIgnore"))
                    break;
                else
                    return child.repObject;
            }
        }
    },

    /**
     * The child node that has a repObject
     */
    getRepNode: function(node)
    {
        for (var child = node; child; child = child.parentNode)
        {
            if (child.repObject != null)
                return child;
        }
    },

    getElementByRepObject: function(element, object)
    {
        for (var child = element.firstChild; child; child = child.nextSibling)
        {
            if (child.repObject === object)
                return child;
        }
    },

    /**
     * Takes an element from a panel document and finds the owning panel.
     */
    getElementPanel: function(element)
    {
        for (; element; element = element.parentNode)
        {
            if (element.ownerPanel)
                return element.ownerPanel;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // nsISupports

    QueryInterface : function(iid)
    {
        if (iid.equals(nsISupports))
        {
            return this;
        }

        throw Components.results.NS_NOINTERFACE;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Placement

    isDetached: function()
    {
        return Firebug.placement == PLACEMENT_DETACHED;
    },

    isMinimized: function()
    {
        return Firebug.placement == PLACEMENT_MINIMIZED;
    },

    isInBrowser: function()
    {
        return Firebug.placement == PLACEMENT_INBROWSER;
    },

    placements: ["none", "inBrowser", "detached", "minimized"],

    placement: 1,

    setPlacement: function(toPlacement)
    {
        // TODO : This should probably be an event so others can link into this
        Firebug.chrome.$("fbSearchBox").hideOptions();

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("Firebug.setPlacement from " + Firebug.getPlacement() + " to " +
                toPlacement + " with chrome " + Firebug.chrome.window.location);

        for (var i=0; i<Firebug.placements.length; i++)
        {
            if (toPlacement == Firebug.placements[i])
            {
                if (Firebug.placement != i) // then we are changing the value
                {
                    Firebug.placement = i;
                    delete Firebug.previousPlacement;
                    Options.set("previousPlacement", Firebug.placement);
                    Firebug.StartButton.resetTooltip();
                }
                return Firebug.placement;
            }
        }
        throw new Error("Firebug.setPlacement cannot match "+toPlacement+" as a placement");
    },

    getPlacement: function()
    {
        return Firebug.placements[Firebug.placement];
    },

    openMinimized: function()
    {
        if (!Firebug.previousPlacement)
            Firebug.previousPlacement = Options.get("previousPlacement");

        return (Firebug.previousPlacement && (Firebug.previousPlacement == PLACEMENT_MINIMIZED) );
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug.TabWatcher Listener

    getContextType: function()
    {
        return Firebug.TabContext;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * This method syncs the UI to a context
     * @param context to become the active and visible context
     */
    selectContext: function(context)
    {
        this.showContext(context.browser, context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    focusBrowserTab: function(win)    // TODO move to FBL
    {
        Firefox.selectTabByWindow(win);
        this.chrome.focus();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // FBTest

    // Expose our test list to the FBTest console for automated testing.
    onGetTestList: function(testLists)
    {
        testLists.push({
            extension: "Firebug",
            testListURL: "http://getfirebug.com/tests/head/firebug.html"
        });
    }
};

// ********************************************************************************************* //
// API for Greasemonkey, Jetpack and other Firefox extensions

/**
 * @param global wrapped up global: outer window or sandbox
 * @return a |console| object for the window
 */
Firebug.getConsoleByGlobal = function getConsoleByGlobal(global)
{
    try
    {
        if (!(global instanceof Window))
            throw new Error("global is not a Window object");
        var win = Wrapper.wrapObject(global);
        return Firebug.Console.getExposedConsole(win);
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("Firebug.getConsoleByGlobal FAILS " + exc, exc);
    }
};

// ********************************************************************************************* //

/**
 * If we are detached and the main Firefox window closes, also close the matching Firebug window.
 */
function shutdownFirebug()
{
    try
    {
        if (Firebug.isDetached())
            Firebug.chrome.close();
    }
    catch (exc)
    {
        window.dump("Firebug.shutdownFirebug EXCEPTION: " + exc + "\n");
    }

    Firebug.shutdown();
}

if (preFirebugKeys)
{
    // Add back the preLoad properties
    preFirebugKeys.forEach(function copyProps(key)
    {
        Firebug[key] = PreFirebug[key];
    });
}

// ********************************************************************************************* //
// Registration

Firebug.Firefox = Firefox;
Firebug.ChromeFactory = ChromeFactory;
Firebug.Options = Options;

return Firebug;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/firefox/browserCommands",
[
    "firebug/lib/trace",
    "firebug/lib/options",
    "firebug/lib/locale",
    "firebug/firefox/browserOverlayLib",
],
function(FBTrace, Options, Locale, BrowserOverlayLib) {
with (BrowserOverlayLib) {

// ********************************************************************************************* //
// Constants

var shortcuts = [
    "toggleFirebug",
    "toggleInspecting",
    "focusCommandLine",
    "detachFirebug",
    "closeFirebug",
    "toggleBreakOn"
];

/* Used by the browser menu, but should be really global shortcuts?
key_increaseTextSize
key_decreaseTextSize
key_normalTextSize
key_help
key_toggleProfiling
key_focusFirebugSearch
key_customizeFBKeys
*/

// ********************************************************************************************* //
// BrowserCommands Implementation

var BrowserCommands =
{
    overlay: function(doc)
    {
        this.overlayCommands(doc);
        this.overlayShortcuts(doc);
    },

    overlayCommands: function(doc)
    {
        $command(doc, "cmd_firebug_closeFirebug", "Firebug.closeFirebug(true);");
        $command(doc, "cmd_firebug_toggleInspecting", "if (!Firebug.currentContext) Firebug.toggleBar(true); Firebug.Inspector.toggleInspecting(Firebug.currentContext);");
        $command(doc, "cmd_firebug_focusCommandLine", "if (!Firebug.currentContext) Firebug.toggleBar(true); Firebug.CommandLine.focus(Firebug.currentContext);");
        $command(doc, "cmd_firebug_toggleFirebug", "Firebug.toggleBar();");
        $command(doc, "cmd_firebug_detachFirebug", "Firebug.toggleDetachBar(false, true);");
        $command(doc, "cmd_firebug_inspect", "Firebug.Inspector.inspectFromContextMenu(arg);", "document.popupNode");
        $command(doc, "cmd_firebug_toggleBreakOn", "if (Firebug.currentContext) Firebug.chrome.breakOnNext(Firebug.currentContext, event);");
        $command(doc, "cmd_firebug_toggleDetachFirebug", "Firebug.toggleDetachBar(false, true);");
        $command(doc, "cmd_firebug_increaseTextSize", "Firebug.Options.changeTextSize(1);");
        $command(doc, "cmd_firebug_decreaseTextSize", "Firebug.Options.changeTextSize(-1);");
        $command(doc, "cmd_firebug_normalTextSize", "Firebug.Options.setTextSize(0);");
        $command(doc, "cmd_firebug_focusFirebugSearch", "if (Firebug.currentContext) Firebug.Search.onSearchCommand(document);");
        $command(doc, "cmd_firebug_customizeFBKeys", "Firebug.ShortcutsModel.customizeShortcuts();");
        $command(doc, "cmd_firebug_enablePanels", "Firebug.PanelActivation.enableAllPanels();");
        $command(doc, "cmd_firebug_disablePanels", "Firebug.PanelActivation.disableAllPanels();");
        $command(doc, "cmd_firebug_clearActivationList", "Firebug.PanelActivation.clearAnnotations();");
        $command(doc, "cmd_firebug_clearConsole", "Firebug.Console.clear(Firebug.currentContext);");
        $command(doc, "cmd_firebug_allOn", "Firebug.PanelActivation.toggleAll('on');");
        $command(doc, "cmd_firebug_toggleOrient", "Firebug.chrome.toggleOrient();");
        $command(doc, "cmd_firebug_resetAllOptions", "Firebug.resetAllOptions(true);");
        $command(doc, "cmd_firebug_toggleProfiling", ""); //todo
        $command(doc, "cmd_firebug_openInEditor", "Firebug.ExternalEditors.onContextMenuCommand(event)");
    },

    overlayShortcuts: function(doc)
    {
        var keyset = $(doc, "mainKeyset");

        for (var i=0; i<shortcuts.length ; i++)
        {
            var id = shortcuts[i];
            var shortcut = Options.get("key.shortcut." + id);
            var tokens = shortcut.split(" ");
            var key = tokens.pop();

            var keyProps = {
                id: "key_firebug_" + id,
                modifiers: tokens.join(","),
                command: "cmd_firebug_" + id,
                position: 1
            };

            if (key.length <= 1)
                keyProps.key = key;
            else if (doc.defaultView.KeyEvent["DOM_"+key])
                keyProps.keycode = key;

            $el(doc, "key", keyProps, keyset);
        }

        keyset.parentNode.insertBefore(keyset, keyset.nextSibling);
    }
};

// ********************************************************************************************* //
// Registration

return BrowserCommands;

// ********************************************************************************************* //
}});
/* See license.txt for terms of usage */

define("firebug/firefox/browserMenu",
[
    "firebug/lib/trace",
    "firebug/lib/options",
    "firebug/lib/locale",
    "firebug/firefox/browserOverlayLib",
],
function(FBTrace, Options, Locale, BrowserOverlayLib) {
with (BrowserOverlayLib) {

// ********************************************************************************************* //
// GlobalCommands Implementation

var BrowserMenu =
{
    overlay: function(doc)
    {
        this.overlayStartButtonMenu(doc);
        this.overlayFirebugMenu(doc);
        this.overlayFirefoxMenu(doc);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug Start Button Popup Menu

    overlayStartButtonMenu: function(doc)
    {
        $menupopupOverlay(doc, $(doc, "mainPopupSet"), [
            $menupopup(doc, 
            {
                id: "fbStatusContextMenu",
                onpopupshowing: "Firebug.browserOverlay.onOptionsShowing(this)"
            },
            [
                $menu(doc, 
                {
                    label: "firebug.uiLocation",
                    tooltiptext: "firebug.menu.tip.UI_Location",
                    "class": "fbInternational"
                },
                [
                    $menupopup(doc, {
                        onpopupshowing: "Firebug.browserOverlay.onPositionPopupShowing(this)"
                    })
                ]),
                $menuseparator(doc),
                $menuitem(doc, {
                    id: "menu_firebug_ClearConsole",
                    label: "firebug.ClearConsole",
                    tooltiptext: "firebug.ClearTooltip",
                    command: "cmd_firebug_clearConsole",
                    key: "key_firebug_clearConsole"
                }),
                $menuitem(doc, {
                    id: "menu_firebug_showErrorCount",
                    type: "checkbox",
                    label: "firebug.Show_Error_Count",
                    tooltiptext: "firebug.menu.tip.Show_Error_Count",
                    oncommand: "Firebug.browserOverlay.onToggleOption(this)",
                    option: "showErrorCount"
                }),
                $menuseparator(doc),
                $menuitem(doc, {
                    id: "menu_firebug_enablePanels",
                    label: "firebug.menu.Enable_All_Panels",
                    tooltiptext: "firebug.menu.tip.Enable_All_Panels",
                    command: "cmd_firebug_enablePanels"
                }),
                $menuitem(doc, {
                    id: "menu_firebug_disablePanels",
                    label: "firebug.menu.Disable_All_Panels",
                    tooltiptext: "firebug.menu.tip.Disable_All_Panels",
                    command: "cmd_firebug_disablePanels"
                }),
                $menuseparator(doc),
                $menuitem(doc, {
                    id: "menu_firebug_AllOn",
                    type: "checkbox",
                    label: "On_for_all_web_pages",
                    tooltiptext: "firebug.menu.tip.On_for_all_Web_Sites",
                    command: "cmd_firebug_allOn",
                    option: "allPagesActivation"
                }),
                $menuitem(doc, {
                    id: "menu_firebug_clearActivationList",
                    label: "firebug.menu.Clear_Activation_List",
                    tooltiptext: "firebug.menu.tip.Clear_Activation_List",
                    command: "cmd_firebug_clearActivationList"
                })
            ])
        ]);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug Global Menu

    /**
     * There are more instances of Firebug Menu (e.g. one in Firefox -> Tools -> Web Developer
     * and one in Firefox 4 (top-left orange button menu) -> Web Developer
     *
     * If extensions want to override the menu they need to iterate all existing instance
     * using document.querySelectorAll(".fbFirebugMenuPopup") and append new menu items to all
     * of them. Iteration must be done in the global space (browser.xul)
     *
     * The same menu is also used for Firebug Icon Menu (Firebug's toolbar). This menu is cloned
     * and initialized as soon as Firebug UI is actually loaded. Since it's cloned from the original
     * (global scope) extensions don't have to extend it (possible new menu items are already there).
     */
    overlayFirebugMenu: function(doc)
    {
        this.firebugMenuContent =
        [
            // Open/close Firebug
            $menuitem(doc,
            {
                id: "menu_firebug_toggleFirebug",
                label: "firebug.ShowFirebug",
                tooltiptext: "firebug.menu.tip.Open_Firebug",
                command: "cmd_firebug_toggleFirebug",
                key: "key_firebug_toggleFirebug",
                "class": "fbInternational"
            }),
            $menuitem(doc,
            {
                id: "menu_firebug_closeFirebug",
                label: "firebug.Deactivate_Firebug",
                tooltiptext: "firebug.tip.Deactivate_Firebug",
                command: "cmd_firebug_closeFirebug",
                key: "key_firebug_closeFirebug",
                "class": "fbInternational"
            }),

            // Firebug UI position
            $menu(doc,
            {
                label: "firebug.uiLocation",
                tooltiptext: "firebug.menu.tip.UI_Location",
                "class": "fbInternational"
            },
            [
                $menupopup(doc, {
                    onpopupshowing: "Firebug.browserOverlay.onPositionPopupShowing(this)"
                })
            ]),

            $menuseparator(doc),

            // External Editors
            $menu(doc,
            {
                id: "FirebugMenu_OpenWith",
                label: "firebug.OpenWith",
                tooltiptext: "firebug.menu.tip.Open_With",
                "class": "fbInternational",
                insertafter: "menu_firebug_openActionsSeparator",
                openFromContext: "true",
                command: "cmd_firebug_openInEditor"
            },
            [
                $menupopup(doc,{id:"fbFirebugMenu_OpenWith",
                    onpopupshowing: "return Firebug.browserOverlay.onEditorsShowing(this);"})
            ]),

            // Text Size
            $menu(doc,
            {
                id: "FirebugMenu_TextSize",
                label: "firebug.TextSize",
                tooltiptext: "firebug.menu.tip.Text_Size",
                "class": "fbInternational"
            },
            [
                $menupopup(doc,{},
                [
                    $menuitem(doc,
                    {
                        id: "menu_firebug_increaseTextSize",
                        label: "firebug.IncreaseTextSize",
                        tooltiptext: "firebug.menu.tip.Increase_Text_Size",
                        command: "cmd_firebug_increaseTextSize",
                        key: "key_firebug_increaseTextSize",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_decreaseTextSize",
                        label: "firebug.DecreaseTextSize",
                        tooltiptext: "firebug.menu.tip.Decrease_Text_Size",
                        command: "cmd_firebug_decreaseTextSize",
                        key: "key_firebug_decreaseTextSize",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_normalTextSize",
                        label: "firebug.NormalTextSize",
                        tooltiptext: "firebug.menu.tip.Normal_Text_Size",
                        command: "cmd_firebug_normalTextSize",
                        key: "key_firebug_normalTextSize",
                        "class": "fbInternational"
                    }),
                ])
            ]),

            // Options
            $menu(doc,
            {
                id: "FirebugMenu_Options",
                label: "firebug.Options",
                tooltiptext: "firebug.menu.tip.Options",
                "class": "fbInternational"
            },
            [
                $menupopup(doc,
                {
                    id: "FirebugMenu_OptionsPopup",
                    onpopupshowing: "return Firebug.browserOverlay.onOptionsShowing(this);"
                },
                [
                    $menuitem(doc,
                    {
                        id: "menu_firebug_toggleShowErrorCount",
                        type: "checkbox",
                        label: "firebug.Show_Error_Count",
                        tooltiptext: "firebug.menu.tip.Show_Error_Count",
                        oncommand: "Firebug.browserOverlay.onToggleOption(this)",
                        option: "showErrorCount",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_showTooltips",
                        type: "checkbox",
                        label: "firebug.menu.Show_Info_Tips",
                        tooltiptext: "firebug.menu.tip.Show_Info_Tips",
                        oncommand: "Firebug.browserOverlay.onToggleOption(this)",
                        option: "showInfoTips",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_shadeBoxModel",
                        type: "checkbox",
                        label: "ShadeBoxModel",
                        tooltiptext: "inspect.option.tip.Shade_Box_Model",
                        oncommand: "Firebug.browserOverlay.onToggleOption(this)",
                        option: "shadeBoxModel",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_showQuickInfoBox",
                        type: "checkbox",
                        label: "ShowQuickInfoBox",
                        tooltiptext: "inspect.option.tip.Show_Quick_Info_Box",
                        oncommand: "Firebug.browserOverlay.onToggleOption(this)",
                        option: "showQuickInfoBox",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_enableA11y",
                        type: "checkbox",
                        label: "firebug.menu.Enable_Accessibility_Enhancements",
                        tooltiptext: "firebug.menu.tip.Enable_Accessibility_Enhancements",
                        oncommand: "Firebug.browserOverlay.onToggleOption(this)",
                        option: "a11y.enable",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_activateSameOrigin",
                        type: "checkbox",
                        label: "firebug.menu.Activate_Same_Origin_URLs2",
                        tooltiptext: "firebug.menu.tip.Activate_Same_Origin_URLs",
                        oncommand: "Firebug.browserOverlay.onToggleOption(this)",
                        option: "activateSameOrigin",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_toggleOrient",
                        type: "checkbox",
                        label: "firebug.menu.Vertical_Panels",
                        tooltiptext: "firebug.menu.tip.Vertical_Panels",
                        command: "cmd_firebug_toggleOrient",
                        option: "viewPanelOrient",
                        "class": "fbInternational"
                    }),
                    $menuseparator(doc, {id: "menu_firebug_optionsSeparator"}),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_resetAllOptions",
                        label: "firebug.menu.Reset_All_Firebug_Options",
                        tooltiptext: "firebug.menu.tip.Reset_All_Firebug_Options",
                        command: "cmd_firebug_resetAllOptions",
                        "class": "fbInternational"
                    }),
                ])
            ]),

            $menuseparator(doc,{id: "FirebugBetweenOptionsAndSites", collapsed: "true"}),

            // Sites
            $menu(doc,
            {
                id: "FirebugMenu_Sites",
                label: "firebug.menu.Firebug_Online",
                tooltiptext: "firebug.menu.tip.Firebug_Online",
                "class": "fbInternational"
            },
            [
                $menupopup(doc,{},
                [
                    $menuitem(doc,
                    {
                        id: "menu_firebug_firebugUrlWebsite",
                        label: "firebug.Website",
                        tooltiptext: "firebug.menu.tip.Website",
                        oncommand: "Firebug.chrome.visitWebsite('main')",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_firebugUrlExtensions",
                        label: "firebug.menu.Extensions",
                        tooltiptext: "firebug.menu.tip.Extensions",
                        oncommand: "Firebug.chrome.visitWebsite('extensions')",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_firebugHelp",
                        label: "firebug.help",
                        tooltiptext: "firebug.menu.tip.help",
                        command: "cmd_firebug_openHelp",
                        key: "key_firebug_help",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_firebugDoc",
                        label: "firebug.Documentation",
                        tooltiptext: "firebug.menu.tip.Documentation",
                        oncommand: "Firebug.chrome.visitWebsite('docs')",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_firebugKeyboard",
                        label: "firebug.KeyShortcuts",
                        tooltiptext: "firebug.menu.tip.Key_Shortcuts",
                        oncommand: "Firebug.chrome.visitWebsite('keyboard')",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_firebugForums",
                        label: "firebug.Forums",
                        tooltiptext: "firebug.menu.tip.Forums",
                        oncommand: "Firebug.chrome.visitWebsite('discuss')",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_firebugIssues",
                        label: "firebug.Issues",
                        tooltiptext: "firebug.menu.tip.Issues",
                        oncommand: "Firebug.chrome.visitWebsite('issues')",
                        "class": "fbInternational"
                    }),
                    $menuitem(doc,
                    {
                        id: "menu_firebug_firebugDonate",
                        label: "firebug.Donate",
                        tooltiptext: "firebug.menu.tip.Donate",
                        oncommand: "Firebug.chrome.visitWebsite('donate')",
                        "class": "fbInternational"
                    }),
                ])
            ]),

            $menuseparator(doc, {id: "menu_firebug_miscActionsSeparator", collapsed: "true"}),

            $menuseparator(doc, {id: "menu_firebug_toolsSeparator", collapsed: "true"}),

            $menuitem(doc,
            {
                id: "menu_firebug_customizeShortcuts",
                label: "firebug.menu.Customize_shortcuts",
                tooltiptext: "firebug.menu.tip.Customize_Shortcuts",
                command: "cmd_firebug_customizeFBKeys",
                key: "key_firebug_customizeFBKeys",
                "class": "fbInternational"
            }),

            $menuseparator(doc, {id: "menu_firebug_aboutSeparator"}),

            $menuitem(doc, {
                id: "menu_firebug_about",
                label: "firebug.About",
                tooltiptext: "firebug.menu.tip.About",
                oncommand: "Firebug.browserOverlay.openAboutDialog()",
                "class": "firebugAbout fbInternational"
            }),
        ];
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Global Menu Overlays

    overlayFirefoxMenu: function(doc)
    {
        // Firefox page context menu
        $menupopupOverlay(doc, $(doc, "contentAreaContextMenu"), [
            $menuseparator(doc),
            $menuitem(doc,{
                id: "menu_firebug_firebugInspect",
                label: "firebug.InspectElementWithFirebug",
                command: "cmd_firebug_inspect",
                "class": "menuitem-iconic fbInternational"
            })
        ]);

        // Firefox view menu
        $menupopupOverlay(doc, $(doc, "menu_viewPopup"),
            [
                $menuitem(doc, {
                    id: "menu_firebug_viewToggleFirebug",
                    insertbefore: "toggle_taskbar",
                    label: "firebug.Firebug",
                    type: "checkbox",
                    key: "key_firebug_toggleFirebug",
                    command: "cmd_firebug_toggleFirebug",
                    "class": "fbInternational"
                })
            ],
            {
                onpopupshowing: "return Firebug.browserOverlay.onViewMenuShowing();"
            }
        );
        
        // SeaMonkey view menu
        $menupopupOverlay(doc, $(doc, "menu_View_Popup"),
            [
                $menuitem(doc, {
                    id: "menu_firebug_viewToggleFirebug",
                    insertafter: "menuitem_fullScreen",
                    label: "firebug.Firebug",
                    type: "checkbox",
                    key: "key_firebug_toggleFirebug",
                    command: "cmd_firebug_toggleFirebug",
                    "class": "menuitem-iconic fbInternational"
                })
            ],
            {
                onpopupshowing: "return Firebug.browserOverlay.onViewMenuShowing();"
            }
        );

        // Firefox Tools -> Web Developer Menu
        $menupopupOverlay(doc, $(doc, "menuWebDeveloperPopup"), [
            $menu(doc, {
                id: "menu_webDeveloper_firebug",
                position: 1,
                label: "firebug.Firebug",
                "class": "menu-iconic fbInternational"
            }, [
                $menupopup(doc, {
                    id: "menu_firebug_firebugMenuPopup",
                    "class": "fbFirebugMenuPopup",
                    onpopupshowing: "return Firebug.browserOverlay.onMenuShowing(this, event);",
                    onpopuphiding: "return Firebug.browserOverlay.onMenuHiding(this, event);"
                })
            ]),
            $menuseparator(doc, {
                insertafter: "menu_webDeveloper_firebug"
            })
        ]);

        // Firefox Button -> Web Developer Menu
        $menupopupOverlay(doc, $(doc, "appmenu_webDeveloper_popup"), [
            $menu(doc, {
                id: "appmenu_firebug",
                position: 1,
                label: "firebug.Firebug",
                iconic: "true",
                "class": "menu-iconic fbInternational"
            }, [
                $menupopup(doc, {
                    id: "appmenu_firebugMenuPopup",
                    "class": "fbFirebugMenuPopup",
                    onpopupshowing: "return Firebug.browserOverlay.onMenuShowing(this, event);",
                    onpopuphiding: "return Firebug.browserOverlay.onMenuHiding(this, event);"
                })
            ]),
            $menuseparator(doc, {
                insertafter: "appmenu_firebug"
            })
        ]);

        // Sea Monkey Tools Menu
        $menupopupOverlay(doc, $(doc, "toolsPopup"), [
            $menu(doc, {
                id: "menu_firebug",
                insertbefore: "appmenu_webConsole",
                command: "cmd_firebug_toggleFirebug",
                key: "key_firebug_toggleFirebug",
                label: "firebug.Firebug",
                "class": "menuitem-iconic fbInternational"
            }, [
                $menupopup(doc, {
                    id: "toolsmenu_firebugMenuPopup",
                    "class": "fbFirebugMenuPopup",
                    onpopupshowing: "return Firebug.browserOverlay.onMenuShowing(this, event);",
                    onpopuphiding: "return Firebug.browserOverlay.onMenuHiding(this, event);"
                })
            ])
        ]);
    }
};

// ********************************************************************************************* //
// Registration

return BrowserMenu;

// ********************************************************************************************* //
}});
/* See license.txt for terms of usage */

define("firebug/firefox/browserOverlay",
[
    "firebug/lib/trace",
    "firebug/lib/options",
    "firebug/lib/locale",
    "firebug/lib/array",
    "firebug/lib/string",
    "firebug/lib/xpcom",
    "firebug/firefox/browserOverlayLib",
    "firebug/firefox/browserCommands",
    "firebug/firefox/browserMenu",
    "firebug/firefox/browserToolbar",
    "firebug/lib/system",
],
function(FBTrace, Options, Locale, Arr, Str, Xpcom, BrowserOverlayLib, BrowserCommands,
    BrowserMenu, BrowserToolbar, System) {

with (BrowserOverlayLib) {

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;
var Cu = Components.utils;

Locale.registerStringBundle("chrome://firebug/locale/firebug.properties");
Locale.registerStringBundle("chrome://firebug/locale/cookies.properties");
Locale.registerStringBundle("chrome://firebug/locale/selectors.properties");
Locale.registerStringBundle("chrome://firebug/locale/keys.properties");
Locale.registerStringBundle("chrome://global-platform/locale/platformKeys.properties");
Locale.registerStringBundle("chrome://global/locale/keys.properties");

Cu.import("resource://firebug/loader.js");
Cu.import("resource://firebug/fbtrace.js");

const firstRunPage = "https://getfirebug.com/firstrun#Firebug ";

// ********************************************************************************************* //
// BrowserOverlay Implementation

function BrowserOverlay(win)
{
    this.win = win;
    this.doc = win.document;
}

BrowserOverlay.prototype =
{
    // When Firebug is disabled or uninstalled this elements must be removed from
    // chrome UI (XUL).
    nodesToRemove: [],

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function(reason)
    {
        // Expose BrowserOverlayLib object to extensions.
        this.win.Firebug.BrowserOverlayLib = BrowserOverlayLib;

        // This element (a broadcaster) is storing Firebug state information. Other elements
        // (like for example the Firebug start button) can watch it and display the info to
        // the user.
        $el(this.doc, "broadcaster", {id: "firebugStatus", suspended: true},
            $(this.doc, "mainBroadcasterSet"));

        var node = $stylesheet(this.doc, "chrome://firebug/content/firefox/browserOverlay.css");

        if (System.isMac(this.win))
            $stylesheet(this.doc, "chrome://firebug/content/firefox/macBrowserOverlay.css");

        this.nodesToRemove.push(node);

        this.loadContextMenuOverlay();
        this.loadFirstRunPage(reason);

        var version = this.getVersion();

        BrowserCommands.overlay(this.doc);
        BrowserMenu.overlay(this.doc);
        BrowserToolbar.overlay(this.doc, version);

        this.internationalize();
        this.allPagesActivation();
    },

    internationalize: function()
    {
        // Internationalize all elements with 'fbInternational' class. Clone
        // before internationalization.
        var elements = Arr.cloneArray(this.doc.getElementsByClassName("fbInternational"));
        Locale.internationalizeElements(this.doc, elements, ["label", "tooltiptext", "aria-label"]);
    },

    allPagesActivation: function()
    {
        // Load Firebug by default if activation is on for all pages (see issue 5522)
        if (Options.get("allPagesActivation") == "on" || !Options.get("delayLoad"))
        {
            var self = this;
            this.startFirebug(function(Firebug)
            {
                var browser = Firebug.Firefox.getBrowserForWindow(self.win);
                var uri = Firebug.Firefox.getCurrentURI();

                // Open Firebug UI (e.g. if the annotations say so, issue 5623)
                if (uri && Firebug.TabWatcher.shouldCreateContext(browser, uri.spec, null))
                    Firebug.toggleBar(true);

                FBTrace.sysout("Firebug loaded by default since 'allPagesActivation' is on " +
                    "or 'delayLoad' is false");
            });
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Load Rest of Firebug

    /**
     * This method is called by the Framework to load entire Firebug. It's executed when
     * the user requires Firebug for the first time.
     *
     * @param {Object} callback Executed when Firebug is fully loaded
     */
    startFirebug: function(callback)
    {
        if (this.win.Firebug.waitingForFirstLoad)
            return;

        if (this.win.Firebug.isInitialized)
            return callback && callback(this.win.Firebug);

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("overlay; Load Firebug...", (callback ? callback.toString() : ""));

        this.win.Firebug.waitingForFirstLoad = true;

        var container = $(this.doc, "appcontent");

        // List of Firebug scripts that must be loaded into the global scope (browser.xul)
        // FBTrace is no longer loaded into the global space.
        var scriptSources = [
            "chrome://firebug/content/legacy.js",
            "chrome://firebug/content/moduleConfig.js"
        ];

        // Create script elements.
        var self = this;
        scriptSources.forEach(function(url)
        {
            $script(self.doc, url);
        });

        // Create Firebug splitter element.
        $el(this.doc, "splitter", {id: "fbContentSplitter", collapsed: "true"}, container);

        // Create Firebug main frame and container.
        $el(this.doc, "vbox", {id: "fbMainFrame", collapsed: "true", persist: "height,width"}, [
            $el(this.doc, "browser", {
                id: "fbMainContainer",
                flex: "2",
                src: "chrome://firebug/content/firefox/firebugFrame.xul",
                disablehistory: "true"
            })
        ], container);

        // When Firebug is fully loaded and initialized it fires a "FirebugLoaded"
        // event to the browser document (browser.xul scope). Wait for that to happen.
        this.doc.addEventListener("FirebugLoaded", function onLoad()
        {
            self.doc.removeEventListener("FirebugLoaded", onLoad, false);
            self.win.Firebug.waitingForFirstLoad = false;

            // xxxHonza: TODO find a better place for notifying extensions
            FirebugLoader.dispatchToScopes("firebugFrameLoad", [self.win.Firebug]);
            callback && callback(self.win.Firebug);
        }, false);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug Menu Handlers

    onOptionsShowing: function(popup)
    {
        for (var child = popup.firstChild; child; child = child.nextSibling)
        {
            if (child.localName == "menuitem")
            {
                var option = child.getAttribute("option");
                if (option)
                {
                    var checked = Options.get(option);

                    // xxxHonza: I believe that allPagesActivation could be simple boolean option.
                    if (option == "allPagesActivation")
                        checked = (checked == "on") ? true : false;

                    child.setAttribute("checked", checked);
                }
            }
        }
    },

    onToggleOption: function(menuItem)
    {
        var option = menuItem.getAttribute("option");
        var checked = menuItem.getAttribute("checked") == "true";

        Options.set(option, checked);
    },

    onMenuShowing: function(popup, event)
    {
        // If the event comes from a sub menu, just ignore it.
        if (popup != event.target)
            return;

        while (popup.lastChild)
            popup.removeChild(popup.lastChild);

        // Generate dynamic content.
        for (var i=0; i<BrowserMenu.firebugMenuContent.length; i++)
            popup.appendChild(BrowserMenu.firebugMenuContent[i].cloneNode(true));

        var collapsed = "true";
        if (this.win.Firebug.chrome)
        {
            var fbContentBox = this.win.Firebug.chrome.$("fbContentBox");
            collapsed = fbContentBox.getAttribute("collapsed");
        }

        var currPos = Options.get("framePosition");
        var placement = this.win.Firebug.getPlacement ? this.win.Firebug.getPlacement() : "";

        // Switch between "Open Firebug" and "Hide Firebug" label in the popup menu.
        var toggleFirebug = popup.querySelector("#menu_firebug_toggleFirebug");
        if (toggleFirebug)
        {
            var hiddenUI = (collapsed == "true" || placement == "minimized");
            toggleFirebug.setAttribute("label", (hiddenUI ?
                Locale.$STR("firebug.ShowFirebug") : Locale.$STR("firebug.HideFirebug")));

            toggleFirebug.setAttribute("tooltiptext", (hiddenUI ?
                Locale.$STR("firebug.menu.tip.Open_Firebug") :
                Locale.$STR("firebug.menu.tip.Minimize_Firebug")));

            var currentLocation = toggleFirebug.ownerDocument.defaultView.top.location.href;
            var inDetachedWindow = currentLocation.indexOf("firebug.xul") > 0;

            // If Firebug is detached, use "Focus Firebug Window" label
            // instead of "Hide Firebug" when the menu isn't opened from
            // within the detached Firebug window. the 'placement' is used
            // to ensure Firebug isn't closed with close button of detached window
            // and 'inDetachedWindow' variable is also used to ensure the menu is
            // opened from within the detached window.
            if (currPos == "detached" && this.win.Firebug.currentContext &&
                placement != "minimized" && !inDetachedWindow)
            {
                toggleFirebug.setAttribute("label", Locale.$STR("firebug.FocusFirebug"));
                toggleFirebug.setAttribute("tooltiptext",
                    Locale.$STR("firebug.menu.tip.Focus_Firebug"));
            }
        }

        // Hide "Deactivate Firebug" menu if Firebug is not active.
        var closeFirebug = popup.querySelector("#menu_firebug_closeFirebug");
        if (closeFirebug)
        {
            closeFirebug.setAttribute("collapsed",
                (this.win.Firebug.currentContext ? "false" : "true"));
        }

        // Update About Menu
        var version = this.getVersion();
        if (version)
        {
            var node = popup.getElementsByClassName("firebugAbout")[0];
            var aboutLabel = node.getAttribute("label");
            node.setAttribute("label", aboutLabel + " " + version);
            node.classList.remove("firebugAbout");
        }

        // Allow Firebug menu customization (see FBTest and FBTrace as an example).
        var event = new this.win.CustomEvent("firebugMenuShowing", {detail: popup});
        this.doc.dispatchEvent(event);
    },

    onMenuHiding: function(popup, event)
    {
        if (popup != event.target)
            return;

        // xxxHonza: I don't know why the timeout must be here, but if it isn't
        // the icon menu is broken (see issue 5427)
        this.win.setTimeout(function()
        {
            while (popup.lastChild)
                popup.removeChild(popup.lastChild);
        });
    },

    onViewMenuShowing: function()
    {
        var suspendMarker = this.win.document.getElementById("firebugStatus");

        // Check whether Firebug is open
        var open = false;
        if (this.win.Firebug.chrome)
        {
            var fbContentBox = this.win.Firebug.chrome.$("fbContentBox");
            open = fbContentBox.getAttribute("collapsed") == "true" ? false : true;
        }

        var firebugViewMenuItem = this.win.document.
            getElementById("menu_firebug_viewToggleFirebug");
        firebugViewMenuItem.setAttribute("checked", open);
    },

    onPositionPopupShowing: function(popup)
    {
        while (popup.lastChild)
            popup.removeChild(popup.lastChild);

        // Load Firebug before the position is changed.
        var oncommand = "Firebug.browserOverlay.startFirebug(function(){" +
            "Firebug.chrome.setPosition('%pos%')" + "})";

        var items = [];
        var currPos = Options.get("framePosition");

        var positions = ["detached", "top", "bottom", "left", "right"];
        for (var i=0; i<positions.length; i++)
        {
            var pos = positions[i];
            var label = Str.capitalize(pos);

            var item = $menuitem(this.doc, {
                label: Locale.$STR("firebug.menu." + label),
                tooltiptext: Locale.$STR("firebug.menu.tip." + label),
                type: "radio",
                oncommand: oncommand.replace("%pos%", pos),
                checked: (currPos == pos)
            });

            if (pos == "detached")
                items.key = "key_firebug_detachFirebug";

            popup.appendChild(item);
        }

        return true;
    },

    openAboutDialog: function()
    {
        var self = this;

        // Firefox 4.0+
        Cu["import"]("resource://gre/modules/AddonManager.jsm");
        this.win.AddonManager.getAddonByID("firebug@software.joehewitt.com", function(addon)
        {
            self.win.openDialog("chrome://mozapps/content/extensions/about.xul", "",
                "chrome,centerscreen,modal", addon);
        });
    },

    setPosition: function(newPosition)
    {
        // todo
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug Version

    getVersion: function()
    {
        var versionURL = "chrome://firebug/content/branch.properties";
        var ioService = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);

        var channel = ioService.newChannel(versionURL, null, null);
        var input = channel.open();
        var sis = Cc["@mozilla.org/scriptableinputstream;1"].
            createInstance(Ci.nsIScriptableInputStream);
        sis.init(input);

        var content = sis.readBytes(input.available());
        sis.close();

        var m = /RELEASE=(.*)/.exec(content);
        if (m)
            var release = m[1];
        else
            return "no RELEASE in " + versionURL;

        m = /VERSION=(.*)/.exec(content);
        if (m)
            var version = m[1];
        else
            return "no VERSION in " + versionURL;

        return version+""+release;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // External Editors

    onEditorsShowing: function(popup)
    {
        var self = this;
        this.startFirebug(function()
        {
            self.win.Firebug.ExternalEditors.onEditorsShowing(popup);
        });

        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Page Context Menu Overlay

    loadContextMenuOverlay: function()
    {
        var contextMenu = this.win.nsContextMenu;
        if (typeof(contextMenu) == "undefined")
            return;

        // isTargetAFormControl is removed, see:
        // https://bugzilla.mozilla.org/show_bug.cgi?id=433168
        if (typeof(contextMenu.prototype.isTargetAFormControl) != "undefined")
        {
            var setTargetOriginal = this.setTargetOriginal = contextMenu.prototype.setTarget;
            contextMenu.prototype.setTarget = function(aNode, aRangeParent, aRangeOffset)
            {
                setTargetOriginal.apply(this, arguments);

                if (this.isTargetAFormControl(aNode))
                    this.shouldDisplay = true;
            };
        }

        // Hide built-in inspector if the pref says so.
        var initItemsOriginal = this.initItemsOriginal = contextMenu.prototype.initItems;
        contextMenu.prototype.initItems = function()
        {
            initItemsOriginal.apply(this, arguments);

            // Hide built-in inspector menu item if the pref "extensions.firebug.hideDefaultInspector"
            // says so. Note that there is also built-in preference "devtools.inspector.enable" that
            // can be used for the same purpose.
            var hideInspect = Options.get("hideDefaultInspector");
            if (hideInspect)
            {
                this.showItem("inspect-separator", false);
                this.showItem("context-inspect", false);
            }
        };
    },

    unloadContextMenuOverlay: function()
    {
        var contextMenu = this.win.nsContextMenu;
        if (typeof(contextMenu) == "undefined")
            return;

        if (this.setTargetOriginal)
            contextMenu.prototype.setTarget = this.setTargetOriginal;

        if (this.initItemsOriginal)
            contextMenu.prototype.initItems = this.initItemsOriginal;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // First Run Page

    loadFirstRunPage: function(reason)
    {
        if (this.checkFirebugVersion(Options.get("currentVersion")) <= 0)
            return;

        // Do not show the first run page when Firebug is being updated. It'll be displayed
        // the next time the browser is restarted
        // # ADDON_UPGRADE == 7
        if (reason == 7)
            return;

        // Open the page in the top most window, so the user can see it immediately.
        var wm = Cc["@mozilla.org/appshell/window-mediator;1"].getService(Ci.nsIWindowMediator);
        if (wm.getMostRecentWindow("navigator:browser") == this.win.top)
        {
            // Update the preference to make sure the page is not displayed again.
            // To avoid being annoying when Firefox crashes, forcibly save it, too.
            var version = this.getVersion();
            Options.set("currentVersion", version);

            if (Options.get("showFirstRunPage"))
            {
                var self = this;
                var timeout = this.win.setTimeout(function()
                {
                    if (self.win.closed)
                        return;

                    self.openFirstRunPage(self.win);
                }, 1000);

                this.win.addEventListener("unload", function()
                {
                    self.win.clearTimeout(timeout);
                }, false);
            }
        }
    },

    openFirstRunPage: function(win)
    {
        var version = this.getVersion();
        var url = firstRunPage + version;

        var browser = win.gBrowser;
        if (!browser)
        {
            FBTrace.sysout("browserOverlay.openFirstRunPage; ERROR there is no gBrowser!");
            return;
        }

        // Open the firstRunPage in background
        /*gBrowser.selectedTab = */browser.addTab(url, null, null, null);

        // Make sure prefs are stored, otherwise the firstRunPage would be displayed
        // again if Firefox crashes.
        this.win.setTimeout(function()
        {
            Options.forceSave();
        }, 400);
    },

    // xxxsz: Can't System.checkFirebugVersion() be used for that?
    checkFirebugVersion: function(currentVersion)
    {
        if (!currentVersion)
            return 1;

        var version = this.getVersion();

        // Use Firefox comparator service
        var versionChecker = Xpcom.CCSV("@mozilla.org/xpcom/version-comparator;1",
            "nsIVersionComparator");

        return versionChecker.compare(version, currentVersion);
    }
};

// ********************************************************************************************* //
// Registration

return BrowserOverlay;

// ********************************************************************************************* //
}});
/* See license.txt for terms of usage */

define("firebug/firefox/browserOverlayLib",
[
    "firebug/lib/trace",
    "firebug/lib/locale",
],
function(FBTrace, Locale) {

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

// ********************************************************************************************* //
// Overlay Helpers

var BrowserOverlayLib =
{
    $: function(doc, id)
    {
        return doc.getElementById(id);
    },

    $$: function(doc, selector)
    {
        return doc.querySelectorAll(selector);
    },

    $el: function(doc, name, attributes, children, parent)
    {
        if (!(doc instanceof Ci.nsIDOMDocument))
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("browserOvelayLib.$el; No document!");
            return;
        }

        attributes = attributes || {};

        if (!Array.isArray(children) && !parent)
        {
            parent = children;
            children = null;
        }

        // localize
        if (attributes.label)
            attributes.label = Locale.$STR(attributes.label);

        if (attributes.tooltiptext)
            attributes.tooltiptext = Locale.$STR(attributes.tooltiptext);

        // persist
        if (attributes.persist)
            updatePersistedValues(doc, attributes);

        var el = doc.createElement(name);
        for (var a in attributes)
            el.setAttribute(a, attributes[a]);

        for (var i=0; children && i<children.length; i++)
            el.appendChild(children[i]);

        if (parent)
        {
            if (attributes.position)
                parent.insertBefore(el, parent.children[attributes.position - 1]);
            else
                parent.appendChild(el);

            // Mark to remove when Firebug is uninstalled.
            el.setAttribute("firebugRootNode", true);
        }

        return el;
    },

    $command: function(doc, id, oncommand, arg)
    {
        // Wrap the command within a startFirebug call. If Firebug isn't yet loaded
        // this will force it to load.
        oncommand = "Firebug.browserOverlay.startFirebug(function(){" + oncommand + "})";
        if (arg)
            oncommand = "void function(arg){" + oncommand + "}(" + arg + ")";

        return this.$el(doc, "command", {
            id: id,
            oncommand: oncommand
        }, this.$(doc, "mainCommandSet"));
    },

    $key: function(doc, id, key, modifiers, command, position)
    {
        var attributes = {
            id: id,
            modifiers: modifiers,
            command: command,
            position: position
        };

        attributes[KeyEvent["DOM_" + key] ? "keycode" : "key"] = key;

        return this.$el(doc, "key", attributes, $(doc, "mainKeyset"));
    },

    $menupopup: function(doc, attributes, children, parent)
    {
        return this.$el(doc, "menupopup", attributes, children, parent);
    },

    $menu: function(doc, attrs, children)
    {
        return this.$el(doc, "menu", attrs, children);
    },

    $menuseparator: function(doc, attrs)
    {
        return this.$el(doc, "menuseparator", attrs);
    },

    $menuitem: function(doc, attrs)
    {
        return this.$el(doc, "menuitem", attrs);
    },

    $menupopupOverlay: function(doc, parent, children, attributes)
    {
        if (!parent)
            return;

        attributes = attributes || {};
        for (var a in attributes)
            parent.setAttribute(a, attributes[a]);

        for (var i=0; i<children.length; ++i)
        {
            var child = children[i];
            var beforeEl = null;

            if (child.getAttribute("position"))
            {
                var pos = child.getAttribute("position");
                beforeEl = parent.children[pos - 1];
            }
            else if (child.getAttribute("insertbefore"))
            {
                var ids = child.getAttribute("insertbefore").split(",");
                for (var j=0; j < ids.length; ++j)
                {
                    beforeEl = parent.querySelector("#" + ids[j]);
                    if (beforeEl)
                        break;
                }
            }
            else if (child.getAttribute("insertafter"))
            {
                var ids = child.getAttribute("insertafter").split(",");
                for (var j=0; j < ids.length; ++j)
                {
                    beforeEl = parent.querySelector("#" + ids[j]);
                    if (beforeEl)
                        break;
                }
                if (beforeEl)
                    beforeEl = beforeEl.nextSibling;
            }

            if (beforeEl)
                parent.insertBefore(child, beforeEl);
            else
                parent.appendChild(child);

            // Mark the inserted node to remove it when Firebug is uninstalled.
            child.setAttribute("firebugRootNode", true);
        }
    },

    $toolbarButton: function(doc, id, attrs, children, defaultPos)
    {
        attrs["class"] = "toolbarbutton-1";
        attrs.firebugRootNode = true;
        attrs.id = id;

        // in seamonkey gNavToolbox is null onload
        this.$el(doc, "toolbarbutton", attrs, children,
            (doc.defaultView.gNavToolbox || this.$(doc, "navigator-toolbox")).palette);

        var selector = "[currentset^='" + id + ",'],[currentset*='," + id +
            ",'],[currentset$='," + id + "']";

        var toolbar = doc.querySelector(selector);
        if (!toolbar)
            return; // todo defaultPos

        var currentset = toolbar.getAttribute("currentset").split(",");
        var i = currentset.indexOf(id) + 1;

        var len = currentset.length;
        var beforeEl = null;
        while (i < len && !(beforeEl = this.$(doc, currentset[i])))
            i++;

        return toolbar.insertItem(id, beforeEl);
    },

    $tooltip: function(doc, attrs, children)
    {
        return this.$el(doc, "tooltip", attrs, children);
    },

    $label: function(doc, attrs)
    {
        return this.$el(doc, "label", attrs);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Stylesheets & Scripts

    $stylesheet: function(doc, href)
    {
        var s = doc.createProcessingInstruction("xml-stylesheet", 'href="' + href + '"');
        doc.insertBefore(s, doc.documentElement);
        return s;
    },

    $script: function(doc, src)
    {
        var script = doc.createElementNS("http://www.w3.org/1999/xhtml", "html:script");
        script.src = src;
        script.type = "text/javascript";
        script.setAttribute("firebugRootNode", true);
        doc.documentElement.appendChild(script);
    }
};

// ********************************************************************************************* //
// Helpers

function updatePersistedValues(doc, options)
{
    var persist = options.persist.split(",");
    var id = options.id;
    var RDF = Cc["@mozilla.org/rdf/rdf-service;1"].getService(Ci.nsIRDFService);
    var store = doc.defaultView.PlacesUIUtils.localStore; //this.RDF.GetDataSource("rdf:local-store");
    var root = RDF.GetResource("chrome://browser/content/browser.xul#" + id);

    var getPersist = function getPersist(aProperty)
    {
        var property = RDF.GetResource(aProperty);
        var target = store.GetTarget(root, property, true);

        if (target instanceof Ci.nsIRDFLiteral)
            return target.Value;
    };

    for (var i=0; i<persist.length; i++)
    {
        var attr = persist[i];
        var val = getPersist(attr);
        if (val)
            options[attr] = val;
    }
}

// ********************************************************************************************* //
// Registration

return BrowserOverlayLib;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/firefox/browserToolbar",
[
    "firebug/lib/trace",
    "firebug/lib/options",
    "firebug/lib/locale",
    "firebug/firefox/browserOverlayLib",
],
function(FBTrace, Options, Locale, BrowserOverlayLib) {
with (BrowserOverlayLib) {

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// Firefox Toolbar Buttons

var BrowserToolbar =
{
    overlay: function(doc, version)
    {
        this.overlayToolbarButtons(doc, version);
        this.customizeToolbar(doc);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug Start Button Popup Menu

    overlayToolbarButtons: function(doc, version)
    {
        $toolbarButton(doc, "firebug-inspectorButton", {
            label: "firebug.Inspect",
            tooltiptext: "firebug.InspectElement",
            observes: "cmd_firebug_toggleInspecting",
            // Needed for the 'Customize Toolbar' dialog
            style: "list-style-image: url(chrome://firebug/skin/inspect.png); " +
                "-moz-image-region: rect(0, 16px, 16px, 0);"
        });

        // Start Button Tooltip. As soon as Firebug is fully loaded, the tooltip content will be
        // generated by firebug/firefox/start-button/startButtonOverlay module.
        $menupopupOverlay(doc, $(doc, "mainPopupSet"), [
            $tooltip(doc, {
                "class": "firebugButtonTooltip",
                id: "firebug-buttonTooltip",
                orient: "vertical",
            }, [
                $label(doc, {
                    "class": "version",
                    "value": "Firebug " + version
                }),
                $label(doc, {
                    "class": "status",
                    "value": Locale.$STR("startbutton.tip.deactivated")
                })
            ])
        ]);

        // TODO: why contextmenu doesn't work without cloning
        $toolbarButton(doc, "firebug-button", {
            label: "firebug.Firebug",
            tooltip: "firebug-buttonTooltip",
            type: "menu-button",
            command: "cmd_firebug_toggleFirebug",
            contextmenu: "fbStatusContextMenu",
            observes: "firebugStatus",
            // Needed for the 'Customize Toolbar' dialog
            style: "list-style-image: url(chrome://firebug/skin/firebug16.png); " +
                "-moz-image-region: rect(0, 16px, 16px, 0);"
        }, [$(doc, "fbStatusContextMenu").cloneNode(true)]);
    },

    customizeToolbar: function(doc)
    {
        // Appends Firebug start button into Firefox toolbar automatically after installation.
        // The button is appended only once - if the user removes it, it isn't appended again.
        // TODO: merge into $toolbarButton?
        // toolbarpalette check is for seamonkey, where it is in the document
        if ((!$(doc, "firebug-button") ||
            $(doc, "firebug-button").parentNode.tagName == "toolbarpalette")
            && !Options.get("toolbarCustomizationDone"))
        {
            Options.set("toolbarCustomizationDone", true);

            // Get the current navigation bar button set (a string of button IDs) and append
            // ID of the Firebug start button into it.
            var startButtonId = "firebug-button";
            var navBarId = "nav-bar";
            var navBar = $(doc, navBarId);
            var currentSet = navBar.currentSet;

            if (FBTrace.DBG_INITIALIZE)
                FBTrace.sysout("Startbutton; curSet (before modification): " + currentSet);

            // Append only if the button is not already there.
            var curSet = currentSet.split(",");
            if (curSet.indexOf(startButtonId) == -1)
            {
                navBar.insertItem(startButtonId);
                navBar.setAttribute("currentset", navBar.currentSet);
                navBar.ownerDocument.persist("nav-bar", "currentset");

                // Check whether insertItem really works
                var curSet = navBar.currentSet.split(",");
                if (curSet.indexOf(startButtonId) == -1)
                    FBTrace.sysout("Startbutton; navBar.insertItem doesn't work", curSet);

                if (FBTrace.DBG_INITIALIZE)
                {
                    FBTrace.sysout("Startbutton; curSet (after modification): " +
                        navBar.currentSet);
                }

                try
                {
                    // The current global scope is browser.xul.
                    BrowserToolboxCustomizeDone(true);
                }
                catch (e)
                {
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("startButton; appendToToolbar EXCEPTION " + e, e);
                }
            }

            // Don't forget to show the navigation bar - just in case it's hidden.
            navBar.removeAttribute("collapsed");
            doc.persist(navBarId, "collapsed");
        }
    }
};

// ********************************************************************************************* //
// Registration

return BrowserToolbar;

// ********************************************************************************************* //
}});
/* See license.txt for terms of usage */
/* Reused code from Keyconfig by Dorando: http://mozilla.dorando.at/keyconfig.xpi*/

define("firebug/firefox/customizeShortcuts",
[
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/string",
    "firebug/lib/events",
    "firebug/lib/system"
],
function(FBTrace, Obj, Locale, Str, Events, System) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cu = Components.utils;

Cu.import("resource://gre/modules/Services.jsm");

var branch = Services.prefs.getBranch("extensions.firebug.key.shortcut.");
var defaultBranch = Services.prefs.getDefaultBranch("extensions.firebug.key.shortcut.");

// Global variables used by this dialog.
var shortcutNames = null;
var gVKNames = [];
var gPlatformKeys = new Object();
var updatedShortcuts = {};
var modified = false;

var mustBeKeyChars = {
    VK_SEMICOLON      : ";",
    VK_EQUALS         : "=",
    VK_MULTIPLY       : "*",
    VK_ADD            : "+",
    VK_SUBTRACT       : "-",
    VK_DECIMAL        : ".",
    VK_DIVIDE         : "/",
    VK_COMMA          : ",",
    VK_PERIOD         : ".",
    VK_SLASH          : "/",
    VK_BACK_QUOTE     : "`",
    VK_OPEN_BRACKET   : "[",
    VK_BACK_SLASH     : "\\",
    VK_CLOSE_BRACKET  : "]",
    VK_QUOTE          : "'"
};

// ********************************************************************************************* //
// CustomizeShortcuts Dialog Implementation

function CustomizeShortcuts()
{
}

CustomizeShortcuts.prototype =
{
    initialize: function(win)
    {
        if (FBTrace.DBG_SHORTCUTS)
            FBTrace.sysout("shortcuts.init; Customize Shortcuts dialog initialized.", win);

        this.win = win;

        this.setKeyInfo();

        shortcutNames = branch.getChildList("", {});
        shortcutNames.sort();
        shortcutNames.forEach(this.addShortcutRow.bind(this));

        this.setHandlers();

        this.win.document.title = Locale.$STR("customizeShortcuts");
    },

    setKeyInfo: function()
    {
        for (var property in KeyEvent)
            gVKNames[KeyEvent[property]] = property.replace("DOM_", "");

        gVKNames[8] = "VK_BACK";
    },

    setHandlers: function()
    {
        var shortcutSinks = this.win.document.getElementsByClassName("shortcutSink");
        for (var i=0; i<shortcutSinks.length; i++)
            shortcutSinks[i].addEventListener("keydown", this.recognizeShortcut.bind(this), false);

        var resetBtns = this.win.document.getElementsByClassName("shortcutResetBtn");
        for (var i=0; i<resetBtns.length; i++)
            resetBtns[i].addEventListener("command", this.handleResetBtn.bind(this), false);
    },

    saveChanges: function()
    {
        if (!modified)
            return true;

        shortcutNames.forEach(this.saveShortcut.bind(this));

        var e = Services.wm.getEnumerator("navigator:browser");
        while (e.hasMoreElements())
        {
            var fbug = e.getNext().Firebug;
            fbug && fbug.ShortcutsModel.initShortcuts();
        }
        return true;
    },

    saveShortcut: function(shortcutId, index, array)
    {
        if (shortcutId in updatedShortcuts)
            branch.setCharPref(shortcutId, updatedShortcuts[shortcutId]);
    },

    handleResetBtn: function(event)
    {
        var element = event.target.id.replace("_reset", "");
        if (branch.prefHasUserValue(element))
        {
            branch.clearUserPref(element);
            modified = true;
        }

        event.target.hidden = true;
        var textbox = this.win.document.getElementById(element + "_shortcut");
        if (textbox)
            textbox.value = this.getHumanShortcut(element);
    },

    getHumanShortcut: function(element, getDefault)
    {
        var shortcut = (getDefault ? defaultBranch : branch).getCharPref(element);
        var tokens = shortcut.split(" ");
        var keyCode = tokens.pop();

        if (keyCode.length == 1)
            return Locale.getFormattedKey(this.win, tokens.join(","), keyCode, null);
        else
            return Locale.getFormattedKey(this.win, tokens.join(","), null, keyCode);
    },

    addShortcutRow: function(element, index, array)
    {
        // Get key configuration from preference
        var shortcut = this.getHumanShortcut(element);
        var defaultShortcut = this.getHumanShortcut(element, true);
        var rows = this.win.document.getElementById("shortcutGridRows");
        var row = this.win.document.createElement("row");

        var label = this.win.document.createElement("label");

        // Get the label from firebug.properties
        var labelText = Locale.$STR("firebug.shortcut."+element+".label");
        var tooltipText = Locale.$STR("firebug.shortcut.tip."+element);

        // $STR defaults to property name (label) if it's not defined. We don't want that
        if (labelText == "label")
            labelText = element;

        label.setAttribute("value", labelText);
        row.appendChild(label);

        var textbox = this.win.document.createElement("textbox");
        textbox.id = element + "_shortcut";
        textbox.className = "shortcutSink";
        row.setAttribute("tooltiptext", tooltipText != "tip" ? tooltipText : "");
        textbox.setAttribute("value", shortcut);
        textbox.setAttribute("default_value", defaultShortcut);
        row.appendChild(textbox);

        var resetBtn = this.win.document.createElement("toolbarbutton");
        resetBtn.id = element + "_reset";
        resetBtn.setAttribute("label", Locale.$STR("a11y.labels.reset"));
        resetBtn.setAttribute("aria-label", Locale.$STRF("a11y.labels.reset_shortcut", [labelText]));
        resetBtn.className = "shortcutResetBtn";
        resetBtn.hidden = defaultShortcut == shortcut;
        row.appendChild(resetBtn);
        rows.appendChild(row);
    },

    recognizeShortcut: function(event)
    {
        // We're using keydown, so we always start with keycode
        var shortcut = "";
        if ([KeyEvent.DOM_VK_TAB, KeyEvent.DOM_VK_SHIFT, KeyEvent.DOM_VK_CONTROL, KeyEvent.DOM_VK_ALT].
                indexOf(event.keyCode) != -1 ||
            ((!event.shiftKey && !event.altKey && !event.ctrlKey) &&
            [KeyEvent.DOM_VK_RETURN, KeyEvent.DOM_VK_ESCAPE].indexOf(event.keyCode) != -1))
        {
            // Always let tab pass. Let enter & escape pass, if no modifiers are used
            return;
        }

        modified = true;

        Events.cancelEvent(event);

        var target = event.target;

        // Backspace pressed
        if (event.keyCode == 8 && !event.shiftKey && !event.altKey && !event.ctrlKey)
        {
            updatedShortcuts[target.id.replace("_shortcut", "")] = "";
            target.value = "";

            // Update reset button visibility
            target.nextSibling.hidden = false;

            return false;
        }

        var modifiers = [];
        if (event.altKey)
            modifiers.push("alt");
        if (event.ctrlKey)
            modifiers.push("control");
        if (event.metaKey)
            modifiers.push("meta");
        if (event.shiftKey)
            modifiers.push("shift");

        modifiers = modifiers.join(" ");
        var keyConstant = key = null;

        keyConstant = gVKNames[event.keyCode];

        if (!keyConstant) //should not happen
            return;

        // Check if the keycode is actually a printable character
        // 1. Convert some of the punctuation keyConstants (e.g. VK_COMMA) back to actual characters
        if (mustBeKeyChars[keyConstant])
        {
            key = mustBeKeyChars[keyConstant];
        }
        else
        {
            // 2. Detect basic alphanumeric keys
            var keyNameGuess = keyConstant.replace("VK_", "");
            if (keyNameGuess.length == 1)
                key = keyNameGuess.toLowerCase();
        }

        if (modifiers.length > 0)
            shortcut += modifiers+" ";
        shortcut += (key ? key : keyConstant);

        updatedShortcuts[target.id.replace("_shortcut", "")] = shortcut;

        // Show formatted shortcut in textbox
        modifiers = modifiers.replace(" ", ",");
        var formatted = Locale.getFormattedKey(this.win, modifiers, key, keyConstant);

        target.value = formatted;

        // Update reset button visibility
        target.nextSibling.hidden = formatted == target.getAttribute("default_value");
        return false;
    }
}

// ********************************************************************************************* //
// Registration

return CustomizeShortcuts;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/firefox/external-editors/changeeditor",
[
    "firebug/firebug",
    "firebug/lib/locale",
    "firebug/lib/trace",
    "firebug/lib/system",
    "firebug/lib/dom",
],
function(Firebug, Locale, FBTrace, System, Dom) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const nsIFilePicker = Ci.nsIFilePicker;

var internalFilefieldTextbox;
var browseButton;

// browsing for a new file modifies image and label only if they are autogenereted from filename
var origLabel = "";
var origImage = null;

// would be good to have auto-suggest for popular editors
var defaultCommandLines =
{
    "emacs/vim/gedit/nano/geany":     "+%line %file",
    "sublimetext":                    "%file:%line:%col",
    "notepad++":                      "-n%line %file",
    "emeditor":                       "/l %line %file",
    "IntelliJ IDEA":                  "%{--line %line%} %file",
    "browser":                        "%url",
    "explorer":                       "/select,%file",
    "wget/curl":                      "%url",
    "firefox":                        "http://validator.w3.org/check?uri=%url"
};

// ********************************************************************************************* //
// ChangeEditor Implementation

function ChangeEditor(item)
{
    this.item = item;
}

ChangeEditor.prototype =
{
    onLoad: function(win)
    {
        this.win = win;

        browseButton = this.win.document.getElementById("browse-button");

        this.win.document.getElementById("name").value = this.item.label;
        if (this.item.executable)
        {
            origImage = System.getIconURLForFile(this.item.executable);
            try
            {
                var file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsIFile);
                file.initWithPath(this.item.executable);
                this.win.document.getElementById("executable").file = file;
                origLabel = file.leafName.replace(".exe","");
            }
            catch(exc)
            {
            }
        }

        if (this.item.cmdline)
            this.win.document.getElementById("cmdline").value = this.item.cmdline;

        this.onChange();

        // Localization
        this.internationalizeUI(this.win.document);

        this.win.sizeToContent();

        if (this.win.document.getAnonymousElementByAttribute &&
           !this.win.document.getElementById("executable").file)
        {
            var self = this;
            setTimeout(function()
            {
                internalFilefieldTextbox = self.win.document.getAnonymousElementByAttribute(
                    self.win.document.getElementById("executable"), "class", "fileFieldLabel");

                if (internalFilefieldTextbox)
                {
                    internalFilefieldTextbox.readOnly = false;
                    internalFilefieldTextbox.addEventListener("input", function(e)
                    {
                        browseButton.disabled = (this.value != "");
                        self.onChange();
                    }, false);
                }
            }, 100);
        }
    },

    internationalizeUI: function(doc)
    {
        var elements = doc.getElementsByClassName("fbInternational");
        var attributes = ["title", "label", "value"];
        for (var i=0; i<elements.length; i++)
        {
            if (elements[i].nodeName == "description")
            {
                var localized = Locale.$STR(elements[i].textContent);
                var parser = Cc["@mozilla.org/xmlextras/domparser;1"].createInstance(Ci.nsIDOMParser);
                var doc = parser.parseFromString("<vbox>" + localized + "</vbox>", "text/xml");
                var root = doc.documentElement;
    
                while (elements[i].firstChild)
                    elements[i].removeChild(elements[i].firstChild);
    
                for (var j=0; j<root.childNodes.length; j++)
                {
                    // ToDo: Show labels correctly
                    // Namespaces are not inherited from doc, so labels 
                    // are not shown as links
                    node = doc.importNode(root.childNodes[j], true);
                    elements[i].appendChild(node);
                }
            }
            else
            {
                for (var j=0; j<attributes.length; j++)
                {
                    if (elements[i].hasAttribute(attributes[j]))
                        Locale.internationalize(elements[i], attributes[j]);
                }
            }
        }
    },

    onAccept: function()
    {
        this.item.label = this.win.document.getElementById("name").value;
    
        if (!browseButton.disabled)
        {
            var file = this.win.document.getElementById("executable").file;
            this.item.executable = "";
            if (file)
                this.item.executable = file.path;
        }
        else
        {
            this.item.executable = internalFilefieldTextbox.value.replace(/^\s+|\s+$/g, '');
        }

        this.item.cmdline = this.win.document.getElementById("cmdline").value;
        if (this.item.image == origImage)
            this.item.image = System.getIconURLForFile(this.item.executable);

        try
        {
            var file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsIFile);
            file.initWithPath(this.item.executable);
            if (!file.isExecutable())
               throw "NotAnExecutable";

            this.win.arguments[1].saveChanges = true;
            return true;
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("changeEditor.onAccept; EXCEPTION " + exc, exc);

            var promptService = Cc["@mozilla.org/embedcomp/prompt-service;1"].createInstance(
                Ci.nsIPromptService);

            if (exc == "NotAnExecutable")
            {
                promptService.alert(null, Locale.$STR("changeEditor.Invalid_Application_Path"),
                    Locale.$STR("changeEditor.Path_is_not_an_executable"));
            }
            else
            {
                promptService.alert(null, Locale.$STR("changeEditor.Invalid_Application_Path"),
                    Locale.$STR("changeEditor.Application_does_not_exist"));
            }

            return false;
        }
    },

    onChange: function()
    {
        this.win.document.documentElement.getButton("accept").disabled = !(
            this.win.document.getElementById("name").value && (
                (browseButton.disabled && internalFilefieldTextbox &&
                    internalFilefieldTextbox.value &&
                    internalFilefieldTextbox.value.replace(/^\s+|\s+$/g, '')) ||
                (!browseButton.disabled && this.win.document.getElementById("executable").file)
            )
        );
    },

    onBrowse: function()
    {
        var picker = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
        picker.init(this.win, "", nsIFilePicker.modeOpen);
        picker.appendFilters(nsIFilePicker.filterApps);

        if (picker.show() == nsIFilePicker.returnOK && picker.file)
        {
            var nameField = this.win.document.getElementById("name");
            var execField = this.win.document.getElementById("executable");
            execField.file = picker.file;

            if (internalFilefieldTextbox)
                internalFilefieldTextbox.readOnly = true;

            if (nameField.value == origLabel || nameField.value == "")
                origLabel = nameField.value = execField.file.leafName.replace(".exe","");

            this.onChange();
            return true;
        }

        return false;
    },

    insertText: function(text, whole)
    {
        var textbox = this.win.document.getElementById("cmdline");
        if (whole)
            textbox.select();

        textbox.editor.QueryInterface(Ci.nsIPlaintextEditor).insertText(text);
        textbox.focus();
    },

    testEditor: function()
    {
        var tmpItem = {};
        var file = this.win.document.getElementById("executable").file;
        if (file)
            tmpItem.executable = file.path;

        tmpItem.cmdline = this.win.document.getElementById("cmdline").value;

        Firebug.ExternalEditors.open(Firebug.Firefox.getCurrentBrowser().currentURI.spec, 5, tmpItem);
    },

    suggestionPopupShowing: function(popup)
    {
        Dom.eraseNode(popup);

        for (var i in defaultCommandLines)
        {
            var box = this.win.document.createElement("hbox");
            var label = this.win.document.createElement("label");
            label.setAttribute("value", i + ': ');
            box.appendChild(label);

            var spacer = this.win.document.createElement("spacer");
            spacer.setAttribute("flex", 1);
            box.appendChild(spacer);

            label = this.win.document.createElement("label");
            label.setAttribute("value", defaultCommandLines[i]);
            label.className = "text-link";
            box.appendChild(label);

            popup.appendChild(box);
        }
    }
}

// ********************************************************************************************* //
// Registration

return ChangeEditor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/firefox/external-editors/editors",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/lib/locale",
    "firebug/lib/array",
    "firebug/lib/system",
    "firebug/firefox/external-editors/changeeditor",
],
function(Firebug, FBTrace, Locale, Arr, System, ChangeEditor) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cu = Components.utils;

const prefs = Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
const names = ["label", "executable", "cmdline", "image"];

// ********************************************************************************************* //
// Globals

function EditorManager(prefName)
{
    this._prefName = prefName;

    this._tree = null;
    this._data = [];
    this._removeButton = null;
    this._changeButton = null;
    this._moveUpButton = null;
}

EditorManager.prototype =
{
    init: function(win)
    {
        this.win = win;

        (this._removeButton = this.win.document.getElementById("removeEditor")).disabled = true;
        (this._changeButton = this.win.document.getElementById("changeEditor")).disabled = true;
        (this._moveUpButton = this.win.document.getElementById("moveUpEditor")).disabled = true;

        this._tree = this.win.document.getElementById("editorsList");

        this._treeView =
        {
            data: this._data,
            selection: null,

            get rowCount() { return this.data.length; },
            getCellText: function(row, column)
            {
                switch (column.id)
                {
                case "editorName":
                    return " "+this.data[row].label;
                case "editorExecutable":
                    return this.data[row].executable;
                case "editorParams":
                    return this.data[row].cmdline;
                }
                return "";
            },
            setTree: function(treebox){ this.treebox = treebox; },
            isContainer: function(row) { return false; },
            isContainerOpen: function(row) { return false; },
            isContainerEmpty: function(row) { return false; },
            isSeparator: function(row) { return false; },
            isSorted: function() { return false; },
            getLevel: function(row) { return 0; },
            getImageSrc: function(row,column) {
                return column.id=="editorName" ? this.data[row].image : null; },
            getRowProperties: function(row,props) {},
            getCellProperties: function(row,column,props) {},
            getColumnProperties: function(colid,column,props) {}
        };

        this._load();
        this._tree.view = this._treeView;

        this.internationalizeUI(this.win.document);
    },

    uninit: function()
    {
    },

    internationalizeUI: function(doc)
    {
        var elements = doc.getElementsByClassName("fbInternational");
        var attributes = ["title", "label", "value"];

        for (var i=0; i<elements.length; i++)
        {
            for (var j=0; j<attributes.length; j++)
            {
                if (elements[i].hasAttribute(attributes[j]))
                    Locale.internationalize(elements[i], attributes[j]);
            }
        }
    },

    onSelectionChanged: function()
    {
        var selection = this._tree.view.selection, disabled = (selection.count != 1);
        this._removeButton.disabled = disabled;
        this._changeButton.disabled = disabled;
        this._moveUpButton.disabled = disabled || (selection.currentIndex == 0);
    },

    addEditorHandler: function()
    {
        var item = { label: "", executable: null, cmdline: "" };
        var result = {};

        this.win.openDialog("chrome://firebug/content/firefox/external-editors/changeeditor.xul",
            "_blank", "modal,centerscreen,resizable", new ChangeEditor(item), result);

        if (result.saveChanges)
        {
            item.id = item.label.replace(/\W/g, "_");
            this._saveItem(item);

            this._loadItem(item);
            this._data.push(item);
            this._tree.view = this._treeView;

            var editors = [];
            try
            {
                editors = prefs.getCharPref(this._prefName).split(",");
                for (var i=0; i<editors.length; ++i)
                {
                    if (editors[i].replace(/^\s+|\s+$/,"") == "")
                        editors.splice(i, 1);
                }
            }
            catch (exc)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("EXCEPTION " + exc, exc);
            }

            editors.push(item.id);
            prefs.setCharPref(this._prefName, editors.join(","));
        }
    },

    removeEditorHandler: function()
    {
        var selection = this._tree.view.selection;
        if (selection.count < 1)
            return;

        var item = this._data[selection.currentIndex];
        this._data.splice(selection.currentIndex, 1);
        this._tree.view = this._treeView;

        try
        {
            var editors = prefs.getCharPref(this._prefName).split(",");
            Arr.remove(editors, item.id);

            prefs.setCharPref(this._prefName, editors.join(","));
            prefs.deleteBranch(this._prefName+"."+item.id);
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("EXCEPTION " + exc, exc);
        }

        // update disabled state of buttons
        if (this._data.length == 0)
            selection.clearSelection();
    },

    changeEditorHandler: function()
    {
        var selection = this._tree.view.selection;
        if (selection.count != 1)
            return;

        var item = this._data[selection.currentIndex];
        var result = {};

        this.win.openDialog("chrome://firebug/content/firefox/external-editors/changeeditor.xul",
            "_blank", "modal,centerscreen", new ChangeEditor(item), result);

        if (result.saveChanges)
            this._saveItem(item);

        this._loadItem(item);
        this._tree.view = this._treeView;
    },

    moveUpEditorHandler: function()
    {
        var selection = this._tree.view.selection;
        if (selection.count < 1)
            return;

        var item = this._data[selection.currentIndex];
        this._data.splice(selection.currentIndex, 1);
        this._data.unshift(item);
        this._tree.view = this._treeView;

        try
        {
            var editors = this._data.map(function(x) x.id);
            prefs.setCharPref(this._prefName, editors.join(","));
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("EXCEPTION " + exc, exc);
        }
    },


    _loadItem: function(item)
    {
        const prefName = this._prefName;

        for (var i=0; i<names.length; ++i)
        {
            try
            {
                item[names[i]] = prefs.getCharPref(prefName+"."+item.id+"."+names[i]);
            }
            catch(exc)
            {
            }
        }

        if (!item.image)
            item.image = System.getIconURLForFile(item.executable);
    },

    _saveItem: function(item)
    {
        if (item.image && item.image == System.getIconURLForFile(item.executable))
            item.image = null;

        const prefName = this._prefName;
        for (var i=0; i<names.length; ++i)
        {
            try
            {
                var value = item[names[i]];
                if (value)
                    prefs.setCharPref(prefName + "." + item.id + "." + names[i], value);
                else
                    prefs.clearUserPref(prefName + "." + item.id + "." + names[i]);
            }
            catch (exc)
            {
            }
        }
    },

    _load: function()
    {
        try
        {
            var list = prefs.getCharPref(this._prefName).split(",");
            for (var i=0; i<list.length; ++i)
            {
                var editorId = list[i].replace(/\s/g, "_");
                if (!editorId)
                    continue;

                var item = { id: editorId };
                this._data.push(item);
                this._loadItem(item);
            }
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("EXCEPTION " + exc, exc);
        }
    }
};

// ********************************************************************************************* //
// URLMappings

Cu.import("resource://firebug/loader.js");

var headerName = "X-Local-File-Path";
var headerExplaination = "\
// the following regexp is used by firebug to determine\n\
// if it should send request to the server to get\n\
// file path with " + headerName + " header\n\
// defalt value is ^https?:\\/\\/(localhost)(\\/|:|$)";

var listExplaination = "\
// list of mappings in the form\n\
// ^https?:\\/\\/my.domain.com/ => c:\\php/www\\ \n\
// ";
var noMapping = "no mappings for tested url";
var willQueryServer = "for this url Firebug will send query to server";

var splitter = " => ";
var gUrlMappingManager =
{
    init: function()
    {
        var extModule = Firebug.ExternalEditors;
        this.checkHeaderRe = extModule.checkHeaderRe;
        this.pathTransformations = extModule.pathTransformations;

        var val = [
            headerExplaination, "\n",
            headerName, splitter, extModule.checkHeaderRe.source,
            "\n\n",
            listExplaination,
            "\n"
        ];

        for (var i = 0; i < this.pathTransformations.length; i++)
        {
            var transform = this.pathTransformations[i];
            val.push(transform.regexp.source, splitter, transform.filePath, "\n");
        }

        val.push(splitter, "\n");

        this.win.document.getElementById("urlMappings").value = val.join("");
        this.win.document.getElementById("test").value = Firebug.Firefox.getCurrentBrowser().currentURI.spec;

        this.onMainInput();
    },

    uninit: function()
    {
        this.save();
        Firebug.ExternalEditors.saveUrlMappings();
    },

    save: function()
    {
        var checkHeaderRe = this.checkHeaderRe;
        var pathTransformations = this.pathTransformations;

        FirebugLoader.forEachWindow(function(win)
        {
            var extModule = win.Firebug.ExternalEditors;
            delete extModule.pathTransformations;
            delete extModule.checkHeaderRe;
            extModule.checkHeaderRe = checkHeaderRe;
            extModule.pathTransformations = pathTransformations;
        });
    },

    parse: function(val)
    {
        var lines = val.split(/(?:\n\r|\n|\r)/);
        var errors = this.errors = [];
        function addRegexp(source, line)
        {
            if (!source)
                return;

            try
            {
                source = source.replace(/\\?\//g, '\\/');
                return RegExp(source, 'i');
            }
            catch(e)
            {
                errors.push(line + ': ' + e);
                return null;
            }
        }

        this.pathTransformations = [];
        this.checkHeaderRe = null;
        for (var i in lines)
        {
            var line = lines[i].split('=>');

            if (!line[1] || !line[0])
                continue;

            var start = line[0].trim();
            var end = line[1].trim();

            if (start[0] == '/' && start[1] == '/')
                continue;

            if (start == headerName)
            {
                if (this.checkHeaderRe)
                    erors.push(i);
                else
                    this.checkHeaderRe = addRegexp(end, i);
                continue;
            }

            var t = {
                regexp: addRegexp(start, i),
                filePath: end
            };

            if (t.regexp && t.filePath)
                this.pathTransformations.push(t);
        }

        if (!this.checkHeaderRe)
            this.checkHeaderRe = /^$/;
    },

    onTestInput: function()
    {
        var testBox = this.win.document.getElementById("test");
        var resultBox = this.win.document.getElementById("result");
        var href = testBox.value;

        if (this.checkHeaderRe.test(href))
        {
            resultBox.value = "firebug will send query to server";
        }
        else
        {
            for (var i=0; i<this.pathTransformations.length; i++)
            {
                var transform = this.pathTransformations[i];
                if (transform.regexp.test(href))
                {
                    var path = href.replace(transform.regexp, transform.filePath);
                    break;
                }
            }

            if (path)
            {
                resultBox.style.cssText = "box-shadow: 0px 0px 1.5px 1px lime;";
                href = path;
            }

            resultBox.value = href.replace(/([^:\\\/])[\\\/]+/g, '$1/');
        }
    },

    onMainInput: function()
    {
        this.parse(this.win.document.getElementById("urlMappings").value);
        var resultBox = this.win.document.getElementById("result");
        if (this.errors.length)
        {
            resultBox.value = this.errors;
            resultBox.style.cssText = "box-shadow: 0px 0px 1.5px 1px red;";
        }
        else
        {
            resultBox.style.cssText = "";
            this.onTestInput();
        }
    },

    schedule: function(funcName)
    {
        if (this._scheduled != "onMainInput")
            this._scheduled = funcName;

        if (this.timeOut != null)
            return;

        this.timeOut = setTimeout(function(_this)
        {
            _this[_this._scheduled]();
            _this._scheduled = _this.timeOut = null;
            _this.save()
        }, 80, this);
    }
};

// ********************************************************************************************* //
// Registration

return EditorManager;

// ********************************************************************************************* //
});/* See license.txt for terms of usage */

define("firebug/firefox/external-editors/externalEditors",
[
    "firebug/chrome/module",
    "firebug/lib/lib",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/locale",
    "firebug/lib/xpcom",
    "firebug/lib/url",
    "firebug/lib/string",
    "firebug/js/sourceLink",
    "firebug/lib/css",
    "firebug/lib/system",
    "firebug/lib/array",
    "firebug/lib/dom",
    "firebug/chrome/menu",
    "firebug/trace/debug",
    "firebug/chrome/firefox",
    "firebug/firefox/external-editors/editors",
    "firebug/lib/options",
],
function(Module, FBL, Obj, Firebug, Locale, Xpcom, Url, Str, SourceLink, Css, System, Arr, Dom,
    Menu, Debug, Firefox, Editors, Options) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const DirService = Xpcom.CCSV("@mozilla.org/file/directory_service;1",
    "nsIDirectoryServiceProvider");
const NS_OS_TEMP_DIR = "TmpD";
const nsIFile = Ci.nsIFile;
const nsISafeOutputStream = Ci.nsISafeOutputStream;
const nsIURI = Ci.nsIURI;

const prefDomain = "extensions.firebug";

var editors = [];
var externalEditors = [];
var temporaryFiles = [];
var temporaryDirectory = null;

// ********************************************************************************************* //
// Module Implementation

Firebug.ExternalEditors = Obj.extend(Module,
{
    dispatchName: "externalEditors",

    initializeUI: function()
    {
        Module.initializeUI.apply(this, arguments);

        Firebug.registerUIListener(this);
        this.loadExternalEditors();
    },

    updateOption: function(name, value)
    {
        if (name.substr(0, 15) == "externalEditors")
            this.loadExternalEditors();
    },

    shutdown: function()
    {
         this.deleteTemporaryFiles();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    registerEditor: function()
    {
        editors.push.apply(editors, arguments);
    },

    getRegisteredEditors: function()
    {
        var newArray = [];

        if (editors.length > 0)
        {
            newArray.push.apply(newArray, editors);
            if (externalEditors.length > 0)
                newArray.push("-");
        }

        if (externalEditors.length > 0)
            newArray.push.apply(newArray, externalEditors);

        return newArray;
    },

    loadExternalEditors: function()
    {
        const prefName = "externalEditors";
        const editorPrefNames = ["label", "executable", "cmdline", "image"];

        externalEditors = [];
        var prefDomain = Options.getPrefDomain();
        var list = Options.getPref(prefDomain, prefName).split(",");

        for (var i=0; i<list.length; ++i)
        {
            var editorId = list[i];
            if (!editorId || editorId == "")
                continue;

            var item = { id: editorId };
            for (var j=0; j<editorPrefNames.length; ++j)
            {
                try
                {
                    item[editorPrefNames[j]] = Options.getPref(prefDomain,
                        prefName + "." + editorId + "." + editorPrefNames[j]);
                }
                catch(exc)
                {
                }
            }

            if (item.label && item.executable)
            {
                if (!item.image)
                    item.image = System.getIconURLForFile(item.executable);
                externalEditors.push(item);
            }
        }
        return externalEditors;
    },

    getDefaultEditor: function()
    {
        return externalEditors[0] || editors[0];
    },

    getEditor: function(id)
    {
        if (typeof id == "object")
            return id;

        if (!id)
            return this.getDefaultEditor();

        var list = Arr.extendArray(externalEditors, editors);
        for (var i=0; i<list.length; i++)
        {
            var editor = list[i];
            if (editor.id == id)
                return editor;
        }
    },

    count: function()
    {
        return externalEditors.length + editors.length;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Overlay menu support

    onEditorsShowing: function(popup)
    {
        Dom.eraseNode(popup);

        var editors = this.getRegisteredEditors();
        for (var i=0; i<editors.length; ++i)
        {
            if (editors[i] == "-")
            {
                Menu.createMenuItem(popup, "-");
                continue;
            }

            var item = {
                label: editors[i].label,
                image: editors[i].image,
                nol10n: true
            };

            var menuitem = Menu.createMenuItem(popup, item);
            menuitem.value = editors[i].id;
        }

        if (editors.length > 0)
            Menu.createMenuItem(popup, "-");

        Menu.createMenuItem(popup, {
            label: Locale.$STR("firebug.Configure_Editors") + "...",
            nol10n: true,
            option: "openEditorList"
        });
    },

    openEditorList: function()
    {
        Firefox.openWindow("Firebug:ExternalEditors",
            "chrome://firebug/content/firefox/external-editors/editors.xul",
            "", new Editors(prefDomain + ".externalEditors"));
    },

    onContextMenu: function(items, object, target, context, panel, popup)
    {
        if (!this.count())
            return

        if (object instanceof SourceLink.SourceLink)
        {
            this.appendContextMenuItem(popup, object.href, object.line);
        }
        else if (target.id == "fbLocationList")
        {
            if (object.href)
                this.appendContextMenuItem(popup, object.href, 0);
        }
        else if (panel)
        {
            var sourceLink = panel.getSourceLink(target, object);
            if (sourceLink)
                this.appendContextMenuItem(popup, sourceLink.href, sourceLink.line);
        }
    },

    createContextMenuItem: function(doc)
    {
        var item = doc.createElement("menu");
        item.setAttribute("iconic", "true");
        item.setAttribute("label", Locale.$STR("firebug.OpenWith"));

        item.addEventListener("command", function(event)
        {
            Firebug.ExternalEditors.onContextMenuCommand(event);
        });

        var menupopup = doc.createElement("menupopup");
        menupopup.addEventListener("popupshowing", function(event)
        {
            return Firebug.ExternalEditors.onEditorsShowing(this);
        });

        item.appendChild(menupopup);
        return item;
    },

    appendContextMenuItem: function(popup, url, line)
    {
        if (FBTrace.DBG_EXTERNALEDITORS)
        {
            FBTrace.sysout("externalEditors.appendContextMenuItem; href: " + url +
                ", line: " + line);
        }

        var editor = this.getDefaultEditor();
        var doc = popup.ownerDocument;
        var item = doc.getElementById("menu_firebug_firebugOpenWithEditor");

        if (item)
        {
            item = item.cloneNode(true);
            item.hidden = false;
            item.removeAttribute("openFromContext");

            item.setAttribute("image", editor.image);
            item.setAttribute("label", editor.label);
            item.value = editor.id;
        }
        else
        {
            item = this.createContextMenuItem(doc);
        }

        popup.appendChild(item);

        this.lastSource = {
            url: url,
            line: line
        };
    },

    onContextMenuCommand: function(event)
    {
        if (event.target.getAttribute("option") == "openEditorList")
            this.openEditorList();
        else if (event.currentTarget.hasAttribute("openFromContext"))
            this.openContext(Firebug.currentContext, event.target.value);
        else
            this.open(this.lastSource.url, this.lastSource.line, event.target.value);
    },

    openContext: function(context, editorId)
    {
        var line = null;
        var panel = Firebug.chrome.getSelectedPanel();
        if (panel)
        {
            var box = panel.selectedSourceBox;
            if (box && box.centralLine)
                line = box.centralLine;
        }

        // if firebug isn't active this will redturn documentURI
        var url = Firebug.chrome.getSelectedPanelURL();
        this.open(url, line, editorId, context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // main

    open: function(href, line, editorId, context)
    {
        try
        {
            if (FBTrace.DBG_EXTERNALEDITORS)
                FBTrace.sysout("externalEditors.open; href: " + href + ", line: " + line +
                    ", editorId: " + editorId + ", context: " + context, context);

            if (!href)
                return;

            var editor = this.getEditor(editorId);
            if (!editor)
                 return;

            if (editor.handler)
                return editor.handler(href, line);

            var options = {
                url: href,
                href: href,
                line: line,
                editor: editor,
                cmdline: editor.cmdline
            };

            var self = this;
            this.getLocalFile(options, function(file)
            {
                if (file.exists())
                {
                    if (file.isDirectory())
                    {
                        file.reveal();
                        return;
                    }

                    options.file = file.path;
                }

                var args = self.parseCmdLine(options.cmdline, options);

                if (FBTrace.DBG_EXTERNALEDITORS)
                    FBTrace.sysout("externalEditors.open; launch program with args:", args);

                System.launchProgram(editor.executable, args);
            });
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("externalEditors.open; EXCEPTION " + exc, exc);

            Debug.ERROR(exc);
        }
    },

    getLocalFile: function(options, callback)
    {
        var href = options.href;
        var file = Url.getLocalOrSystemFile(href);
        if (file)
            return callback(file);

        if (this.checkHeaderRe.test(href))
        {
            if (FBTrace.DBG_EXTERNALEDITORS)
                FBTrace.sysout("externalEditors. connecting server for", href);

            var req = new XMLHttpRequest;
            req.open("HEAD", href, true);
            req.setRequestHeader("X-Line", options.line);
            req.setRequestHeader("X-Column", options.col);
            req.onloadend = function()
            {
                var path = req.getResponseHeader("X-Local-File-Path");
                if (FBTrace.DBG_EXTERNALEDITORS)
                    FBTrace.sysout("externalEditors. server says", path);

                var file = fixupFilePath(path);
                if (file)
                    callback(file);

                // TODO: do we need to notify the user if path was wrong?
                // xxxHonza: note that there can be already a notification
                // coming from external editor (e.g. Notepad has its own
                // error dialog informing about an invalid path).
            };

            req.send(null);
            return;
        }

        file = this.transformHref(href);
        if (file)
            return callback(file);

        this.saveToTemporaryFile(href, callback);
    },

    parseCmdLine: function(cmdLine, options)
    {
        cmdLine = cmdLine || "";

        var lastI = 0, args = [], argIndex = 0, inGroup;
        var subs = "col|line|file|url".split("|");

        // do not send argument with bogus line number
        function checkGroup()
        {
            var group = args.slice(argIndex), isValid = null;
            for (var i=0; i<subs.length; i++)
            {
                var sub = subs[i];
                if (group.indexOf("%" + sub) == -1)
                    continue;

                if (options[sub] == undefined)
                {
                    isValid = false;
                }
                else
                {
                    isValid = true;
                    break;
                }
            }

            if (isValid == false)
                args = args.slice(0, argIndex);

            argIndex = args.length;
        }

        cmdLine.replace(/(\s+|$)|(?:%([{}]|(%|col|line|file|url)))/g, function(a, b, c, d, i, str)
        {
            var skipped = str.substring(lastI, i);
            lastI = i + a.length;
            skipped && args.push(skipped);

            if (b || !a)
            {
                args.push(" ");
                if (!inGroup)
                    checkGroup();
            }
            else if (c == "{")
            {
                inGroup = true;
            }
            else if (c == "}")
            {
                inGroup = false;
                checkGroup();
            }
            else if (d)
            {
                args.push(a);
            }
        });

        cmdLine = args.join("");

        // add %file
        if (!/%(url|file)/.test(cmdLine))
            cmdLine += " %file";

        args = cmdLine.trim().split(" ");
        args = args.map(function(x)
        {
            return x.replace(/(?:%(%|col|line|file|url))/g, function(a, b)
            {
                if (b == "%")
                    return b;
                if (options[b] == null)
                    return "";
                return options[b];
            });
        });

        return args;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    transformHref: function(href)
    {
        for (var i=0; i<this.pathTransformations.length; i++)
        {
            var transform = this.pathTransformations[i];
            if (transform.regexp.test(href))
            {
                var path = href.replace(transform.regexp, transform.filePath);
                var file = fixupFilePath(path);
                if (file && file.exists())
                {
                    if (FBTrace.DBG_EXTERNALEDITORS)
                        FBTrace.sysout("externalEditors. " + href + " transformed to", file.path);
                    return file;
                }
            }
        }
    },

    saveToTemporaryFile: function(href, callback)
    {
        var data = Firebug.currentContext.sourceCache.loadText(href);
        var file = this.createTemporaryFile(href, data);

        callback(file);
    },

    createTemporaryFile: function(href, data)
    {
        if (!data)
            return;

        if (!temporaryDirectory)
        {
            var tmpDir = DirService.getFile(NS_OS_TEMP_DIR, {});
            tmpDir.append("fbtmp");
            tmpDir.createUnique(nsIFile.DIRECTORY_TYPE, 0775);
            temporaryDirectory = tmpDir;
        }

        var lpath = href.replace(/^[^:]+:\/*/g, "").replace(/\?.*$/g, "")
            .replace(/[^0-9a-zA-Z\/.]/g, "_");

        /* dummy comment to workaround eclipse bug */
        if (!/\.[\w]{1,5}$/.test(lpath))
        {
            if (lpath.charAt(lpath.length-1) == "/")
                lpath += "index";
            lpath += ".html";
        }

        if (System.getPlatformName() == "WINNT")
            lpath = lpath.replace(/\//g, "\\");

        var file = Xpcom.QI(temporaryDirectory.clone(), nsIFile);
        file.appendRelativePath(lpath);
        if (!file.exists())
            file.create(nsIFile.NORMAL_FILE_TYPE, 0664);
        temporaryFiles.push(file.path);

        // TODO detect charset from current tab
        data = Str.convertFromUnicode(data);

        var stream = Xpcom.CCIN("@mozilla.org/network/safe-file-output-stream;1",
            "nsIFileOutputStream");
        stream.init(file, 0x04 | 0x08 | 0x20, 0664, 0); // write, create, truncate
        stream.write(data, data.length);

        if (stream instanceof nsISafeOutputStream)
            stream.finish();
        else
            stream.close();

        return file;
    },

    // TODO call on "shutdown" event to modules
    deleteTemporaryFiles: function()
    {
        try
        {
            var file = Xpcom.CCIN("@mozilla.org/file/local;1", "nsIFile");
            for (var i = 0; i < temporaryFiles.length; ++i)
            {
                file.initWithPath(temporaryFiles[i]);
                if (file.exists())
                    file.remove(false);
            }
        }
        catch(exc)
        {
        }

        try
        {
            if (temporaryDirectory && temporaryDirectory.exists())
                temporaryDirectory.remove(true);
        }
        catch(exc)
        {
        }
    },
});

// ********************************************************************************************* //
// Helpers

function fixupFilePath(path)
{
    var file = Url.getLocalOrSystemFile(path);
    if (!file)
    {
        path = "file:///" + path.replace(/[\/\\]+/g, "/");
        file = Url.getLocalOrSystemFile(path);
    }
    return file;
}

// object.extend doesn't handle getters
// xxxHonza: now it does we should fix this.
Firebug.ExternalEditors.__defineGetter__("pathTransformations",
    lazyLoadUrlMappings.bind(Firebug.ExternalEditors, "pathTransformations"));

Firebug.ExternalEditors.__defineGetter__("checkHeaderRe",
    lazyLoadUrlMappings.bind(Firebug.ExternalEditors, "checkHeaderRe"));

function lazyLoadUrlMappings(propName)
{
    delete this.pathTransformations;
    delete this.checkHeaderRe;

    var lines = readEntireFile(userFile("urlMappings.txt")).split(/[\n\r]+/);
    var sp = "=>";

    function safeRegexp(source)
    {
        try
        {
            return RegExp(source, "i");
        }
        catch(e)
        {
        }
    }

    this.pathTransformations = [];
    this.checkHeaderRe = null;

    for (var i in lines)
    {
        var line = lines[i].split("=>");

        if (!line[1] || !line[0])
            continue;

        var start = line[0].trim();
        var end = line[1].trim();

        if (start[0] == "/" && start[1] == "/")
            continue;

        if (start == "X-Local-File-Path")
        {
            this.checkHeaderRe = safeRegexp(end);
            continue;
        }
        var t = {
            regexp: safeRegexp(start, i),
            filePath: end
        };
        if (t.regexp && t.filePath)
            this.pathTransformations.push(t);
    }

    if (!this.checkHeaderRe)
        this.checkHeaderRe = /^https?:\/\/(localhost)(\/|:|$)/i;

    return this[propName];
}

Firebug.ExternalEditors.saveUrlMappings = function()
{
    var sp = " => ";
    var text = [
        "X-Local-File-Path", sp, this.checkHeaderRe.source, "\n\n"
    ];

    for (var i = 0; i < this.pathTransformations.length; i++)
    {
        var t = this.pathTransformations[i];
        text.push(t.regexp, sp, t.filePath, "\n");
    }

    var file = userFile("urlMappings.txt");
    writeToFile(file, text.join(""));
};

// file helpers
function userFile(name)
{
    var file = Services.dirsvc.get("ProfD", Ci.nsIFile);
    file.append("firebug");
    file.append(name);
    return file;
}

function readEntireFile(file)
{
    if (!file.exists())
        return "";

    var data = "", str = {};
    var fstream = Cc["@mozilla.org/network/file-input-stream;1"]
        .createInstance(Ci.nsIFileInputStream);
    var converter = Cc["@mozilla.org/intl/converter-input-stream;1"]
        .createInstance(Ci.nsIConverterInputStream);

    const replacementChar = Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER;
    fstream.init(file, -1, 0, 0);
    converter.init(fstream, "UTF-8", 1024, replacementChar);

    while (converter.readString(4096, str) != 0)
        data += str.value;

    converter.close();

    return data;
}

function writeToFile(file, text)
{
    var fostream = Cc["@mozilla.org/network/file-output-stream;1"]
        .createInstance(Ci.nsIFileOutputStream);
    var converter = Cc["@mozilla.org/intl/converter-output-stream;1"]
        .createInstance(Ci.nsIConverterOutputStream);

    if (!file.exists())
        file.create(Ci.nsIFile.NORMAL_FILE_TYPE, 0664);

    fostream.init(file, 0x02 | 0x08 | 0x20, 0664, 0); // write, create, truncate
    converter.init(fostream, "UTF-8", 4096, 0x0000);
    converter.writeString(text);
    converter.close();
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.ExternalEditors);

return Firebug.ExternalEditors;

// ********************************************************************************************* //
});/* See license.txt for terms of usage */

define("firebug/firefox/start-button/startButtonOverlay",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/firefox/browserOverlayLib",
],
function(Module, Obj, Firebug, Firefox, Locale, Events, Dom, Options, BrowserOverlayLib) {

"use strict";

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

// ********************************************************************************************* //
// Module Implementation

/**
 * @module StartButton module represents the UI entry point to Firebug. This "start button"
 * formerly known as "the status bar icon" is automatically appended into Firefox toolbar
 * (since Firefox 4).
 *
 * Start button is associated with a menu (fbStatusContextMenu) that contains basic actions
 * such as panel activation and also indicates whether Firebug is activated/deactivated for
 * the current page (by changing its color).
 */
Firebug.StartButton = Obj.extend(Module,
/** @lends Firebug.StartButton */
{
    dispatchName: "startButton",

    initializeUI: function()
    {
        Module.initializeUI.apply(this, arguments);

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("StartButton.initializeUI;");

        // When Firebug is full loaded content of the start button tooltip
        // will be generated by this StartButton object.
        var firebugButton = Firefox.getElementById("firebug-buttonTooltip");
        var listener = Firebug.StartButton.onTooltipShowing.bind(this);
        firebugButton.addEventListener("popupshowing", listener);
    },

    shutdown: function()
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Tooltip

    onTooltipShowing: function(event)
    {
        var tooltip = event.target;
        var doc = tooltip.ownerDocument;

        Dom.eraseNode(tooltip);

        tooltip.appendChild(BrowserOverlayLib.$label(doc, {
            "class": "version",
            value: Locale.$STR("Firebug") + " " + Firebug.getVersion()
        }));

        var status = BrowserOverlayLib.$el(doc, "hbox");
        tooltip.appendChild(status);

        var suspended = Firebug.getSuspended();
        status.appendChild(BrowserOverlayLib.$label(doc, {
            "class": "status",
            value: suspended ? Locale.$STR("startbutton.tip.deactivated") :
                Locale.$STRP("plural.Total_Firebugs2", [Firebug.TabWatcher.contexts.length])
        }));

        if (suspended)
            return;

        status.appendChild(BrowserOverlayLib.$label(doc, {
            "class": "placement",
            value: "(" + Locale.$STR(Firebug.getPlacement()) + ")"
        }));

        if (Firebug.allPagesActivation == "on")
        {
            tooltip.appendChild(BrowserOverlayLib.$label(doc, {
                "class": "alwaysOn",
                value: Locale.$STR("enablement.on") + " " +
                    Locale.$STR("enablement.for_all_pages")
            }));
        }

        // Panel enablement status info
        tooltip.appendChild(BrowserOverlayLib.$label(doc, {
            "class": "enablement",
            value: Locale.$STR("enablement.Panel_activation_status")
        }));

        var statuses = this.getEnablementStatus();
        for (var i=0; i<statuses.length; i++)
        {
            var status = statuses[i];
            var parent = BrowserOverlayLib.$el(doc, "hbox");
            tooltip.appendChild(parent);

            parent.appendChild(BrowserOverlayLib.$label(doc, {
                "class": "panelName " + status.status,
                value: status.name + ":"
            }));

            parent.appendChild(BrowserOverlayLib.$label(doc, {
                "class": "panelStatus " + status.status,
                value: status.statusLabel
            }));
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Error count

    showCount: function(errorCount)
    {
        var firebugButton = Firefox.getElementById("firebug-button");
        if (errorCount && Firebug.showErrorCount)
        {
            if (firebugButton)
            {
                firebugButton.setAttribute("showErrors", "true");
                firebugButton.setAttribute("errorCount", errorCount);
            }
        }
        else
        {
            if (firebugButton)
            {
                firebugButton.removeAttribute("showErrors");

                // Use '0', so the horizontal space for the number is still allocated.
                // The button will cause re-layout if there are more than 9 errors.
                firebugButton.setAttribute("errorCount", "0");
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Tooltip

    resetTooltip: function()
    {
        var firebugStatus = Firefox.getElementById("firebugStatus");
        if (!firebugStatus)
            return;

        // The start button is colorful only if there is a context
        var active = Firebug.currentContext ? "true" : "false";
        firebugStatus.setAttribute("firebugActive", active);

        if (FBTrace.DBG_TOOLTIP)
            FBTrace.sysout("StartButton.resetTooltip; called: firebug active: " + active);
    },

    getEnablementStatus: function()
    {
        var firebugStatus = Firefox.getElementById("firebugStatus");
        if (!firebugStatus)
            return;

        var panels = Firebug.getActivablePanelTypes();
        var statuses = [];

        var strOn = Locale.$STR("enablement.on");
        var strOff = Locale.$STR("enablement.off");

        for (var i=0; i<panels.length; ++i)
        {
            var panelName = panels[i].prototype.name;
            var status = firebugStatus.getAttribute(panelName);
            var statusLabel = (status == "on") ? strOn : strOff;

            statuses.push({
                name: Firebug.getPanelTitle(panels[i]),
                status: status,
                statusLabel: statusLabel
            });
        }

        return statuses;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Activation

    getSuspended: function()
    {
        var suspendMarker = Firefox.getElementById("firebugStatus");
        if (suspendMarker && suspendMarker.hasAttribute("suspended"))
            return suspendMarker.getAttribute("suspended");

        return null;
    },

    setSuspended: function(value)
    {
        var suspendMarker = Firefox.getElementById("firebugStatus");

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("StartButton.setSuspended; to " + value + ". Browser: " +
                Firebug.chrome.window.document.title);

        if (value == "suspended")
            suspendMarker.setAttribute("suspended", value);
        else
            suspendMarker.removeAttribute("suspended");

        this.resetTooltip();
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.StartButton);

// ********************************************************************************************* //

return Firebug.StartButton;
});
/* See license.txt for terms of usage */

define("firebug/html/highlighterCache",
[
],
function() {

"use strict";

// ********************************************************************************************* //
// Constants

const ident = {
    frame: 0,
    boxModel: 1,
    imageMap: 2,
    proxyElt: 3
};

// ********************************************************************************************* //
// Implementation

var HighlighterCache =
{
    ident: ident,

    highlighters: {
        frameArr: [],
        boxModelArr: [],
        proxyEltArr: []
    },

    get: function(type)
    {
        var node;
        var hl = this.highlighters;

        switch (type)
        {
            case ident.boxModel:
                if (hl.boxModelArr.length === 1)
                {
                    node = hl.boxModelArr[0];
                    if (!node.parentElement)
                        return node;
                }
            break;
            case ident.frame:
                if (hl.frameArr.length === 1)
                {
                    node = hl.frameArr[0];
                    if (!node.parentElement)
                        return node;
                }
            break;
            case ident.proxyElt:
                if (hl.proxyEltArr.length === 1)
                {
                    node = hl.proxyEltArr[0];
                    if (!node.parentElement)
                        return node;
                }
            break;
        }
    },

    add: function(node)
    {
        switch (node.ident)
        {
            case ident.boxModel:
                this.highlighters.boxModelArr.push(node);
            break;
            case ident.frame:
                this.highlighters.frameArr.push(node);
            break;
            case ident.proxyElt:
                this.highlighters.proxyEltArr.push(node);
            break;
        }
    },

    clear: function()
    {
        clearBoxModelCache(this.highlighters.boxModelArr);

        clearCache(this.highlighters.frameArr);
        clearCache(this.highlighters.proxyEltArr);

        this.highlighters.boxModelArr = [];
        this.highlighters.frameArr = [];
        this.highlighters.proxyEltArr = [];
    }
};

// ********************************************************************************************* //
// Helpers

function clearCache(arr)
{
    try
    {
        var i, highlighter;
        for (i = arr.length - 1; i >= 0; i--)
        {
            highlighter = arr[i];

            if (highlighter && highlighter.parentNode)
                highlighter.parentNode.removeChild(highlighter);
        }
    }
    catch (err)
    {
        FBTrace.sysout("highlighterCache.clearCache; EXCEPTION " + err, err);
    }
}

function clearBoxModelCache(arr)
{
    try
    {
        var node;
        for (var i = arr.length - 1; i >= 0; i--)
        {
            var names = ["lines", "offset", "parent"];
            for (var j=0; j<names.length; j++)
            {
                var name = names[j];
                if (name === "lines")
                {
                    var lineNames = ["bottom", "left", "top", "right"];
                    for (var k=0; k<lineNames.length; k++)
                    {
                        var lineName = lineNames[k];
                        node = arr[i].lines[lineName];

                        if (node && node.parentNode)
                            node.parentNode.removeChild(node);
                    }
                }
                else
                {
                    node = arr[i][name];
                    if (node && node.parentNode)
                        node.parentNode.removeChild(node);
                }
            }
        }
    }
    catch (err)
    {
        FBTrace.sysout("clearBoxModelCache.clearCache; EXCEPTION " + err, err);
    }
}

// ********************************************************************************************* //
// Registration

return HighlighterCache;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/html/htmlLib",
[
    "firebug/lib/object",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/search",
    "firebug/lib/xml",
    "firebug/lib/xpath",
    "firebug/lib/string",
],
function(Obj, Events, Css, Dom, Search, Xml, Xpath, Str) {

// ********************************************************************************************* //
// Constants

const Ci = Components.interfaces;
const SHOW_ALL = Ci.nsIDOMNodeFilter.SHOW_ALL;

// ********************************************************************************************* //

/**
 * @class Static utility class. Contains utilities used for displaying and
 *        searching a HTML tree.
 */
var HTMLLib =
{
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Node Search Utilities

    /**
     * Constructs a NodeSearch instance.
     *
     * @class Class used to search a DOM tree for the given text. Will display
     *        the search results in a IO Box.
     *
     * @constructor
     * @param {String} text Text to search for
     * @param {Object} root Root of search. This may be an element or a document
     * @param {Object} panelNode Panel node containing the IO Box representing the DOM tree.
     * @param {Object} ioBox IO Box to display the search results in
     * @param {Object} walker Optional walker parameter.
     */
    NodeSearch: function(text, root, panelNode, ioBox, walker)
    {
        root = root.documentElement || root;
        walker = walker || new HTMLLib.DOMWalker(root);
        var re = new Search.ReversibleRegExp(text, "m");
        var matchCount = 0;
        var nodeSet = new Set();

        // Try also to parse the text as a CSS or XPath selector, and merge
        // the result sets together.
        try
        {
            var isXPath = (text.charAt(0) === "/");
            function eachDoc(doc)
            {
                var nodes = isXPath ?
                    Xpath.evaluateXPath(doc, text, doc, XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE) :
                    doc.querySelectorAll(text);

                for (var i = 0, len = nodes.length; i < len; ++i)
                    nodeSet.add(nodes[i]);

                var frames = doc.getElementsByTagName("iframe");
                for (var i = 0, len = frames.length; i < len; ++i)
                {
                    var fr = frames[i];
                    if (fr.contentDocument)
                        eachDoc(fr.contentDocument);
                }
            }
            eachDoc(root.ownerDocument || root);
        }
        catch (exc)
        {
            // Not a valid selector.
            nodeSet = null;
        }

        /**
         * Finds the first match within the document.
         *
         * @param {boolean} revert true to search backward, false to search forward
         * @param {boolean} caseSensitive true to match exact case, false to ignore case
         * @return true if no more matches were found, but matches were found previously.
         */
        this.find = function(reverse, caseSensitive)
        {
            var match = this.findNextMatch(reverse, caseSensitive);
            if (match)
            {
                this.lastMatch = match;
                ++matchCount;

                var node = match.node;
                var nodeBox = this.openToNode(node, match.isValue);

                this.selectMatched(nodeBox, node, match, reverse);
            }
            else if (matchCount)
            {
                return true;
            }
            else
            {
                this.noMatch = true;
                Events.dispatch([Firebug.A11yModel], "onHTMLSearchNoMatchFound",
                    [panelNode.ownerPanel, text]);
            }
        };

        /**
         * Resets the search to the beginning of the document.
         */
        this.reset = function()
        {
            delete this.lastMatch;
        };

        /**
         * Finds the next match in the document.
         *
         * The return value is an object with the fields
         * - node: Node that contains the match
         * - isValue: true if the match is a match due to the value of the node, false if it is due to the name
         * - match: Regular expression result from the match
         *
         * @param {boolean} revert true to search backward, false to search forward
         * @param {boolean} caseSensitive true to match exact case, false to ignore case
         * @return Match object if found
         */
        this.findNextMatch = function(reverse, caseSensitive)
        {
            var innerMatch = this.findNextInnerMatch(reverse, caseSensitive);
            if (innerMatch)
                return innerMatch;
            else
                this.reset();

            function walkNode() { return reverse ? walker.previousNode() : walker.nextNode(); }

            var node;
            while (node = walkNode())
            {
                if (node.nodeType == Node.TEXT_NODE && HTMLLib.isSourceElement(node.parentNode))
                    continue;

                var m = this.checkNode(node, reverse, caseSensitive);
                if (m)
                    return m;
            }
        };

        /**
         * Helper util used to scan the current search result for more results
         * in the same object.
         *
         * @private
         */
        this.findNextInnerMatch = function(reverse, caseSensitive)
        {
            if (this.lastMatch)
            {
                var lastMatchNode = this.lastMatch.node;
                var lastReMatch = this.lastMatch.match;
                var m = re.exec(lastReMatch.input, reverse, lastReMatch.caseSensitive, lastReMatch);
                if (m)
                {
                    return {
                        node: lastMatchNode,
                        isValue: this.lastMatch.isValue,
                        match: m
                    };
                }

                // May need to check the pair for attributes
                if (lastMatchNode.nodeType == Node.ATTRIBUTE_NODE &&
                    this.lastMatch.isValue == !!reverse)
                {
                    return this.checkNode(lastMatchNode, reverse, caseSensitive, 1);
                }
            }
        };

        /**
         * Checks a given node for a search match.
         *
         * @private
         */
        this.checkNode = function(node, reverse, caseSensitive, firstStep)
        {
            if (nodeSet && nodeSet.has(node))
            {
                // If a selector matches the node, that takes priority.
                return {
                    node: node,
                    isValue: false,
                    match: re.fakeMatch(node.localName, reverse, caseSensitive),
                    fullNodeMatch: true
                };
            }

            var checkOrder;
            if (node.nodeType == Node.ELEMENT_NODE)
            {
                // For non-qualified XML names (where localName and nodeName are the same thing) we
                // want the initial capitalization (localName); when !caseSensitive it doesn't matter.
                var name = (!caseSensitive || node.nodeName.length > node.localName.length ?
                    "nodeName" : "localName");
                checkOrder = [{name: name, isValue: false}];
            }
            else if (node.nodeType == Node.TEXT_NODE)
            {
                checkOrder = [{name: "nodeValue", isValue: false}];
            }
            else if (node.nodeType == Node.ATTRIBUTE_NODE)
            {
                checkOrder = [{name: "nodeName", isValue: false}, {name: "nodeValue", isValue: true}];
                if (reverse)
                    checkOrder.reverse();
            }
            else
            {
                // Skip comment nodes etc.
                return;
            }

            for (var i = firstStep || 0; i < checkOrder.length; i++)
            {
                var m = re.exec(node[checkOrder[i].name], reverse, caseSensitive);
                if (m) {
                    return {
                        node: node,
                        isValue: checkOrder[i].isValue,
                        match: m
                    };
                }
            }
        };

        /**
         * Opens the given node in the associated IO Box.
         *
         * @private
         */
        this.openToNode = function(node, isValue)
        {
            if (node.nodeType == Node.ELEMENT_NODE)
            {
                var nodeBox = ioBox.openToObject(node);
                return nodeBox.getElementsByClassName("nodeTag")[0];
            }
            else if (node.nodeType == Node.ATTRIBUTE_NODE)
            {
                var nodeBox = ioBox.openToObject(node.ownerElement);
                if (nodeBox)
                {
                    var attrNodeBox = HTMLLib.findNodeAttrBox(nodeBox, node.name);
                    return Dom.getChildByClass(attrNodeBox, isValue ? "nodeValue" : "nodeName");
                }
            }
            else if (node.nodeType == Node.TEXT_NODE)
            {
                var nodeBox = ioBox.openToObject(node);
                if (nodeBox)
                {
                    return nodeBox;
                }
                else
                {
                    var nodeBox = ioBox.openToObject(node.parentNode);
                    if (Css.hasClass(nodeBox, "textNodeBox"))
                        nodeBox = HTMLLib.getTextElementTextBox(nodeBox);
                    return nodeBox;
                }
            }
        };

        /**
         * Selects the search results.
         *
         * @private
         */
        this.selectMatched = function(nodeBox, node, match, reverse)
        {
            // Force a reflow to make sure search highlighting works (issue 6952).
            nodeBox.offsetWidth;

            if (match.fullNodeMatch)
            {
                this.selectWholeNode(nodeBox);
            }
            else
            {
                var reMatch = match.match;
                this.selectNodeText(nodeBox, node, reMatch[0], reMatch.index, reverse,
                    reMatch.caseSensitive);
            }

            Events.dispatch([Firebug.A11yModel], "onHTMLSearchMatchFound",
                [panelNode.ownerPanel, match]);
        };

        /**
         * Select a whole node as a search result.
         *
         * @private
         */
        this.selectWholeNode = function(nodeBox)
        {
            nodeBox = Dom.getAncestorByClass(nodeBox, "nodeBox");
            var labelBox = Dom.getChildByClass(nodeBox, "nodeLabel");
            Css.setClass(labelBox, "search-selection");
            Dom.scrollIntoCenterView(labelBox, panelNode);

            var sel = panelNode.ownerDocument.defaultView.getSelection();
            sel.removeAllRanges();

            var range = panelNode.ownerDocument.createRange();
            var until = labelBox.getElementsByClassName("nodeBracket")[0];
            var from = until.parentNode.firstChild;
            range.setStartBefore(from);
            range.setEndAfter(until);
            sel.addRange(range);

            Css.removeClass(labelBox, "search-selection");
        },

        /**
         * Select text node search results.
         *
         * @private
         */
        this.selectNodeText = function(nodeBox, node, text, index, reverse, caseSensitive)
        {
            var row;

            // If we are still inside the same node as the last search, advance the range
            // to the next substring within that node
            if (nodeBox == this.lastNodeBox)
            {
                row = this.textSearch.findNext(false, true, reverse, caseSensitive);
            }

            if (!row)
            {
                // Search for the first instance of the string inside the node
                function findRow(node)
                {
                    return node.nodeType == Node.ELEMENT_NODE ? node : node.parentNode;
                }

                this.textSearch = new Search.TextSearch(nodeBox, findRow);
                row = this.textSearch.find(text, reverse, caseSensitive);
                this.lastNodeBox = nodeBox;
            }

            if (row)
            {
                var trueNodeBox = Dom.getAncestorByClass(nodeBox, "nodeBox");

                // Temporarily add '-moz-user-select: text' to the node, so
                // that selections show up (issue 2741).
                // XXX(simon): This doesn't seem to be needed any more as of
                // Fx 27, so we ought to remove it at some point.
                Css.setClass(trueNodeBox, "search-selection");

                Dom.scrollIntoCenterView(row, panelNode);
                var sel = panelNode.ownerDocument.defaultView.getSelection();
                sel.removeAllRanges();
                sel.addRange(this.textSearch.range);

                Css.removeClass(trueNodeBox, "search-selection");
                return true;
            }
        };
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Constructs a DOMWalker instance.
     *
     * @constructor
     * @class Implements an ordered traveral of the document, including attributes and
     *        iframe contents within the results.
     *
     *        Note that the order for attributes is not defined. This will follow the
     *        same order as the Element.attributes accessor.
     * @param {Element} root Element to traverse
     */
    DOMWalker: function(root)
    {
        var walker;
        var currentNode, attrIndex;
        var pastStart, pastEnd;
        var doc = root.ownerDocument;

        function createWalker(docElement)
        {
            var walk = doc.createTreeWalker(docElement, SHOW_ALL, null, true);
            walker.unshift(walk);
        }

        function getLastAncestor()
        {
            while (walker[0].lastChild()) {}
            return walker[0].currentNode;
        }

        /**
         * Move to the previous node.
         *
         * @return The previous node if one exists, undefined otherwise.
         */
        this.previousNode = function()
        {
            if (pastStart)
                return undefined;

            if (attrIndex)
            {
                attrIndex--;
            }
            else
            {
                var prevNode;
                if (currentNode == walker[0].root)
                {
                    if (walker.length > 1)
                    {
                        walker.shift();
                        prevNode = walker[0].currentNode;
                    }
                    else
                    {
                        prevNode = undefined;
                    }
                }
                else
                {
                    prevNode = !currentNode ? getLastAncestor(): walker[0].previousNode();

                    // Really shouldn't occur, but to be safe
                    if (!prevNode)
                        prevNode = walker[0].root;

                    while ((prevNode.nodeName || "").toUpperCase() == "IFRAME")
                    {
                        createWalker(prevNode.contentDocument.documentElement);
                        prevNode = getLastAncestor();
                    }
                }
                currentNode = prevNode;
                attrIndex = ((prevNode || {}).attributes || []).length;
            }

            if (!currentNode)
                pastStart = true;
            else
                pastEnd = false;

            return this.currentNode();
        };

        /**
         * Move to the next node.
         *
         * @return The next node if one exists, otherwise undefined.
         */
        this.nextNode = function()
        {
            if (pastEnd)
                return undefined;

            if (!currentNode)
            {
                // We are working with a new tree walker
                currentNode = walker[0].root;
                attrIndex = 0;
            }
            else
            {
                // First check attributes
                var attrs = currentNode.attributes || [];
                if (attrIndex < attrs.length)
                {
                    attrIndex++;
                }
                else if ((currentNode.nodeName || "").toUpperCase() == "IFRAME")
                {
                    // Attributes have completed, check for iframe contents
                    createWalker(currentNode.contentDocument.documentElement);
                    currentNode = walker[0].root;
                    attrIndex = 0;
                }
                else
                {
                    // Next node
                    var nextNode = walker[0].nextNode();
                    while (!nextNode && walker.length > 1)
                    {
                        walker.shift();
                        nextNode = walker[0].nextNode();
                    }
                    currentNode = nextNode;
                    attrIndex = 0;
                }
            }

            if (!currentNode)
                pastEnd = true;
            else
                pastStart = false;

            return this.currentNode();
        };

        /**
         * Retrieves the current node.
         *
         * @return The current node, if not past the beginning or end of the iteration.
         */
        this.currentNode = function()
        {
            return !attrIndex ? currentNode : currentNode.attributes[attrIndex-1];
        };

        /**
         * Resets the walker position back to the initial position.
         */
        this.reset = function()
        {
            pastStart = false;
            pastEnd = false;
            walker = [];
            currentNode = undefined;
            attrIndex = 0;

            createWalker(root);
        };

        this.reset();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Node/Element Utilities

    /**
     * Determines if the given element is the source for a non-DOM resource such
     * as Javascript source or CSS definition.
     *
     * @param {Element} element Element to test
     * @return true if the element is a source element
     */
    isSourceElement: function(element)
    {
        if (!Xml.isElementHTMLOrXHTML(element))
            return false;

        var tag = element.localName ? element.localName.toLowerCase() : "";
        return tag == "script" || (tag == "link" && element.getAttribute("rel") == "stylesheet") ||
            tag == "style";
    },

    /**
     * Retrieves the source URL for any external resource associated with a node.
     *
     * @param {Element} element Element to examine
     * @return URL of the external resouce.
     */
    getSourceHref: function(element)
    {
        var tag = element.localName.toLowerCase();
        if (tag == "script" && element.src)
            return element.src;
        else if (tag == "link")
            return element.href;
        else
            return null;
    },

    /**
     * Retrieves the source text for inline script and style elements.
     *
     * @param {Element} element Script or style element
     * @return Source text
     */
    getSourceText: function(element)
    {
        var tag = element.localName.toLowerCase();
        if (tag == "script" && !element.src)
            return element.textContent;
        else if (tag == "style")
            return element.textContent;
        else
            return null;
    },

    /**
     * Determines if the given element is a container element.
     *
     * @param {Element} element Element to test
     * @return True if the element is a container element.
     */
    isContainerElement: function(element)
    {
        var tag = element.localName.toLowerCase();
        switch (tag)
        {
            case "script":
            case "style":
            case "iframe":
            case "frame":
            case "tabbrowser":
            case "browser":
                return true;
            case "link":
                return element.getAttribute("rel") == "stylesheet";
            case "embed":
                return element.getSVGDocument();
        }
        return false;
    },

    /**
     * Determines if the given node has any children which are elements.
     *
     * @param {Element} element Element to test.
     * @return true if immediate children of type Element exist, false otherwise
     */
    hasNoElementChildren: function(element)
    {
        if (element === null)
            return true;

        if (element.childElementCount != 0)  // FF 3.5+
            return false;

        // https://developer.mozilla.org/en/XBL/XBL_1.0_Reference/DOM_Interfaces
        if (element.ownerDocument instanceof Ci.nsIDOMDocumentXBL)
        {
            if (FBTrace.DBG_HTML)
            {
                FBTrace.sysout("hasNoElementChildren "+Css.getElementCSSSelector(element)+
                    " (element.ownerDocument instanceof Ci.nsIDOMDocumentXBL) "+
                    (element.ownerDocument instanceof Ci.nsIDOMDocumentXBL), element);
            }

            var walker = new HTMLLib.ElementWalker();
            var child = walker.getFirstChild(element);

            while (child)
            {
                if (child.nodeType === Node.ELEMENT_NODE)
                    return false;
                child = walker.getNextSibling(child);
            }
        }

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("hasNoElementChildren TRUE "+element.tagName+
                " (element.ownerDocument instanceof Ci.nsIDOMDocumentXBL) "+
                (element.ownerDocument instanceof Ci.nsIDOMDocumentXBL), element);

        return true;
    },


    /**
     * Determines if the given node has any children which are comments.
     *
     * @param {Element} element Element to test.
     * @return true if immediate children of type Comment exist, false otherwise
     */
    hasCommentChildren: function(element)
    {
        if (element.hasChildNodes())
        {
            var children = element.childNodes;
            for (var i = 0; i < children.length; i++)
            {
                if (children[i] instanceof Comment)
                   return true;
            }
        };
        return false;
    },


    /**
     * Determines if the given node consists solely of whitespace text.
     *
     * @param {Node} node Node to test.
     * @return true if the node is a whitespace text node
     */
    isWhitespaceText: function(node)
    {
        if (node instanceof window.HTMLAppletElement)
            return false;

        return node.nodeType == window.Node.TEXT_NODE && Str.isWhitespace(node.nodeValue);
    },

    /**
     * Determines if a given element is empty. When the
     * {@link Firebug#showTextNodesWithWhitespace} parameter is true, an element is
     * considered empty if it has no child elements and is self closing. When
     * false, an element is considered empty if the only children are whitespace
     * nodes.
     *
     * @param {Element} element Element to test
     * @return true if the element is empty, false otherwise
     */
    isEmptyElement: function(element)
    {
        // XXXjjb the commented code causes issues 48, 240, and 244. I think the lines should be deleted.
        // If the DOM has whitespace children, then the element is not empty even if
        // we decide not to show the whitespace in the UI.

        // XXXsroussey reverted above but added a check for self closing tags
        if (Firebug.showTextNodesWithWhitespace)
        {
            return !element.firstChild && Xml.isSelfClosing(element);
        }
        else
        {
            for (var child = element.firstChild; child; child = child.nextSibling)
            {
                if (!HTMLLib.isWhitespaceText(child))
                    return false;
            }
        }
        return Xml.isSelfClosing(element);
    },

    /**
     * Finds the next sibling of the given node. If the
     * {@link Firebug#showTextNodesWithWhitespace} parameter is set to true, the next
     * sibling may be a whitespace, otherwise the next is the first adjacent
     * non-whitespace node.
     *
     * @param {Node} node Node to analyze.
     * @return Next sibling node, if one exists
     */
    findNextSibling: function(node)
    {
        return this.findNextNodeFrom(node.nextSibling);
    },

    /**
     * Like findNextSibling, except it also allows returning the node itself.
     */
    findNextNodeFrom: function(node)
    {
        if (Firebug.showTextNodesWithWhitespace)
        {
            return node;
        }
        else
        {
            // only return a non-whitespace node
            for (var child = node; child; child = child.nextSibling)
            {
                if (!HTMLLib.isWhitespaceText(child))
                    return child;
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Domplate Utilities

    /**
     * Locates the attribute domplate node for a given element domplate. This method will
     * only examine notes marked with the "nodeAttr" class that are the direct
     * children of the given element.
     *
     * @param {Object} objectNodeBox The domplate element to look up the attribute for.
     * @param {String} attrName Attribute name
     * @return Attribute's domplate node
     */
    findNodeAttrBox: function(objectNodeBox, attrName)
    {
        var child = objectNodeBox.firstChild.lastChild.firstChild;
        for (; child; child = child.nextSibling)
        {
            if (Css.hasClass(child, "nodeAttr") && child.childNodes[1].firstChild
                && child.childNodes[1].firstChild.nodeValue == attrName)
            {
                return child;
            }
        }
    },

    /**
     * Locates the text domplate node for a given text element domplate.
     * @param {Object} nodeBox Text element domplate
     * @return Element's domplate text node
     */
    getTextElementTextBox: function(nodeBox)
    {
        var nodeLabelBox = nodeBox.firstChild.lastChild;
        return Dom.getChildByClass(nodeLabelBox, "nodeText");
    },

    // These functions can be copied to add tree walking feature, they allow Chromebug
    // to reuse the HTML panel
    ElementWalkerFunctions:
    {
        getTreeWalker: function(node)
        {
            if (!this.treeWalker || this.treeWalker.currentNode !== node)
                this.treeWalker = node.ownerDocument.createTreeWalker(
                    node, NodeFilter.SHOW_ALL, null, false);

            return this.treeWalker;
        },

        getFirstChild: function(node)
        {
            return node.firstChild;
        },

        getNextSibling: function(node)
        {
            // the Mozilla XBL tree walker fails for nextSibling
            return node.nextSibling;
        },

        getParentNode: function(node)
        {
            // the Mozilla XBL tree walker fails for parentNode
            return node.parentNode;
        }
    },

    ElementWalker: function()  // tree walking via new ElementWalker
    {

    }
};

// ********************************************************************************************* //
// Registration

HTMLLib.ElementWalker.prototype = HTMLLib.ElementWalkerFunctions;

return HTMLLib;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/html/htmlPanel",
[
    "firebug/chrome/panel",
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/html/htmlLib",
    "firebug/lib/events",
    "firebug/lib/system",
    "firebug/js/sourceLink",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/chrome/window",
    "firebug/lib/options",
    "firebug/lib/xpath",
    "firebug/lib/string",
    "firebug/lib/xml",
    "firebug/lib/array",
    "firebug/lib/persist",
    "firebug/chrome/menu",
    "firebug/lib/url",
    "firebug/css/cssModule",
    "firebug/css/selectorEditor",
    "firebug/css/cssReps",
    "firebug/chrome/module",
    "firebug/editor/baseEditor",
    "firebug/editor/editor",
    "firebug/editor/inlineEditor",
    "firebug/js/breakpoint",
    "firebug/chrome/searchBox",
    "firebug/html/insideOutBox",
    "firebug/html/inspector",
    "firebug/html/layout"
],
function(Panel, Rep, Obj, Firebug, Domplate, FirebugReps, Locale, HTMLLib, Events, System,
    SourceLink, Css, Dom, Win, Options, Xpath, Str, Xml, Arr, Persist, Menu, Url, CSSModule,
    CSSSelectorEditor, CSSInfoTip, Module, BaseEditor, Editor, InlineEditor) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, TAG, DIV, SPAN, TR, P, UL, LI, A, IMG, INPUT, TEXTAREA} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;

const BP_BREAKONATTRCHANGE = 1;
const BP_BREAKONCHILDCHANGE = 2;
const BP_BREAKONREMOVE = 3;
const BP_BREAKONTEXT = 4;

var KeyEvent = window.KeyEvent;

// ********************************************************************************************* //

Firebug.HTMLModule = Obj.extend(Module,
{
    dispatchName: "htmlModule",

    initialize: function(prefDomain, prefNames)
    {
        Module.initialize.apply(this, arguments);
        Firebug.connection.addListener(this.DebuggerListener);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);
        Firebug.connection.removeListener(this.DebuggerListener);
    },

    initContext: function(context, persistedState)
    {
        Module.initContext.apply(this, arguments);
        context.mutationBreakpoints = new MutationBreakpointGroup(context);
    },

    loadedContext: function(context, persistedState)
    {
        context.mutationBreakpoints.load(context);
    },

    destroyContext: function(context, persistedState)
    {
        Module.destroyContext.apply(this, arguments);

        context.mutationBreakpoints.store(context);
    },

    deleteNode: function(node, context)
    {
        Events.dispatch(this.fbListeners, "onBeginFirebugChange", [node, context]);
        node.parentNode.removeChild(node);
        Events.dispatch(this.fbListeners, "onEndFirebugChange", [node, context]);
    },

    deleteAttribute: function(node, attr, context)
    {
        Events.dispatch(this.fbListeners, "onBeginFirebugChange", [node, context]);
        node.removeAttribute(attr);
        Events.dispatch(this.fbListeners, "onEndFirebugChange", [node, context]);
    }
});

// ********************************************************************************************* //

Firebug.HTMLPanel = function() {};

var WalkingPanel = Obj.extend(Panel, HTMLLib.ElementWalkerFunctions);

Firebug.HTMLPanel.prototype = Obj.extend(WalkingPanel,
{
    inspectable: true,

    toggleEditing: function()
    {
        if (this.editing)
            this.stopEditing();
        else
            this.editNode(this.selection);
    },

    stopEditing: function()
    {
        Editor.stopEditing();
    },

    isEditing: function()
    {
        var editButton = Firebug.chrome.$("fbToggleHTMLEditing");
        return (this.editing && editButton.getAttribute("checked") === "true");
    },

    // Update the Edit button to reflect editability of the selection
    setEditEnableState: function(ignoreEditing)
    {
        var editButton = Firebug.chrome.$("fbToggleHTMLEditing");
        editButton.disabled = (this.selection && (!this.isEditing() || ignoreEditing) &&
            Css.nonEditableTags.hasOwnProperty(this.selection.localName));
    },

    resetSearch: function()
    {
        delete this.lastSearch;
    },

    select: function(object, forceUpdate, noEditChange)
    {
        if (!object)
            object = this.getDefaultSelection();

        if (FBTrace.DBG_PANELS)
        {
            FBTrace.sysout("firebug.select " + this.name + " forceUpdate: " + forceUpdate + " " +
                object + ((object == this.selection) ? "==" : "!=") + this.selection);
        }

        if (forceUpdate || object != this.selection)
        {
            this.selection = object;
            this.updateSelection(object);

            this.setEditEnableState();

            // Distribute selection change further to listeners.
            Events.dispatch(Firebug.uiListeners, "onObjectSelected", [object, this]);

            // If the 'free text' edit mode is active change the current markup
            // displayed in the editor (textarea) so that it corresponds to the current
            // selection. This typically happens when the user clicks on object-status-path
            // buttons in the toolbar.
            // For the case when the selection is changed from within the editor, don't
            // change the edited element.
            if (this.isEditing() && !noEditChange)
                this.editNode(object);
        }
    },

    selectNext: function()
    {
        var objectBox = this.ioBox.createObjectBox(this.selection);
        var next = this.ioBox.getNextObjectBox(objectBox);
        if (next)
        {
            this.select(next.repObject);

            if (Firebug.Inspector.inspecting)
                Firebug.Inspector.inspectNode(next.repObject);
        }
    },

    selectPrevious: function()
    {
        var objectBox = this.ioBox.createObjectBox(this.selection);
        var previous = this.ioBox.getPreviousObjectBox(objectBox);
        if (previous)
        {
            this.select(previous.repObject);

            if (Firebug.Inspector.inspecting)
                Firebug.Inspector.inspectNode(previous.repObject);
        }
    },

    selectNodeBy: function(dir)
    {
        if (dir == "up")
        {
            this.selectPrevious();
        }
        else if (dir == "down")
        {
            this.selectNext();
        }
        else if (dir == "left")
        {
            var box = this.ioBox.createObjectBox(this.selection);
            if (Css.hasClass(box, "open"))
            {
                this.ioBox.contractObjectBox(box);
            }
            else
            {
                var parentBox = this.ioBox.getParentObjectBox(box);
                if (parentBox && parentBox.repObject instanceof window.Element)
                    this.select(parentBox.repObject);
            }
        }
        else if (dir == "right")
        {
            var box = this.ioBox.createObjectBox(this.selection);
            if (!Css.hasClass(box, "open"))
                this.ioBox.expandObject(this.selection);
            else
                this.selectNext();
        }

        Firebug.Inspector.highlightObject(this.selection, this.context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    editNewAttribute: function(elt)
    {
        var objectNodeBox = this.ioBox.findObjectBox(elt);
        if (objectNodeBox)
        {
            var labelBox = objectNodeBox.querySelector("*> .nodeLabel > .nodeLabelBox");
            var bracketBox = labelBox.querySelector("*> .nodeBracket");
            Editor.insertRow(bracketBox, "before");
        }
    },

    editAttribute: function(elt, attrName)
    {
        var objectNodeBox = this.ioBox.findObjectBox(elt);
        if (objectNodeBox)
        {
            var attrBox = HTMLLib.findNodeAttrBox(objectNodeBox, attrName);
            if (attrBox)
            {
                var attrValueBox = attrBox.childNodes[3];
                var value = elt.getAttribute(attrName);
                Editor.startEditing(attrValueBox, value);
            }
        }
    },

    deleteAttribute: function(elt, attrName)
    {
        Firebug.HTMLModule.deleteAttribute(elt, attrName, this.context);
    },

    localEditors:{}, // instantiated editor cache
    editNode: function(node)
    {
        var objectNodeBox = this.ioBox.findObjectBox(node);
        if (objectNodeBox)
        {
            var type = Xml.getElementType(node);
            var editor = this.localEditors[type];
            if (!editor)
            {
                // look for special purpose editor (inserted by an extension),
                // otherwise use our html editor
                var specializedEditor = Firebug.HTMLPanel.Editors[type] ||
                    Firebug.HTMLPanel.Editors["html"];
                editor = this.localEditors[type] = new specializedEditor(this.document);
            }

            this.startEditingNode(node, objectNodeBox, editor, type);
        }
    },

    startEditingNode: function(node, box, editor, type)
    {
        if (type === "html" || type === "xhtml")
            this.startEditingHTMLNode(node, box, editor);
        else
            this.startEditingXMLNode(node, box, editor);
    },

    startEditingXMLNode: function(node, box, editor)
    {
        var xml = Xml.getElementXML(node);
        Editor.startEditing(box, xml, editor);
    },

    startEditingHTMLNode: function(node, box, editor)
    {
        if (Css.nonEditableTags.hasOwnProperty(node.localName))
            return;

        editor.innerEditMode = node.localName in Css.innerEditableTags;

        var html = editor.innerEditMode ? node.innerHTML : Xml.getElementHTML(node);
        html = Str.escapeForHtmlEditor(html);
        Editor.startEditing(box, html, editor);
    },

    deleteNode: function(node, dir)
    {
        var box = this.ioBox.createObjectBox(node);
        if (Css.hasClass(box, "open"))
            this.ioBox.contractObjectBox(box);

        if (dir === "up")
        {
            // We want a "backspace"-like behavior, including traversing parents.
            this.selectPrevious();
        }
        else
        {
            // Move to the next sibling if there is one, else backwards.
            var nextSelection = this.ioBox.getNextSiblingObjectBox(box);
            if (nextSelection)
                this.select(nextSelection.repObject);
            else
                this.selectPrevious();
        }

        Firebug.HTMLModule.deleteNode(node, this.context);

        Firebug.Inspector.highlightObject(this.selection, this.context);
    },

    toggleAll: function(event, node)
    {
        var expandExternalContentNodes = Events.isShift(event);
        this.ioBox.toggleObject(node, true, expandExternalContentNodes ?
            null : ["link", "script", "style"]);
    },

    updateNodeVisibility: function(node)
    {
        var wasHidden = node.classList.contains("nodeHidden");
        if (!Xml.isVisible(node.repObject))
        {
            // Hide this node and, through CSS, every descendant.
            node.classList.add("nodeHidden");
        }
        else if (wasHidden)
        {
            // The node has changed state from hidden to shown. While in the
            // hidden state, some descendants may have been explicitly marked
            // with .nodeHidden (not just through CSS inheritance), so we need
            // to recheck the visibility of those.
            node.classList.remove("nodeHidden");
            var desc = Arr.cloneArray(node.getElementsByClassName("nodeHidden"));
            for (var i = 0; i < desc.length; ++i)
            {
                if (Xml.isVisible(desc[i].repObject))
                    desc[i].classList.remove("nodeHidden");
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getElementSourceText: function(node)
    {
        if (this.sourceElements)
        {
            var index = this.sourceElementNodes.indexOf(node);
            if (index != -1)
                return this.sourceElements[index];
        }

        var lines;

        var url = HTMLLib.getSourceHref(node);
        if (url)
        {
            lines = this.context.sourceCache.load(url);
        }
        else
        {
            var text = HTMLLib.getSourceText(node);
            lines = Str.splitLines(text);
        }

        var sourceElt = new Firebug.HTMLModule.SourceText(lines, node);

        if (!this.sourceElements)
        {
            this.sourceElements =  [sourceElt];
            this.sourceElementNodes = [node];
        }
        else
        {
            this.sourceElements.push(sourceElt);
            this.sourceElementNodes.push(node);
        }

        return sourceElt;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    registerMutationListeners: function(win)
    {
        var context = this.context;
        if (!context.registeredHTMLMutationObservers)
            context.registeredHTMLMutationObservers = new WeakMap();

        var self = this;
        function addObserver(win)
        {
            var doc = win.document;
            if (context.registeredHTMLMutationObservers.has(doc))
                return;

            // xxxHonza: an iframe doesn't have to be loaded yet, so do not
            // register mutation observers in such cases since they wouldn't
            // be removed.
            // The listeners can be registered later in watchWindowDelayed,
            // but it's also risky. Mutation observers should be registered
            // at the moment when it's clear that the window/frame has been
            // loaded.

            // This breaks HTML panel for about:blank pages (see issue 5120).
            //if (doc.location == "about:blank")
            //    return;

            var observer = new MutationObserver(self.onMutationObserve);
            observer.observe(doc, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
            context.registeredHTMLMutationObservers.set(doc, observer);
        }

        // If a window is specified use it, otherwise register observers for all
        // context windows (including the main window and all embedded iframes).
        if (win)
            addObserver(win);
        else
            Win.iterateWindows(this.context.window, addObserver);

        this.registerMutationBreakpointListeners(win);
    },

    unregisterMutationListeners: function(win)
    {
        this.unregisterMutationBreakpointListeners(win);

        var context = this.context;
        if (!context.registeredHTMLMutationObservers)
            return;

        function removeObserver(win)
        {
            var doc = win.document;
            var observer = context.registeredHTMLMutationObservers.get(doc);
            if (!observer)
                return;

            observer.disconnect();
            context.registeredHTMLMutationObservers.delete(doc);
        }

        if (win)
            removeObserver(win);
        else
            Win.iterateWindows(context.window, removeObserver);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    registerMutationBreakpointListeners: function(win)
    {
        var context = this.context;
        if (!context.mutationBreakpointListenersEnabled)
            return;

        if (!context.registeredHTMLMutationEvents)
            context.registeredHTMLMutationEvents = new WeakMap();

        var self = this;
        function addListeners(win)
        {
            var doc = win.document;
            if (context.registeredHTMLMutationEvents.has(doc))
                return;
            context.registeredHTMLMutationEvents.set(doc, 1);

            // (See also the changes in registerMutationListeners's addObserver)
            Events.addEventListener(doc, "DOMAttrModified", self.onMutateAttr, false);
            Events.addEventListener(doc, "DOMCharacterDataModified", self.onMutateText, false);
            Events.addEventListener(doc, "DOMNodeInserted", self.onMutateNode, false);
            Events.addEventListener(doc, "DOMNodeRemoved", self.onMutateNode, false);
        }

        if (win)
            addListeners(win);
        else
            Win.iterateWindows(context.window, addListeners);
    },

    unregisterMutationBreakpointListeners: function(win)
    {
        var context = this.context;
        if (!context.mutationBreakpointListenersEnabled)
            return;

        if (!context.registeredHTMLMutationEvents)
            return;

        var self = this;
        function removeListeners(win)
        {
            var doc = win.document;
            if (!context.registeredHTMLMutationEvents.has(doc))
                return;
            context.registeredHTMLMutationEvents.delete(doc);

            Events.removeEventListener(doc, "DOMAttrModified", self.onMutateAttr, false);
            Events.removeEventListener(doc, "DOMCharacterDataModified", self.onMutateText, false);
            Events.removeEventListener(doc, "DOMNodeInserted", self.onMutateNode, false);
            Events.removeEventListener(doc, "DOMNodeRemoved", self.onMutateNode, false);
        }

        if (win)
            removeListeners(win);
        else
            Win.iterateWindows(context.window, removeListeners);
    },

    updateMutationBreakpointListeners: function()
    {
        var context = this.context;
        var isEnabled = !!context.mutationBreakpointListenersEnabled;
        var shouldEnable = this.shouldBreakOnNext() ||
            context.mutationBreakpoints.hasEnabledBreakpoints();
        if (isEnabled === shouldEnable)
            return;
        if (shouldEnable)
        {
            context.mutationBreakpointListenersEnabled = true;
            this.registerMutationBreakpointListeners();
        }
        else
        {
            this.unregisterMutationBreakpointListeners();
            context.mutationBreakpointListenersEnabled = false;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    mutateAttr: function(target, attrName, attrValue, removal)
    {
        // Due to the delay call this may or may not exist in the tree anymore
        if (!this.ioBox.isInExistingRoot(target))
        {
            if (FBTrace.DBG_HTML)
                FBTrace.sysout("mutateAttr: different tree " + target, target);
            return;
        }

        if (FBTrace.DBG_HTML)
        {
            FBTrace.sysout("html.mutateAttr target:" + target + " attrName:" + attrName +
                " attrValue: " + attrValue + " removal: " + removal, target);
        }

        this.markChange();

        var objectNodeBox = Firebug.scrollToMutations || Firebug.expandMutations ?
            this.ioBox.createObjectBox(target) : this.ioBox.findObjectBox(target);

        if (!objectNodeBox)
            return;

        this.updateNodeVisibility(objectNodeBox);

        if (!removal)
        {
            var nodeAttr = HTMLLib.findNodeAttrBox(objectNodeBox, attrName);

            if (FBTrace.DBG_HTML)
                FBTrace.sysout("mutateAttr " + removal + " " + attrName + "=" + attrValue +
                    " node: " + nodeAttr, nodeAttr);

            if (nodeAttr && nodeAttr.childNodes.length > 3)
            {
                var attrValueBox = nodeAttr.getElementsByClassName("nodeValue")[0];
                var attrValueText = attrValueBox.firstChild;
                if (attrValueText)
                    attrValueText.nodeValue = attrValue;
                else
                    attrValueBox.textContent = attrValue;

                this.highlightMutation(attrValueBox, objectNodeBox, "mutated");
            }
            else
            {
                function filterAttributeByName(attr)
                {
                    return attr.name == attrName;
                }

                var attributes = Array.prototype.slice.call(target.attributes);
                var attr = attributes.filter(filterAttributeByName)[0];

                if (FBTrace.DBG_HTML)
                {
                    FBTrace.sysout("mutateAttr attribute node " + removal + " " + attrName +
                        "=" + attrValue + " node: " + attr, attr);
                }

                if (attr)
                {
                    nodeAttr = Firebug.HTMLPanel.AttrNode.tag.replace({attr: attr},
                        this.document);

                    var labelBox = objectNodeBox.querySelector("*> .nodeLabel > .nodeLabelBox");
                    var bracketBox = labelBox.querySelector("*> .nodeBracket");
                    labelBox.insertBefore(nodeAttr, bracketBox);

                    this.highlightMutation(nodeAttr, objectNodeBox, "mutated");
                }
            }
        }
        else
        {
            var nodeAttr = HTMLLib.findNodeAttrBox(objectNodeBox, attrName);
            if (nodeAttr)
                nodeAttr.parentNode.removeChild(nodeAttr);

            // We want to highlight regardless as the domplate may have been
            // generated after the attribute was removed from the node
            this.highlightMutation(objectNodeBox, objectNodeBox, "mutated");
        }

        Firebug.Inspector.repaint();
    },

    mutateText: function(target, parent, textValue)
    {
        // Due to the delay call this may or may not exist in the tree anymore
        if (!this.ioBox.isInExistingRoot(target))
        {
            if (FBTrace.DBG_HTML)
                FBTrace.sysout("mutateText: different tree " + target, target);
            return;
        }

        this.markChange();

        var parentNodeBox = Firebug.scrollToMutations || Firebug.expandMutations ?
            this.ioBox.createObjectBox(parent) : this.ioBox.findObjectBox(parent);

        if (!parentNodeBox)
        {
            if (FBTrace.DBG_HTML)
                FBTrace.sysout("html.mutateText failed to update text, parent node " +
                    "box does not exist");
            return;
        }

        if (!Firebug.showFullTextNodes)
            textValue = Str.cropMultipleLines(textValue);

        var parentTag = getNodeBoxTag(parentNodeBox);
        if (parentTag == Firebug.HTMLPanel.TextElement.tag)
        {
            if (FBTrace.DBG_HTML)
                FBTrace.sysout("html.mutateText target: " + target + " parent: " + parent);

            // Rerender the entire parentNodeBox. Proper entity-display logic will
            // be automatically applied according to the preferences.
            var newParentNodeBox = parentTag.replace({object: parentNodeBox.repObject}, this.document);
            if (parentNodeBox.parentNode)
                parentNodeBox.parentNode.replaceChild(newParentNodeBox, parentNodeBox);

            // Reselect if the element was selected before.
            if (this.selection && (!this.selection.parentNode || parent == this.selection))
                this.ioBox.select(parent, true);

            var nodeText = HTMLLib.getTextElementTextBox(newParentNodeBox);
            if (!nodeText.firstChild)
            {
                if (FBTrace.DBG_HTML)
                {
                    FBTrace.sysout("html.mutateText failed to update text, " +
                        "TextElement firstChild does not exist");
                }
                return;
            }

            // Highlight the text box only (not the entire parentNodeBox/element).
            this.highlightMutation(nodeText, newParentNodeBox, "mutated");
        }
        else
        {
            var childBox = this.ioBox.getChildObjectBox(parentNodeBox);
            if (!childBox)
            {
                if (FBTrace.DBG_HTML)
                {
                    FBTrace.sysout("html.mutateText failed to update text, " +
                        "no child object box found");
                }
                return;
            }

            var textNodeBox = this.ioBox.findChildObjectBox(childBox, target);
            if (textNodeBox)
            {
                // structure for comment and cdata. Are there others?
                textNodeBox.firstChild.firstChild.nodeValue = textValue;

                this.highlightMutation(textNodeBox, parentNodeBox, "mutated");
            }
            else if (Firebug.scrollToMutations || Firebug.expandMutations)
            {
                // We are not currently rendered but we are set to highlight
                var objectBox = this.ioBox.createObjectBox(target);
                this.highlightMutation(objectBox, objectBox, "mutated");
            }
        }
    },

    mutateNode: function(target, parent, nextSibling, removal)
    {
        if (FBTrace.DBG_HTML)
            FBTrace.sysout("html.mutateNode target:" + target + " parent:" + parent +
                (removal ? "REMOVE" : ""));

        // Due to the delay call this may or may not exist in the tree anymore
        if (!removal && !this.ioBox.isInExistingRoot(target))
        {
            if (FBTrace.DBG_HTML)
                FBTrace.sysout("mutateNode: different tree " + target, target);
            return;
        }

        this.markChange();  // This invalidates the panels for every mutate

        var parentNodeBox = Firebug.scrollToMutations || Firebug.expandMutations
            ? this.ioBox.createObjectBox(parent)
            : this.ioBox.findObjectBox(parent);

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("html.mutateNode parent:" + parent + " parentNodeBox:" +
                parentNodeBox);

        if (!parentNodeBox)
            return;

        // Ignore whitespace nodes.
        if (!Firebug.showTextNodesWithWhitespace && this.isWhitespaceText(target))
            return;

        var newParentTag = getNodeTag(parent);
        var oldParentTag = getNodeBoxTag(parentNodeBox);

        var objectBox = null;

        if (newParentTag == oldParentTag)
        {
            if (parentNodeBox.populated)
            {
                if (removal)
                {
                    this.ioBox.removeChildBox(parentNodeBox, target);

                    // Special case for docType.
                    if (target instanceof HTMLHtmlElement)
                        this.ioBox.removeChildBox(parentNodeBox, target.parentNode.doctype);

                    this.highlightMutation(parentNodeBox, parentNodeBox, "mutated");
                }
                else
                {
                    var childBox = this.ioBox.getChildObjectBox(parentNodeBox);

                    var comments = Firebug.showCommentNodes;
                    var whitespaces = Firebug.showTextNodesWithWhitespace;

                    // Get the right next sibling that match following criteria:
                    // 1) It's not a whitespace text node in case 'show whitespaces' is false.
                    // 2) It's not a comment in case 'show comments' is false.
                    // 3) There is a child box already created for it in the HTML panel UI.
                    // The new node will then be inserted before that sibling's child box, or
                    // appended at the end (issue 5255).
                    while (nextSibling && (
                       (!whitespaces && HTMLLib.isWhitespaceText(nextSibling)) ||
                       (!comments && nextSibling instanceof window.Comment) ||
                       (!this.ioBox.findChildObjectBox(childBox, nextSibling))))
                    {
                       nextSibling = this.findNextSibling(nextSibling);
                    }

                    objectBox = nextSibling ?
                        this.ioBox.insertChildBoxBefore(parentNodeBox, target, nextSibling) :
                        this.ioBox.appendChildBox(parentNodeBox, target);

                    // Special case for docType.
                    if (target instanceof HTMLHtmlElement)
                    {
                        this.ioBox.insertChildBoxBefore(parentNodeBox,
                            target.parentNode.doctype, target);
                    }

                    this.highlightMutation(objectBox, objectBox, "mutated");
                }
            }
            else // !parentNodeBox.populated
            {
                var newParentNodeBox = newParentTag.replace({object: parent}, this.document);
                parentNodeBox.parentNode.replaceChild(newParentNodeBox, parentNodeBox);

                if (this.selection && (!this.selection.parentNode || parent == this.selection))
                    this.ioBox.select(parent, true);

                this.highlightMutation(newParentNodeBox, newParentNodeBox, "mutated");

                if (!removal && (Firebug.scrollToMutations || Firebug.expandMutations))
                {
                    objectBox = this.ioBox.createObjectBox(target);
                    this.highlightMutation(objectBox, objectBox, "mutated");
                }
            }
        }
        else // newParentTag != oldParentTag
        {
            var newParentNodeBox = newParentTag.replace({object: parent}, this.document);
            if (parentNodeBox.parentNode)
                parentNodeBox.parentNode.replaceChild(newParentNodeBox, parentNodeBox);

            if (Css.hasClass(parentNodeBox, "open"))
                this.ioBox.toggleObjectBox(newParentNodeBox, true);

            if (this.selection && (!this.selection.parentNode || parent == this.selection))
                this.ioBox.select(parent, true);

            this.highlightMutation(newParentNodeBox, newParentNodeBox, "mutated");

            if (!removal && (Firebug.scrollToMutations || Firebug.expandMutations))
            {
                objectBox = this.ioBox.createObjectBox(target);
                this.highlightMutation(objectBox, objectBox, "mutated");
            }
        }

        if (objectBox && this.selection === target)
            this.ioBox.selectObjectBox(objectBox);
    },

    highlightMutation: function(elt, objectBox, type)
    {
        if (FBTrace.DBG_HTML)
            FBTrace.sysout("html.highlightMutation Firebug.highlightMutations:" +
                Firebug.highlightMutations, {elt: elt, objectBox: objectBox, type: type});

        if (!elt)
            return;

        if (Firebug.scrollToMutations || Firebug.expandMutations)
        {
            if (this.context.mutationTimeout)
            {
                this.context.clearTimeout(this.context.mutationTimeout);
                delete this.context.mutationTimeout;
            }

            var ioBox = this.ioBox;
            var panelNode = this.panelNode;

            this.context.mutationTimeout = this.context.setTimeout(function()
            {
                ioBox.openObjectBox(objectBox);

                if (Firebug.scrollToMutations)
                    Dom.scrollIntoCenterView(objectBox, panelNode);
            }, 200);
        }

        if (Firebug.highlightMutations)
            Css.setClassTimed(elt, type, this.context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // InsideOutBoxView implementation

    createObjectBox: function(object, isRoot)
    {
        if (FBTrace.DBG_HTML)
        {
            FBTrace.sysout("html.createObjectBox(" + Css.getElementCSSSelector(object) +
                ", isRoot:" + (isRoot? "true" : "false")+")");
        }

        var tag = getNodeTag(object);
        if (tag)
            return tag.replace({object: object}, this.document);
    },

    getParentObject: function(node)
    {
        if (node instanceof Firebug.HTMLModule.SourceText)
            return node.owner;

        var parentNode = this.getParentNode(node);

        // for chromebug to avoid climbing out to browser.xul
        if (node.nodeName == "#document")
            return null;

        //if (FBTrace.DBG_HTML)
        //    FBTrace.sysout("html.getParentObject for "+node.nodeName+" parentNode:"+
        //        Css.getElementCSSSelector(parentNode));

        if (parentNode)
        {
            if (parentNode.nodeType == Node.DOCUMENT_NODE)
            {
                if (parentNode.defaultView)
                {
                    if (parentNode.defaultView == this.context.window)
                        return parentNode;

                    if (FBTrace.DBG_HTML)
                    {
                        FBTrace.sysout("getParentObject; node is document node"+
                            ", frameElement:" + parentNode.defaultView.frameElement);
                    }

                    return parentNode.defaultView.frameElement;
                }
                else
                {
                    var skipParent = this.getEmbedConnection(parentNode);
                    if (FBTrace.DBG_HTML)
                        FBTrace.sysout("getParentObject skipParent:" +
                            (skipParent ? skipParent.nodeName : "none"));

                    if (skipParent)
                        return skipParent;
                    else
                        return null; // parent is document element, but no window at defaultView.
                }
            }
            else if (!parentNode.localName)
            {
                if (FBTrace.DBG_HTML)
                    FBTrace.sysout("getParentObject: null localName must be window, no parentObject");
                return null;
            }
            else
            {
                return parentNode;
            }
        }
        else
        {
            // Documents have no parentNode; Attr, Document, DocumentFragment, Entity,
            // and Notation. top level windows have no parentNode
            if (node && node.nodeType == Node.DOCUMENT_NODE)
            {
                // generally a reference to the window object for the document, however
                // that is not defined in the specification
                if (node.defaultView)
                {
                    var embeddingFrame = node.defaultView.frameElement;
                    if (embeddingFrame)
                        return embeddingFrame.contentDocument;
                }
                else
                {
                    // a Document object without a parentNode or window
                    return null;  // top level has no parent
                }
            }
        }
    },

    setEmbedConnection: function(node, skipChild)
    {
        if (!this.embeddedBrowserParents)
        {
            this.embeddedBrowserParents = [];
            this.embeddedBrowserDocument = [];
        }

        this.embeddedBrowserDocument.push(skipChild);

        // store our adopted child in a side table
        this.embeddedBrowserParents.push(node);

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("Found skipChild " + Css.getElementCSSSelector(skipChild) +
                " for  " + Css.getElementCSSSelector(node) + " with node.contentDocument " +
                node.contentDocument);

        return skipChild;
    },

    getEmbedConnection: function(node)
    {
        if (this.embeddedBrowserParents)
        {
            var index = this.embeddedBrowserParents.indexOf(node);
            if (index !== -1)
                return this.embeddedBrowserDocument[index];
        }
    },

    /**
     * @param: node a DOM node from the Web page
     * @param: index counter for important children, may skip whitespace
     * @param: previousSibling a node from the web page
     */
    getChildObject: function(node, index, previousSibling)
    {
        if (!node)
        {
            FBTrace.sysout("getChildObject: null node");
            return;
        }

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("getChildObject " + node.tagName + " index " + index +
                " previousSibling: " +
                (previousSibling ? Css.getElementCSSSelector(previousSibling) : "null"),
                {node: node, previousSibling:previousSibling});

        if (this.isSourceElement(node))
        {
            if (index == 0)
                return this.getElementSourceText(node);
            else
                return null;  // no siblings of source elements
        }
        else if (node instanceof window.Document)
        {
            if (previousSibling !== null)
                return this.getNextSibling(previousSibling);
            else
                return this.getFirstChild(node);
        }
        else if (node.contentDocument)  // then the node is a frame
        {
            if (index == 0)
            {
                // punch thru and adopt the document node as our child
                var skipChild = node.contentDocument.firstChild;

                // (the node's).(type 9 document).(HTMLElement)
                return this.setEmbedConnection(node, skipChild);
            }
            else if (previousSibling)
            {
                // Next child of a document (after doc-type) is <html>.
                return this.getNextSibling(previousSibling);
            }
        }
        else if (node.getSVGDocument && node.getSVGDocument())  // then the node is a frame
        {
            if (index == 0)
            {
                var skipChild = node.getSVGDocument().documentElement; // unwrap

                // (the node's).(type 9 document).(HTMLElement)
                return this.setEmbedConnection(node, skipChild);
            }
            else
            {
                return null;
            }
        }

        var child;
        if (previousSibling)  // then we are walking
            child = this.getNextSibling(previousSibling);  // may return null, meaning done with iteration.
        else
            child = this.getFirstChild(node); // child is set to at the beginning of an iteration.

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("getChildObject firstChild " + Css.getElementCSSSelector(child) +
                " with Firebug.showTextNodesWithWhitespace " +
                Firebug.showTextNodesWithWhitespace);

        if (Firebug.showTextNodesWithWhitespace)  // then the index is true to the node list
        {
            return child;
        }
        else
        {
            for (; child; child = this.getNextSibling(child))
            {
                if (!this.isWhitespaceText(child))
                    return child;
            }
        }

        return null;  // we have no children worth showing.
    },

    isWhitespaceText: function(node)
    {
        return HTMLLib.isWhitespaceText(node);
    },

    findNextSibling: function (node)
    {
        return HTMLLib.findNextSibling(node);
    },

    isSourceElement: function(element)
    {
        return HTMLLib.isSourceElement(element);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Events

    onMutationObserve: function(records)
    {
        for (var ri = 0; ri < records.length; ++ri)
        {
            var record = records[ri];

            var target = record.target;
            if (Firebug.shouldIgnore(target))
                continue;

            var type = record.type;
            if (type === "attributes")
            {
                var attrName = record.attributeName;
                var newValue = target.getAttribute(attrName);
                var removal = (newValue === null);
                this.context.throttle(this.mutateAttr, this,
                    [target, attrName, newValue, removal]);
            }
            else if (type === "childList")
            {
                var added = record.addedNodes, removed = record.removedNodes;
                if (added.length)
                {
                    var nextSibling = HTMLLib.findNextNodeFrom(record.nextSibling);
                    for (var i = 0; i < added.length; ++i)
                    {
                        var node = added[i];
                        if (Firebug.shouldIgnore(node))
                            continue;
                        this.context.throttle(this.mutateNode, this,
                            [node, target, nextSibling, false]);
                    }
                }
                for (var i = 0; i < removed.length; ++i)
                {
                    var node = removed[i];
                    if (Firebug.shouldIgnore(node))
                        continue;
                    this.context.throttle(this.mutateNode, this,
                        [node, target, null, true]);
                }
            }
            else if (type === "characterData")
            {
                this.context.throttle(this.mutateText, this,
                    [target, target.parentNode, target.data]);
            }
        }
    },

    onMutateAttr: function(event)
    {
        var target = event.target;
        if (Firebug.shouldIgnore(target))
            return;

        Firebug.HTMLModule.MutationBreakpoints.onMutateAttr(event, this.context);
        this.updateMutationBreakpointListeners();
    },

    onMutateText: function(event)
    {
        if (FBTrace.DBG_HTML)
            FBTrace.sysout("html.onMutateText; ", event);

        Firebug.HTMLModule.MutationBreakpoints.onMutateText(event, this.context);
        this.updateMutationBreakpointListeners();
    },

    onMutateNode: function(event)
    {
        var target = event.target;
        if (Firebug.shouldIgnore(target))
            return;

        Firebug.HTMLModule.MutationBreakpoints.onMutateNode(event, this.context);
        this.updateMutationBreakpointListeners();
    },

    onClick: function(event)
    {
        if (Events.isLeftClick(event) && Events.isDoubleClick(event))
        {
            // The double-click expands an HTML element, but the user must click
            // on the element itself not on the twisty.
            // The logic should be as follows:
            // - click on the twisty expands/collapses the element
            // - double click on the element name expands/collapses it
            // - click on the element name selects it
            if (!Css.hasClass(event.target, "twisty") && !Css.hasClass(event.target, "nodeLabel"))
                this.toggleNode(event);
        }
        else if (Events.isAltClick(event) && !this.editing)
        {
            var node = Firebug.getRepObject(event.target);
            this.editNode(node);
            this.setEditEnableState();
        }
        else if (Dom.getAncestorByClass(event.target, "nodeBracket"))
        {
            var bracketBox = Dom.getAncestorByClass(event.target, "nodeBracket");
            Editor.insertRow(bracketBox, "before");
        }
    },

    onMouseDown: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        if (Dom.getAncestorByClass(event.target, "nodeTag"))
        {
            var node = Firebug.getRepObject(event.target);
            this.noScrollIntoView = true;
            this.select(node);

            delete this.noScrollIntoView;

            if (Css.hasClass(event.target, "twisty"))
                this.toggleNode(event);
        }
    },

    toggleNode: function(event)
    {
        var node = Firebug.getRepObject(event.target);
        var box = this.ioBox.createObjectBox(node);
        if (!Css.hasClass(box, "open"))
            this.ioBox.expandObject(node);
        else
            this.ioBox.contractObject(this.selection);
    },

    onKeyPress: function(event)
    {
        if (this.editing)
            return;

        var node = this.selection;
        if (!node)
            return;

        // * expands the node with all its children
        // + expands the node
        // - collapses the node
        var ch = String.fromCharCode(event.charCode);
        if (ch == "*")
            this.toggleAll(event, node);

        // Edit the HTML on Ctrl/Meta+E
        if (Events.isControl(event) && ch === "e")
            this.editNode(node);

        if (!Events.noKeyModifiers(event))
          return;

        if (ch == "+")
            this.ioBox.expandObject(node);
        else if (ch == "-")
            this.ioBox.contractObject(node);

        if (event.keyCode == KeyEvent.DOM_VK_UP)
            this.selectNodeBy("up");
        else if (event.keyCode == KeyEvent.DOM_VK_DOWN)
            this.selectNodeBy("down");
        else if (event.keyCode == KeyEvent.DOM_VK_LEFT)
            this.selectNodeBy("left");
        else if (event.keyCode == KeyEvent.DOM_VK_RIGHT)
            this.selectNodeBy("right");
        else if (event.keyCode == KeyEvent.DOM_VK_BACK_SPACE)
        {
            if (!Css.nonDeletableTags.hasOwnProperty(node.localName))
                this.deleteNode(node, "up");
        }
        else if (event.keyCode == KeyEvent.DOM_VK_DELETE)
        {
            if (!Css.nonDeletableTags.hasOwnProperty(node.localName))
                this.deleteNode(node, "down");
        }
        else
            return;

        Events.cancelEvent(event);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // CSS Listener

    updateVisibilitiesForSelectorInSheet: function(sheet, selector)
    {
        if (!selector)
            return;
        var doc = (sheet && sheet.ownerNode && sheet.ownerNode.ownerDocument);
        if (!doc)
            return;

        var affected = doc.querySelectorAll(selector);
        if (!affected.length || !this.ioBox.isInExistingRoot(affected[0]))
            return;

        for (var i = 0; i < affected.length; ++i)
        {
            var node = this.ioBox.findObjectBox(affected[i]);
            if (node)
                this.updateNodeVisibility(node);
        }
    },

    updateVisibilitiesForRule: function(rule)
    {
        this.updateVisibilitiesForSelectorInSheet(rule.parentStyleSheet, rule.selectorText);
    },

    cssPropAffectsVisibility: function(propName)
    {
        // Pretend that "display" is the only property which affects visibility,
        // which is a half-truth. We could make this more technically correct
        // by unconditionally returning true, but forcing a synchronous reflow
        // and computing offsetWidth/Height on up to every element on the page
        // isn't worth it.
        return (propName === "display");
    },

    cssTextAffectsVisibility: function(cssText)
    {
        return (cssText.indexOf("display:") !== -1);
    },

    onAfterCSSDeleteRule: function(styleSheet, cssText, selector)
    {
        if (this.cssTextAffectsVisibility(cssText))
            this.updateVisibilitiesForSelectorInSheet(styleSheet, selector);
    },

    onCSSInsertRule: function(styleSheet, cssText, ruleIndex)
    {
        if (this.cssTextAffectsVisibility(cssText))
            this.updateVisibilitiesForRule(styleSheet.cssRules[ruleIndex]);
    },

    onCSSSetProperty: function(style, propName, propValue, propPriority, prevValue,
        prevPriority, rule, baseText)
    {
        if (this.cssPropAffectsVisibility(propName))
            this.updateVisibilitiesForRule(rule);
    },

    onCSSRemoveProperty: function(style, propName, prevValue, prevPriority, rule, baseText)
    {
        if (this.cssPropAffectsVisibility(propName))
            this.updateVisibilitiesForRule(rule);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    name: "html",
    searchable: true,
    searchPlaceholder: "search.html.Search_by_text_or_CSS_selector",
    breakable: true,
    dependents: ["css", "computed", "layout", "dom", "domSide", "watch"],
    inspectorHistory: new Array(5),
    enableA11y: true,
    order: 20,

    initialize: function()
    {
        this.onMutationObserve = this.onMutationObserve.bind(this);
        this.onMutateText = this.onMutateText.bind(this);
        this.onMutateAttr = this.onMutateAttr.bind(this);
        this.onMutateNode = this.onMutateNode.bind(this);
        this.onClick = this.onClick.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onKeyPress = this.onKeyPress.bind(this);

        Panel.initialize.apply(this, arguments);
        Firebug.CSSModule.addListener(this);
    },

    destroy: function(state)
    {
        Persist.persistObjects(this, state);

        Panel.destroy.apply(this, arguments);

        delete this.embeddedBrowserParents;
        delete this.embeddedBrowserDocument;

        // xxxHonza: I don't know why this helps, but it helps to release the
        // page compartment (at least by observing about:memory);
        // Note that inspectorHistory holds references to page elements.
        for (var i=0; i<this.inspectorHistory.length; i++)
            delete this.inspectorHistory[i];
        delete this.inspectorHistory;

        Firebug.CSSModule.removeListener(this);
        this.unregisterMutationListeners();
    },

    initializeNode: function(oldPanelNode)
    {
        if (!this.ioBox)
            this.ioBox = new Firebug.InsideOutBox(this, this.panelNode);

        Events.addEventListener(this.panelNode, "click", this.onClick, false);
        Events.addEventListener(this.panelNode, "mousedown", this.onMouseDown, false);

        Panel.initializeNode.apply(this, arguments);
    },

    destroyNode: function()
    {
        Events.removeEventListener(this.panelNode, "click", this.onClick, false);
        Events.removeEventListener(this.panelNode, "mousedown", this.onMouseDown, false);

        Events.removeEventListener(this.panelNode.ownerDocument, "keypress",
            this.onKeyPress, true);

        if (this.ioBox)
        {
            this.ioBox.destroy();
            delete this.ioBox;
        }

        Panel.destroyNode.apply(this, arguments);
    },

    show: function(state)
    {
        this.showToolbarButtons("fbHTMLButtons", true);
        this.showToolbarButtons("fbStatusButtons", true);

        Events.addEventListener(this.panelNode.ownerDocument, "keypress", this.onKeyPress, true);

        if (this.context.loaded)
        {
            this.registerMutationListeners();

            Persist.restoreObjects(this, state);
        }
    },

    hide: function()
    {
        // clear the state that is tracking the infotip so it is reset after next show()
        delete this.infoTipURL;

        Events.removeEventListener(this.panelNode.ownerDocument, "keypress", this.onKeyPress, true);
    },

    watchWindow: function(context, win)
    {
        var self = this;
        setTimeout(function() {
            self.watchWindowDelayed(context, win);
        }, 100);
    },

    watchWindowDelayed: function(context, win)
    {
        if (this.context.window && this.context.window != win)
        {
            // then I guess we are an embedded window
            var htmlPanel = this;
            Win.iterateWindows(this.context.window, function(subwin)
            {
                if (win == subwin)
                {
                    if (FBTrace.DBG_HTML)
                        FBTrace.sysout("html.watchWindow found subwin.location.href="+
                            win.location.href);

                    htmlPanel.mutateDocumentEmbedded(win, false);
                }
            });
        }

        this.registerMutationListeners(win);
    },

    unwatchWindow: function(context, win)
    {
        if (this.context.window && this.context.window != win)
        {
            // then I guess we are an embedded window
            var htmlPanel = this;
            Win.iterateWindows(this.context.window, function(subwin)
            {
                if (win == subwin)
                {
                    if (FBTrace.DBG_HTML)
                        FBTrace.sysout("html.unwatchWindow found subwin.location.href="+
                            win.location.href);

                    htmlPanel.mutateDocumentEmbedded(win, true);
                }
            });
        }

        this.unregisterMutationListeners(win);
    },

    mutateDocumentEmbedded: function(win, remove)
    {
        //xxxHonza: win.document.documentElement is null if this method is synchronously
        // called after watchWindow. This is why watchWindowDelayed is introduced.
        // See issue 3342

        // document.documentElement - Returns the Element that is a direct child of document.
        // For HTML documents, this normally the HTML element.
        var target = win.document.documentElement;
        var parent = win.frameElement;
        var nextSibling = this.findNextSibling(target || parent);
        try
        {
            this.mutateNode(target, parent, nextSibling, remove);
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("html.mutateDocumentEmbedded FAILS " + exc, exc);
        }
    },

    supportsObject: function(object, type)
    {
        if (object instanceof window.Element || object instanceof window.Text ||
            object instanceof window.CDATASection)
        {
            return 2;
        }
        else if (object instanceof SourceLink.SourceLink && object.type == "css" &&
            !Url.reCSS.test(object.href))
        {
            return 2;
        }
        else
        {
            return 0;
        }
    },

    updateOption: function(name, value)
    {
        var options = new Set();
        options.add("showCommentNodes");
        options.add("entityDisplay");
        options.add("showTextNodesWithWhitespace");
        options.add("showFullTextNodes");

        if (options.has(name))
        {
            this.resetSearch();
            Dom.clearNode(this.panelNode);
            if (this.ioBox)
                this.ioBox.destroy();

            this.ioBox = new Firebug.InsideOutBox(this, this.panelNode);
            this.ioBox.select(this.selection, true, true);
        }
    },

    updateSelection: function(object)
    {
        if (FBTrace.DBG_HTML)
            FBTrace.sysout("html.updateSelection " + object, object);

        if (this.ioBox.sourceRow)
            this.ioBox.sourceRow.removeAttribute("exe_line");

        // && object.type == "css" and !Url.reCSS(object.href) by supports
        if (object instanceof SourceLink.SourceLink)
        {
            var sourceLink = object;
            var stylesheet = Css.getStyleSheetByHref(sourceLink.href, this.context);
            if (stylesheet)
            {
                var ownerNode = stylesheet.ownerNode;

                if (FBTrace.DBG_CSS)
                {
                    FBTrace.sysout("html panel updateSelection stylesheet.ownerNode=" +
                        stylesheet.ownerNode + " href:" + sourceLink.href);
                }

                if (ownerNode)
                {
                    var objectbox = this.ioBox.select(ownerNode, true, true, this.noScrollIntoView);

                    // XXXjjb seems like this could be bad for errors at the end of long files
                    // first source row in style
                    var sourceRow = objectbox.getElementsByClassName("sourceRow").item(0);
                    for (var lineNo = 1; lineNo < sourceLink.line; lineNo++)
                    {
                        if (!sourceRow) break;
                        sourceRow = Dom.getNextByClass(sourceRow,  "sourceRow");
                    }

                    if (FBTrace.DBG_CSS)
                    {
                        FBTrace.sysout("html panel updateSelection sourceLink.line=" +
                            sourceLink.line + " sourceRow=" +
                            (sourceRow ? sourceRow.innerHTML : "undefined"));
                    }

                    if (sourceRow)
                    {
                        this.ioBox.sourceRow = sourceRow;
                        this.ioBox.sourceRow.setAttribute("exe_line", "true");

                        Dom.scrollIntoCenterView(sourceRow);

                        // sourceRow isn't an objectBox, but the function should work anyway...
                        this.ioBox.selectObjectBox(sourceRow, false);
                    }
                }
            }
        }
        else if (Firebug.Inspector.inspecting)
        {
            this.ioBox.highlight(object);
        }
        else
        {
            var found = this.ioBox.select(object, true, false, this.noScrollIntoView);
            if (!found)
            {
                // Look up for an enclosing parent. NB this will mask failures in createObjectBoxes
                var parentNode = this.getParentObject(object);

                if (FBTrace.DBG_ERRORS && FBTrace.DBG_HTML)
                    FBTrace.sysout("html.updateSelect no objectBox for object:"+
                        Css.getElementCSSSelector(object) + " trying "+
                        Css.getElementCSSSelector(parentNode));

                this.updateSelection(parentNode);
                return;
            }

            this.inspectorHistory.unshift(object);
            if (this.inspectorHistory.length > 5)
                this.inspectorHistory.pop();
        }
    },

    stopInspecting: function(object, canceled)
    {
        if (object != this.inspectorHistory)
        {
            // Manage history of selection for later access in the command line.
            this.inspectorHistory.unshift(object);
            if (this.inspectorHistory.length > 5)
                this.inspectorHistory.pop();

            if (FBTrace.DBG_HTML)
                FBTrace.sysout("html.stopInspecting: inspectoryHistory updated",
                    this.inspectorHistory);
        }

        this.ioBox.highlight(null);

        if (!canceled)
            this.ioBox.select(object, true);
    },

    search: function(text, reverse)
    {
        if (!text)
            return;

        var search;
        if (text == this.searchText && this.lastSearch)
        {
            search = this.lastSearch;
        }
        else
        {
            var doc = this.context.window.document;
            search = this.lastSearch = new HTMLLib.NodeSearch(text, doc, this.panelNode, this.ioBox);
        }

        var loopAround = search.find(reverse, Firebug.Search.isCaseSensitive(text));
        if (loopAround)
        {
            this.resetSearch();
            this.search(text, reverse);
        }

        return !search.noMatch && (loopAround ? "wraparound" : true);
    },

    shouldIgnoreIntermediateSearchFailure: function(value)
    {
        // Ignore failures for values that, according to the auto-completion system,
        // can be extended into valid selectors, or that are obviously incomplete
        // selectors.
        var editor = new CSSSelectorEditor();
        var range = editor.getAutoCompleteRange(value, value.length);
        var preExpr = value.slice(0, range.start);
        var expr = value.slice(range.start);

        if (preExpr.lastIndexOf("[") > preExpr.lastIndexOf("]"))
            return true;
        if (preExpr.lastIndexOf("(") > preExpr.lastIndexOf(")"))
            return true;

        var list = editor.getAutoCompleteList(preExpr, expr, "", range, false, this.context, {});
        return list && list.some(function(x)
        {
            return x.startsWith(expr);
        });
    },

    getSearchOptionsMenuItems: function()
    {
        return [
            Firebug.Search.searchOptionMenu("search.Case_Sensitive", "searchCaseSensitive",
                "search.tip.Case_Sensitive")
        ];
    },

    getDefaultSelection: function()
    {
        try
        {
            var doc = this.context.window.document;
            return doc.body ? doc.body : Dom.getPreviousElement(doc.documentElement.lastChild);
        }
        catch (exc)
        {
            return null;
        }
    },

    getObjectPath: function(element)
    {
        var path = [];
        for (; element; element = this.getParentObject(element))
        {
            // Ignore the document itself, it shouldn't be displayed in
            // the object path (aka breadcrumbs).
            if (element instanceof window.Document)
                continue;

            // Ignore elements without parent
            if (!element.parentNode)
                continue;

            path.push(element);
        }
        return path;
    },

    getPopupObject: function(target)
    {
        return Firebug.getRepObject(target);
    },

    getTooltipObject: function(target)
    {
        if (Dom.getAncestorByClass(target, "nodeLabelBox") ||
            Dom.getAncestorByClass(target, "nodeCloseLabelBox"))
        {
            return Firebug.getRepObject(target);
        }
    },

    getOptionsMenuItems: function()
    {
        return [
            Menu.optionMenu("ShowFullText", "showFullTextNodes",
                "html.option.tip.Show_Full_Text"),
            Menu.optionMenu("ShowWhitespace", "showTextNodesWithWhitespace",
                "html.option.tip.Show_Whitespace"),
            Menu.optionMenu("ShowComments", "showCommentNodes",
                "html.option.tip.Show_Comments"),
            "-",
            {
                label: "html.option.Show_Entities_As_Symbols",
                tooltiptext: "html.option.tip.Show_Entities_As_Symbols",
                type: "radio",
                name: "entityDisplay",
                id: "entityDisplaySymbols",
                command: Obj.bind(this.setEntityDisplay, this, "symbols"),
                checked: Options.get("entityDisplay") == "symbols"
            },
            {
                label: "html.option.Show_Entities_As_Names",
                tooltiptext: "html.option.tip.Show_Entities_As_Names",
                type: "radio",
                name: "entityDisplay",
                id: "entityDisplayNames",
                command: Obj.bind(this.setEntityDisplay, this, "names"),
                checked: Options.get("entityDisplay") == "names"
            },
            {
                label: "html.option.Show_Entities_As_Unicode",
                tooltiptext: "html.option.tip.Show_Entities_As_Unicode",
                type: "radio",
                name: "entityDisplay",
                id: "entityDisplayUnicode",
                command: Obj.bind(this.setEntityDisplay, this, "unicode"),
                checked: Options.get("entityDisplay") == "unicode"
            },
            "-",
            Menu.optionMenu("HighlightMutations", "highlightMutations",
                "html.option.tip.Highlight_Mutations"),
            Menu.optionMenu("ExpandMutations", "expandMutations",
                "html.option.tip.Expand_Mutations"),
            Menu.optionMenu("ScrollToMutations", "scrollToMutations",
                "html.option.tip.Scroll_To_Mutations"),
            "-",
            Menu.optionMenu("ShadeBoxModel", "shadeBoxModel",
                "inspect.option.tip.Shade_Box_Model"),
            Menu.optionMenu("ShowQuickInfoBox","showQuickInfoBox",
                "inspect.option.tip.Show_Quick_Info_Box")
        ];
    },

    getContextMenuItems: function(node, target)
    {
        if (!node)
            return null;

        var items = [];

        if (node.nodeType == Node.ELEMENT_NODE)
        {
            items.push(
                "-",
                {
                    label: "NewAttribute",
                    id: "htmlNewAttribute",
                    tooltiptext: "html.tip.New_Attribute",
                    command: Obj.bindFixed(this.editNewAttribute, this, node)
                }
            );

            var attrBox = Dom.getAncestorByClass(target, "nodeAttr");
            if (Dom.getAncestorByClass(target, "nodeAttr"))
            {
                var attrName = attrBox.childNodes[1].textContent;

                items.push(
                    {
                        label: Locale.$STRF("EditAttribute", [attrName]),
                        tooltiptext: Locale.$STRF("html.tip.Edit_Attribute", [attrName]),
                        nol10n: true,
                        command: Obj.bindFixed(this.editAttribute, this, node, attrName)
                    },
                    {
                        label: Locale.$STRF("DeleteAttribute", [attrName]),
                        tooltiptext: Locale.$STRF("html.tip.Delete_Attribute", [attrName]),
                        nol10n: true,
                        command: Obj.bindFixed(this.deleteAttribute, this, node, attrName)
                    }
                );
            }

            if (!(Css.nonEditableTags.hasOwnProperty(node.localName)))
            {
                var type;

                if (Xml.isElementHTMLOrXHTML(node))
                    type = "HTML";
                else if (Xml.isElementMathML(node))
                    type = "MathML";
                else if (Xml.isElementSVG(node))
                    type = "SVG";
                else if (Xml.isElementXUL(node))
                    type = "XUL";
                else
                    type = "XML";

                items.push("-",
                {
                    label: Locale.$STRF("html.Edit_Node", [type]),
                    tooltiptext: Locale.$STRF("html.tip.Edit_Node", [type]),
                    nol10n: true,
                    acceltext: (Locale.getFormattedKey(window, "accel", "E")),
                    command: Obj.bindFixed(this.editNode, this, node)
                },
                {
                    label: "DeleteElement",
                    tooltiptext: "html.Delete_Element",
                    acceltext: Locale.getFormattedKey(window, null, null, "VK_DELETE"),
                    command: Obj.bindFixed(this.deleteNode, this, node),
                    disabled:(node.localName in Css.innerEditableTags)
                });
            }

            var objectBox = Dom.getAncestorByClass(target, "nodeBox");
            var nodeChildBox = this.ioBox.getChildObjectBox(objectBox);
            if (nodeChildBox)
            {
                items.push(
                    "-",
                    {
                        label: "html.label.Expand/Contract_All",
                        tooltiptext: "html.tip.Expand/Contract_All",
                        acceltext: Locale.getFormattedKey(window, null, "*"),
                        command: Obj.bind(this.toggleAll, this, node)
                    }
                );
            }
        }
        else
        {
            var nodeLabel = Locale.$STR("html.Node");
            items.push(
                "-",
                {
                    label: Locale.$STRF("html.Edit_Node", [nodeLabel]),
                    tooltiptext: Locale.$STRF("html.tip.Edit_Node", [nodeLabel]),
                    nol10n: true,
                    command: Obj.bindFixed(this.editNode, this, node)
                },
                {
                    label: "DeleteNode",
                    tooltiptext: "html.Delete_Node",
                    command: Obj.bindFixed(this.deleteNode, this, node)
                }
            );
        }

        Firebug.HTMLModule.MutationBreakpoints.getContextMenuItems(
            this.context, node, target, items);

        return items;
    },

    showInfoTip: function(infoTip, target, x, y)
    {
        if (!Css.hasClass(target, "nodeValue"))
            return;

        var node = Firebug.getRepObject(target);
        if (node && node.nodeType == Node.ELEMENT_NODE)
        {
            var nodeName = node.localName.toUpperCase();
            var attribute = Dom.getAncestorByClass(target, "nodeAttr");
            var attributeName = attribute.getElementsByClassName("nodeName").item(0).textContent;

            if ((nodeName == "IMG" || nodeName == "INPUT") && attributeName == "src")
            {
                var url = node.src;

                // This state cleared in hide()
                if (url == this.infoTipURL)
                    return true;

                this.infoTipURL = url;
                return CSSInfoTip.populateImageInfoTip(infoTip, url);
            }
        }
    },

    getEditor: function(target, value)
    {
        if (Css.hasClass(target, "nodeName") || Css.hasClass(target, "nodeValue") ||
            Css.hasClass(target, "nodeBracket"))
        {
            if (!this.attrEditor)
                this.attrEditor = new Firebug.HTMLPanel.Editors.Attribute(this.document);

            return this.attrEditor;
        }
        else if (Css.hasClass(target, "nodeComment") || Css.hasClass(target, "nodeCDATA"))
        {
            if (!this.textDataEditor)
                this.textDataEditor = new Firebug.HTMLPanel.Editors.TextData(this.document);

            return this.textDataEditor;
        }
        else if (Css.hasClass(target, "nodeText"))
        {
            if (!this.textNodeEditor)
                this.textNodeEditor = new Firebug.HTMLPanel.Editors.TextNode(this.document);

            return this.textNodeEditor;
        }
    },

    getInspectorVars: function()
    {
        var vars = {};
        for (var i=0; i<this.inspectorHistory.length; i++)
            vars["$"+i] = this.inspectorHistory[i] || null;

        return vars;
    },

    setEntityDisplay: function(event, type)
    {
        Options.set("entityDisplay", type);

        var menuItem = event.target;
        menuItem.setAttribute("checked", "true");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Break on Mutate

    breakOnNext: function(breaking)
    {
        Firebug.HTMLModule.MutationBreakpoints.breakOnNext(this.context, breaking);
        this.updateMutationBreakpointListeners();
    },

    shouldBreakOnNext: function()
    {
        return !!this.context.breakOnNextMutate;
    },

    getBreakOnNextTooltip: function(enabled)
    {
        return (enabled ? Locale.$STR("html.Disable Break On Mutate") :
            Locale.$STR("html.Break On Mutate"));
    }
});

// ********************************************************************************************* //

var AttrTag = Firebug.HTMLPanel.AttrTag =
    SPAN({"class": "nodeAttr editGroup"},
        "&nbsp;", SPAN({"class": "nodeName editable"}, "$attr.name"), "=&quot;",
        SPAN({"class": "nodeValue editable"}, "$attr|getAttrValue"), "&quot;"
    );

var TextTag = Firebug.HTMLPanel.TextTag =
    SPAN({"class": "nodeText editable"},
        FOR("char", "$object|getNodeTextGroups",
            SPAN({"class": "$char.class $char.extra"}, "$char.str")
        )
    );

// ********************************************************************************************* //

Firebug.HTMLPanel.CompleteElement = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox open $object|getHidden", _repObject: "$object", role: "presentation"},
            DIV({"class": "nodeLabel", role: "presentation"},
                SPAN({"class": "nodeLabelBox repTarget", role: "treeitem", "aria-expanded": "false"},
                    "&lt;",
                    SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                    FOR("attr", "$object|attrIterator", AttrTag),
                    SPAN({"class": "nodeBracket"}, "&gt;")
                )
            ),
            DIV({"class": "nodeChildBox", role: "group"},
                FOR("child", "$object|childIterator",
                    TAG("$child|getNodeTag", {object: "$child"})
                )
            ),
            DIV({"class": "nodeCloseLabel", role:"presentation"},
                "&lt;/",
                SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                "&gt;"
             )
        ),

    getNodeTag: function(node)
    {
        return getNodeTag(node, true);
    },

    childIterator: function(node)
    {
        if (node.contentDocument)
            return [node.contentDocument.documentElement];

        if (Firebug.showTextNodesWithWhitespace)
        {
            return Arr.cloneArray(node.childNodes);
        }
        else
        {
            var nodes = [];
            var walker = new HTMLLib.ElementWalker();

            for (var child = walker.getFirstChild(node); child; child = walker.getNextSibling(child))
            {
                if (child.nodeType != Node.TEXT_NODE || !HTMLLib.isWhitespaceText(child))
                    nodes.push(child);
            }

            return nodes;
        }
    }
});

Firebug.HTMLPanel.SoloElement = domplate(Firebug.HTMLPanel.CompleteElement,
{
    tag:
        DIV({"class": "soloElement", onmousedown: "$onMouseDown"},
            Firebug.HTMLPanel.CompleteElement.tag
        ),

    onMouseDown: function(event)
    {
        for (var child = event.target; child; child = child.parentNode)
        {
            if (child.repObject)
            {
                var panel = Firebug.getElementPanel(child);
                Firebug.chrome.select(child.repObject);
                break;
            }
        }
    }
});

Firebug.HTMLPanel.Element = domplate(FirebugReps.Element,
{
    tag:
    DIV({"class": "nodeBox containerNodeBox $object|getHidden", _repObject: "$object",
            role: "presentation"},
        DIV({"class": "nodeLabel", role: "presentation"},
            DIV({"class": "twisty", role: "presentation"}),
            SPAN({"class": "nodeLabelBox repTarget", role: "treeitem", "aria-expanded": "false"},
                "&lt;",
                SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                FOR("attr", "$object|attrIterator", AttrTag),
                SPAN({"class": "nodeBracket editable insertBefore"}, "&gt;")
            )
        ),
        DIV({"class": "nodeChildBox", role: "group"}), /* nodeChildBox is special signal in insideOutBox */
        DIV({"class": "nodeCloseLabel", role: "presentation"},
            SPAN({"class": "nodeCloseLabelBox repTarget"},
                "&lt;/",
                SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                "&gt;"
            )
        )
    )
});

Firebug.HTMLPanel.HTMLDocument = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox documentNodeBox containerNodeBox",
            _repObject: "$object", role: "presentation"},
            DIV({"class": "nodeChildBox", role: "group"})
        )
});

Firebug.HTMLPanel.HTMLDocType = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox docTypeNodeBox containerNodeBox",
            _repObject: "$object", role: "presentation"},
            DIV({"class": "docType"},
                "$object|getDocType"
            )
        ),

    getDocType: function(doctype)
    {
        return "<!DOCTYPE " + doctype.name + (doctype.publicId ? " PUBLIC \"" + doctype.publicId +
            "\"": "") + (doctype.systemId ? " \"" + doctype.systemId + "\"" : "") + ">";
    }
});

Firebug.HTMLPanel.HTMLHtmlElement = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox htmlNodeBox containerNodeBox $object|getHidden",
            _repObject: "$object", role: "presentation"},
            DIV({"class": "nodeLabel", role: "presentation"},
                DIV({"class": "twisty", role: "presentation"}),
                SPAN({"class": "nodeLabelBox repTarget", role: "treeitem",
                    "aria-expanded": "false"},
                    "&lt;",
                    SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                    FOR("attr", "$object|attrIterator", AttrTag),
                    SPAN({"class": "nodeBracket editable insertBefore"}, "&gt;")
                )
            ),
            DIV({"class": "nodeChildBox", role: "group"}), /* nodeChildBox is special signal in insideOutBox */
            DIV({"class": "nodeCloseLabel", role: "presentation"},
                SPAN({"class": "nodeCloseLabelBox repTarget"},
                    "&lt;/",
                    SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                    "&gt;"
                )
            )
        )
});

Firebug.HTMLPanel.TextElement = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox textNodeBox $object|getHidden", _repObject: "$object", role: "presentation"},
            DIV({"class": "nodeLabel", role: "presentation"},
                SPAN({"class": "nodeLabelBox repTarget", role: "treeitem"},
                    "&lt;",
                    SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                    FOR("attr", "$object|attrIterator", AttrTag),
                    SPAN({"class": "nodeBracket editable insertBefore"}, "&gt;"),
                    TextTag,
                    "&lt;/",
                    SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                    "&gt;"
                )
            )
        )
});

Firebug.HTMLPanel.EmptyElement = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox emptyNodeBox $object|getHidden", _repObject: "$object", role: "presentation"},
            DIV({"class": "nodeLabel", role: "presentation"},
                SPAN({"class": "nodeLabelBox repTarget", role: "treeitem"},
                    "&lt;",
                    SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                    FOR("attr", "$object|attrIterator", AttrTag),
                    SPAN({"class": "nodeBracket editable insertBefore"}, "&gt;")
                )
            )
        )
});

Firebug.HTMLPanel.XEmptyElement = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox emptyNodeBox $object|getHidden", _repObject: "$object", role: "presentation"},
            DIV({"class": "nodeLabel", role: "presentation"},
                SPAN({"class": "nodeLabelBox repTarget", role: "treeitem"},
                    "&lt;",
                    SPAN({"class": "nodeTag"}, "$object|getNodeName"),
                    FOR("attr", "$object|attrIterator", AttrTag),
                    SPAN({"class": "nodeBracket editable insertBefore"}, "/&gt;")
                )
            )
        )
});

Firebug.HTMLPanel.AttrNode = domplate(FirebugReps.Element,
{
    tag: AttrTag
});

Firebug.HTMLPanel.TextNode = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox", _repObject: "$object", role: "presentation"},
            TextTag
        )
});

Firebug.HTMLPanel.CDATANode = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox", _repObject: "$object", role: "presentation"},
            "&lt;![CDATA[",
            SPAN({"class": "nodeText nodeCDATA editable"}, "$object.nodeValue"),
            "]]&gt;"
        )
});

Firebug.HTMLPanel.CommentNode = domplate(FirebugReps.Element,
{
    tag:
        DIV({"class": "nodeBox nodeComment", _repObject: "$object", role: "presentation"},
            "&lt;!--",
            SPAN({"class": "nodeComment editable"}, "$object.nodeValue"),
            "--&gt;"
        )
});

// ********************************************************************************************* //
// TextDataEditor

/**
 * TextDataEditor deals with text of comments and cdata nodes
 */
function TextDataEditor(doc)
{
    this.initializeInline(doc);
}

TextDataEditor.prototype = domplate(InlineEditor.prototype,
{
    saveEdit: function(target, value, previousValue)
    {
        var node = Firebug.getRepObject(target);
        if (!node)
            return;

        target.data = value;
        node.data = value;
    }
});

// ********************************************************************************************* //
// TextNodeEditor

/**
 * TextNodeEditor deals with text nodes that do and do not have sibling elements. If
 * there are no sibling elements, the parent is known as a TextElement. In other cases
 * we keep track of their position via a range (this is in part because as people type
 * html, the range will keep track of the text nodes and elements that the user
 * is creating as they type, and this range could be in the middle of the parent
 * elements children).
 */
function TextNodeEditor(doc)
{
    this.initializeInline(doc);
}

TextNodeEditor.prototype = domplate(InlineEditor.prototype,
{
    getInitialValue: function(target, value)
    {
        // The text displayed within the HTML panel can be shortened if the 'Show Full Text'
        // option is false, so get the original textContent from the associated page element
        // (issue 2183).
        var repObject = Firebug.getRepObject(target);
        if (repObject)
            return repObject.textContent;

        return value;
    },

    beginEditing: function(target, value)
    {
        var node = Firebug.getRepObject(target);
        if (!node || node instanceof window.Element)
            return;

        var document = node.ownerDocument;
        this.range = document.createRange();
        this.range.setStartBefore(node);
        this.range.setEndAfter(node);
    },

    endEditing: function(target, value, cancel)
    {
        if (this.range)
        {
            this.range.detach();
            delete this.range;
        }

        // Remove empty groups by default
        return true;
    },

    saveEdit: function(target, value, previousValue)
    {
        var node = Firebug.getRepObject(target);
        if (!node)
            return;

        value = Str.unescapeForTextNode(value || "");
        target.textContent = value;

        if (node instanceof window.Element)
        {
            if (Xml.isElementMathML(node) || Xml.isElementSVG(node))
                node.textContent = value;
            else
                node.innerHTML = value;
        }
        else
        {
            try
            {
                var documentFragment = this.range.createContextualFragment(value);
                var cnl = documentFragment.childNodes.length;
                this.range.deleteContents();
                this.range.insertNode(documentFragment);
                var r = this.range, sc = r.startContainer, so = r.startOffset;
                this.range.setEnd(sc,so+cnl);
            }
            catch (e)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("TextNodeEditor.saveEdit; EXCEPTION " + e, e);
            }
        }
    }
});

// ********************************************************************************************* //
// AttributeEditor

function AttributeEditor(doc)
{
    this.initializeInline(doc);
}

AttributeEditor.prototype = domplate(InlineEditor.prototype,
{
    saveEdit: function(target, value, previousValue)
    {
        var element = Firebug.getRepObject(target);
        if (!element)
            return;

        // XXXstr unescape value
        target.textContent = value;

        if (Css.hasClass(target, "nodeName"))
        {
            if (value != previousValue)
                element.removeAttribute(previousValue);

            if (value)
            {
                var attrValue = Dom.getNextByClass(target, "nodeValue").textContent;
                element.setAttribute(value, attrValue);
            }
            else
            {
                element.removeAttribute(value);
            }
        }
        else if (Css.hasClass(target, "nodeValue"))
        {
            var attrName = Dom.getPreviousByClass(target, "nodeName").textContent;
            element.setAttribute(attrName, value);
        }

        var panel = Firebug.getElementPanel(target);
        Events.dispatch(Firebug.uiListeners, "onObjectChanged", [element, panel]);

        //this.panel.markChange();
    },

    advanceToNext: function(target, charCode)
    {
        if (charCode == 61 /* '=' */ && Css.hasClass(target, "nodeName"))
        {
            return true;
        }
        else if ((charCode == 34 /* '"' */ || charCode == 39 /* ''' */) &&
            Css.hasClass(target, "nodeValue"))
        {
            var nonRestrictiveAttributes =
            [
                "onabort",
                "onblur",
                "onchange",
                "onclick",
                "ondblclick",
                "onerror",
                "onfocus",
                "onkeydown",
                "onkeypress",
                "onkeyup",
                "onload",
                "onmousedown",
                "onmousemove",
                "onmouseout",
                "onmouseover",
                "onmouseup",
                "onreset",
                "onselect",
                "onsubmit",
                "onunload",
                "title",
                "alt",
                "style"
            ];

            var attrName = Dom.getPreviousByClass(target, "nodeName").textContent;

            // This should cover most of the cases where quotes are allowed inside the value
            // See issue 4542
            for (var i = 0; i < nonRestrictiveAttributes.length; i++)
            {
                if (attrName == nonRestrictiveAttributes[i])
                    return false;
            }
            return true;
        }
    },

    insertNewRow: function(target, insertWhere)
    {
        var emptyAttr = {name: "", value: ""};
        var sibling = insertWhere == "before" ? target.previousSibling : target;
        return AttrTag.insertAfter({attr: emptyAttr}, sibling);
    },

    getInitialValue: function(target, value)
    {
        if (value == "")
            return value;

        var element = Firebug.getRepObject(target);
        if (element && element instanceof window.Element)
        {
            // If object that was clicked to edit was
            // attribute value, not attribute name.
            if (Css.hasClass(target, "nodeValue"))
            {
                var attributeName = Dom.getPreviousByClass(target, "nodeName").textContent;
                return element.getAttribute(attributeName);
            }
        }
        return value;
    }
});

// ********************************************************************************************* //
// HTMLEditor

function HTMLEditor(doc)
{
    this.box = this.tag.replace({}, doc, this);
    this.input = this.box.firstChild;
    this.multiLine = true;
    this.tabNavigation = false;
    this.arrowCompletion = false;
}

HTMLEditor.prototype = domplate(BaseEditor,
{
    tag:
        DIV(
            TEXTAREA({"class": "htmlEditor fullPanelEditor", oninput: "$onInput"})
        ),

    getValue: function()
    {
        return this.input.value;
    },

    setValue: function(value)
    {
        return this.input.value = value;
    },

    show: function(target, panel, value, textSize)
    {
        this.target = target;
        this.panel = panel;
        var el = target.repObject;
        if (this.innerEditMode)
        {
            this.editingParent = el;
        }
        else
        {
            this.editingRange = el.ownerDocument.createRange();
            this.editingRange.selectNode(el);
            this.originalLocalName = el.localName;
        }

        this.panel.panelNode.appendChild(this.box);

        this.input.value = value;
        this.input.focus();

        var command = Firebug.chrome.$("cmd_firebug_toggleHTMLEditing");
        command.setAttribute("checked", true);
    },

    hide: function()
    {
        var command = Firebug.chrome.$("cmd_firebug_toggleHTMLEditing");
        command.setAttribute("checked", false);

        this.panel.panelNode.removeChild(this.box);

        delete this.editingParent;
        delete this.editingRange;
        delete this.originalLocalName;
        delete this.target;
        delete this.panel;
    },

    getNewSelection: function(fragment)
    {
        // Get a new element to select in the HTML panel. An element with the
        // same localName is preferred, or just any element. If there is none,
        // we choose the parent instead.
        var found = null;
        var nodes = fragment.childNodes;
        for (var i = 0; i < nodes.length; ++i)
        {
            var n = nodes[i];
            if (n.nodeType === Node.ELEMENT_NODE)
            {
                if (n.localName === this.originalLocalName)
                    return n;
                if (!found)
                    found = n;
            }
        }
        if (found)
            return found;
        return this.editingRange.startContainer;
    },

    saveEdit: function(target, value, previousValue)
    {
        if (this.innerEditMode)
        {
            try
            {
                // xxxHonza: Catch "can't access dead object" exception.
                this.editingParent.innerHTML = value;
            }
            catch (e)
            {
                FBTrace.sysout("htmlPanel.saveEdit; EXCEPTION " + e, e);
            }
        }
        else
        {
            try
            {
                var range = this.editingRange;
                var fragment = range.createContextualFragment(value);
                var sel = this.getNewSelection(fragment);

                var cnl = fragment.childNodes.length;
                range.deleteContents();
                range.insertNode(fragment);
                var sc = range.startContainer, so = range.startOffset;
                range.setEnd(sc, so + cnl);

                this.panel.select(sel, false, true);

                // Clear and update the status path, to make sure it doesn't
                // show elements no longer in the DOM.
                Firebug.chrome.clearStatusPath();
                Firebug.chrome.syncStatusPath();
            }
            catch (e)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("HTMLEditor.saveEdit; EXCEPTION " + e, e);
            }
        }
    },

    endEditing: function()
    {
        //this.panel.markChange();
        this.panel.setEditEnableState(true);
        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onInput: function()
    {
        Editor.update();
    }
});

// ********************************************************************************************* //
// Editors

Firebug.HTMLPanel.Editors = {
    html : HTMLEditor,
    Attribute : AttributeEditor,
    TextNode: TextNodeEditor,
    TextData: TextDataEditor
};

// ********************************************************************************************* //
// Local Helpers

function getEmptyElementTag(node)
{
    var isXhtml = Xml.isElementXHTML(node);
    if (isXhtml)
        return Firebug.HTMLPanel.XEmptyElement.tag;
    else
        return Firebug.HTMLPanel.EmptyElement.tag;
}

function getNodeTag(node, expandAll)
{
    if (node instanceof window.Element)
    {
        if (node instanceof window.HTMLHtmlElement && node.ownerDocument && node.ownerDocument.doctype)
            return Firebug.HTMLPanel.HTMLHtmlElement.tag;
        else if (node instanceof window.HTMLAppletElement)
            return getEmptyElementTag(node);
        else if (Firebug.shouldIgnore(node))
            return null;
        else if (HTMLLib.isContainerElement(node))
            return expandAll ? Firebug.HTMLPanel.CompleteElement.tag : Firebug.HTMLPanel.Element.tag;
        else if (HTMLLib.isEmptyElement(node))
            return getEmptyElementTag(node);
        else if (Firebug.showCommentNodes && HTMLLib.hasCommentChildren(node))
            return expandAll ? Firebug.HTMLPanel.CompleteElement.tag : Firebug.HTMLPanel.Element.tag;
        else if (HTMLLib.hasNoElementChildren(node))
            return Firebug.HTMLPanel.TextElement.tag;
        else
            return expandAll ? Firebug.HTMLPanel.CompleteElement.tag : Firebug.HTMLPanel.Element.tag;
    }
    else if (node instanceof window.Text)
        return Firebug.HTMLPanel.TextNode.tag;
    else if (node instanceof window.CDATASection)
        return Firebug.HTMLPanel.CDATANode.tag;
    else if (node instanceof window.Comment && (Firebug.showCommentNodes || expandAll))
        return Firebug.HTMLPanel.CommentNode.tag;
    else if (node instanceof Firebug.HTMLModule.SourceText)
        return FirebugReps.SourceText.tag;
    else if (node instanceof window.Document)
        return Firebug.HTMLPanel.HTMLDocument.tag;
    else if (node instanceof window.DocumentType)
        return Firebug.HTMLPanel.HTMLDocType.tag;
    else
        return FirebugReps.Nada.tag;
}

function getNodeBoxTag(nodeBox)
{
    var re = /([^\s]+)NodeBox/;
    var m = re.exec(nodeBox.className);
    if (!m)
        return null;

    var nodeBoxType = m[1];
    if (nodeBoxType == "container")
        return Firebug.HTMLPanel.Element.tag;
    else if (nodeBoxType == "text")
        return Firebug.HTMLPanel.TextElement.tag;
    else if (nodeBoxType == "empty")
        return Firebug.HTMLPanel.EmptyElement.tag;
}

// ********************************************************************************************* //

Firebug.HTMLModule.SourceText = function(lines, owner)
{
    this.lines = lines;
    this.owner = owner;
};

Firebug.HTMLModule.SourceText.getLineAsHTML = function(lineNo)
{
    return Str.escapeForSourceLine(this.lines[lineNo-1]);
};

// ********************************************************************************************* //
// Mutation Breakpoints

/**
 * @class Represents {@link Firebug.Debugger} listener. This listener is reponsible for
 * providing a list of mutation-breakpoints into the Breakpoints side-panel.
 */
Firebug.HTMLModule.DebuggerListener =
{
    getBreakpoints: function(context, groups)
    {
        if (!context.mutationBreakpoints.isEmpty())
            groups.push(context.mutationBreakpoints);
    }
};

Firebug.HTMLModule.MutationBreakpoints =
{
    breakOnNext: function(context, breaking)
    {
        context.breakOnNextMutate = breaking;
    },

    breakOnNextMutate: function(event, context, type)
    {
        if (!context.breakOnNextMutate)
            return false;

        // Ignore changes in ignored branches
        if (isAncestorIgnored(event.target))
            return false;

        context.breakOnNextMutate = false;

        this.breakWithCause(event, context, type);
    },

    breakWithCause: function(event, context, type)
    {
        var changeLabel = Firebug.HTMLModule.BreakpointRep.getChangeLabel({type: type});
        context.breakingCause = {
            title: Locale.$STR("html.Break On Mutate"),
            message: changeLabel,
            type: event.type,
            target: event.target,
            relatedNode: event.relatedNode, // http://www.w3.org/TR/DOM-Level-2-Events/events.html
            prevValue: event.prevValue,
            newValue: event.newValue,
            attrName: event.attrName,
            attrChange: event.attrChange,
        };

        Firebug.Breakpoint.breakNow(context.getPanel("html", true));
        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Mutation event handlers.

    onMutateAttr: function(event, context)
    {
        if (this.breakOnNextMutate(event, context, BP_BREAKONATTRCHANGE))
            return;

        var breakpoints = context.mutationBreakpoints;
        var self = this;
        breakpoints.enumerateBreakpoints(function(bp) {
            if (bp.checked && bp.node == event.target && bp.type == BP_BREAKONATTRCHANGE) {
                self.breakWithCause(event, context, BP_BREAKONATTRCHANGE);
                return true;
            }
        });
    },

    onMutateText: function(event, context)
    {
        if (this.breakOnNextMutate(event, context, BP_BREAKONTEXT))
            return;
    },

    onMutateNode: function(event, context)
    {
        var node = event.target;
        var removal = event.type == "DOMNodeRemoved";

        if (this.breakOnNextMutate(event, context, removal ?
            BP_BREAKONREMOVE : BP_BREAKONCHILDCHANGE))
        {
            return;
        }

        var breakpoints = context.mutationBreakpoints;
        var breaked = false;

        if (removal)
        {
            var self = this;
            breaked = breakpoints.enumerateBreakpoints(function(bp) {
                if (bp.checked && bp.node == node && bp.type == BP_BREAKONREMOVE) {
                    self.breakWithCause(event, context, BP_BREAKONREMOVE);
                    return true;
                }
            });
        }

        if (!breaked)
        {
            // Collect all parents of the mutated node.
            var parents = [];
            for (var parent = node.parentNode; parent; parent = parent.parentNode)
                parents.push(parent);

            // Iterate over all parents and see if some of them has a breakpoint.
            var self = this;
            breakpoints.enumerateBreakpoints(function(bp)
            {
                for (var i=0; i<parents.length; i++)
                {
                    if (bp.checked && bp.node == parents[i] && bp.type == BP_BREAKONCHILDCHANGE)
                    {
                        self.breakWithCause(event, context, BP_BREAKONCHILDCHANGE);
                        return true;
                    }
                }
            });
        }

        if (removal)
        {
            // Remove all breakpoints associated with removed node.
            var invalidate = false;
            breakpoints.enumerateBreakpoints(function(bp)
            {
                if (bp.node == node)
                {
                    breakpoints.removeBreakpoint(bp);
                    invalidate = true;
                }
            });

            if (invalidate)
                context.invalidatePanels("breakpoints");
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Context menu items

    getContextMenuItems: function(context, node, target, items)
    {
        if (!(node && node.nodeType == Node.ELEMENT_NODE))
            return;

        var breakpoints = context.mutationBreakpoints;

        var attrBox = Dom.getAncestorByClass(target, "nodeAttr");
        if (Dom.getAncestorByClass(target, "nodeAttr"))
        {
        }

        if (!(Css.nonEditableTags.hasOwnProperty(node.localName)))
        {
            items.push(
                "-",
                {
                    label: "html.label.Break_On_Attribute_Change",
                    tooltiptext: "html.tip.Break_On_Attribute_Change",
                    type: "checkbox",
                    checked: breakpoints.findBreakpoint(node, BP_BREAKONATTRCHANGE),
                    command: Obj.bindFixed(this.onModifyBreakpoint, this, context, node,
                        BP_BREAKONATTRCHANGE)
                },
                {
                    label: "html.label.Break_On_Child_Addition_or_Removal",
                    tooltiptext: "html.tip.Break_On_Child_Addition_or_Removal",
                    type: "checkbox",
                    checked: breakpoints.findBreakpoint(node, BP_BREAKONCHILDCHANGE),
                    command: Obj.bindFixed(this.onModifyBreakpoint, this, context, node,
                        BP_BREAKONCHILDCHANGE)
                },
                {
                    label: "html.label.Break_On_Element_Removal",
                    tooltiptext: "html.tip.Break_On_Element_Removal",
                    type: "checkbox",
                    checked: breakpoints.findBreakpoint(node, BP_BREAKONREMOVE),
                    command: Obj.bindFixed(this.onModifyBreakpoint, this, context, node,
                        BP_BREAKONREMOVE)
                }
            );
        }
    },

    onModifyBreakpoint: function(context, node, type)
    {
        var xpath = Xpath.getElementXPath(node);
        if (FBTrace.DBG_HTML)
            FBTrace.sysout("html.onModifyBreakpoint " + xpath );

        var breakpoints = context.mutationBreakpoints;
        var bp = breakpoints.findBreakpoint(node, type);

        // Remove an existing or create new breakpoint.
        if (bp)
            breakpoints.removeBreakpoint(bp);
        else
            breakpoints.addBreakpoint(node, type);

        Events.dispatch(Firebug.HTMLModule.fbListeners, "onModifyBreakpoint",
            [context, xpath, type]);
    }
};

Firebug.HTMLModule.Breakpoint = function(node, type)
{
    this.node = node;
    this.xpath = Xpath.getElementXPath(node);
    this.checked = true;
    this.type = type;
};

Firebug.HTMLModule.BreakpointRep = domplate(Rep,
{
    inspectable: false,

    tag:
        DIV({"class": "breakpointRow focusRow", $disabled: "$bp|isDisabled", _repObject: "$bp",
            role: "option", "aria-checked": "$bp.checked"},
            DIV({"class": "breakpointBlockHead"},
                INPUT({"class": "breakpointCheckbox", type: "checkbox",
                    _checked: "$bp.checked", tabindex: "-1", onclick: "$onEnable"}),
                TAG("$bp.node|getNodeTag", {object: "$bp.node"}),
                DIV({"class": "breakpointMutationType"}, "$bp|getChangeLabel"),
                SPAN({"class": "closeButton", onclick: "$onRemove"})
            ),
            DIV({"class": "breakpointCode"},
                TAG("$bp.node|getSourceLine", {object: "$bp.node"})
            )
        ),

    getNodeTag: function(node)
    {
        var rep = Firebug.getRep(node, Firebug.currentContext);
        return rep.shortTag ? rep.shortTag : rep.tag;
    },

    getSourceLine: function(node)
    {
        return getNodeTag(node, false);
    },

    getChangeLabel: function(bp)
    {
        switch (bp.type)
        {
        case BP_BREAKONATTRCHANGE:
            return Locale.$STR("html.label.Break On Attribute Change");
        case BP_BREAKONCHILDCHANGE:
            return Locale.$STR("html.label.Break On Child Addition or Removal");
        case BP_BREAKONREMOVE:
            return Locale.$STR("html.label.Break On Element Removal");
        case BP_BREAKONTEXT:
            return Locale.$STR("html.label.Break On Text Change");
        }

        return "";
    },

    isDisabled: function(bp)
    {
        return !bp.checked;
    },

    onRemove: function(event)
    {
        Events.cancelEvent(event);

        var bpPanel = Firebug.getElementPanel(event.target);
        var context = bpPanel.context;

        if (Css.hasClass(event.target, "closeButton"))
        {
            // Remove from list of breakpoints.
            var row = Dom.getAncestorByClass(event.target, "breakpointRow");
            context.mutationBreakpoints.removeBreakpoint(row.repObject);

            bpPanel.refresh();
        }
    },

    onEnable: function(event)
    {
        var checkBox = event.target;
        var bpRow = Dom.getAncestorByClass(checkBox, "breakpointRow");

        if (checkBox.checked)
        {
            Css.removeClass(bpRow, "disabled");
            bpRow.setAttribute("aria-checked", "true");
        }
        else
        {
            Css.setClass(bpRow, "disabled");
            bpRow.setAttribute("aria-checked", "false");
        }

        var bp = bpRow.repObject;
        bp.checked = checkBox.checked;

        var bpPanel = Firebug.getElementPanel(event.target);
        var context = bpPanel.context;

        context.mutationBreakpoints.updateListeners();
    },

    supportsObject: function(object, type)
    {
        return object instanceof Firebug.HTMLModule.Breakpoint;
    }
});

// ********************************************************************************************* //

function MutationBreakpointGroup(context)
{
    this.breakpoints = [];
    this.context = context;
}

MutationBreakpointGroup.prototype = Obj.extend(new Firebug.Breakpoint.BreakpointGroup(),
{
    name: "mutationBreakpoints",
    title: Locale.$STR("html.label.HTML Breakpoints"),

    addBreakpoint: function(node, type)
    {
        this.breakpoints.push(new Firebug.HTMLModule.Breakpoint(node, type));
        this.updateListeners();
    },

    matchBreakpoint: function(bp, args)
    {
        var node = args[0];
        var type = args[1];
        return (bp.node == node) && (!bp.type || bp.type == type);
    },

    removeBreakpoint: function(bp)
    {
        Arr.remove(this.breakpoints, bp);
        this.updateListeners();
    },

    hasEnabledBreakpoints: function()
    {
        return this.breakpoints.some(function(bp)
        {
            return bp.checked;
        });
    },

    updateListeners: function()
    {
        var htmlPanel = this.context.getPanel("html");
        htmlPanel.updateMutationBreakpointListeners();
    },

    // Persistence
    load: function(context)
    {
        var panelState = Persist.getPersistedState(context, "html");
        if (panelState.breakpoints)
            this.breakpoints = panelState.breakpoints;

        this.enumerateBreakpoints(function(bp)
        {
            var elts = Xpath.getElementsByXPath(context.window.document, bp.xpath);
            bp.node = elts && elts.length ? elts[0] : null;
        });

        this.updateListeners();
    },

    store: function(context)
    {
        this.enumerateBreakpoints(function(bp)
        {
            bp.node = null;
        });

        var panelState = Persist.getPersistedState(context, "html");
        panelState.breakpoints = this.breakpoints;
    },
});

function isAncestorIgnored(node)
{
    for (var parent = node; parent; parent = parent.parentNode)
    {
        if (Firebug.shouldIgnore(parent))
            return true;
    }

    return false;
}

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(Firebug.HTMLPanel);
Firebug.registerModule(Firebug.HTMLModule);
Firebug.registerRep(Firebug.HTMLModule.BreakpointRep);

return Firebug.HTMLModule;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/html/insideOutBox",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/xml",
],
function(Obj, Firebug, Events, Css, Dom, Xml) {

// ************************************************************************************************

/**
 * View interface used to populate an InsideOutBox object.
 *
 * All views must implement this interface (directly or via duck typing).
 */
var InsideOutBoxView = {
    /**
     * Retrieves the parent object for a given child object.
     */
    getParentObject: function(child) {},

    /**
     * Retrieves a given child node.
     *
     * If both index and previousSibling are passed, the implementation
     * may assume that previousSibling will be the return for getChildObject
     * with index-1.
     */
    getChildObject: function(parent, index, previousSibling) {},

    /**
     * Renders the HTML representation of the object. Should return an HTML
     * object which will be displayed to the user.
     */
    createObjectBox: function(object, isRoot) {}
};

/**
 * Creates a tree based on objects provided by a separate "view" object.
 *
 * Construction uses an "inside-out" algorithm, meaning that the view's job is first
 * to tell us the ancestry of each object, and secondarily its descendants.
 */
Firebug.InsideOutBox = function(view, box)
{
    this.view = view;
    this.box = box;

    this.rootObject = null;

    this.rootObjectBox = null;
    this.selectedObjectBox = null;
    this.highlightedObjectBox = null;

    this.onMouseDown = Obj.bind(this.onMouseDown, this);
    Events.addEventListener(this.box, "mousedown", this.onMouseDown, false);
};

Firebug.InsideOutBox.prototype =
{
    destroy: function()
    {
        Events.removeEventListener(this.box, "mousedown", this.onMouseDown, false);
    },

    highlight: function(object)
    {
        var objectBox = this.createObjectBox(object);
        this.highlightObjectBox(objectBox);
        return objectBox;
    },

    openObject: function(object)
    {
        var firstChild = this.view.getChildObject(object, 0);
        if (firstChild)
            object = firstChild;

        var objectBox = this.createObjectBox(object);
        this.openObjectBox(objectBox);
        return objectBox;
    },

    openToObject: function(object)
    {
        var objectBox = this.createObjectBox(object);
        this.openObjectBox(objectBox);
        return objectBox;
    },

    select: function(object, makeBoxVisible, forceOpen, noScrollIntoView)
    {
        if (FBTrace.DBG_HTML)
            FBTrace.sysout("insideOutBox.select object:"+object, object);

        var objectBox = this.createObjectBox(object);
        this.selectObjectBox(objectBox, forceOpen);

        if (makeBoxVisible)
        {
            this.openObjectBox(objectBox);
            if (!noScrollIntoView)
                Dom.scrollIntoCenterView(objectBox, this.box);
        }

        return objectBox;
    },

    toggleObject: function(object, all, exceptions)
    {
        var objectBox = this.createObjectBox(object);
        if (!objectBox)
            return;

        if (Css.hasClass(objectBox, "open"))
            this.contractObjectBox(objectBox, all);
        else
            this.expandObjectBox(objectBox, all, exceptions);
    },

    expandObject: function(object, expandAll)
    {
        var objectBox = this.createObjectBox(object);
        if (objectBox)
            this.expandObjectBox(objectBox, expandAll);
    },

    contractObject: function(object, contractAll)
    {
        var objectBox = this.createObjectBox(object);
        if (objectBox)
            this.contractObjectBox(objectBox, contractAll);
    },

    highlightObjectBox: function(objectBox)
    {
        if (this.highlightedObjectBox)
        {
            Css.removeClass(this.highlightedObjectBox, "highlighted");

            var highlightedBox = this.getParentObjectBox(this.highlightedObjectBox);
            for (; highlightedBox; highlightedBox = this.getParentObjectBox(highlightedBox))
                Css.removeClass(highlightedBox, "highlightOpen");
        }

        this.highlightedObjectBox = objectBox;

        if (objectBox)
        {
            Css.setClass(objectBox, "highlighted");

            var highlightedBox = this.getParentObjectBox(objectBox);
            for (; highlightedBox; highlightedBox = this.getParentObjectBox(highlightedBox))
                Css.setClass(highlightedBox, "highlightOpen");

            Dom.scrollIntoCenterView(objectBox, this.box);
        }
    },

    selectObjectBox: function(objectBox, forceOpen)
    {
        var panel = Firebug.getElementPanel(objectBox);

        if (!panel)
        {
            if (FBTrace.DBG_ERRORS && FBTrace.DBG_HTML)
                FBTrace.sysout("selectObjectBox no panel for " + objectBox, objectBox);
            return;
        }

        var isSelected = this.selectedObjectBox && objectBox == this.selectedObjectBox;
        if (!isSelected)
        {
            Css.removeClass(this.selectedObjectBox, "selected");
            Events.dispatch(panel.fbListeners, "onObjectBoxUnselected", [this.selectedObjectBox]);
            this.selectedObjectBox = objectBox;

            if (objectBox)
            {
                Css.setClass(objectBox, "selected");

                // Force it open the first time it is selected
                if (forceOpen)
                    this.toggleObjectBox(objectBox, true);
            }
        }
        Events.dispatch(panel.fbListeners, "onObjectBoxSelected", [objectBox]);
    },

    openObjectBox: function(objectBox)
    {
        if (objectBox)
        {
            // Set all of the node's ancestors to be permanently open
            var parentBox = this.getParentObjectBox(objectBox);
            var labelBox;
            for (; parentBox; parentBox = this.getParentObjectBox(parentBox))
            {
                Css.setClass(parentBox, "open");
                labelBox = parentBox.getElementsByClassName("nodeLabelBox").item(0);
                if (labelBox)
                    labelBox.setAttribute("aria-expanded", "true");
            }
        }
    },

    expandObjectBox: function(objectBox, expandAll, exceptions)
    {
        var nodeChildBox = this.getChildObjectBox(objectBox);
        if (!nodeChildBox)
            return;

        if (!objectBox.populated)
        {
            var firstChild = this.view.getChildObject(objectBox.repObject, 0);
            this.populateChildBox(firstChild, nodeChildBox);
        }

        var labelBox = objectBox.getElementsByClassName("nodeLabelBox").item(0);
        if (labelBox)
            labelBox.setAttribute("aria-expanded", "true");
        Css.setClass(objectBox, "open");

        // Recursively expand all child boxes
        if (expandAll)
        {
            for (var child = nodeChildBox.firstChild; child; child = child.nextSibling)
            {
                if (exceptions && child.repObject)
                {
                    var localName = child.repObject.localName;
                    localName = localName && localName.toLowerCase();

                    if (exceptions.indexOf(localName) !== -1 &&
                        Xml.isElementHTMLOrXHTML(child.repObject))
                    {
                        continue;
                    }
                }

                if (Css.hasClass(child, "containerNodeBox"))
                    this.expandObjectBox(child, expandAll, exceptions);
            }
        }
    },

    contractObjectBox: function(objectBox, contractAll)
    {
        Css.removeClass(objectBox, "open");

        var nodeLabel = objectBox.getElementsByClassName("nodeLabel").item(0);
        var labelBox = nodeLabel.getElementsByClassName('nodeLabelBox').item(0);
        if (labelBox)
            labelBox.setAttribute("aria-expanded", "false");

        if (contractAll)
        {
            // Recursively contract all child boxes
            var nodeChildBox = this.getChildObjectBox(objectBox);
            if (!nodeChildBox)
                return;

            for (var child = nodeChildBox.firstChild; child; child = child.nextSibling)
            {
                if (Css.hasClass(child, "containerNodeBox") && Css.hasClass(child, "open"))
                    this.contractObjectBox(child, contractAll);
            }
        }
    },

    toggleObjectBox: function(objectBox, forceOpen)
    {
        var isOpen = Css.hasClass(objectBox, "open");
        var nodeLabel = objectBox.getElementsByClassName("nodeLabel").item(0);
        var labelBox = nodeLabel.getElementsByClassName('nodeLabelBox').item(0);
        if (labelBox)
            labelBox.setAttribute("aria-expanded", isOpen);

        if (!forceOpen && isOpen)
            this.contractObjectBox(objectBox);
        else if (!isOpen)
            this.expandObjectBox(objectBox);
    },

    getNextObjectBox: function(objectBox)
    {
        return Dom.findNext(objectBox, isVisibleTarget, false, this.box);
    },

    getPreviousObjectBox: function(objectBox)
    {
        return Dom.findPrevious(objectBox, isVisibleTarget, true, this.box);
    },

    getNextSiblingObjectBox: function(objectBox)
    {
        if (!objectBox)
            return null;
        return Dom.findNext(objectBox, isVisibleTarget, true, objectBox.parentNode);
    },

    /**
     * Creates all of the boxes for an object, its ancestors, and siblings.
     */
    createObjectBox: function(object)
    {
        if (!object)
            return null;

        this.rootObject = this.getRootNode(object);

        // Get or create all of the boxes for the target and its ancestors
        var objectBox = this.createObjectBoxes(object, this.rootObject);

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("----insideOutBox.createObjectBox: createObjectBoxes(object="+
                formatNode(object)+", rootObject="+formatNode(this.rootObject)+") ="+
                formatNode(objectBox), objectBox);

        if (!objectBox)  // we found an object outside of the navigatible tree
            return;
        else if (object == this.rootObject)
            return objectBox;
        else
            return this.populateChildBox(object, objectBox.parentNode);
    },

    /**
     * Creates all of the boxes for an object, its ancestors, and siblings up to a root.
     */
    createObjectBoxes: function(object, rootObject)
    {
        if (!object)
            return null;

        if (object == rootObject)
        {
            if (!this.rootObjectBox || this.rootObjectBox.repObject != rootObject)
            {
                if (this.rootObjectBox)
                {
                    try
                    {
                        this.box.removeChild(this.rootObjectBox);
                    }
                    catch (exc)
                    {
                        if (FBTrace.DBG_HTML)
                            FBTrace.sysout(" this.box.removeChild(this.rootObjectBox) FAILS "+
                                this.box+" must not contain "+this.rootObjectBox);
                    }
                }

                this.highlightedObjectBox = null;
                this.selectedObjectBox = null;
                this.rootObjectBox = this.view.createObjectBox(object, true);
                this.box.appendChild(this.rootObjectBox);
            }

            if (FBTrace.DBG_HTML)
            {
                FBTrace.sysout("insideOutBox.createObjectBoxes("+formatNode(object)+","+
                    formatNode(rootObject)+") rootObjectBox: "+this.rootObjectBox, object);
            }

            if ((FBTrace.DBG_HTML || FBTrace.DBG_ERRORS) && !this.rootObjectBox.parentNode)
                FBTrace.sysout("insideOutBox.createObjectBoxes; ERROR - null parent node. "+
                    "object: " + formatNode(object)+", rootObjectBox: "+
                        formatObjectBox(this.rootObjectBox), object);

            return this.rootObjectBox;
        }
        else
        {
            var parentNode = this.view.getParentObject(object);

            if (FBTrace.DBG_HTML)
                FBTrace.sysout("insideOutBox.createObjectBoxes createObjectBoxes recursing " +
                    "with parentNode "+formatNode(parentNode)+" from object "+formatNode(object));

            // recurse towards parent, eventually returning rootObjectBox
            var parentObjectBox = this.createObjectBoxes(parentNode, rootObject);

            if (FBTrace.DBG_HTML)
                FBTrace.sysout("insideOutBox.createObjectBoxes createObjectBoxes("+
                    formatNode(parentNode)+","+formatNode(rootObject)+"):parentObjectBox: "+
                        formatObjectBox(parentObjectBox), parentObjectBox);

            if (!parentObjectBox)
                return null;

            // Returns an inner box (nodeChildBox) that contains list of child boxes (nodeBox).
            var childrenBox = this.getChildObjectBox(parentObjectBox);

            if (FBTrace.DBG_HTML)
                FBTrace.sysout("insideOutBox.createObjectBoxes getChildObjectBox("+
                    formatObjectBox(parentObjectBox)+")= childrenBox: "+formatObjectBox(childrenBox));

            if (!childrenBox)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("insideOutBox.createObjectBoxes FAILS for "+formatNode(object)+
                        " getChildObjectBox("+formatObjectBox(parentObjectBox)+")= childrenBox: "+
                        formatObjectBox(childrenBox));

                // This is where we could try to create a box for objects we cannot get to by
                // navigation via walker or DOM nodes (native anonymous)
                return null;
            }

            var childObjectBox = this.findChildObjectBox(childrenBox, object);

            if (FBTrace.DBG_HTML)
                FBTrace.sysout("insideOutBox.createObjectBoxes findChildObjectBox("+
                    formatNode(childrenBox)+","+formatNode(object)+"): childObjectBox: "+
                        formatObjectBox(childObjectBox), childObjectBox);

            return childObjectBox ? childObjectBox : this.populateChildBox(object, childrenBox);
        }
    },

    findObjectBox: function(object)
    {
        if (!object)
            return null;

        if (object == this.rootObject)
            return this.rootObjectBox;
        else
        {
            var parentNode = this.view.getParentObject(object);
            var parentObjectBox = this.findObjectBox(parentNode);
            if (!parentObjectBox)
                return null;

            var childrenBox = this.getChildObjectBox(parentObjectBox);
            if (!childrenBox)
                return null;

            return this.findChildObjectBox(childrenBox, object);
        }
    },

    appendChildBox: function(parentNodeBox, repObject)
    {
        var childBox = this.getChildObjectBox(parentNodeBox);
        var objectBox = this.findChildObjectBox(childBox, repObject);
        if (objectBox)
            return objectBox;

        objectBox = this.view.createObjectBox(repObject);
        if (objectBox)
        {
            var childBox = this.getChildObjectBox(parentNodeBox);
            childBox.appendChild(objectBox);
        }
        return objectBox;
    },

    insertChildBoxBefore: function(parentNodeBox, repObject, nextSibling)
    {
        var childBox = this.getChildObjectBox(parentNodeBox);
        var objectBox = this.findChildObjectBox(childBox, repObject);
        if (objectBox)
            return objectBox;

        objectBox = this.view.createObjectBox(repObject);
        if (objectBox)
        {
            var siblingBox = this.findChildObjectBox(childBox, nextSibling);
            childBox.insertBefore(objectBox, siblingBox);
        }
        return objectBox;
    },

    removeChildBox: function(parentNodeBox, repObject)
    {
        var childBox = this.getChildObjectBox(parentNodeBox);
        var objectBox = this.findChildObjectBox(childBox, repObject);
        if (objectBox)
            childBox.removeChild(objectBox);
    },

    // We want all children of the parent of repObject.
    populateChildBox: function(repObject, nodeChildBox)
    {
        if (!repObject)
            return null;

        var parentObjectBox = Dom.getAncestorByClass(nodeChildBox, "nodeBox");

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("+++insideOutBox.populateChildBox("+
                Css.getElementCSSSelector(repObject)+") parentObjectBox.populated "+
                parentObjectBox.populated);

        if (parentObjectBox.populated)
            return this.findChildObjectBox(nodeChildBox, repObject);

        var lastSiblingBox = this.getChildObjectBox(nodeChildBox);
        var siblingBox = nodeChildBox.firstChild;
        var targetBox = null;

        var view = this.view;

        var targetSibling = null;
        var parentNode = view.getParentObject(repObject);
        for (var i = 0; 1; ++i)
        {
            targetSibling = view.getChildObject(parentNode, i, targetSibling);
            if (!targetSibling)
                break;

            // Check if we need to start appending, or continue to insert before
            if (lastSiblingBox && lastSiblingBox.repObject == targetSibling)
                lastSiblingBox = null;

            if (!siblingBox || siblingBox.repObject != targetSibling)
            {
                var newBox = view.createObjectBox(targetSibling);
                if (newBox)
                {
                    if (!nodeChildBox)
                        FBTrace.sysout("insideOutBox FAILS no nodeChildBox "+repObject, repObject);

                    if (lastSiblingBox)
                    {
                        try
                        {
                            nodeChildBox.insertBefore(newBox, lastSiblingBox);
                        }
                        catch(exc)
                        {
                            FBTrace.sysout("insideOutBox FAILS insertBefore",
                                {repObject:repObject, nodeChildBox: nodeChildBox, newBox: newBox,
                                lastSiblingBox: lastSiblingBox});
                        }
                    }
                    else
                        nodeChildBox.appendChild(newBox);
                }

                siblingBox = newBox;
            }

            if (targetSibling == repObject)
                targetBox = siblingBox;

            if (siblingBox && siblingBox.repObject == targetSibling)
                siblingBox = siblingBox.nextSibling;
        }

        if (targetBox)
            parentObjectBox.populated = true;

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("---insideOutBox.populateChildBox("+
                (repObject.localName?repObject.localName:repObject)+") targetBox "+targetBox);

        return targetBox;
    },

    getParentObjectBox: function(objectBox)
    {
        var parent = objectBox.parentNode ? objectBox.parentNode.parentNode : null;
        return parent && parent.repObject ? parent : null;
    },

    getChildObjectBox: function(objectBox)
    {
        return objectBox.getElementsByClassName("nodeChildBox").item(0);
    },

    findChildObjectBox: function(parentNodeBox, repObject)
    {
        for (var childBox = parentNodeBox.firstChild; childBox; childBox = childBox.nextSibling)
        {
            if (FBTrace.DBG_HTML)
                FBTrace.sysout("insideOutBox.findChildObjectBox repObject: " +
                    formatNode(repObject)+" in "+formatNode(childBox)+" = "+
                    formatNode(childBox.repObject),
                    {childBoxRepObject: childBox.repObject,repObject:repObject});

            if (childBox.repObject == repObject)
                return childBox;
        }

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("insideOutBox.findChildObjectBox no match for repObject: " +
                formatNode(repObject)+" in "+formatNode(parentNodeBox));
    },

    /**
     * Determines if the given node is an ancestor of the current root.
     */
    isInExistingRoot: function(node)
    {
        if (FBTrace.DBG_HTML)
            var dbg_isInExistingRoot = "";

        var parentNode = node;
        while (parentNode && parentNode != this.rootObject)
        {
            if (FBTrace.DBG_HTML)
                dbg_isInExistingRoot = dbg_isInExistingRoot + parentNode.localName+" < ";

            parentNode = this.view.getParentObject(parentNode);
        }

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("insideOutBox.isInExistingRoot  "+dbg_isInExistingRoot+
                ": (parentNode == this.rootObject)="+(parentNode == this.rootObject));

        return parentNode == this.rootObject;
    },

    getRootNode: function(node)
    {
        if (FBTrace.DBG_HTML)
            var dbg_getRootNode = "";

        while (1)
        {
            var parentNode = this.view.getParentObject(node);

            if (!parentNode)
                break;

            if (FBTrace.DBG_HTML)
                dbg_getRootNode += node.localName+" < ";

            node = parentNode;
        }

        if (FBTrace.DBG_HTML)
            FBTrace.sysout("insideOutBox.getRootNode "+dbg_getRootNode);

        return node;
    },

    // ********************************************************************************************

    onMouseDown: function(event)
    {
        var hitTwisty = false;
        for (var child = event.target; child; child = child.parentNode)
        {
            if (Css.hasClass(child, "twisty"))
                hitTwisty = true;
            else if (child.repObject)
            {
                if (hitTwisty)
                    this.toggleObjectBox(child);
                break;
            }
        }
    }
};

// ************************************************************************************************
// Local Helpers

function isVisibleTarget(node)
{
    if (node.repObject && node.repObject.nodeType == Node.ELEMENT_NODE)
    {
        for (var parent = node.parentNode; parent; parent = parent.parentNode)
        {
            if (Css.hasClass(parent, "nodeChildBox")
                && !Css.hasClass(parent.parentNode, "open")
                && !Css.hasClass(parent.parentNode, "highlightOpen"))
                return false;
        }
        return true;
    }
}

function formatNode(object)
{
    if (object)
    {
        if (!object.localName)
        {
            var str = object.toString();
            if (str)
                return str;
            else
                return "(an object with no localName or toString result)";
        }
        else  return Css.getElementCSSSelector(object);
    }
    else
        return "(null object)";
}

function formatObjectBox(object)
{
    if (object)
    {
        if (object.localName)
            return Css.getElementCSSSelector(object);
        return object.textContent;
    }
    else
        return "(null object)";
}

function getObjectPath(element, aView)
{
    var path = [];
    for (; element; element = aView.getParentObject(element))
        path.push(element);

    return path;
}

// ************************************************************************************************
// Registration

return Firebug.InsideOutBox;

// ************************************************************************************************
});
/* See license.txt for terms of usage */

define("firebug/html/inspector",
[
    "firebug/firebug",
    "firebug/lib/trace",
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/lib/array",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/xml",
    "firebug/lib/system",
    "firebug/chrome/window",
    "firebug/html/highlighterCache",
    "firebug/html/quickInfoBox",
],
function(Firebug, FBTrace, Module, Obj, Events, Wrapper, Arr, Css, Dom, Xml, System, Win,
    HighlighterCache, QuickInfoBox) {

"use strict";

// ********************************************************************************************* //
// Constants

const inspectDelay = 200;
const highlightCssUrl = "chrome://firebug/content/html/highlighter.css";
const ident = HighlighterCache.ident;
const Cu = Components.utils;

// ********************************************************************************************* //
// Globals

var boxModelHighlighter = null;
var frameHighlighter = null;

// ********************************************************************************************* //

/**
 * @module Implements Firebug Inspector logic.
 */
Firebug.Inspector = Obj.extend(Module,
{
    dispatchName: "inspector",
    inspecting: false,
    inspectingPanel: null,

    /**
     * Main highlighter method. Can be used to highlight elements using the box model,
     * frame or image map highlighters. Can highlight single or multiple elements.
     *
     * Examples:
     * Firebug.Inspector.highlightObject([window.content.document.getElementById("gbar"),
     *     window.content.document.getElementById("logo")],
     *     window.content, "frame", null,
     *     ["#ff0000",{background:"#0000ff", border:"#ff0000"}])
     * or
     * Firebug.Inspector.highlightObject([window.content.document.getElementById("gbar"),
     *     window.content.document.getElementById("logo")], window.content, "boxModel", null,
     *     [{content: "#ff0000", padding: "#eeeeee", border: "#00ff00", margin: "#0000ff"},
     *         {content: "#00ff00", padding: "#eeeeee", border: "#00ff00", margin: "#0000ff"}])
     *
     * @param {Array} elementArr Elements to highlight
     * @param {Window} context Context of the elements to be highlighted
     * @param {String} [highlightType] Either "frame" or "boxModel". Default is configurable.
     * @param {String} [boxFrame] Displays the line guides for the box model layout view.
     *      Valid values are: "content", "padding", "border" or "margin"
     * @param {String | Array} [colorObj] Any valid html color e.g. red, #f00, #ff0000, etc.,
     *      a valid color object or any valid highlighter color array.
     */
    highlightObject: function(elementArr, context, highlightType, boxFrame, colorObj)
    {
        var i, elt, elementLen, oldContext, usingColorArray;
        var highlighter = highlightType ? getHighlighter(highlightType) : this.defaultHighlighter;

        if (!elementArr || !Arr.isArrayLike(elementArr))
        {
            // Not everything that comes through here is wrapped - fix that.
            elementArr = Wrapper.wrapObject(elementArr);

            // highlight a single element
            if (!elementArr || !Dom.isElement(elementArr) ||
                (typeof elementArr === "object" && !Xml.isVisible(elementArr)))
            {
                if (elementArr && Dom.isRange(elementArr))
                    elementArr = elementArr;
                else if (elementArr && elementArr.nodeType == Node.TEXT_NODE)
                    elementArr = elementArr.parentNode;
                else
                    elementArr = null;
            }

            if (elementArr && context && context.highlightTimeout)
            {
                context.clearTimeout(context.highlightTimeout);
                delete context.highlightTimeout;
            }

            oldContext = this.highlightedContext;
            if (oldContext && oldContext.window)
                this.clearAllHighlights();

            // Stop multi element highlighting
            if (!elementArr)
                this.repaint.element = null;

            this.highlighter = highlighter;
            this.highlightedContext = context;

            if (elementArr)
            {
                if (elementArr.nodeName && !isVisibleElement(elementArr))
                    highlighter.unhighlight(context);
                else if (context && context.window && context.window.document)
                    highlighter.highlight(context, elementArr, boxFrame, colorObj, false);
            }
            else if (oldContext)
            {
                oldContext.highlightTimeout = oldContext.setTimeout(function()
                {
                    if (FBTrace.DBG_INSPECT)
                        FBTrace.sysout("Removing inspector highlighter due to setTimeout loop");

                    if (!oldContext.highlightTimeout)
                        return;

                    delete oldContext.highlightTimeout;

                    if (oldContext.window && oldContext.window.document)
                    {
                        highlighter.unhighlight(oldContext);
                    }
                }, inspectDelay);
            }
        }
        else
        {
            // Highlight multiple elements
            if (context && context.highlightTimeout)
            {
                context.clearTimeout(context.highlightTimeout);
                delete context.highlightTimeout;
            }

            this.clearAllHighlights();
            usingColorArray = Array.isArray(colorObj);

            if (context && context.window && context.window.document)
            {
                for (i=0, elementLen=elementArr.length; i<elementLen; i++)
                {
                    // Like above, wrap things.
                    elt = Wrapper.wrapObject(elementArr[i]);

                    if (elt && elt instanceof HTMLElement)
                    {
                        if (elt.nodeType == Node.TEXT_NODE)
                            elt = elt.parentNode;

                        var obj = usingColorArray ? colorObj[i] : colorObj;
                        highlighter.highlight(context, elt, null, obj, true);
                    }
                }
            }

            storeHighlighterParams(null, context, elementArr, null, colorObj, highlightType, true);
        }
    },

    /**
     * Clear all highlighted areas on a page.
     */
    clearAllHighlights: function()
    {
        HighlighterCache.clear();
    },

    /**
     * Toggle inspecting on / off
     * @param {Window} [context] The window to begin inspecting in, necessary to toggle inspecting on.
     */
    toggleInspecting: function(context)
    {
        if (this.inspecting)
            this.stopInspecting(true);
        else
            this.startInspecting(context);
    },

    /**
     * Check if the new panel has the inspectable property set. If so set it as the new inspectingPanel.
     */
    onPanelChanged: function()
    {
        if (this.inspecting)
        {
            var panelBar1 = Firebug.chrome.$("fbPanelBar1");
            var panel = panelBar1.selectedPanel;

            if (panel && panel.inspectable)
            {
                this.inspectNode(null);
                this.inspectingPanel = panel;
            }
        }
    },

    /**
     * Turn inspecting on.
     * @param {Window} context The main browser window
     */
    startInspecting: function(context)
    {
        if (this.inspecting || !context || !context.loaded)
            return;

        this.clearAllHighlights();

        this.inspecting = true;
        this.inspectingContext = context;

        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleInspecting", "checked", "true");
        this.attachInspectListeners(context);

        var inspectingPanelName = this._resolveInspectingPanelName(context);
        this.inspectingPanel = Firebug.chrome.switchToPanel(context, inspectingPanelName);

        if (Firebug.isDetached())
            context.window.focus();
        else if (Firebug.isMinimized())
            Firebug.showBar(true);

        this.inspectingPanel.panelNode.focus();
        this.inspectingPanel.startInspecting();

        Events.dispatch(this.fbListeners, "onStartInspecting", [context]);

        if (context.stopped)
            Firebug.Debugger.thaw(context);

        var hoverNodes = context.window.document.querySelectorAll(":hover");

        if (hoverNodes.length != 0)
            this.inspectNode(hoverNodes[hoverNodes.length-1]);
    },

    /**
     * Highlight a node using the frame highlighter. Can only be used after inspecting has already started.
     * @param {Element} node The element to inspect
     */
    inspectNode: function(node)
    {
        if (node && node.nodeType != Node.ELEMENT_NODE)
            node = node.parentNode;

        if (node && Firebug.shouldIgnore(node) && !node.fbProxyFor)
            return;

        var context = this.inspectingContext;

        if (this.inspectTimeout)
        {
            context.clearTimeout(this.inspectTimeout);
            delete this.inspectTimeout;
        }

        if (node && node.fbProxyFor)
            node = node.fbProxyFor;

        var inspectingPanel = this.inspectingPanel;

        // Some panels may want to only allow inspection of panel-supported objects
        node = inspectingPanel ? inspectingPanel.getInspectNode(node) : node;

        var highlightColor = inspectingPanel ? inspectingPanel.inspectHighlightColor : "";
        this.highlightObject(node, context, "frame", undefined, highlightColor);

        this.inspectingNode = node;

        if (node)
        {
            var _this = this;

            this.inspectTimeout = context.setTimeout(function()
            {
                var selection = inspectingPanel ? inspectingPanel.inspectNode(node) : null;
                Events.dispatch(_this.fbListeners, "onInspectNode", [context, node]);
                if (selection)
                    inspectingPanel.select(node);
            }, inspectDelay);
        }
    },

    /**
     * Stop inspecting and clear all highlights.
     * @param {Boolean} canceled Indicates whether inspect was canceled (usually via the escape key)
     * @param {Boolean} [waitForClick] Indicates whether the next click will still forward you
     *      to the clicked element in the HTML panel.
     */
    stopInspecting: function(canceled, waitForClick)
    {
        if (!this.inspecting)
            return;

        var context = this.inspectingContext;

        if (context.stopped)
            Firebug.Debugger.freeze(context);

        if (this.inspectTimeout)
        {
            context.clearTimeout(this.inspectTimeout);
            delete this.inspectTimeout;
        }

        this.detachInspectListeners(context);
        if (!waitForClick)
            this.detachClickInspectListeners(context.window);

        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleInspecting", "checked", "false");

        this.inspecting = false;

        if (this.inspectingPanel)
        {
            Firebug.chrome.unswitchToPanel(context, this.inspectingPanel.name, canceled);
            this.inspectingPanel.stopInspecting(this.inspectingNode, canceled);
        }
        else
        {
            FBTrace.sysout("inspector.stopInspecting; ERROR? inspectingPanel is NULL");
        }

        Events.dispatch(this.fbListeners, "onStopInspecting", [context, this.inspectingNode, canceled]);

        this.inspectNode(null);

        // Make sure there are no (indirect) references to the page document.
        this.inspectingPanel = null;
        this.inspectingContext = null;

        if (Firebug.isDetached())
            window.focus();
    },

    /**
     * Get the name of the inspectable panel.
     * @param {Window} context Context of the panel
     */
    _resolveInspectingPanelName: function(context)
    {
        var requestingPanel = context && context.getPanel(context.panelName);

        return (requestingPanel && requestingPanel.inspectable) ? requestingPanel.name : "html";
    },

    /**
     * Inspect from context menu.
     * @param {Element} elt The element to inspect
     */
    inspectFromContextMenu: function(elt)
    {
        var panel;
        var inspectingPanelName = "html";

        Firebug.toggleBar(true, inspectingPanelName);
        Firebug.chrome.select(elt, inspectingPanelName);
        panel = Firebug.chrome.selectPanel(inspectingPanelName);
        panel.panelNode.focus();
    },

    /**
     * Navigate up and down through the DOM and highlight the result. This method is used by
     * the key handlers for the up and down arrow keys.
     *
     * @param {String} dir Direction to navigate the Dom, either "up" or "down"
     */
    inspectNodeBy: function(dir)
    {
        var target;
        var node = this.inspectingNode;

        if (dir == "up")
        {
            target = Firebug.chrome.getNextObject();
        }
        else if (dir == "down")
        {
            target = Firebug.chrome.getNextObject(true);
            if (node && !target)
            {
                target = node.contentDocument ?
                    node.contentDocument.documentElement : Dom.getNextElement(node.firstChild);
            }
        }

        if (target && Dom.isElement(target))
            this.inspectNode(target);
        else
            System.beep();
    },

    /**
     * Repaint the highlighter. Called from the window scroll and resize handlers.
     */
    repaint: function()
    {
        var rp = this.repaint;
        var highlighter = rp.highlighter;
        var context = rp.context;
        var element = rp.element;
        var boxFrame = rp.boxFrame;
        var colorObj = rp.colorObj;
        var highlightType = rp.highlightType;
        var isMulti = rp.isMulti;

        if (!context || (!highlighter && !isMulti))
            return;

        if (isMulti && element)
        {
            this.highlightObject(element, context, highlightType, null, colorObj);
        }
        else if (!isMulti)
        {
            var highlighterNode = HighlighterCache.get(highlighter.ident);

            if (highlighterNode && highlighter.ident === ident.boxModel)
                highlighterNode = highlighterNode.offset;

            if (highlighterNode && highlighterNode.parentNode)
            {
                this.clearAllHighlights();
                highlighter.highlight(context, element, boxFrame, colorObj, isMulti);
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Attach the scroll and resize handlers to elt's window. Called from every highlight call.
     * @param {Element} elt Passed in order to reliably obtain context
     */
    attachRepaintInspectListeners: function(context, elt)
    {
        if (!elt || !elt.ownerDocument || !elt.ownerDocument.defaultView)
            return;

        var win = elt.ownerDocument.defaultView;

        if (FBTrace.DBG_INSPECT)
            FBTrace.sysout("inspector.attachRepaintInspectListeners to " + win.location.href, elt);

        // there is no way to check if the listeners have already been added and we should
        // avoid adding properties to the users page.
        // Adding them again will do no harm so lets just do that.

        // xxxHonza: I think that adding them twice could actually do harm,
        // so make sure they are removed before.
        context.removeEventListener(win.document, "resize", this.onInspectingResizeWindow, true);
        context.removeEventListener(win.document, "scroll", this.onInspectingScroll, true);

        // Register again.
        context.addEventListener(win.document, "resize", this.onInspectingResizeWindow, true);
        context.addEventListener(win.document, "scroll", this.onInspectingScroll, true);
    },

    /**
     * Attach key and mouse events to windows recursively.
     * @param {Window} context Context of the main browser window
     */
    attachInspectListeners: function(context)
    {
        var win = context.window;
        if (!win || !win.document)
            return;

        if (FBTrace.DBG_INSPECT)
            FBTrace.sysout("inspector.attachInspectListeners to all subWindows of " + win.location);

        var chrome = Firebug.chrome;

        this.keyListeners =
        [
            chrome.keyCodeListen("RETURN", null, Obj.bindFixed(this.stopInspecting, this)),
            chrome.keyCodeListen("ESCAPE", null, Obj.bindFixed(this.stopInspecting, this, true)),
            chrome.keyCodeListen("UP", Events.isControl, Obj.bindFixed(this.inspectNodeBy, this,
                "up"), true),
            chrome.keyCodeListen("DOWN", Events.isControl, Obj.bindFixed(this.inspectNodeBy, this,
                "down"), true),
        ];

        Win.iterateWindows(win, Obj.bind(function(subWin)
        {
            if (FBTrace.DBG_INSPECT)
                FBTrace.sysout("inspector.attacheInspectListeners to " + subWin.location +
                    " subWindow of " + win.location);

            Events.addEventListener(subWin.document, "mouseover", this.onInspectingMouseOver,
                true);
            Events.addEventListener(subWin.document, "mousedown", this.onInspectingMouseDown,
                true);
            Events.addEventListener(subWin.document, "mouseup", this.onInspectingMouseUp, true);
            Events.addEventListener(subWin.document, "click", this.onInspectingClick, true);
            Events.addEventListener(subWin.document, "keypress", this.onInspectingKeyPress, true);
        }, this));
    },

    /**
     * Remove all event listeners except click listener from windows recursively.
     * @param {Window} context Context of the main browser window
     */
    detachInspectListeners: function(context)
    {
        var i, keyListenersLen;
        var win = context.window;

        if (!win || !win.document)
            return;

        var chrome = Firebug.chrome;

        if (this.keyListeners)  // XXXjjb for some reason this is null sometimes.
        {
            keyListenersLen = this.keyListeners.length;
            for (i = 0; i < keyListenersLen; ++i)
                chrome.keyIgnore(this.keyListeners[i]);
            delete this.keyListeners;
        }

        Win.iterateWindows(win, Obj.bind(function(subWin)
        {
            Events.removeEventListener(subWin.document, "mouseover", this.onInspectingMouseOver,
                true);
            Events.removeEventListener(subWin.document, "mousedown", this.onInspectingMouseDown,
                true);
            Events.removeEventListener(subWin.document, "mouseup", this.onInspectingMouseUp, true);
            Events.removeEventListener(subWin.document, "keypress", this.onInspectingKeyPress,
                true);
        }, this));
    },

    /**
     * Remove the click listener independently from detachInspectListeners because if we remove
     * it after mousedown, we won't be able to cancel clicked links.
     *
     * @param {Window} context Context of the main browser window
     */
    detachClickInspectListeners: function(context)
    {
        Win.iterateWindows(context, Obj.bind(function(subWin)
        {
            Events.removeEventListener(subWin.document, "click", this.onInspectingClick, true);
        }, this));
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Repaint last highlight in the correct position on window resize.
     * @param {Event} event Passed for tracing
     */
    onInspectingResizeWindow: function(event)
    {
        if (FBTrace.DBG_INSPECT)
           FBTrace.sysout("onInspectingResizeWindow event", event);

        this.repaint();
    },

    /**
     * Repaint last highlight in the correct position on scroll.
     * @param {Event} event Passed for tracing
     */
    onInspectingScroll: function(event)
    {
        if (FBTrace.DBG_INSPECT)
           FBTrace.sysout("onInspectingScroll event", event);

        this.repaint();
    },

    /**
     * Call inspectNode(event.target) highlighting the element that was moused over.
     * @param {Event} event Passed for tracing and to identify the target of inspection
     */
    onInspectingMouseOver: function(event)
    {
        if (FBTrace.DBG_INSPECT)
           FBTrace.sysout("onInspectingMouseOver event", event);

        this.inspectNode(event.target);
    },

    /**
     * Trap mousedown events to prevent clicking a document from triggering a document's
     * mousedown event when inspecting.
     *
     * @param {Event} event Used for tracing and canceling the event
     */
    onInspectingMouseDown: function(event)
    {
        if (FBTrace.DBG_INSPECT)
        {
            FBTrace.sysout("onInspectingMouseDown event", {originalTarget: event.originalTarget,
                tmpRealOriginalTarget:event.tmpRealOriginalTarget, event:event});
        }

        // Allow to scroll the document while inspecting
        if (event.originalTarget && event.originalTarget.tagName == "xul:thumb")
            return;

        Events.cancelEvent(event);
    },

    /**
     * Trap mouseup events to prevent clicking a document from triggering a document's mouseup
     * event when inspecting.
     *
     * @param {Event} event Used for tracing and canceling the event
     */
    onInspectingMouseUp: function(event)
    {
        if (FBTrace.DBG_INSPECT)
        {
            FBTrace.sysout("onInspectingMouseUp event", {originalTarget: event.originalTarget,
                tmpRealOriginalTarget:event.tmpRealOriginalTarget,event:event});
        }

        // Allow to release scrollbar while inspecting
        if (event.originalTarget && event.originalTarget.tagName == "xul:thumb")
            return;

        this.stopInspecting(false, true);

        Events.cancelEvent(event);
    },

    /**
     * Trap click events to prevent clicking a document from triggering a document's click event
     * when inspecting and removes the click inspect listener.
     *
     * @param {Event} event Used for tracing and canceling the event
     */
    onInspectingClick: function(event)
    {
        if (FBTrace.DBG_INSPECT)
            FBTrace.sysout("onInspectingClick event", event);

        var win = event.currentTarget.defaultView;
        if (win)
        {
            win = Win.getRootWindow(win);
            this.detachClickInspectListeners(win);
        }

        Events.cancelEvent(event);
    },

    /**
     * Trap keypress events to allow manipulation of the hovered elements
     *
     * @param {Event} event Used for canceling the event
     */
    onInspectingKeyPress: function(event)
    {
        if (event.keyCode == KeyEvent.DOM_VK_DELETE)
        {
            Events.dispatch(this.fbListeners, "onBeginFirebugChange", [this.inspectingNode, this]);
            this.inspectingNode.parentNode.removeChild(this.inspectingNode);
            Events.dispatch(this.fbListeners, "onEndFirebugChange", [this.inspectingNode, this]);
            Events.cancelEvent(event);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    /**
     * Initialize the inspector
     */
    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        this.onInspectingResizeWindow = Obj.bind(this.onInspectingResizeWindow, this);
        this.onInspectingScroll = Obj.bind(this.onInspectingScroll, this);
        this.onInspectingMouseOver = Obj.bind(this.onInspectingMouseOver, this);
        this.onInspectingMouseDown = Obj.bind(this.onInspectingMouseDown, this);
        this.onInspectingMouseUp = Obj.bind(this.onInspectingMouseUp, this);
        this.onInspectingClick = Obj.bind(this.onInspectingClick, this);
        this.onInspectingKeyPress = Obj.bind(this.onInspectingKeyPress, this);
        this.onPanelChanged = Obj.bind(this.onPanelChanged, this);

        this.updateOption("shadeBoxModel", Firebug.shadeBoxModel);
        this.updateOption("showQuickInfoBox", Firebug.showQuickInfoBox);

        var panelBar1 = Firebug.chrome.$("fbPanelBar1");
        Events.addEventListener(panelBar1, "selectPanel", this.onPanelChanged, false);

        if (FBTrace.DBG_INSPECT)
            FBTrace.sysout("inspector.initialize;");
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        var panelBar1 = Firebug.chrome.$("fbPanelBar1");
        Events.removeEventListener(panelBar1, "selectPanel", this.onPanelChanged, false);
    },

    /**
     * Stop inspecting and delete timers.
     * @param {Window} context Context of the main window
     */
    destroyContext: function(context)
    {
        if (context.highlightTimeout)
        {
            context.clearTimeout(context.highlightTimeout);
            delete context.highlightTimeout;
        }

        if (this.inspecting)
            this.stopInspecting(true);
    },

    /**
     */
    unwatchWindow: function(context, win)
    {
        try
        {
            QuickInfoBox.hideQuickInfoBox();
            this.inspectNode(null);
        }
        catch (ex)
        {
            // Get unfortunate errors here sometimes, so let's just ignore them since the
            // window is going away anyhow
        }
    },

    /**
     * Called when a FF tab is created or activated (user changes FF tab). We stop inspecting
     * in this situation.
     *
     * @param {xul:browser} [browser] Browser
     * @param {Window} [context] The main browser window
     */
    showContext: function(browser, context)
    {
        if (this.inspecting)
            this.stopInspecting(true);
    },

    /**
     * Called when a panel is shown.
     * @param {xul:browser} [browser] Browser
     * @param {Panel} [panel] Panel
     */
    showPanel: function(browser, panel)
    {
        // Don't disable the cmd_toggleInspecting command. The related shortcut <key> must
        // be available even if Firebug is not activated for the site. See 4452
        // The panel can be null (if disabled) so use the global context.
        // var context = Firebug.currentContext;
        // var disabled = (context && context.loaded) ? false : true;
        // Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleInspecting", "disabled", disabled);
    },

    /**
     * Called after a context's page gets DOMContentLoaded. We enable inspection here.
     * @param {Window} [context] Context of the main window
     */
    loadedContext: function(context)
    {
        // See the comment in showPanel.
        // Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleInspecting", "disabled", "false");
    },

    /**
     * Update the shadeBoxModel or showQuickInfoBox options
     * @param {String} name Either "shadeBoxModel" or "showQuickInfoBox"
     * @param {Boolean} value Enable or Disable the option
     */
    updateOption: function(name, value)
    {
        if (name == "shadeBoxModel")
        {
            this.highlightObject(null);
            this.defaultHighlighter = value ? getHighlighter("boxModel") : getHighlighter("frame");
        }
        else if(name == "showQuickInfoBox")
        {
            QuickInfoBox.boxEnabled = value;
        }
    },

    /**
     * Gets stylesheet by Url.
     * @param {Window} context the main browser window
     * @param {String} url URL of the stylesheet
     */
    getObjectByURL: function(context, url)
    {
        var styleSheet = Css.getStyleSheetByHref(url, context);
        if (styleSheet)
            return styleSheet;
    },
});

// ********************************************************************************************* //
// Local Helpers

function getHighlighter(type)
{
    switch (type)
    {
        case "boxModel":
            if (!boxModelHighlighter)
                boxModelHighlighter = new BoxModelHighlighter();

            return boxModelHighlighter;

        case "frame":
            if (!frameHighlighter)
                frameHighlighter = new Firebug.Inspector.FrameHighlighter();

            return frameHighlighter;
    }
}

function pad(element, t, r, b, l)
{
    var css = "padding:" + Math.abs(t) + "px " + Math.abs(r) + "px "
         + Math.abs(b) + "px " + Math.abs(l) + "px !important;";

    if (element)
        element.style.cssText = css;
    else
        return css;
}

function moveImp(element, x, y)
{
    var css = "left:" + x + "px !important;top:" + y + "px !important;";

    if (element)
        element.style.cssText = css;
    else
        return css;
}

function resizeImp(element, w, h)
{
    var css = "width:" + w + "px !important;height:" + h + "px !important;";

    if (element)
        element.style.cssText = css;
    else
        return css;
}

// ********************************************************************************************* //
// Imagemap Highlighter

function getImageMapHighlighter(context)
{
    if (!context)
        return;

    var canvas, ctx, mx, my;
    var doc = context.window.document;

    var init = function(elt)
    {
        if (elt)
            doc = elt.ownerDocument;

        canvas = doc.getElementById("firebugCanvas");

        if (!canvas)
        {
            canvas = doc.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            hideElementFromInspection(canvas);
            canvas.id = "firebugCanvas";
            canvas.className = "firebugResetStyles firebugBlockBackgroundColor firebugCanvas";
            canvas.width = context.window.innerWidth;
            canvas.height = context.window.innerHeight;

            Events.addEventListener(context.window, "scroll", function()
            {
                context.imageMapHighlighter.show(false);
            }, true);

            Events.addEventListener(doc, "mousemove", function(event)
            {
                mx = event.clientX;
                my = event.clientY;
            }, true);

            doc.body.appendChild(canvas);
        }
    };

    if (!context.imageMapHighlighter)
    {
        context.imageMapHighlighter =
        {
            ident: ident.imageMap,

            show: function(state)
            {
                if (!canvas)
                    init(null);

                canvas.style.cssText = "display:"+(state ? "block" : "none")+" !important";
            },

            getImages: function(mapName, multi)
            {
                if (!mapName)
                    return;

                var xpe = new XPathEvaluator();
                var nsResolver = xpe.createNSResolver(doc.documentElement);

                var elts = xpe.evaluate("//map[@name='" + mapName + "']", doc,
                    nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);

                if (elts.snapshotLength === 0)
                    return;

                elts = xpe.evaluate("(//img | //input)[@usemap='#" + mapName + "']",
                    doc.documentElement, nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                var eltsLen = elts.snapshotLength;

                var images = [];
                for (var i = 0; i < eltsLen; ++i)
                {
                    var elt = elts.snapshotItem(i);
                    var rect = Dom.getLTRBWH(elt);

                    if (multi)
                    {
                        images.push(elt);
                    }
                    else if (rect.left <= mx && rect.right >= mx && rect.top <= my &&
                        rect.bottom >= my)
                    {
                        images[0] = elt;
                        break;
                    }
                }

                return images;
            },

            highlight: function(eltArea, multi)
            {
                if (!eltArea || !eltArea.coords)
                    return;

                var images = this.getImages(eltArea.parentNode.name, multi) || [];

                init(eltArea);

                var v = eltArea.coords.split(",");

                if (!ctx)
                    ctx = canvas.getContext("2d");

                ctx.fillStyle = "rgba(135, 206, 235, 0.7)";
                ctx.strokeStyle = "rgb(44, 167, 220)";
                ctx.lineWidth = 2;

                if (images.length == 0)
                    images[0] = eltArea;

                for (var j = 0, imagesLen = images.length; j < imagesLen; ++j)
                {
                    var rect = Dom.getLTRBWH(images[j], context);

                    ctx.beginPath();

                    if (!multi || (multi && j===0))
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                    var shape = eltArea.shape.toLowerCase();

                    if (shape === "rect")
                    {
                        ctx.rect(rect.left + parseInt(v[0], 10), rect.top + parseInt(v[1], 10), v[2] - v[0], v[3] - v[1]);
                    }
                    else if (shape === "circle")
                    {
                        ctx.arc(rect.left + parseInt(v[0], 10) + ctx.lineWidth / 2, rect.top + parseInt(v[1], 10) + ctx.lineWidth / 2, v[2], 0, Math.PI / 180 * 360, false);
                    }
                    else
                    {
                        var vLen = v.length;
                        ctx.moveTo(rect.left + parseInt(v[0], 10), rect.top + parseInt(v[1], 10));
                        for (var i = 2; i < vLen; i += 2)
                            ctx.lineTo(rect.left + parseInt(v[i], 10), rect.top + parseInt(v[i + 1], 10));
                        ctx.lineTo(rect.left + parseInt(v[0], 10), rect.top + parseInt(v[1], 10));
                    }

                    ctx.fill();
                    ctx.stroke();
                    ctx.closePath();
                }

                this.show(true);
            },

            destroy: function()
            {
                this.show(false);
                canvas = null;
                ctx = null;
            }
        };
    }

    return context.imageMapHighlighter;
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

Firebug.Inspector.FrameHighlighter = function()
{
};

Firebug.Inspector.FrameHighlighter.prototype =
{
    ident: ident.frame,

    doNotHighlight: function(element)
    {
        return false; // (element instanceof XULElement);
    },

    highlight: function(context, element, extra, colorObj, isMulti)
    {
        if (this.doNotHighlight(element))
            return;

        // if a single color was passed in lets use it as the border color
        if (typeof colorObj === "string")
            colorObj = {background: "transparent", border: colorObj};
        else
            colorObj = colorObj || {background: "transparent", border: "highlight"};

        Firebug.Inspector.attachRepaintInspectListeners(context, element);
        storeHighlighterParams(this, context, element, null, colorObj, null, isMulti);

        var cs;
        var offset = Dom.getLTRBWH(element);
        var x = offset.left, y = offset.top;
        var w = offset.width, h = offset.height;

        if (FBTrace.DBG_INSPECT)
            FBTrace.sysout("FrameHighlighter HTML tag:" + element.tagName + " x:" + x +
                " y:" + y + " w:" + w + " h:" + h);

        var wacked = isNaN(x) || isNaN(y) || isNaN(w) || isNaN(h);
        if (wacked)
        {
            if (FBTrace.DBG_INSPECT)
                FBTrace.sysout("FrameHighlighter.highlight has bad boxObject for " + element.tagName);

            return;
        }

        if (element.tagName !== "AREA")
        {
            if (FBTrace.DBG_INSPECT)
                FBTrace.sysout("FrameHighlighter " + element.tagName);

            var body = Dom.getNonFrameBody(element);
            if (!body)
                return this.unhighlight(context);

            this.ihl && this.ihl.show(false);

            QuickInfoBox.show(element);

            var highlighter = this.getHighlighter(context, isMulti);
            var bgDiv = highlighter.firstChild;
            var css = moveImp(null, x, y) + resizeImp(null, w, h);

            if (Dom.isElement(element))
            {
                cs = body.ownerDocument.defaultView.getComputedStyle(element, null);

                if (cs.transform && cs.transform != "none")
                    css += "transform: " + cs.transform + " !important;" +
                           "transform-origin: " + cs.transformOrigin + " !important;";
                if (cs.borderRadius)
                    css += "border-radius: " + cs.borderRadius + " !important;";
                if (cs.borderTopLeftRadius)
                    css += "border-top-left-radius: " + cs.borderTopLeftRadius + " !important;";
                if (cs.borderTopRightRadius)
                    css += "border-top-right-radius: " + cs.borderTopRightRadius + " !important;";
                if (cs.borderBottomRightRadius)
                    css += "border-bottom-right-radius: " + cs.borderBottomRightRadius + " !important;";
                if (cs.borderBottomLeftRadius)
                    css += "border-bottom-left-radius: " + cs.borderBottomLeftRadius + " !important;";
            }
            css += "box-shadow: 0 0 2px 2px "+
                (colorObj && colorObj.border ? colorObj.border : "highlight")+"!important;";

            if (colorObj && colorObj.background)
            {
                bgDiv.style.cssText = "width: 100%!important; height: 100%!important;" +
                    "background-color: "+colorObj.background+"!important; opacity: 0.6!important;";
            }
            else
            {
                bgDiv.style.cssText = "background-color: transparent!important;";
            }

            highlighter.style.cssText = css;

            var needsAppend = !highlighter.parentNode || highlighter.ownerDocument != body.ownerDocument;
            if (needsAppend)
            {
                if (FBTrace.DBG_INSPECT)
                    FBTrace.sysout("FrameHighlighter needsAppend: " + highlighter.ownerDocument.documentURI +
                        " !?= " + body.ownerDocument.documentURI, highlighter);

                attachStyles(context, body.ownerDocument);

                try
                {
                    body.appendChild(highlighter);
                }
                catch(exc)
                {
                    if (FBTrace.DBG_INSPECT)
                        FBTrace.sysout("inspector.FrameHighlighter.highlight body.appendChild FAILS for body " +
                            body + " " + exc, exc);
                }

                // otherwise the proxies take up screen space in browser.xul
                if (element.ownerDocument && element.ownerDocument.contentType.indexOf("xul") === -1)
                    createProxiesForDisabledElements(body);
            }
        }
        else
        {
            this.ihl = getImageMapHighlighter(context);
            this.ihl.highlight(element, false);
        }
    },

    unhighlight: function(context)
    {
        if (FBTrace.DBG_INSPECT)
            FBTrace.sysout("FrameHighlighter unhighlight", context.window.location);

        var highlighter = this.getHighlighter(context);
        var body = highlighter.parentNode;
        if (body)
        {
            body.removeChild(highlighter);
            QuickInfoBox.hide();
        }

        this.ihl && this.ihl.destroy();
        this.ihl = null;
    },

    getHighlighter: function(context, isMulti)
    {
        if (!isMulti)
        {
            var div = HighlighterCache.get(ident.frame);
            if (div)
                return div;
        }

        var doc = context.window.document;
        div = doc.createElementNS("http://www.w3.org/1999/xhtml", "div");
        var div2 = doc.createElementNS("http://www.w3.org/1999/xhtml", "div");

        hideElementFromInspection(div);
        hideElementFromInspection(div2);

        div.className = "firebugResetStyles firebugBlockBackgroundColor";
        div2.className = "firebugResetStyles";
        div.appendChild(div2);
        div.ident = ident.frame;
        HighlighterCache.add(div);
        return div;
    }
};

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

function BoxModelHighlighter()
{
}

Firebug.Inspector.BoxModelHighlighter = BoxModelHighlighter;

BoxModelHighlighter.prototype =
{
    ident: ident.boxModel,

    highlight: function(context, element, boxFrame, colorObj, isMulti)
    {
        var line, contentCssText, paddingCssText, borderCssText, marginCssText,
            nodes = this.getNodes(context, isMulti),
            highlightFrame = boxFrame ? nodes[boxFrame] : null;

        // if a single color was passed in lets use it as the content box color
        if (typeof colorObj === "string")
            colorObj = {content: colorObj, padding: "SlateBlue", border: "#444444", margin: "#EDFF64"};
        else
            colorObj = colorObj || {content: "SkyBlue", padding: "SlateBlue", border: "#444444", margin: "#EDFF64"};

        Firebug.Inspector.attachRepaintInspectListeners(context, element);
        storeHighlighterParams(this, context, element, boxFrame, colorObj, null, isMulti);

        if (context.highlightFrame)
            Css.removeClass(context.highlightFrame, "firebugHighlightBox");

        if (element.tagName !== "AREA")
        {
            this.ihl && this.ihl.show(false);

            QuickInfoBox.show(element);
            context.highlightFrame = highlightFrame;

            if (highlightFrame)
            {
                Css.setClass(nodes.offset, "firebugHighlightGroup");
                Css.setClass(highlightFrame, "firebugHighlightBox");
            }
            else
                Css.removeClass(nodes.offset, "firebugHighlightGroup");

            var win = (element.ownerDocument ? element.ownerDocument.defaultView : null);
            if (!win)
                return;

            var style = win.getComputedStyle(element, "");
            if (!style)
            {
                if (FBTrace.DBG_INSPECT)
                    FBTrace.sysout("highlight: no style for element " + element, element);
                return;
            }

            var styles = Css.readBoxStyles(style);
            var offset = Dom.getLTRBWH(element);
            var x = offset.left - Math.abs(styles.marginLeft);
            var y = offset.top - Math.abs(styles.marginTop);
            var w = offset.width - (styles.paddingLeft + styles.paddingRight + styles.borderLeft + styles.borderRight);
            var h = offset.height - (styles.paddingTop + styles.paddingBottom + styles.borderTop + styles.borderBottom);

            moveImp(nodes.offset, x, y);
            marginCssText = pad(null, styles.marginTop, styles.marginRight, styles.marginBottom, styles.marginLeft);
            borderCssText = pad(null, styles.borderTop, styles.borderRight, styles.borderBottom, styles.borderLeft);
            paddingCssText = pad(null, styles.paddingTop, styles.paddingRight, styles.paddingBottom, styles.paddingLeft);
            contentCssText = resizeImp(null, w, h);

            // element.tagName !== "BODY" for issue 2447. hopefully temporary, robc
            var showLines = Firebug.showRulers && boxFrame && element.tagName !== "BODY";
            if (showLines)
            {
                var offsetParent = element.offsetParent;

                if (offsetParent)
                    this.setNodesByOffsetParent(win, offsetParent, nodes);

                var left = x;
                var top = y;
                var width = w-1;
                var height = h-1;

                if (boxFrame == "content")
                {
                    left += Math.abs(styles.marginLeft) + Math.abs(styles.borderLeft)
                        + Math.abs(styles.paddingLeft);
                    top += Math.abs(styles.marginTop) + Math.abs(styles.borderTop)
                        + Math.abs(styles.paddingTop);
                }
                else if (boxFrame == "padding")
                {
                    left += Math.abs(styles.marginLeft) + Math.abs(styles.borderLeft);
                    top += Math.abs(styles.marginTop) + Math.abs(styles.borderTop);
                    width += Math.abs(styles.paddingLeft) + Math.abs(styles.paddingRight);
                    height += Math.abs(styles.paddingTop) + Math.abs(styles.paddingBottom);
                }
                else if (boxFrame == "border")
                {
                    left += Math.abs(styles.marginLeft);
                    top += Math.abs(styles.marginTop);
                    width += Math.abs(styles.paddingLeft) + Math.abs(styles.paddingRight)
                         + Math.abs(styles.borderLeft) + Math.abs(styles.borderRight);
                    height += Math.abs(styles.paddingTop) + Math.abs(styles.paddingBottom)
                        + Math.abs(styles.borderTop) + Math.abs(styles.borderBottom);
                }
                else if (boxFrame == "margin")
                {
                    width += Math.abs(styles.paddingLeft) + Math.abs(styles.paddingRight)
                         + Math.abs(styles.borderLeft) + Math.abs(styles.borderRight)
                         + Math.abs(styles.marginLeft) + Math.abs(styles.marginRight);
                    height += Math.abs(styles.paddingTop) + Math.abs(styles.paddingBottom)
                        + Math.abs(styles.borderTop) + Math.abs(styles.borderBottom)
                        + Math.abs(styles.marginTop) + Math.abs(styles.marginBottom);
                }

                moveImp(nodes.lines.top, 0, top);
                moveImp(nodes.lines.right, left + width, 0);
                moveImp(nodes.lines.bottom, 0, top + height);
                moveImp(nodes.lines.left, left, 0);
            }

            var body = Dom.getNonFrameBody(element);
            if (!body)
                return this.unhighlight(context);

            if (colorObj.content)
                nodes.content.style.cssText = contentCssText + " background-color: " + colorObj.content + " !important;";
            else
                nodes.content.style.cssText = contentCssText + " background-color: #87CEEB !important;";

            if (colorObj.padding)
                nodes.padding.style.cssText = paddingCssText + " background-color: " + colorObj.padding + " !important;";
            else
                nodes.padding.style.cssText = paddingCssText + " background-color: #6A5ACD !important;";

            if (colorObj.border)
                nodes.border.style.cssText = borderCssText + " background-color: " + colorObj.border + " !important;";
            else
                nodes.border.style.cssText = borderCssText + " background-color: #444444 !important;";

            if (colorObj.margin)
                nodes.margin.style.cssText = marginCssText + " background-color: " + colorObj.margin + " !important;";
            else
                nodes.margin.style.cssText = marginCssText + " background-color: #EDFF64 !important;";

            var needsAppend = !nodes.offset.parentNode
                || nodes.offset.parentNode.ownerDocument != body.ownerDocument;

            if (needsAppend)
            {
                attachStyles(context, body.ownerDocument);
                body.appendChild(nodes.offset);
            }

            if (showLines)
            {
                if (!nodes.lines.top.parentNode)
                {
                    if (nodes.parent)
                        body.appendChild(nodes.parent);

                    for (line in nodes.lines)
                        body.appendChild(nodes.lines[line]);
                }
            }
            else if (nodes.lines.top.parentNode)
            {
                if (nodes.parent)
                    body.removeChild(nodes.parent);

                for (line in nodes.lines)
                    body.removeChild(nodes.lines[line]);
            }
        }
        else
        {
            this.ihl = getImageMapHighlighter(context);
            this.ihl.highlight(element, true);
        }
    },

    unhighlight: function(context)
    {
        HighlighterCache.clear();
        QuickInfoBox.hide();
    },

    getNodes: function(context, isMulti)
    {
        function create(className, name)
        {
            var div = doc.createElementNS("http://www.w3.org/1999/xhtml", "div");
            hideElementFromInspection(div);

            if (className !== CustomizableBox)
                div.className = className + name;
            else
                div.className = className;

            return div;
        }

        if (context.window)
        {
            var doc = context.window.document;

            if (FBTrace.DBG_ERRORS && !doc)
                FBTrace.sysout("inspector getNodes no document for window:" + window.location);
            if (FBTrace.DBG_INSPECT && doc)
                FBTrace.sysout("inspect.getNodes doc: " + doc.location);

            if (!isMulti)
            {
                var nodes = HighlighterCache.get(ident.boxModel);
                if (nodes)
                    return nodes;
            }

            var Ruler = "firebugResetStyles firebugBlockBackgroundColor firebugRuler firebugRuler";
            var Box = "firebugResetStyles firebugBlockBackgroundColor firebugLayoutBox firebugLayoutBox";
            var CustomizableBox = "firebugResetStyles firebugLayoutBox";
            var Line = "firebugResetStyles firebugBlockBackgroundColor firebugLayoutLine firebugLayoutLine";

            var nodes =
            {
                parent: create(Box, "Parent"),
                rulerH: create(Ruler, "H"),
                rulerV: create(Ruler, "V"),
                offset: create(Box, "Offset"),
                margin: create(CustomizableBox, "Margin"),
                border: create(CustomizableBox, "Border"),
                padding: create(CustomizableBox, "Padding"),
                content: create(CustomizableBox, "Content"),
                lines: {
                    top: create(Line, "Top"),
                    right: create(Line, "Right"),
                    bottom: create(Line, "Bottom"),
                    left: create(Line, "Left")
                }
            };

            nodes.parent.appendChild(nodes.rulerH);
            nodes.parent.appendChild(nodes.rulerV);
            nodes.offset.appendChild(nodes.margin);
            nodes.margin.appendChild(nodes.border);
            nodes.border.appendChild(nodes.padding);
            nodes.padding.appendChild(nodes.content);
        }

        nodes.ident = ident.boxModel;
        HighlighterCache.add(nodes);
        return nodes;
    },

    setNodesByOffsetParent: function(win, offsetParent, nodes)
    {
        var parentStyle = win.getComputedStyle(offsetParent, "");
        var parentOffset = Dom.getLTRBWH(offsetParent);
        var parentX = parentOffset.left + parseInt(parentStyle.borderLeftWidth, 10);
        var parentY = parentOffset.top + parseInt(parentStyle.borderTopWidth, 10);
        var parentW = offsetParent.offsetWidth-1;
        var parentH = offsetParent.offsetHeight-1;

        nodes.parent.style.cssText = moveImp(null, parentX, parentY) + resizeImp(null, parentW, parentH);

        if (parentX < 14)
            Css.setClass(nodes.parent, "overflowRulerX");
        else
            Css.removeClass(nodes.parent, "overflowRulerX");

        if (parentY < 14)
            Css.setClass(nodes.parent, "overflowRulerY");
        else
            Css.removeClass(nodes.parent, "overflowRulerY");
    }
};

// ********************************************************************************************* //

function attachStyles(context, doc)
{
    if (!context.highlightStyleCache)
        context.highlightStyleCache = new WeakMap();
    var highlightStyleCache = context.highlightStyleCache;

    var style;
    if (highlightStyleCache.has(doc))
    {
        style = highlightStyleCache.get(doc);
    }
    else
    {
        style = Css.createStyleSheet(doc, highlightCssUrl);
        highlightStyleCache.set(doc, style);
    }

    // Cater for the possiblity that someone might have removed our stylesheet.
    if (!style.parentNode)
        Css.addStyleSheet(doc, style);
}

function createProxiesForDisabledElements(body)
{
    var i, rect, div, node, cs, css,
        doc = body.ownerDocument,
        xpe = new XPathEvaluator(),
        nsResolver = xpe.createNSResolver(doc.documentElement);

    var result = xpe.evaluate("//*[@disabled]", doc.documentElement,
        nsResolver, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);

    var l = result.snapshotLength;
    for (i=0; i<l; i++)
    {
        node = result.snapshotItem(i);
        cs = body.ownerDocument.defaultView.getComputedStyle(node, null);
        rect = node.getBoundingClientRect();
        div = doc.createElementNS("http://www.w3.org/1999/xhtml", "div");
        hideElementFromInspection(div);
        div.className = "firebugResetStyles fbProxyElement";

        css = moveImp(null, rect.left, rect.top + body.scrollTop) + resizeImp(null, rect.width, rect.height);
        if (cs.transform && cs.transform != "none")
            css += "transform:" + cs.transform + " !important;" +
                   "transform-origin:" + cs.transformOrigin + " !important;";
        if (cs.borderRadius)
            css += "border-radius:" + cs.borderRadius + " !important;";
        if (cs.borderTopLeftRadius)
            css += "border-top-left-radius:" + cs.borderTopLeftRadius + " !important;";
        if (cs.borderTopRightRadius)
            css += "border-top-right-radius:" + cs.borderTopRightRadius + " !important;";
        if (cs.borderBottomRightRadius)
            css += "border-bottom-right-radius:" + cs.borderBottomRightRadius + " !important;";
        if (cs.borderBottomLeftRadius)
            css += "border-bottom-left-radius:" + cs.borderBottomLeftRadius + " !important;";

        div.style.cssText = css;
        div.fbProxyFor = node;

        body.appendChild(div);
        div.ident = ident.proxyElt;
        HighlighterCache.add(div);
    }
}

function isVisibleElement(elt)
{
    var invisibleElements =
        {
            "head": true,
            "base": true,
            "basefont": true,
            "isindex": true,
            "link": true,
            "meta": true,
            "script": true,
            "style": true,
            "title": true
        };

    return !invisibleElements[elt.nodeName.toLowerCase()];
}

function hideElementFromInspection(elt)
{
    if (!FBTrace.DBG_INSPECT)
        Firebug.setIgnored(elt);
}

// highlightType is only to be used for multihighlighters
function storeHighlighterParams(highlighter, context, element, boxFrame, colorObj,
    highlightType, isMulti)
{
    var fir = Firebug.Inspector.repaint;

    fir.highlighter = highlighter;
    fir.context = context;
    fir.element = element;
    fir.boxFrame = boxFrame;
    fir.colorObj = colorObj;
    fir.highlightType = highlightType;
    fir.isMulti = isMulti;

    Firebug.Inspector.highlightedContext = context;
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.Inspector);

return Firebug.Inspector;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/html/layout",
[
    "firebug/firebug",
    "firebug/chrome/panel",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/xml",
    "firebug/chrome/menu",
    "firebug/editor/inlineEditor",
    "firebug/chrome/measureBox",
],
function(Firebug, Panel, FBTrace, Obj, Domplate, Locale, Events, Css, Dom, Xml, Menu,
    InlineEditor, MeasureBox) {

"use strict"

// ********************************************************************************************* //
// Constants

var {domplate, DIV, SPAN} = Domplate;

// ********************************************************************************************* //
// LayoutPanel Implementation

/**
 * @panel Represents the Layout side panel available within the HTML panel. The Layout
 * panel allows inspecting and manipulating the layout data of the selected DOM node.
 * The layout data editing is done through {@LayoutEditor} object.
 */
function LayoutPanel() {}
LayoutPanel.prototype = Obj.extend(Panel,
/** @lends LayoutPanel */
{
    name: "layout",
    parentPanel: "html",
    order: 2,
    enableA11y: true,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Domplate

    template: domplate(
    {
        tag:
            DIV({"class": "outerLayoutBox"},
                DIV({"class": "positionLayoutBox $outerTopMode $outerRightMode " +
                        "$outerBottomMode $outerLeftMode focusGroup"},
                    DIV({"class": "layoutEdgeTop layoutEdge"}),
                    DIV({"class": "layoutEdgeRight layoutEdge"}),
                    DIV({"class": "layoutEdgeBottom layoutEdge"}),
                    DIV({"class": "layoutEdgeLeft layoutEdge"}),

                    DIV({"class": "layoutLabelBottom layoutLabel layoutLabelPosition"},
                        SPAN({"class": "layoutPosition layoutCaption",
                                "aria-label": Locale.$STR("a11y.layout.position")},
                            Locale.$STR("position") + ": " + "$position"),
                        SPAN({"class": "layoutBoxSizing layoutCaption",
                                "aria-label": Locale.$STR("a11y.layout.box-sizing")},
                            Locale.$STR("a11y.layout.box-sizing") + ": " + "$boxSizing"),
                        SPAN({"class": "layoutZIndex", $invisible: "$zIndex|isInvisible",
                                "aria-label": Locale.$STR("a11y.layout.z-index")},
                            "z: " + "$zIndex")
                    ),

                    DIV({"class": "layoutLabelTop layoutLabel",
                            $invisible: "$outerTop|isInvisible"},
                        SPAN({"class": "layoutLabelOuterTop editable focusStart",
                                "aria-label": Locale.$STR("a11y.layout.position top")},
                            "$outerTop"
                        )
                    ),
                    DIV({"class": "layoutLabelRight layoutLabel",
                            $invisible: "$outerRight|isInvisible"},
                        SPAN({"class": "layoutLabelOuterRight editable",
                                "aria-label": Locale.$STR("a11y.layout.position right")},
                            "$outerRight"
                        )
                    ),
                    DIV({"class": "layoutLabelBottom layoutLabel",
                            $invisible: "$outerBottom|isInvisible"},
                        SPAN({"class": "layoutLabelOuterBottom editable",
                                "aria-label": Locale.$STR("a11y.layout.position bottom")},
                            "$outerBottom"
                        )
                    ),
                    DIV({"class": "layoutLabelLeft layoutLabel",
                            $invisible: "$outerLeft|isInvisible"},
                        SPAN({"class": "layoutLabelOuterLeft editable",
                                "aria-label": Locale.$STR("a11y.layout.position left")},
                            "$outerLeft"
                        )
                    ),

                    DIV({"class": "outerLabel layoutCaption"}, "$outerLabel"),


                    DIV({"class": "marginLayoutBox layoutBox editGroup focusGroup"},
                        DIV({"class": "layoutCaption"}, Locale.$STR("LayoutMargin")),
                        DIV({"class": "layoutLabelTop layoutLabel",
                                $invisible: "$marginTop|isInvisible"},
                            SPAN({"class": "layoutLabelMarginTop editable focusStart",
                                    "aria-label": Locale.$STR("a11y.layout.margin top")},
                                "$marginTop"
                            )
                        ),
                        DIV({"class": "layoutLabelRight layoutLabel",
                                $invisible: "$marginRight|isInvisible"},
                            SPAN({"class": "layoutLabelMarginRight editable",
                                    "aria-label": Locale.$STR("a11y.layout.margin right")},
                                "$marginRight"
                            )
                        ),
                        DIV({"class": "layoutLabelBottom layoutLabel",
                                $invisible: "$marginBottom|isInvisible"},
                            SPAN({"class": "layoutLabelMarginBottom editable",
                                    "aria-label": Locale.$STR("a11y.layout.margin bottom")},
                                "$marginBottom"
                            )
                        ),
                        DIV({"class": "layoutLabelLeft layoutLabel",
                                $invisible: "$marginLeft|isInvisible"},
                            SPAN({"class": "layoutLabelMarginLeft editable",
                                    "aria-label": Locale.$STR("a11y.layout.margin left")},
                                "$marginLeft"
                            )
                        ),

                        DIV({"class": "borderLayoutBox layoutBox editGroup focusGroup"},
                            DIV({"class": "layoutCaption"}, Locale.$STR("LayoutBorder")),
                            DIV({"class": "layoutLabelTop layoutLabel",
                                    $invisible: "$borderTop|isInvisible"},
                                SPAN({"class": "layoutLabelBorderTop editable  focusStart",
                                        "aria-label": Locale.$STR("a11y.layout.border top")},
                                    "$borderTop"
                                )
                            ),
                            DIV({"class": "layoutLabelRight layoutLabel",
                                    $invisible: "$borderRight|isInvisible"},
                                SPAN({"class": "layoutLabelBorderRight editable",
                                        "aria-label": Locale.$STR("a11y.layout.border right")},
                                    "$borderRight"
                                )
                            ),
                            DIV({"class": "layoutLabelBottom layoutLabel",
                                    $invisible: "$borderBottom|isInvisible"},
                                SPAN({"class": "layoutLabelBorderBottom editable",
                                        "aria-label": Locale.$STR("a11y.layout.border bottom")},
                                    "$borderBottom"
                                )
                            ),
                            DIV({"class": "layoutLabelLeft layoutLabel",
                                    $invisible: "$borderLeft|isInvisible"},
                                SPAN({"class": "layoutLabelBorderLeft editable",
                                        "aria-label": Locale.$STR("a11y.layout.border left")},
                                    "$borderLeft"
                                )
                            ),

                            DIV({"class": "paddingLayoutBox layoutBox editGroup focusGroup"},
                                DIV({"class": "layoutCaption"}, Locale.$STR("LayoutPadding")),
                                DIV({"class": "layoutLabelTop layoutLabel",
                                        $invisible: "$paddingTop|isInvisible"},
                                    SPAN({"class": "layoutLabelPaddingTop editable focusStart",
                                            "aria-label": Locale.$STR("a11y.layout.padding top")},
                                        "$paddingTop"
                                    )
                                ),
                                DIV({"class": "layoutLabelRight layoutLabel",
                                        $invisible: "$paddingRight|isInvisible"},
                                    SPAN(
                                        {
                                            "class": "layoutLabelPaddingRight editable",
                                            "aria-label":
                                                Locale.$STR("a11y.layout.padding right")
                                        },
                                        "$paddingRight"
                                    )
                                ),
                                DIV({"class": "layoutLabelBottom layoutLabel",
                                        $invisible: "$paddingBottom|isInvisible"},
                                    SPAN(
                                        {
                                            "class": "layoutLabelPaddingBottom editable",
                                            "aria-label":
                                                Locale.$STR("a11y.layout.padding bottom")
                                        },
                                        "$paddingBottom"
                                    )
                                ),
                                DIV({"class": "layoutLabelLeft layoutLabel",
                                        $invisible: "$paddingLeft|isInvisible"},
                                    SPAN({"class": "layoutLabelPaddingLeft editable",
                                            "aria-label": Locale.$STR("a11y.layout.padding left")},
                                        "$paddingLeft"
                                    )
                                ),

                                DIV({"class": "contentLayoutBox layoutBox editGroup focusGroup"},
                                    DIV({"class": "layoutLabelCenter layoutLabel"},
                                        SPAN({"class": "layoutLabelWidth layoutLabel editable "+
                                                "focusStart",
                                                "aria-label": Locale.$STR("a11y.layout.width")},
                                            "$width"
                                        ),
                                        " x ",
                                        SPAN({"class": "layoutLabelHeight layoutLabel editable",
                                                "aria-label": Locale.$STR("a11y.layout.height")},
                                            "$height"
                                        )
                                    )
                                )
                            )
                        )
                    )
                )
            ),

        isInvisible: function(value)
        {
            return value == 0;
        }
    }),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onMouseOver: function(event)
    {
        var layoutBox = Dom.getAncestorByClass(event.target, "layoutBox");
        var boxFrame = layoutBox ? getBoxFrame(layoutBox) : null;

        if (this.highlightedBox)
            Css.removeClass(this.highlightedBox, "highlighted");

        this.highlightedBox = layoutBox;

        if (layoutBox)
            Css.setClass(layoutBox, "highlighted");

        Firebug.Inspector.highlightObject(this.selection, this.context, "boxModel", boxFrame);
    },

    onMouseOut: function(event)
    {
        var nextTarget = event.relatedTarget;
        if (nextTarget && Dom.getAncestorByClass(nextTarget, "layoutBox"))
            return;

        if (this.highlightedBox)
            Css.removeClass(this.highlightedBox, "highlighted");

        this.highlightedBox = null;

        Firebug.Inspector.highlightObject(null, null, "boxModel");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Extends Panel

    initialize: function()
    {
        this.onMouseOver = Obj.bind(this.onMouseOver, this);
        this.onMouseOut = Obj.bind(this.onMouseOut, this);
        this.onAfterPaint = Obj.bindFixed(this.onMozAfterPaint, this);

        Panel.initialize.apply(this, arguments);
    },

    initializeNode: function(oldPanelNode)
    {
        Events.addEventListener(this.panelNode, "mouseover", this.onMouseOver, false);
        Events.addEventListener(this.panelNode, "mouseout", this.onMouseOut, false);

        Panel.initializeNode.apply(this, arguments);
    },

    destroyNode: function()
    {
        Events.removeEventListener(this.panelNode, "mouseover", this.onMouseOver, false);
        Events.removeEventListener(this.panelNode, "mouseout", this.onMouseOut, false);

        Panel.destroyNode.apply(this, arguments);
    },

    show: function(state)
    {
        Events.addEventListener(this.context.browser, "MozAfterPaint", this.onAfterPaint, true);
    },

    hide: function()
    {
        Events.removeEventListener(this.context.browser, "MozAfterPaint", this.onAfterPaint, true);
    },

    supportsObject: function(object, type)
    {
        return object instanceof window.Element ? 1 : 0;
    },

    onMozAfterPaint: function()
    {
        // TabContext.invalidatePanels() method calls panel.refresh() on timeout and ensures
        // that it isn't executed too often. This is necessary in this case since
        // "MozAfterPaint" event can be fired very often (especially in case of animations)
        // and the update (see: updateSelection) could consume CPU cycles (see issue 6336).
        this.context.invalidatePanels("layout");
    },

    refresh: function()
    {
        this.updateSelection(this.selection);
    },

    updateSelection: function(element)
    {
        var view = element ? element.ownerDocument.defaultView : null;
        if (!view)
            return this.panelNode.textContent = "";

        var style = view.getComputedStyle(element, "");
        var args = Css.getBoxFromStyles(style, element);

        args.outerLeft = args.outerRight = args.outerTop = args.outerBottom = '';
        args.outerLeftMode = args.outerRightMode = args.outerTopMode = args.outerBottomMode = "";
        args.zIndex = args.zIndex ? args.zIndex : "auto";

        var boxSizing = style.getPropertyCSSValue("box-sizing") ||
            style.getPropertyCSSValue("-moz-box-sizing");
        args.boxSizing = boxSizing.cssText;

        var position = style.getPropertyCSSValue("position").cssText;
        args.position = position;
        args.outerLabel = "";

        if (Xml.isElementSVG(element) || Xml.isElementMathML(element) || Xml.isElementXUL(element))
        {
            var rect = element.getBoundingClientRect();
            // XXXjjb I believe this is incorrect. We should use the value as given by the call
            //if (rect.wrappedJSObject)
            //    rect = rect.wrappedJSObject;

            args.width = Math.round(rect.width);
            args.height = Math.round(rect.height);
        }

        // these Modes are classes on the domplate
        args.outerLeftMode = args.outerRightMode = args.outerTopMode = args.outerBottomMode =
            "blankEdge";

        function getStyle(style, name)
        {
            var value = style.getPropertyCSSValue(name);
            return value && value.cssText ? parseInt(value.cssText) : " ";
        }

        if (position == "absolute" || position == "fixed" || position == "relative")
        {
            args.outerLabel = Locale.$STR("LayoutPosition");
            args.outerLeft = getStyle(style, "left");
            args.outerTop = getStyle(style, "top");
            args.outerRight = getStyle(style, "right");
            args.outerBottom = getStyle(style, "bottom");
            args.outerLeftMode = args.outerRightMode = args.outerTopMode = args.outerBottomMode =
                "absoluteEdge";
        }

        var node = this.panelNode.getElementsByClassName("outerLayoutBox").item(0);
        // If the layout panel content was already created, just fill in the new values
        if (node)
        {
            // The styles for the positionLayoutBox need to be set manually
            var positionLayoutBox = this.panelNode.getElementsByClassName("positionLayoutBox").
                item(0);

            positionLayoutBox.className = "positionLayoutBox " + args.outerTopMode + " " +
                args.outerRightMode + " " + args.outerBottomMode + " " + args.outerLeftMode +
                " focusGroup";

            var values =
            {
                layoutPosition: {label: Locale.$STR("position"), value: "position"},
                layoutBoxSizing: {label: Locale.$STR("a11y.layout.box-sizing"),
                    value: "boxSizing"},
                layoutZIndex: {label: "z", value: "zIndex"},
                layoutLabelOuterTop: {value: "outerTop"},
                layoutLabelOuterRight: {value: "outerRight"},
                layoutLabelOuterBottom: {value: "outerBottom"},
                layoutLabelOuterLeft: {value: "outerLeft"},
                layoutLabelMarginTop: {value: "marginTop"},
                layoutLabelMarginRight: {value: "marginRight"},
                layoutLabelMarginBottom: {value: "marginBottom"},
                layoutLabelMarginLeft: {value: "marginLeft"},
                layoutLabelBorderTop: {value: "borderTop"},
                layoutLabelBorderRight: {value: "borderRight"},
                layoutLabelBorderBottom: {value: "borderBottom"},
                layoutLabelBorderLeft: {value: "borderLeft"},
                layoutLabelPaddingTop: {value: "paddingTop"},
                layoutLabelPaddingRight: {value: "paddingRight"},
                layoutLabelPaddingBottom: {value: "paddingBottom"},
                layoutLabelPaddingLeft: {value: "paddingLeft"},
                layoutLabelWidth: {value: "width"},
                layoutLabelHeight: {value: "height"},
                outerLabel: {value: "outerLabel"}
            };

            for (var val in values)
            {
                var element = this.panelNode.getElementsByClassName(val).item(0);

                element.textContent = values[val].label ?
                    values[val].label+": "+args[values[val].value] : args[values[val].value];

                if (this.template.isInvisible(args[values[val].value]))
                    Css.setClass(element.parentNode, "invisible");
                else
                    Css.removeClass(element.parentNode, "invisible");
            }
        }
        else
        {
            node = this.template.tag.replace(args, this.panelNode);
        }

        this.adjustCharWidth(this.getMaxCharWidth(args, node), this.panelNode);

        Events.dispatch(this.fbListeners, "onLayoutBoxCreated", [this, node, args]);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * The nested boxes of the Layout panel have digits which need to fit between the boxes.
     * @param maxWidth: pixels the largest digit string
     * @param node: panelNode to be adjusted (from tag:)
     */
    adjustCharWidth: function(maxWidth, node)
    {
        maxWidth += 10; // margin
        if (maxWidth < 20)
            maxWidth = 20;

        this.adjustBoxWidth(node, "marginLayoutBox", maxWidth);
        this.adjustBoxWidth(node, "borderLayoutBox", maxWidth);
        this.adjustBoxWidth(node, "paddingLayoutBox", maxWidth);

        var box = node.getElementsByClassName("outerLayoutBox").item(0);
        box.style.cssText = "width: "+(240 + 3*maxWidth) + "px;";  // defaults to 300px

        this.adjustLabelWidth(node, "layoutLabelLeft", maxWidth);
        this.adjustLabelWidth(node, "layoutLabelRight", maxWidth);
    },

    /**
     * By adjusting this width, the labels can be centered.
     */
    adjustLabelWidth: function(node, labelName, maxWidth)
    {
        var labels = node.getElementsByClassName(labelName);
        for (var i = 0; i < labels.length; i++)
            labels[i].style.cssText = "width: " + maxWidth + "px;";
    },

    adjustBoxWidth: function(node, boxName, width)
    {
        var box = node.getElementsByClassName(boxName).item(0);
        box.style.cssText = "right: " + width + "px;" + " left: " + width + "px;";
    },

    getMaxCharWidth: function(args, node)
    {
        MeasureBox.startMeasuring(node);

        var maxWidth = Math.max(
            MeasureBox.measureText(args.marginLeft + "").width,
            MeasureBox.measureText(args.marginRight + "").width,
            MeasureBox.measureText(args.borderLeft + "").width,
            MeasureBox.measureText(args.borderRight + "").width,
            MeasureBox.measureText(args.paddingLeft + "").width,
            MeasureBox.measureText(args.paddingRight + "").width
        );

        MeasureBox.stopMeasuring();
        return maxWidth;
    },

    getOptionsMenuItems: function()
    {
        return [
            Menu.optionMenu("ShowRulers", "showRulers", "layout.option.tip.Show_Rulers")
        ];
    },

    getEditor: function(target, value)
    {
        if (!this.editor)
            this.editor = new LayoutEditor(this.document);

        return this.editor;
    }
});

// ********************************************************************************************* //
// LayoutEditor Implementation

function LayoutEditor(doc)
{
    this.initializeInline(doc);

    this.noWrap = false;
    this.numeric = true;
}

/**
 * @editor Represents an inline editor that is used by {@LayoutPanel} to modify layout data.
 */
LayoutEditor.prototype = domplate(InlineEditor.prototype,
/** @lends LayoutEditor */
{
    saveEdit: function(target, value, previousValue)
    {
        if (!this.panel.selection.style)
            return;

        var labelBox = Dom.getAncestorByClass(target, "layoutLabel");
        var layoutBox = getLayoutBox(labelBox);

        var boxFrame = getBoxFrame(layoutBox);
        var boxEdge = getBoxEdge(labelBox);

        var styleName;
        if (boxFrame == "content" || boxFrame == "position")
            styleName = boxEdge.toLowerCase();
        else if (boxFrame == "border")
            styleName = boxFrame+boxEdge+"Width";
        else
            styleName = boxFrame+boxEdge;

        var intValue = value ? value : 0;
        this.panel.selection.style[styleName] = intValue + "px";

        if (Firebug.Inspector.highlightedElement == this.panel.selection)
        {
            var boxFrame = this.highlightedBox ? getBoxFrame(this.highlightedBox) : null;
            Firebug.Inspector.highlightObject(this.panel.selection, this.panel.context,
                "boxModel", boxFrame);
        }

        target.textContent = intValue;
    },

    endEditing: function(target, value, cancel)
    {
        // Don't remove groups
        return false;
    }
});

// ********************************************************************************************* //
// Local Helpers

function getLayoutBox(element)
{
    var re = /([^\s]+)LayoutBox/;
    for (var box = element; box; box = box.parentNode)
    {
        if (re.exec(box.className))
            return box;
    }
}

function getBoxFrame(element)
{
    var re = /([^\s]+)LayoutBox/;
    var m = re.exec(element.className);
    return m ? m[1] : "";
}

function getBoxEdge(element)
{
    var re = /layoutLabel([^\s]+)/;
    var m = re.exec(element.className);
    return m ? m[1] : "";
}

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(LayoutPanel);

return LayoutPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/html/quickInfoBox",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/chrome/firefox",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/lib/domplate",
    "firebug/lib/object",
    "firebug/lib/css"
],
function(Firebug, Module, Firefox, Locale, Events, Dom, Options, Domplate, Obj, Css) {

"use strict"

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;
var Cu = Components.utils;

var domAttribs = ["nodeName", "id", "name", "offsetWidth", "offsetHeight"];
var cssAttribs = ["position"];
var compAttribs = [
    "width", "height", "zIndex", "position", "top", "right", "bottom", "left",
    "margin-top", "margin-right", "margin-bottom", "margin-left", "color",
    "backgroundColor", "fontFamily", "cssFloat", "display", "visibility"
];

// ********************************************************************************************* //
// Domplate

var {domplate, DIV, TABLE, TBODY, TR, TD, SPAN} = Domplate;

var tableTag =
    TABLE({"class": "fbQuickInfoTable", cellpadding: 0, cellspacing: 0},
        TBODY(
            TR({"class": "pin"},
                TD({"class": "", align: "right"},
                    DIV({"class": "fbQuickInfoPin $pin button", onclick: "$onClickPin"}),
                    DIV({"class": "fbQuickInfoClose button", onclick: "$onClickClose"})
                )
            )
        )
    );

var titleTag =
    TR(
        TD({"class": "fbQuickInfoBoxTitle"},
            SPAN("$title")
        )
    );

var rowTag =
    TR({"class": "row"},
        TD({"class": ""},
            SPAN({"class": "fbQuickInfoName"}, "$name: "),
            SPAN({"class": "fbQuickInfoValue"}, "$value")
        )
    );

// ********************************************************************************************* //
// Implementation

/**
 * Displays the most important DOM properties and computed CSS styles for the currently
 * inspected element. It can be freely positioned at the monitor via drag & drop.
 */
var QuickInfoBox = Obj.extend(Module,
/** @lends QuickInfoBox */
{
    boxEnabled: undefined,
    dragging: false,
    storedX: null,
    storedY: null,
    prevX: null,
    prevY: null,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        this.qiPanel = Firebug.chrome.$("fbQuickInfoPanel");

        this.onContentLoadedListener = this.onContentLoaded.bind(this);
        this.onMouseDownListener = this.onMouseDown.bind(this);
        this.onMouseOverListener = this.onMouseOver.bind(this);
        this.onMouseOutListener = this.onMouseOut.bind(this);
        this.onMouseMoveListener = this.onMouseMove.bind(this);
        this.onMouseUpListener = this.onMouseUp.bind(this);

        var frame = this.getContentFrame();
        Events.addEventListener(frame, "load", this.onContentLoadedListener, true);

        Events.addEventListener(this.qiPanel, "mousedown", this.onMouseDownListener, true);
        Events.addEventListener(this.qiPanel, "mouseover", this.onMouseOverListener, true);
        Events.addEventListener(this.qiPanel, "mouseout", this.onMouseOutListener, true);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        var frame = this.getContentFrame();
        Events.removeEventListener(frame, "load", this.onContentLoadedListener, true);

        Events.removeEventListener(this.qiPanel, "mousedown", this.onMouseDownListener, true);
        Events.removeEventListener(this.qiPanel, "mouseover", this.onMouseOverListener, true);
        Events.removeEventListener(this.qiPanel, "mouseout", this.onMouseOutListener, true);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onContentLoaded: function(event)
    {
        var doc = this.getContentDoc();
        doc.body.classList.add("fbQuickInfoPanelBody");

        Css.appendStylesheet(doc, "chrome://firebug/content/html/quickInfoBox.css");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Show/hide

    show: function(element)
    {
        if (!this.boxEnabled || !element)
            return;

        this.needsToHide = false;

        if (this.qiPanel.state === "closed")
        {
            var content = Firefox.getElementById("content");
            this.storedX = this.storedX || content.tabContainer.boxObject.screenX + 5;
            this.storedY = this.storedY || content.tabContainer.boxObject.screenY + 35;

            // Dynamically set noautohide to avoid Mozilla bug 545265.
            if (!this.noautohideAdded)
            {
                var self = this;
                this.noautohideAdded = true;
                this.qiPanel.addEventListener("popupshowing", function runOnce()
                {
                    self.qiPanel.removeEventListener("popupshowing", runOnce, false);
                    self.qiPanel.setAttribute("noautohide", true);
                }, false);
            }

            this.qiPanel.openPopupAtScreen(this.storedX, this.storedY, false);
        }

        var doc = this.getContentDoc();
        var parentNode = doc.body;

        // The tableTag template doesn't have its own object and so, we specify
        // all event handlers and properties through the input object.
        var input = {
            onClickPin: this.onClickPin.bind(this),
            pin: Options.get("pinQuickInfoBox") ? "pin" : "",
            onClickClose: this.onClickClose.bind(this),
        }

        // Render the basic quick-box layout. It's a table where every row represents
        // a CSS property or a section title. The pin icon displayed at the top-right
        // corner also gets one row.
        var table = tableTag.replace(input, parentNode, this);
        var tbody = table.firstChild;

        var needsTitle = this.addRows(element, tbody, domAttribs);
        var needsTitle2 = this.addRows(element.style, tbody, cssAttribs);

        // Properly create section titles.
        if (needsTitle || needsTitle2)
            titleTag.insertRows({title: Locale.$STR("quickInfo")}, tbody.firstChild, this);

        titleTag.insertRows({title: Locale.$STR("computedStyle")}, tbody.lastChild, this);

        // Generate content (a row == CSS property)
        this.addRows(element, tbody, compAttribs, true);

        // Always update size of the panel according to the content size. Some elements might
        // have more styles than others and so, require more space. We always need
        // to avoid scroll-bars.
        // Keep the default width (specified in firebugOverlay.xul for fbQuickInfoPanel)
        // and change only the height.
        this.qiPanel.sizeTo(this.qiPanel.popupBoxObject.width, doc.documentElement.clientHeight);
    },

    hide: function()
    {
        // If the preference says pin == true then do not hide.
        // xxxHonza: the box should be hidden when the user switches out of the HTML panel.
        if (Options.get("pinQuickInfoBox"))
            return;

        // if mouse is over panel defer hiding to mouseout to not cause flickering
        if (this.mouseover || this.dragging)
        {
            this.needsToHide = true;
            return;
        }

        this.prevX = null;
        this.prevY = null;
        this.needsToHide = false;

        this.qiPanel.hidePopup();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    addRows: function(domBase, parentNode, attribs, computedStyle)
    {
        if (!domBase)
            return;

        // Iterate over all attributes and generate HTML content of the info box.
        var needsTitle = false;
        for (var i=0; i<attribs.length; i++)
        {
            var value;
            if (computedStyle)
            {
                var defaultView = Dom.getNonFrameBody(domBase).ownerDocument.defaultView;
                var cs = defaultView.getComputedStyle(domBase, null);

                value = cs.getPropertyValue(attribs[i]);

                if (value && /rgb\(\d+,\s\d+,\s\d+\)/.test(value))
                    value = rgbToHex(value);
            }
            else
            {
                value = domBase[attribs[i]];
            }

            if (!value)
                continue;

            // There is at least one value displayed so, the title should be generated.
            needsTitle = true;

            var input = {name: attribs[i], value: value}
            rowTag.insertRows(input, parentNode.lastChild, rowTag);
        }

        return needsTitle;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Events

    onClickPin: function(event)
    {
        var target = event.target;
        if (!Css.hasClass(target, "fbQuickInfoPin"))
            return;

        // The state of the pin needs to be updated in preferences.
        Options.togglePref("pinQuickInfoBox");

        // Update also the icon state.
        Css.toggleClass(target, "pin");
    },

    onClickClose: function(event)
    {
        var target = event.target;
        if (!Css.hasClass(target, "fbQuickInfoClose"))
            return;

        this.qiPanel.hidePopup();
    },

    onMouseDown: function(event)
    {
        var target = event.target;
        var node = target.firstChild ? target.firstChild.nodeType : target.nodeType;

        // skip dragging when user click on button or on text
        if (Css.hasClass(target, "button") || node == Node.TEXT_NODE)
            return;

        Events.addEventListener(this.qiPanel, "mousemove", this.onMouseMoveListener, true);
        Events.addEventListener(this.qiPanel, "mouseup", this.onMouseUpListener, true);

        this.dragging = true;
        this.prevX = event.screenX;
        this.prevY = event.screenY;
    },

    // this is a hack to find when mouse enters and leaves panel
    // it requires that #fbQuickInfoPanel have border
    onMouseOver: function(event)
    {
        if (this.dragging)
            return;

        this.mouseover = true;
    },

    onMouseOut: function(event)
    {
        if (this.dragging)
            return;

        this.mouseover = false;

        // if hiding was deferred because mouse was over panel hide it
        if (this.needsToHide && event.target.nodeName == "panel")
            this.hide();
    },

    onMouseMove: function(event)
    {
        if (!this.dragging)
            return;

        var box = this.qiPanel.boxObject;
        var boxX = box.screenX;
        var boxY = box.screenY;
        var x = event.screenX;
        var y = event.screenY;
        var diffX = x - this.prevX;
        var diffY = y - this.prevY;

        this.qiPanel.moveTo(boxX + diffX, boxY + diffY);

        this.prevX = x;
        this.prevY = y;
        this.storedX = boxX;
        this.storedY = boxY;
    },

    onMouseUp: function(event)
    {
        Events.removeEventListener(this.qiPanel, "mousemove", this.onMouseMoveListener, true);
        Events.removeEventListener(this.qiPanel, "mouseup", this.onMouseUpListener, true);

        this.prevX = this.prevY = null;
        this.dragging = false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Toggle the quick info box.
     */
    toggleQuickInfoBox: function()
    {
        if (this.qiPanel.state == "open")
            QuickInfoBox.hide();

        QuickInfoBox.boxEnabled = !QuickInfoBox.boxEnabled;

        Options.set("showQuickInfoBox", QuickInfoBox.boxEnabled);
    },

    /**
     * Hide the quick info box.
     */
    hideQuickInfoBox: function()
    {
        if (this.qiPanel.state === "open")
            QuickInfoBox.hide();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Helpers

    getContentFrame: function()
    {
        return this.qiPanel.getElementsByClassName("fbQuickInfoPanelContent")[0];
    },

    getContentDoc: function()
    {
        var contentFrame = this.getContentFrame();
        return contentFrame.contentWindow.document;
    },
});

// ********************************************************************************************* //
// Helpers

// xxxHonza: duplication of Css.rgbToHex
function rgbToHex(value)
{
    return value.replace(/\brgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/gi, function(_, r, g, b)
    {
        return "#"+((1 << 24) + (r << 16) + (g << 8) + (b << 0)).toString(16).substr(-6).toUpperCase();
    });
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(QuickInfoBox);

return QuickInfoBox;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/breakpoint",
[
    "firebug/chrome/module",
    "firebug/chrome/panel",
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/js/sourceLink",
    "firebug/js/stackFrame",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/lib/persist",
    "firebug/chrome/menu",
    "firebug/js/fbs",
    "firebug/editor/editor",
    "firebug/console/autoCompleter"
],
function(Module, Panel, Rep, Obj, Firebug, Domplate, FirebugReps, Locale, Events, SourceLink,
    StackFrame, Css, Dom, Str, Arr, Persist, Menu, FBS) {

// ********************************************************************************************* //
// Constants

var animationDuration = 0.8;

// ********************************************************************************************* //
// Breakpoints

Firebug.Breakpoint = Obj.extend(Module,
{
    dispatchName: "breakpoints",

    initialize: function()
    {
        Firebug.connection.addListener(this);
    },

    shutdown: function()
    {
        Firebug.connection.removeListener(this);
    },

    toggleBreakOnNext: function(panel)
    {
        var breakable = Firebug.chrome.getGlobalAttribute("cmd_firebug_toggleBreakOn", "breakable");

        if (FBTrace.DBG_BP)
        {
            FBTrace.sysout("breakpoint.toggleBreakOnNext; currentBreakable " + breakable +
                " in " + panel.context.getName());
        }

        // Toggle button's state.
        breakable = (breakable == "true" ? "false" : "true");
        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleBreakOn", "breakable", breakable);

        // Call the current panel's logic related to break-on-next.
        // If breakable == "true" the feature is currently disabled.
        var enabled = (breakable == "true" ? false : true);
        panel.breakOnNext(enabled);

        this.updatePanelState(panel);

        return enabled;
    },

    showPanel: function(browser, panel)
    {
        this.updatePanelState(panel);
    },

    onDebuggerEnabled: function()
    {
        var panel = Firebug.chrome.getSelectedPanel();
        this.updatePanelState(panel);
    },

    updatePanelState: function(panel)
    {
        // there is no selectedPanel?
        if (!panel)
            return;

        var breakButton = Firebug.chrome.$("fbBreakOnNextButton");
        if (panel.name)
            breakButton.setAttribute("panelName", panel.name);

        breakButton.removeAttribute("type");
        Dom.collapse(Firebug.chrome.$("fbBonButtons"), !panel.breakable);

        // The script panel can be created at this moment (the second parameter is false)
        // It's needed for break on next to work (do not wait till the user actually
        // selects the panel).
        var scriptPanel = panel.context.getPanel("script");
        var scriptEnabled = scriptPanel && scriptPanel.isEnabled();
        var tool = Firebug.connection.getTool("script");
        var scriptActive = tool && tool.getActive();
        var supported = panel.supportsBreakOnNext();

        // Enable by default and disable if needed.
        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleBreakOn", "disabled", null);

        // Disable BON if script is disabled or if BON isn't supported by the current panel.
        if (!scriptEnabled || !scriptActive || !supported)
        {
            Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleBreakOn", "breakable", "disabled");
            Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleBreakOn", "disabled", "true");
            this.updateBreakOnNextTooltips(panel);
            return;
        }

        // Set the tooltips and update break-on-next button's state.
        var shouldBreak = panel.shouldBreakOnNext();
        this.updateBreakOnNextState(panel, shouldBreak);
        this.updateBreakOnNextTooltips(panel);
        this.updatePanelTab(panel, shouldBreak);

        var menuItems = panel.getBreakOnMenuItems();
        if (!menuItems || !menuItems.length)
            return;

        breakButton.setAttribute("type", "menu-button");

        var menuPopup = Firebug.chrome.$("fbBreakOnNextOptions");
        Dom.eraseNode(menuPopup);

        Menu.createMenuItems(menuPopup, menuItems);
    },

    toggleTabHighlighting: function(event)
    {
        // Don't continue if it's the wrong animation phase
        if (Math.floor(event.elapsedTime * 10) % (animationDuration * 20) != 0)
            return;

        Events.removeEventListener(event.target, "animationiteration",
            Firebug.Breakpoint.toggleTabHighlighting, true);

        var panel = Firebug.currentContext.getPanel(event.target.panelType.prototype.name);
        if (!panel)
            return;

        if (!panel.context.delayedArmedTab)
            return;

        panel.context.delayedArmedTab.setAttribute("breakOnNextArmed", "true");
        delete panel.context.delayedArmedTab;
    },

    updateBreakOnNextTooltips: function(panel)
    {
        var breakable = Firebug.chrome.getGlobalAttribute("cmd_firebug_toggleBreakOn", "breakable");

        // Get proper tooltip for the break-on-next button from the current panel.
        // If breakable is set to "false" the feature is already activated (throbbing).
        var armed = (breakable == "false");
        var tooltip = panel.getBreakOnNextTooltip(armed);
        if (!tooltip)
            tooltip = "";

        // The user should know that BON is disabled if the Script panel (debugger) is disabled.
        if (breakable == "disabled")
            tooltip += " " + Locale.$STR("firebug.bon.scriptPanelNeeded");

        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleBreakOn", "tooltiptext", tooltip);
    },

    updateBreakOnNextState: function(panel, armed)
    {
        // If the panel should break at the next chance, set the button to not breakable,
        // which means already active (throbbing).
        var breakable = armed ? "false" : "true";
        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleBreakOn", "breakable", breakable);

        // Set the button as 'checked', so it has visual border (see issue 6567).
        var checked = armed ? "true" : "false";
        Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleBreakOn", "checked", checked);
    },

    updatePanelTab: function(panel, armed)
    {
        if (!panel)
            return;

        // If the script panels is disabled, BON can't be active.
        if (!Firebug.PanelActivation.isPanelEnabled("script"))
            armed = false;

        var panelBar = Firebug.chrome.$("fbPanelBar1");
        var tab = panelBar.getTab(panel.name);
        if (tab)
        {
            if (armed)
            {
                // If there is already a panel armed synchronize highlighting of the panel tabs
                var tabPanel = tab.parentNode;
                var otherTabIsArmed = false;
                for (var i = 0; i < tabPanel.children.length; ++i)
                {
                    var panelTab = tabPanel.children[i];
                    if (panelTab !== tab && panelTab.getAttribute("breakOnNextArmed") == "true")
                    {
                        panel.context.delayedArmedTab = tab;
                        Events.addEventListener(panelTab, "animationiteration",
                            this.toggleTabHighlighting, true);
                        otherTabIsArmed = true;
                        break;
                    }
                }

                if (!otherTabIsArmed)
                    tab.setAttribute("breakOnNextArmed", "true");
            }
            else
            {
                delete panel.context.delayedArmedTab;
                tab.setAttribute("breakOnNextArmed", "false");
            }
        }
    },

    updatePanelTabs: function(context)
    {
        if (!context)
            return;

        var panelTypes = Firebug.getMainPanelTypes(context);
        for (var i=0; i<panelTypes.length; ++i)
        {
            var panelType = panelTypes[i];
            var panel = context.getPanel(panelType.prototype.name);
            var shouldBreak = (panel && panel.shouldBreakOnNext()) ? true : false;
            this.updatePanelTab(panel, shouldBreak);
        }
    },

    // supports non-JS break on next
    breakNow: function(panel)
    {
        this.updatePanelTab(panel, false);
        Firebug.Debugger.breakNow(panel.context);  // TODO BTI
    },

    updateOption: function(name, value)
    {
        if (name == "showBreakNotification")
        {
            var panelBar1 = Firebug.chrome.$("fbPanelBar1");
            var doc = panelBar1.browser.contentDocument;
            var checkboxes = doc.querySelectorAll(".doNotShowBreakNotification");

            for (var i=0; i<checkboxes.length; i++)
                checkboxes[i].checked = !value;
        }
    },
});

// ********************************************************************************************* //

with (Domplate) {
Firebug.Breakpoint.BreakpointListRep = domplate(Rep,
{
    tag:
        DIV({role : "list"},
            FOR("group", "$groups",
                DIV({"class": "breakpointBlock breakpointBlock-$group.name", role: "list",
                        $opened: "$group.opened", _repObject: "$group", onclick: "$onClick"},
                    H1({"class": "breakpointHeader groupHeader"},
                        DIV({"class": "twisty", role: "presentation"}),
                        SPAN({"class": "breakpointsHeaderLabel"}, "$group.title")
                    ),
                    DIV({"class": "breakpointsGroupListBox", role: "listbox"},
                        FOR("bp", "$group.breakpoints",
                            TAG("$bp|getBreakpointRep", {bp: "$bp"})
                        )
                    )
                )
            )
        ),

    getBreakpointRep: function(bp)
    {
        var rep = Firebug.getRep(bp, Firebug.currentContext);
        return rep.tag;
    },

    toggleGroup: function(node)
    {
        var panel = Firebug.getElementPanel(node);
        var groupNode = Dom.getAncestorByClass(node, "breakpointBlock");
        var group = Firebug.getRepObject(groupNode);

        Css.toggleClass(groupNode, "opened");
        var opened = Css.hasClass(groupNode, "opened");
        panel.groupOpened[group.name] = opened;

        if (opened)
        {
            var offset = Dom.getClientOffset(node);
            var titleAtTop = offset.y < panel.panelNode.scrollTop;
            Dom.scrollTo(groupNode, panel.panelNode, null,
                groupNode.offsetHeight > panel.panelNode.clientHeight || titleAtTop ? "top" : "bottom");
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onClick: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        var header = Dom.getAncestorByClass(event.target, "breakpointHeader");
        if (header)
        {
            this.toggleGroup(event.target);
            return;
        }
    }
});

// ********************************************************************************************* //

Firebug.Breakpoint.BreakpointRep = domplate(Rep,
{
    tag:
        DIV({"class": "breakpointRow focusRow", $disabled: "$bp|isDisabled", role: "option",
                "aria-checked": "$bp.checked", _repObject: "$bp", onclick: "$onClick"},
            DIV({"class": "breakpointBlockHead"},
                INPUT({"class": "breakpointCheckbox", type: "checkbox",
                    _checked: "$bp.checked", tabindex : '-1'}),
                SPAN({"class": "breakpointName"}, "$bp.name"),
                TAG(FirebugReps.SourceLink.tag, {object: "$bp|getSourceLink"}),
                SPAN({"class": "closeButton"})
            ),
            DIV({"class": "breakpointCode"}, "$bp.sourceLine")
        ),

    getSourceLink: function(bp)
    {
        return new SourceLink.SourceLink(bp.href, bp.lineNumber, "js");
    },

    removeBreakpoint: function(groupName, href, lineNumber)
    {
        if (groupName == "breakpoints")
            FBS.clearBreakpoint(href, lineNumber);
        else if (groupName == "errorBreakpoints")
            FBS.clearErrorBreakpoint(href, lineNumber);
        else if (groupName == "monitors")
            FBS.unmonitor(href, lineNumber);
    },

    enableBreakpoint: function(href, lineNumber)
    {
        FBS.enableBreakpoint(href, lineNumber);
    },

    disableBreakpoint: function(href, lineNumber)
    {
        FBS.disableBreakpoint(href, lineNumber);
    },

    isDisabled: function(bp)
    {
        return !bp.checked;
    },

    getContextMenuItems: function(breakpoint, target)
    {
        var head = Dom.getAncestorByClass(target, "breakpointBlock");
        var groupName = Css.getClassValue(head, "breakpointBlock");

        var items = [{
            label: "breakpoints.Remove_Breakpoint",
            tooltiptext: "breakpoints.tip.Remove_Breakpoint",
            command: Obj.bindFixed(this.removeBreakpoint, this, groupName,
                breakpoint.href, breakpoint.lineNumber)
        }];

        if (groupName == "breakpoints")
        {
            if (breakpoint.checked)
            {
                items.push({
                    label: "breakpoints.Disable_Breakpoint",
                    tooltiptext: "breakpoints.tip.Disable_Breakpoint",
                    command: Obj.bindFixed(this.disableBreakpoint, this, breakpoint.href,
                        breakpoint.lineNumber)
                });
            }
            else
            {
                items.push({
                    label: "breakpoints.Enable_Breakpoint",
                    tooltiptext: "breakpoints.tip.Enable_Breakpoint",
                    command: Obj.bindFixed(this.enableBreakpoint, this, breakpoint.href,
                        breakpoint.lineNumber)
                });
            }
        }

        items.push(
             "-"
        );

        return items;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    inspectable: false,

    supportsObject: function(object, type)
    {
        return (object instanceof Firebug.Debugger.Breakpoint);  // FIXME moz back end
    },

    onClick: function(event)
    {
        var panel = Firebug.getElementPanel(event.target);

        if (Dom.getAncestorByClass(event.target, "breakpointCheckbox"))
        {
            var node = event.target.parentNode.getElementsByClassName(
                "objectLink-sourceLink").item(0);

            if (!node)
                return;

            var sourceLink = node.repObject;

            panel.noRefresh = true;
            var checkBox = event.target;
            var bpRow = Dom.getAncestorByClass(checkBox, "breakpointRow");

            if (checkBox.checked)
            {
                this.enableBreakpoint(sourceLink.href, sourceLink.line);
                bpRow.setAttribute("aria-checked", "true");
            }
            else
            {
                this.disableBreakpoint(sourceLink.href, sourceLink.line);
                bpRow.setAttribute("aria-checked", "false");
            }
            panel.noRefresh = false;
        }
        else if (Dom.getAncestorByClass(event.target, "closeButton"))
        {
            panel.noRefresh = true;
            var sourceLink = event.target.parentNode.getElementsByClassName(
                "objectLink-sourceLink").item(0).repObject;

            var head = Dom.getAncestorByClass(event.target, "breakpointBlock");
            var groupName = Css.getClassValue(head, "breakpointBlock");

            this.removeBreakpoint(groupName, sourceLink.href, sourceLink.line);

            panel.noRefresh = false;
        }

        panel.refresh();
    }
});
};

// ********************************************************************************************* //

Firebug.Breakpoint.BreakpointsPanel = function() {};

Firebug.Breakpoint.BreakpointsPanel.prototype = Obj.extend(Panel,
{
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    name: "breakpoints",
    parentPanel: "script",
    order: 2,
    enableA11y: true,
    deriveA11yFrom: "console",

    initialize: function()
    {
        this.groupOpened = [];

        Panel.initialize.apply(this, arguments);
    },

    destroy: function(state)
    {
        state.groupOpened = this.groupOpened;

        Panel.destroy.apply(this, arguments);
    },

    show: function(state)
    {
        if (this.context.loaded)
        {
            var state = null;
            Persist.restoreObjects(this, state);

            if (state)
            {
                if (state.groupOpened)
                    this.groupOpened = state.groupOpened;
            }
        }

        this.refresh();
    },

    refresh: function()
    {
        if (this.noRefresh)
            return;

        var extracted = this.extractBreakpoints(this.context);

        var breakpoints = extracted.breakpoints;
        var errorBreakpoints = extracted.errorBreakpoints;
        var monitors = extracted.monitors;

        if (FBTrace.DBG_BP)
            FBTrace.sysout("breakpoints.refresh extracted " +
                breakpoints.length+errorBreakpoints.length+monitors.length,
                [breakpoints, errorBreakpoints, monitors]);

        function sortBreakpoints(a, b)
        {
            if (a.href == b.href)
                return a.lineNumber < b.lineNumber ? -1 : 1;
            else
                return a.href < b.href ? -1 : 1;
        }

        breakpoints.sort(sortBreakpoints);
        errorBreakpoints.sort(sortBreakpoints);
        monitors.sort(sortBreakpoints);

        if (FBTrace.DBG_BP)
            FBTrace.sysout("breakpoints.refresh sorted "+breakpoints.length+
                errorBreakpoints.length+monitors.length, [breakpoints, errorBreakpoints, monitors]);

        var groups = [];

        if (breakpoints.length)
            groups.push({name: "breakpoints", title: Locale.$STR("Breakpoints"),
                breakpoints: breakpoints});

        if (errorBreakpoints.length)
            groups.push({name: "errorBreakpoints", title: Locale.$STR("ErrorBreakpoints"),
                breakpoints: errorBreakpoints});

        if (monitors.length)
            groups.push({name: "monitors", title: Locale.$STR("LoggedFunctions"),
                breakpoints: monitors});

        Firebug.connection.dispatch("getBreakpoints", [this.context, groups]);

        if (groups.length != 0)
        {
            for (var i = 0; i < groups.length; ++i)
            {
                groups[i].opened = typeof this.groupOpened[groups[i].name] != "undefined" ?
                    this.groupOpened[groups[i].name] : true;
            }

            Firebug.Breakpoint.BreakpointListRep.tag.replace({groups: groups}, this.panelNode);
        }
        else
        {
            FirebugReps.Warning.tag.replace({object: "NoBreakpointsWarning"}, this.panelNode);
        }

        if (FBTrace.DBG_BP)
        {
            FBTrace.sysout("breakpoints.refresh "+breakpoints.length+
                errorBreakpoints.length+monitors.length, [breakpoints, errorBreakpoints, monitors]);
        }

        Events.dispatch(this.fbListeners, "onBreakRowsRefreshed", [this, this.panelNode]);
    },

    extractBreakpoints: function(context)
    {
        var breakpoints = [];
        var errorBreakpoints = [];
        var monitors = [];

        var renamer = new SourceFileRenamer(context);
        var Breakpoint = Firebug.Debugger.Breakpoint;

        for (var url in context.sourceFileMap)
        {
            FBS.enumerateBreakpoints(url, {call: function(url, line, props, scripts)
            {
                if (FBTrace.DBG_BP)
                    FBTrace.sysout("breakpoints.extractBreakpoints type: "+props.type+" in url "+
                        url+"@"+line+" context "+context.getName(), props);

                // some url in this sourceFileMap has changed, we'll be back.
                if (renamer.checkForRename(url, line, props))
                    return;

                var isFuture = false;
                var name = "";
                if (scripts)  // then this is a current (not future) breakpoint
                {
                    var script = scripts[0];
                    var analyzer = Firebug.SourceFile.getScriptAnalyzer(context, script);
                    if (FBTrace.DBG_BP)
                        FBTrace.sysout("breakpoints.refresh enumerateBreakpoints for script="+
                            script.tag+(analyzer?" has analyzer":" no analyzer")+" in context "+
                            context.getName());

                    name = analyzer ?
                        analyzer.getFunctionDescription(script, context).name :
                        StackFrame.guessFunctionName(url, 1, context);
                }
                else
                {
                    if (FBTrace.DBG_BP)
                        FBTrace.sysout("breakpoints.refresh enumerateBreakpoints future for url@line="+
                            url+"@"+line+"\n");

                    isFuture = true;
                }

                var source = context.sourceCache.getLine(url, line);
                breakpoints.push(new Breakpoint(name, url, line, !props.disabled, source, isFuture));
            }});

            FBS.enumerateErrorBreakpoints(url, {call: function(url, line, props)
            {
                // some url in this sourceFileMap has changed, we'll be back.
                if (renamer.checkForRename(url, line, props))
                    return;

                var name = Firebug.SourceFile.guessEnclosingFunctionName(url, line, context);
                var source = context.sourceCache.getLine(url, line);
                errorBreakpoints.push(new Breakpoint(name, url, line, true, source));
            }});

            FBS.enumerateMonitors(url, {call: function(url, line, props)
            {
                // some url in this sourceFileMap has changed, we'll be back.
                if (renamer.checkForRename(url, line, props))
                    return;

                var name = Firebug.SourceFile.guessEnclosingFunctionName(url, line, context);
                monitors.push(new Breakpoint(name, url, line, true, ""));
            }});
        }

        var result = null;

        if (renamer.needToRename(context))
        {
            // since we renamed some sourceFiles we need to refresh the breakpoints again.
            result = this.extractBreakpoints(context);
        }
        else
        {
            result = {
                breakpoints: breakpoints,
                errorBreakpoints: errorBreakpoints,
                monitors: monitors
            };
        }

        // even if we did not rename, some bp may be dynamic
        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("breakpoints.extractBreakpoints context.dynamicURLhasBP: "+
                context.dynamicURLhasBP, result);

        return result;
    },

    getOptionsMenuItems: function()
    {
        var items = [];

        var context = this.context;

        var bpCount = 0, disabledCount = 0;
        var checkBoxes = this.panelNode.getElementsByClassName("breakpointCheckbox");
        for (var i=0; i<checkBoxes.length; i++)
        {
            ++bpCount;
            if (!checkBoxes[i].checked)
                ++disabledCount;
        }

        if (disabledCount)
        {
            items.push(
                {
                    label: "EnableAllBreakpoints",
                    command: Obj.bindFixed(this.enableAllBreakpoints, this, context, true),
                    tooltiptext: "breakpoints.option.tip.Enable_All_Breakpoints"
                }
            );
        }
        if (bpCount && disabledCount != bpCount)
        {
            items.push(
                {
                    label: "DisableAllBreakpoints",
                    command: Obj.bindFixed(this.enableAllBreakpoints, this, context, false),
                    tooltiptext: "breakpoints.option.tip.Disable_All_Breakpoints"
                }
            );
        }

        items.push(
            "-",
            {
                label: "ClearAllBreakpoints",
                disabled: !bpCount,
                command: Obj.bindFixed(this.clearAllBreakpoints, this, context),
                tooltiptext: "breakpoints.option.tip.Clear_All_Breakpoints"
            }
        );

        return items;
    },

    getContextMenuItems: function(object, target, context)
    {
        return this.getOptionsMenuItems();
    },

    enableAllBreakpoints: function(context, status)
    {
        var checkBoxes = this.panelNode.getElementsByClassName("breakpointCheckbox");
        for (var i=0; i<checkBoxes.length; i++)
        {
            var box = checkBoxes[i];
            if (box.checked != status)
                this.click(box);
        }
    },

    clearAllBreakpoints: function(context)
    {
        this.noRefresh = true;

        try
        {
            // Remove regular JSD breakpoints
            Firebug.Debugger.clearAllBreakpoints(context);
        }
        catch(exc)
        {
            FBTrace.sysout("breakpoint.clearAllBreakpoints FAILS "+exc, exc);
        }

        this.noRefresh = false;
        this.refresh();

        // Remove the rest of all the other kinds of breakpoints (after refresh).
        // These can come from various modules and perhaps extensions, so use
        // the appropriate remove buttons.
        var buttons = this.panelNode.getElementsByClassName("closeButton");
        while (buttons.length)
            this.click(buttons[0]);

        // Breakpoint group titles must also go away.
        this.refresh();
    },

    click: function(node)
    {
        var doc = node.ownerDocument, event = doc.createEvent("MouseEvents");
        event.initMouseEvent("click", true, true, doc.defaultView, 0, 0, 0, 0, 0,
            false, false, false, false, 0, null);
        return node.dispatchEvent(event);
    }
});

// ********************************************************************************************* //

function countBreakpoints(context)
{
    var count = 0;
    for (var url in context.sourceFileMap)
    {
        FBS.enumerateBreakpoints(url, {call: function(url, lineNo)
        {
            ++count;
        }});
    }
    return count;
}

// ********************************************************************************************* //

Firebug.Breakpoint.BreakpointGroup = function()
{
    this.breakpoints = [];
};

Firebug.Breakpoint.BreakpointGroup.prototype =
{
    removeBreakpoint: function(bp)
    {
        Arr.remove(this.breakpoints, bp);
    },

    enumerateBreakpoints: function(callback)
    {
        var breakpoints = Arr.cloneArray(this.breakpoints);
        for (var i=0; i<breakpoints.length; i++)
        {
            var bp = breakpoints[i];
            if (callback(bp))
                return true;
        }
        return false;
    },

    findBreakpoint: function()
    {
        for (var i=0; i<this.breakpoints.length; i++)
        {
            var bp = this.breakpoints[i];
            if (this.matchBreakpoint(bp, arguments))
                return bp;
        }
        return null;
    },

    matchBreakpoint: function(bp, args)
    {
        // TODO: must be implemented in derived objects.
        return false;
    },

    isEmpty: function()
    {
        return !this.breakpoints.length;
    }
};

// ********************************************************************************************* //
// TODO move to mozilla back end

function SourceFileRenamer(context)
{
    this.renamedSourceFiles = [];
    this.context = context;
    this.bps = [];
}

SourceFileRenamer.prototype.checkForRename = function(url, line, props)
{
    var sourceFile = this.context.sourceFileMap[url];
    if (sourceFile.isEval() || sourceFile.isEvent())
    {
        var segs = sourceFile.href.split('/');
        if (segs.length > 2)
        {
            if (segs[segs.length - 2] == "seq")
            {
                this.renamedSourceFiles.push(sourceFile);
                this.bps.push(props);
            }
        }

        // whether not we needed to rename, the dynamic sourceFile has a bp.
        this.context.dynamicURLhasBP = true;

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("breakpoints.checkForRename found bp in "+sourceFile+" renamed files:",
                this.renamedSourceFiles);
    }
    else
    {
        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("breakpoints.checkForRename found static bp in " + sourceFile +
                " bp:", props);
    }

    return (this.renamedSourceFiles.length > 0);
};

SourceFileRenamer.prototype.needToRename = function(context)
{
    if (this.renamedSourceFiles.length > 0)
        this.renameSourceFiles(context);

    if (FBTrace.DBG_SOURCEFILES)
        FBTrace.sysout("debugger renamed " + this.renamedSourceFiles.length + " sourceFiles",
            context.sourceFileMap);

    return this.renamedSourceFiles.length;
};

SourceFileRenamer.prototype.renameSourceFiles = function(context)
{
    for (var i = 0; i < this.renamedSourceFiles.length; i++)
    {
        var sourceFile = this.renamedSourceFiles[i];
        var bp = this.bps[i];

        var oldURL = sourceFile.href;
        var sameType = bp.type;
        var sameLineNo = bp.lineNo;

        // last is sequence #, next-last is "seq", next-next-last is kind
        var segs = oldURL.split('/');
        var kind = segs.splice(segs.length - 3, 3)[0];
        var callerURL = segs.join('/');
        if (!sourceFile.source)
        {
            FBTrace.sysout("breakpoint.renameSourceFiles no source for " + oldURL +
                " callerURL " + callerURL, sourceFile);
            continue;
        }

        var newURL = Firebug.Debugger.getURLFromMD5(callerURL, sourceFile.source, kind);
        sourceFile.href = newURL.href;

        FBS.removeBreakpoint(bp.type, oldURL, bp.lineNo);
        delete context.sourceFileMap[oldURL];  // SourceFile delete

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("breakpoints.renameSourceFiles type: "+bp.type, bp);

        Firebug.Debugger.watchSourceFile(context, sourceFile);
        var newBP = FBS.addBreakpoint(sameType, sourceFile, sameLineNo, bp, Firebug.Debugger);

        var panel = context.getPanel("script", true);
        if (panel)
        {
            panel.context.invalidatePanels("breakpoints");
            panel.renameSourceBox(oldURL, newURL.href);
        }

        if (context.sourceCache.isCached(oldURL))
        {
            var lines = context.sourceCache.load(oldURL);
            context.sourceCache.storeSplitLines(newURL.href, lines);
            context.sourceCache.invalidate(oldURL);
        }

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("SourceFileRenamer renamed " + oldURL + " to " + newURL,
                { newBP: newBP, oldBP: bp});
    }

    return this.renamedSourceFiles.length;
};

// ********************************************************************************************* //

Firebug.Breakpoint.ConditionEditor = function(doc)
{
    this.initialize(doc);
};

with (Domplate) {
Firebug.Breakpoint.ConditionEditor.prototype = domplate(Firebug.JSEditor.prototype,
{
    tag:
        DIV({"class": "conditionEditor"},
            DIV({"class": "conditionCaption"}, Locale.$STR("ConditionInput")),
            INPUT({"class": "conditionInput completionBox", type: "text",
                tabindex: "-1"}),
            INPUT({"class": "conditionInput completionInput", type: "text",
                "aria-label": Locale.$STR("ConditionInput"),
                oninput: "$onInput", onkeypress: "$onKeyPress"}
            )
        ),

    initialize: function(doc)
    {
        this.box = this.tag.replace({}, doc, this);
        this.input = this.box.getElementsByClassName("completionInput").item(0);

        var completionBox = this.box.getElementsByClassName("completionBox").item(0);
        var options = {
            tabWarnings: true
        };
        this.setupCompleter(completionBox, options);
    },

    show: function(sourceLine, panel, value)
    {
        this.target = sourceLine;
        this.panel = panel;

        this.getAutoCompleter().reset();

        Dom.hide(this.box, true);
        panel.selectedSourceBox.appendChild(this.box);

        this.input.value = value;

        setTimeout(Obj.bindFixed(function()
        {
            var offset = Dom.getClientOffset(sourceLine);

            var bottom = offset.y+sourceLine.offsetHeight;
            var y = bottom - this.box.offsetHeight;
            if (y < panel.selectedSourceBox.scrollTop)
            {
                y = offset.y;
                Css.setClass(this.box, "upsideDown");
            }
            else
            {
                Css.removeClass(this.box, "upsideDown");
            }

            this.box.style.top = y + "px";
            Dom.hide(this.box, false);

            this.input.focus();
            this.input.select();
        }, this));
    },

    hide: function()
    {
        this.box.parentNode.removeChild(this.box);

        delete this.target;
        delete this.panel;
    },

    layout: function()
    {
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    endEditing: function(target, value, cancel)
    {
        if (!cancel)
        {
            var compilationUnit = this.panel.location;
            var lineNo = parseInt(this.target.textContent);
            // TODO rest is mozilla backend
            var sourceFile = compilationUnit.sourceFile;
            FBS.setBreakpointCondition(sourceFile, lineNo, value, Firebug.Debugger);
        }
    }
});

// ********************************************************************************************* //

/**
 * Construct a break notification popup
 * @param doc the document to contain the notification
 * @param cause info object for the popup, with these optional fields:
 *   strings: title, message, attrName
 *   elements: target, relatedTarget: element
 *   objects: prevValue, newValue
 */
Firebug.Breakpoint.BreakNotification = function(doc, cause)
{
    this.document = doc;
    this.cause = cause;
};

Firebug.Breakpoint.BreakNotification.prototype = domplate(Rep,
/** @lends Firebug.ScriptPanel.Notification */
{
    tag:
        DIV({"class": "notificationBox"},
            TABLE({"class": "notificationTable", onclick: "$onHide",
                onmouseover: "$onMouseOver", onmouseout: "$onMouseOut"},
                TBODY(
                    TR(
                        TD({"class": "imageCol"},
                            IMG({"class": "notificationImage",
                                src: "chrome://firebug/skin/breakpoint.png"})
                        ),
                        TD({"class": "descCol"},
                            SPAN({"class": "notificationDesc"}, "$cause|getDescription"),
                            SPAN("&nbsp;"),
                            SPAN({"class": "diff"}, "$cause|getDiff"),
                            SPAN({"class": "targets"}),
                            DIV({"class": "noNotificationDesc"})
                        ),
                        TD({"class": "buttonsCol"},
                            BUTTON({"class": "notificationButton copyButton",
                                onclick: "$onCopyAction",
                                $collapsed: "$cause|hideCopyAction"},
                                Locale.$STR("Copy")
                            ),
                            BUTTON({"class": "notificationButton skipButton",
                                onclick: "$onSkipAction",
                                $collapsed: "$cause|hideSkipAction"},
                                Locale.$STR("script.balloon.Disable")
                            ),
                            BUTTON({"class": "notificationButton okButton",
                                onclick: "$onOkAction",
                                $collapsed: "$cause|hideOkAction"},
                                Locale.$STR("script.balloon.Continue")
                            )
                        ),
                        TD(
                            DIV({"class": "notificationClose", onclick: "$onHide"})
                        )
                    )
                )
            )
        ),

    targets:
        SPAN(
            SPAN("&nbsp;"),
            TAG("$cause|getTargetTag", {object: "$cause.target"}),
            SPAN("&nbsp;"),
            TAG("$cause|getRelatedTargetTag", {object: "$cause.relatedNode"})
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onMouseOver: function(event)
    {
        var target = event.target;
        var box = Dom.getAncestorByClass(target, "notificationBox");
        var close = box.querySelector(".notificationClose");

        // The close button is "active" (red) if the mouse hovers over the notification
        // area except when it hovers over a button or link.
        var localName = target.localName ? target.localName.toLowerCase() : "";
        if (Css.hasClass(target, "notificationButton") || localName == "a")
            close.removeAttribute("active");
        else
            close.setAttribute("active", true);
    },

    onMouseOut: function(event)
    {
        var box = Dom.getAncestorByClass(event.target, "notificationBox");
        var close = box.querySelector(".notificationClose");
        close.removeAttribute("active");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onHide: function(event)
    {
        var notify = this.getNotifyObject(event.target);
        notify.hide();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getDescription: function(cause)
    {
        var str = cause.message + (cause.attrName ? (" '" + cause.attrName + "'") : "");
        if (this.getDiff(cause))
            str += ":";

        return str;
    },

    getTargetTag: function(cause)
    {
        return this.getElementTag(cause.target) || null;
    },

    getRelatedTargetTag: function(cause)
    {
        return this.getElementTag(cause.relatedNode) || null;
    },

    getElementTag: function(node)
    {
        if (node)
        {
            var rep = Firebug.getRep(node);
            if (rep)
                return rep.shortTag || rep.tag;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Button Handlers

    hideCopyAction: function(cause)
    {
        return !cause.copyAction;
    },

    hideSkipAction: function(cause)
    {
        return !cause.skipAction;
    },

    hideOkAction: function(cause)
    {
        return !cause.okAction;
    },

    onCopyAction: function(event)
    {
        var notify = this.getNotifyObject(event.target);
        if (notify.cause.copyAction)
            notify.cause.copyAction();
    },

    onSkipAction: function(event)
    {
        var notify = this.getNotifyObject(event.target);
        if (notify.cause.skipAction)
            notify.cause.skipAction();
    },

    onOkAction: function(event)
    {
        var notify = this.getNotifyObject(event.target);
        if (notify.cause.okAction)
            notify.cause.okAction();
    },

    onCloseAction: function(event)
    {
        var notify = this.getNotifyObject(event.target);
        if (notify.cause.onCloseAction)
            notify.cause.onCloseAction();
        else
            notify.hide(event); // same as click on notify body
    },

    getNotifyObject: function(target)
    {
        var parentNode = Dom.getAncestorByClass(target, "notificationBox");
        return parentNode.repObject;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Action handlers from "do not show again" description

    onClickLink: function(event)
    {
        this.showTabMenu(event);
    },

    disableNotifications: function(event)
    {
        Firebug.setPref(Firebug.prefDomain, "showBreakNotification", false);

        // Hide the notification, but default processing of this event would hide it anyway.
        this.onHide(event);
    },

    showTabMenu: function(event)
    {
        // Open panel's tab menu to show the "Show Break Notifications" option
        // to teach the user where to enable it again.
        var panelBar = Firebug.chrome.$("fbPanelBar1");
        var tab = panelBar.getTab("script");
        tab.tabMenu.showMenu();

        // Avoid default processing that hides the notification popup.
        Events.cancelEvent(event);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Helpers

    getDiff: function(cause)
    {
        var str = "";

        if (cause.prevValue)
            str += Str.cropString(cause.prevValue, 40) + " -> ";

        if (cause.newValue)
            str += Str.cropString(cause.newValue, 40);

        if (!str.length)
            return "";

        if (!cause.target)
            return str;

        return str;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Public

    show: function(parentNode)
    {
        if (FBTrace.DBG_BP)
            FBTrace.sysout("breakNotification.show; " + this.id);

        // Reneder the entire notification box.
        this.box = this.tag.append(this.cause, parentNode, this);
        this.box.repObject = this;

        // Appends the HTML targets dynamically. In case they are null, it breaks
        // click events.
        // xxxHonza: this problem would deserve clarification.
        if (this.cause.target || this.cause.relatedNode)
        {
            var targetsNode = this.box.querySelector(".targets");
            this.targets.replace(this.cause, targetsNode, this);
        }

        // Render "do not show again" text
        var descNode = this.box.querySelector(".noNotificationDesc");
        FirebugReps.Description.render(Locale.$STR("firebug.breakpoint.doNotShowBreakNotification2"),
            descNode, Obj.bind(this.onClickLink, this));

        // Tooltips
        if (this.cause.skipActionTooltip)
            this.box.querySelector(".skipButton").setAttribute("title", this.cause.skipActionTooltip);
        if (this.cause.okActionTooltip)
            this.box.querySelector(".okButton").setAttribute("title", this.cause.okActionTooltip);
        if (this.cause.copyActionTooltip)
            this.box.querySelector(".copyButton").setAttribute("title", this.cause.copyActionTooltip);

        // xxxHonza: disable the animation, the interval seems to be frozen during debugger break.
        this.box.style.top = "0";
        return;

        // Animation
        var self = this;
        var delta = Math.max(3, Math.floor(this.box.clientHeight/5));
        var clientHeight = this.box.clientHeight;

        this.box.style.top = -clientHeight + "px";
        var interval = setInterval(function slide(event)
        {
            var top = parseInt(self.box.style.top, 10);
            if (top >= 0)
            {
                clearInterval(interval);
            }
            else
            {
                var newTop = (top + delta) > 0 ? 0 : (top + delta);
                self.box.style.top = newTop + "px";
            }
        }, 15);

        return this.box;
    },

    hide: function()
    {
        if (FBTrace.DBG_BP)
            FBTrace.sysout("breakNotification.hide;");

        // xxxHonza: disable the animation, the interval seems to be frozen during debugger break.
        if (this.box.parentNode)
            this.box.parentNode.removeChild(this.box);
        return;

        // Animation
        var self = this;
        var delta = Math.max(3, Math.floor(this.box.clientHeight/5));
        var clientHeight = this.box.clientHeight;
        var top = 0;

        var interval = setInterval(function slide(event)
        {
            top = top - delta;
            if (top < -clientHeight)
            {
                clearInterval(interval);

                if (self.box.parentNode)
                    self.box.parentNode.removeChild(self.box);
            }
            else
            {
                self.box.style.top = top + "px";
            }
        }, 15);
    }
});
};

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(Firebug.Breakpoint.BreakpointsPanel);
Firebug.registerRep(Firebug.Breakpoint.BreakpointRep);
Firebug.registerModule(Firebug.Breakpoint);

return Firebug.Breakpoint;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/callstack",
[
    "firebug/chrome/panel",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/reps",
    "arch/javascripttool",
    "firebug/lib/events",
    "firebug/lib/wrapper",
    "firebug/js/stackFrame",
    "firebug/lib/css",
    "firebug/lib/array",
    "firebug/lib/dom",
    "firebug/lib/options",
    "firebug/chrome/menu"
],
function(Panel, Obj, Firebug, FirebugReps, JavaScriptTool, Events, Wrapper, StackFrame,
    Css, Arr, Dom, Options, Menu) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

// ********************************************************************************************* //
// Callstack Panel

/**
 * @Panel This panel is responsible for displaying a call-stack (list of function calls)
 * at specified point of Javascript execution. It's used as a side panel for the Script
 * panel.
 */
Firebug.CallstackPanel = function() {};
Firebug.CallstackPanel.prototype = Obj.extend(Panel,
/** @lends Firebug.CallstackPanel */
{
    name: "callstack",
    parentPanel: "script",
    order: 1,
    enableA11y: true,
    deriveA11yFrom: "console",

    initialize: function(context, doc)
    {
        Panel.initialize.apply(this, arguments);

        Firebug.connection.addListener(this);
    },

    destroy: function(state)
    {
        Firebug.connection.removeListener(this);

        Panel.destroy.apply(this, arguments);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onStartDebugging: function(context, frame)
    {
        // if we get a show() call then create and set new location
        delete this.location;

        // then we should reshow
        if (this.visible)
            this.show();

        if (FBTrace.DBG_STACK)
            FBTrace.sysout("callstack; onStartDebugging "+this.visible, this);
    },

    onStopDebugging: function(context)
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("callstack; onStopDebugging");

        // clear the view
        this.showStackTrace(null);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    show: function(state)
    {
        if (!this.location)
        {
            this.location = StackFrame.buildStackTrace(JavaScriptTool.Turn.currentFrame);
            this.updateLocation(this.location);
        }
        // then we are lazy

        if (FBTrace.DBG_STACK)
            FBTrace.sysout("callstack.show state: "+state+" this.location: "+this.location,
                {state: state, panel: this,
                  currentFrame: JavaScriptTool.Turn.currentFrame});

        if (state)
        {
            if (state.callstackToggles)
            {
                var frameElts = this.panelNode.getElementsByClassName("objectBox-stackFrame");
                for (var i = 0; i < frameElts.length; i++)
                {
                    if (state.callstackToggles[i])
                        FirebugReps.StackFrame.expandArguments(frameElts[i]);
                }
            }

            if (state.selectedCallStackFrameIndex)
            {
                this.selectFrame(state.selectedCallStackFrameIndex);
            }
        }
    },

    hide: function(state)
    {
        var frameElts = this.panelNode.getElementsByClassName("objectBox-stackFrame");
        state.callstackToggles = [];
        for (var i = 0; i < frameElts.length; i++)
        {
            var item = frameElts[i];
            if (item.classList.contains("opened"))
                state.callstackToggles[i] = true;

            if (item.getAttribute("selected") == "true")
                state.selectedCallStackFrameIndex = i + 1;  // traces are 1 base
        }

        if (FBTrace.DBG_STACK)
            FBTrace.sysout("callstack.hide state: "+state, state);
    },

    supportsObject: function(object, type)
    {
        return (object instanceof StackFrame.StackTrace) ||
            (object instanceof Ci.jsdIStackFrame) ||
            (object instanceof StackFrame.StackFrame);
    },

    // this.selection is a StackFrame in our this.location
    updateSelection: function(object)
    {
        if (!this.location) // then we are lazy
        {
            this.location = StackFrame.buildStackTrace(JavaScriptTool.Turn.currentFrame);
            this.updateLocation(this.location);
        }

        // The selection object should be StackFrame
        if (object instanceof StackFrame.StackFrame)
        {
            var trace = this.location;
            var frameIndex = object.getFrameIndex();
            if (frameIndex)
            {
                trace.currentFrameIndex = frameIndex;
                this.selectFrame(frameIndex);
            }

            if (FBTrace.DBG_STACK)
                FBTrace.sysout("Callstack updateSelection index:"+trace.currentFrameIndex+
                    " StackFrame "+object, object);
        }
        else if (object instanceof Ci.jsdIStackFrame)
        {
            var trace = this.location;
            if (trace)
            {
                trace.frames.forEach(function selectMatching(frame)
                {
                    if (frame.nativeFrame === object)
                        this.select(frame);
                }, this);
            }
        }
    },

    // this.location is a StackTrace
    updateLocation: function(object)
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("callstack; updateLocation "+object, object);

        // All paths lead to showStackTrace
        if (object instanceof StackFrame.StackTrace)
            this.showStackTrace(object);
        else if (object instanceof Ci.jsdIStackFrame)
            this.navigate(StackFrame.getCorrectedStackTrace(object, this.context));
        else if (object instanceof StackFrame.StackFrame)
            this.showStackFrame(object);
    },

    showStackFrame: function(frame)
    {
        var trace = StackFrame.buildStackTrace(frame);
        this.navigate(trace);
    },

    showStackTrace: function(trace)
    {
        Dom.clearNode(this.panelNode);

        Css.setClass(this.panelNode, "objectBox-stackTrace");

        // Update visibility of stack frame arguments.
        var name = "showStackFrameArguments";
        this.updateOption(name, Options.get(name));

        if (trace && trace.frames.length != 0)
        {
            var rep = Firebug.getRep(trace, this.context);

            if (FBTrace.DBG_STACK)
                FBTrace.sysout("callstack showStackFrame with "+trace.frames.length+" frames using "
                    +rep+" into "+this.panelNode, {trace: trace, rep:rep, node:this.panelNode});

            rep.tag.replace({object:trace}, this.panelNode);

            if (trace.currentFrameIndex)
                this.select(trace[trace.currentFrameIndex]);

            Events.dispatch(this.fbListeners, "onStackCreated", [this]);
        }
        else
        {
            FirebugReps.Warning.tag.replace({object: "callstack.Execution_not_stopped"}, this.panelNode);
        }
    },

    selectFrame: function(frameIndex)
    {
        var frameElts = this.panelNode.getElementsByClassName("objectBox-stackFrame");
        this.selectItem(frameElts[frameIndex - 1]);
    },

    selectItem: function(item)
    {
        if (this.selectedItem)
            this.selectedItem.removeAttribute("selected");

        this.selectedItem = item;

        if (item)
            item.setAttribute("selected", "true");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Menus

    getOptionsMenuItems: function()
    {
        var items = [];

        // an option handled by chrome.js
        items.push(Menu.optionMenu("OmitObjectPathStack",
            "omitObjectPathStack",
            "callstack.option.tip.Omit_Object_Path_Stack"));

        // Show/hide stack frame arguments.
        items.push(Menu.optionMenu("callstack.option.Show_Arguments",
            "showStackFrameArguments",
            "callstack.option.tip.Show_Arguments"));

        return items;
    },

    getContextMenuItems: function(nada, target)
    {
        var items = [
            {
                label: "callstack.Expand_All",
                tooltiptext: "callstack.tip.Expand_All",
                command: Obj.bindFixed(this.onExpandAll, this, target)
            },
            {
                label: "callstack.Collapse_All",
                tooltiptext: "callstack.tip.Collapse_All",
                command: Obj.bindFixed(this.onCollapseAll, this, target)
            }
        ];
        return items;
    },

    onExpandAll: function()
    {
        var elements = this.panelNode.querySelectorAll(".objectBox-stackFrame");
        for (var i=0; i<elements.length; i++)
            FirebugReps.StackFrame.expandArguments(elements[i]);
    },

    onCollapseAll: function()
    {
        var elements = this.panelNode.querySelectorAll(".objectBox-stackFrame");
        for (var i=0; i<elements.length; i++)
            FirebugReps.StackFrame.collapseArguments(elements[i]);
    },

    updateOption: function(name, value)
    {
        if (name == "showStackFrameArguments")
        {
            if (value)
                Css.removeClass(this.panelNode, "hideArguments");
            else
                Css.setClass(this.panelNode, "hideArguments");
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Referents xxxHonza, xxxJJB: what is this? Incomplete feature for finding all
    // references to a function

    showReferents: function()
    {
        // Find obj.functionName for the currently executing function
        // The general case is (expr_for_this).(expr_for_fn)().
        // expr navigates us using names from the scope chain
        delete this.parent;

        var frame = this.context.currentFrame;
        var fnName = StackFrame.getFunctionName(frame.script, this.context, frame, true);

        var referents = this.getReferents(frame, fnName);
    },
});

// ********************************************************************************************* //

function Referent(containerName, container, propertyName, obj)
{
    this._firebug = true;
    // Reverse order, deep is first
    this.values = [container];
    this.names = [propertyName, containerName];
    this.object = obj;
}

Referent.prototype =
{
    getContainer: function()
    {
        return this.container;
    },

    /**
     * A string of identifiers separated by dots such that container[string] gives obj
     */
    getObjectPathExpression: function()
    {
        this.objectPathExpr = Arr.cloneArray(this.names).reverse().join('.');
        return this.objectPathExpr;
    },

    getObjectPathObjects: function()
    {
        this.objChain = Arr.cloneArray(this.values);
        this.objChain.push(this.object);
        this.objChain.reverse();
        return this.objChain;
    },

    prependPath: function(p, segmentObject)
    {
        this.names.push(p);
        this.values.push(segmentObject);
    },
};

// ********************************************************************************************* //

function getReferents(frame, fnName)
{
    if (FBTrace.DBG_STACK)
        FBTrace.sysout('showReferents '+frame, frame);

    // lookup the name of the function using frame.eval() -> function object
    // use 'this' as a lookup scope since function calls can be obj.fn or just fn
    var js = "with (this) {"+fnName +";}";

    var result = {};
    var ok = frame.eval(js, "", 1, result);
    if (ok)
    {
        if (result.value instanceof Ci.jsdIValue)
        {
            if (FBTrace.DBG_STACK)
                FBTrace.sysout("Firebug.Debugger.showReferents evaled "+js+" and got "+
                    result.value, result);

            try
            {
                var fn = result.value.getWrappedValue();
                var thisObject = Wrapper.unwrapIValueObject(frame.thisValue, Firebug.viewChrome);
                var referents = findObjectPropertyPath("this", thisObject, fn, []);

                if (FBTrace.DBG_STACK)
                    FBTrace.sysout("Firebug.Debugger.showReferents found from thisObject "+
                        referents.length, {thisObject: thisObject, fn: fn, referents: referents});

                var containingScope = Wrapper.unwrapIValueObject(result.value.jsParent,
                    Firebug.viewwChrome);

                if (FBTrace.DBG_STACK)
                    FBTrace.sysout("Firebug.Debugger.showReferents containingScope from "+
                        result.value.jsParent.jsClassName, containingScope);

                var scopeReferents = findObjectPropertyPath(result.value.jsParent.jsClassName,
                    containingScope, fn, []);
                // Do we need to look in the entire scope chain? I think yes

                if (FBTrace.DBG_STACK)
                    FBTrace.sysout("Firebug.Debugger.showReferents found scope referents "+
                        scopeReferents.length, {containingScope: containingScope, fn: fn,
                            referents: scopeReferents});

                referents = referents.concat(scopeReferents);
                FBTrace.sysout("Firebug.Debugger.showReferents found total referents "+
                    referents.length, {fn: fn, referents: referents});

                for (var i = 0; i < referents.length; i++)
                {
                    if (FBTrace.DBG_STACK)
                        FBTrace.sysout("Firebug.Debugger.showReferents found referent "+
                            referents[i].getObjectPathExpression(), {fn: fn, referent: referents[i],
                            path:referents[i].getObjectPathObjects() });
                }
            }
            catch(exc)
            {
                if (FBTrace.DBG_STACK || FBTrace.DBG_ERRORS)
                    FBTrace.sysout("Firebug.Debugger.showReferents FAILED: "+exc, exc);
            }
        }
        else
        {
            if (FBTrace.DBG_STACK || FBTrace.DBG_ERRORS)
                FBTrace.sysout("Firebug.Debugger.showReferents evaled "+js+
                    " but result.value not instanceof Ci.jsdIValue "+result.value, result);
        }
        return referents;
    }
    else
    {
        if (FBTrace.DBG_STACK || FBTrace.DBG_ERRORS)
            FBTrace.sysout("Firebug.Debugger.showReferents eval failed with "+ok+" result "+
                result.value, result);
    }
}

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(Firebug.CallstackPanel);

return Firebug.CallstackPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/debugger",
[
    "firebug/chrome/activableModule",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "arch/compilationunit",
    "firebug/lib/xpcom",
    "firebug/chrome/reps",
    "firebug/lib/locale",
    "firebug/lib/wrapper",
    "firebug/lib/url",
    "firebug/js/sourceLink",
    "firebug/js/stackFrame",
    "firebug/lib/css",
    "firebug/chrome/window",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/trace/debug",
    "firebug/js/fbs",
    "firebug/lib/events",
    "firebug/debugger/debuggerLib",
    "firebug/console/errors",
],
function(ActivableModule, Obj, Firebug, Firefox, CompilationUnit, Xpcom, FirebugReps, Locale,
    Wrapper, Url, SourceLink, StackFrame, Css, Win, Str, Arr, Debug, FBS, Events, DebuggerLib) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const jsdIScript = Ci.jsdIScript;
const jsdIStackFrame = Ci.jsdIStackFrame;
const jsdIExecutionHook = Ci.jsdIExecutionHook;
const nsISupports = Ci.nsISupports;
const nsICryptoHash = Ci.nsICryptoHash;
const nsIURI = Ci.nsIURI;

const PCMAP_SOURCETEXT = jsdIScript.PCMAP_SOURCETEXT;
const PCMAP_PRETTYPRINT = jsdIScript.PCMAP_PRETTYPRINT;

const RETURN_VALUE = jsdIExecutionHook.RETURN_RET_WITH_VAL;
const RETURN_THROW_WITH_VAL = jsdIExecutionHook.RETURN_THROW_WITH_VAL;
const RETURN_CONTINUE = jsdIExecutionHook.RETURN_CONTINUE;
const RETURN_CONTINUE_THROW = jsdIExecutionHook.RETURN_CONTINUE_THROW;
const RETURN_ABORT = jsdIExecutionHook.RETURN_ABORT;
const RETURN_HOOK_ERROR = jsdIExecutionHook.RETURN_HOOK_ERROR;

const TYPE_THROW = jsdIExecutionHook.TYPE_THROW;
const TYPE_DEBUGGER_KEYWORD = jsdIExecutionHook.TYPE_DEBUGGER_KEYWORD;

const STEP_OVER = 1;
const STEP_INTO = 2;
const STEP_OUT = 3;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

const tooltipTimeout = 300;

const reEval =  /\s*eval\s*\(([^)]*)\)/m;        // eval ( $1 )
const reHTM = /\.[hH][tT][mM]/;
const reFunction = /\s*Function\s*\(([^)]*)\)/m;
const reTooMuchRecursion = /too\smuch\srecursion/;

var jsd = Cc["@mozilla.org/js/jsd/debugger-service;1"].getService(Ci.jsdIDebuggerService);

// ************************************************************************************************

Firebug.Debugger = Obj.extend(ActivableModule,
{
    dispatchName: "debugger",
    fbs: FBS, // access to firebug-service in chromebug under browser.xul.Dom.Firebug.Debugger.fbs

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
    // Debugging

    // moz
    hasValidStack: function(context)
    {
        return context.stopped && context.currentFrame.isValid;
    },

    // on bti, method of stack
    evaluate: function(js, context, scope)  // TODO remote: move to backend, proxy to front
    {
        var frame = context.currentFrame;
        if (!frame)
            return;

        frame.scope.refresh(); // XXX what's this do?

        var result = {};
        var scriptToEval = js;

        // This seem to be safe; eval'ing a getter property in content that tries to
        // be evil and get Components.classes results in a permission denied error.
        var ok = frame.eval(scriptToEval, "", 1, result);

        var value = Wrapper.unwrapIValue(result.value, Firebug.viewChrome);
        if (ok)
            return value;
        else
            throw value;
    },

    // on bti (not called in firebug source)
    evaluateInCallingFrame: function(js, fileName, lineNo)
    {
        return this.halt(function evalInFrame(frame)
        {
            FBTrace.sysout("evaluateInCallingFrame " + js + " fileName: " +
                frame.script.fileName + " stack: " + StackFrame.getJSDStackDump(frame));

            var result = {};
            var ok = frame.eval(js, fileName, lineNo, result);
            var value = Wrapper.unwrapIValue(result.value, Firebug.viewChrome);

            if (ok)
                return value;
            else
                throw value;
        });
    },

    _temporaryRunWithJSD2Debugger: function(context, callback)
    {
        return DebuggerLib.withTemporaryDebugger(context, context.getCurrentGlobal(), callback);
    },

    _temporaryTransformSyntax: function(expr, win, context)
    {
        return Firebug.ClosureInspector.withExtendedLanguageSyntax(expr, win, context,
            function(newExpr)
        {
            return newExpr;
        });
    },

    /**
     * Used by autocomplete in commandLine
     * @return array of locally visible property names for each scope we are in
     */
    getCurrentFrameKeys: function(context)  // TODO remote, on bti
    {
        // return is safe
        var globals = Arr.keys(Wrapper.getContentView(context.getCurrentGlobal()));
        if (context.currentFrame)
            return this.getFrameKeys(context.currentFrame, globals);

        return globals;
    },

    /**
     * private to Debugger, returns list of strings
     */
    getFrameKeys: function(frame, names) // moz
    {
        var scope = frame.scope;
        while (scope)
        {
            var listValue = {value: null}, lengthValue = {value: 0};
            scope.getProperties(listValue, lengthValue);

            for (var i=0; i<lengthValue.value; ++i)
            {
                var prop = listValue.value[i];
                var name = Wrapper.unwrapIValue(prop.name);
                names.push(name);
            }

            scope = scope.jsParent;
        }

        return names;
    },

    // @Deprecated  see chrome.js
    focusWatch: function(context)  // TODO moved
    {
        return Firebug.chrome.focusWatch(context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Private to Debugger

    // moz
    beginInternalOperation: function() // stop debugger operations like breakOnErrors
    {
        var state = {breakOnErrors: Firebug.breakOnErrors};
        Firebug.breakOnErrors = false;
        return state;
    },

    // moz
    endInternalOperation: function(state)  // pass back the object given by beginInternalOperation
    {
        Firebug.breakOnErrors = state.breakOnErrors;
        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    // moz
    halt: function(fnOfFrame)
    {
        if(FBTrace.DBG_BP)
            FBTrace.sysout('debugger.halt '+fnOfFrame);

        return FBS.halt(this, fnOfFrame);
    },

    // on bti
    getCurrentStackTrace: function(context)
    {
        var trace = null;

        Firebug.Debugger.halt(function(frame)
        {
            if (FBTrace.DBG_STACK)
                FBTrace.sysout("lib.getCurrentStackTrace frame:", frame);

            trace = StackFrame.getCorrectedStackTrace(frame, context);

            if (FBTrace.DBG_STACK)
                FBTrace.sysout("lib.getCurrentStackTrace trace:", trace.toString().split('\n'));
        });

        return trace;
    },

    // Used by FBTest
    breakAsIfDebugger: function(frame)
    {
        // should return 'this' but also sets this.breakContext
        var debuggr = FBS.findDebugger(frame);
        FBS.breakIntoDebugger(debuggr, frame, 3);
    },

    // This URL prefix is used to skip frames from chrome URLs. Note that sometimes chrome URLs
    // are used even in web pages, but only in rare cases so don't worry about it.
    // Don't be specific like: chrome://firebug/ since frames coming from extensions e.g.
    // chrome://firecookie/ wouldn't be skipped then.
    breakNowURLPrefix: "chrome://",

    // on bti
    breakNow: function(context)
    {
        Firebug.Debugger.halt(function haltAnalysis(frame)
        {
            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.breakNow: frame "+frame.script.fileName+" context "+
                    context.getName(), StackFrame.getJSDStackDump(frame) );

            for (; frame && frame.isValid; frame = frame.callingFrame)
            {
                var fileName = frame.script.fileName;
                if (!fileName)
                    continue;
                else if (Str.hasPrefix(fileName, Firebug.Debugger.breakNowURLPrefix))
                    continue;
                else if (fileName.indexOf("/modules/firebug-") != -1)
                    continue;
                else
                    break;
            }

            if (frame)
            {
                Firebug.Debugger.breakContext = context;

                // I just made up a type that won't match TYPE_DEBUGGER_KEYWORD
                Firebug.Debugger.onBreak(frame, "halt");
            }
            else
            {
                if (FBTrace.DBG_UI_LOOP)
                    FBTrace.sysout("debugger.breakNow: no frame that not starting with "+
                        Firebug.Debugger.breakNowURLPrefix);
            }
        });
    },

    // moz, called by back end
    stop: function(context, frame, type, rv)
    {
        if (context.stopped)
            return RETURN_CONTINUE;

        if (!this.isAlwaysEnabled())
            return RETURN_CONTINUE;

        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("debugger.stop "+context.getName()+" frame",frame);

        // Do not break if the user is on another tab
        if (Firefox.getCurrentURI().spec !== context.window.location.toString())
        {
            if (FBTrace.DBG_UI_LOOP)
            {
                var current = Firefox.getCurrentURI().spec;
                var prev = context.window.location.toString();
                var locations = {current: current, context: prev};

                FBTrace.sysout("debugger.stop ERROR break is not in current window ", locations);
            }
            return RETURN_CONTINUE;
        }

        context.stoppedFrame = frame;  // the frame we stopped in, don't change this elsewhere.
        context.currentFrame = frame;  // the frame we show to user, depends on selection
        context.stopped = true;
        try
        {
            context.stoppedGlobal = Wrapper.wrapObject(
                Wrapper.unwrapIValue(frame.executionContext.globalObject));
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("debugger.stop failed to get global scope");
        }

        var hookReturn = Firebug.connection.dispatch("onStop", [context, frame, type, rv]);
        if ( hookReturn && hookReturn >= 0 )
        {
            delete context.stopped;
            delete context.stoppedFrame;
            delete context.stoppedGlobal;
            delete context.currentFrame;

            if (FBTrace.DBG_UI_LOOP)
            {
                FBTrace.sysout("debugger.stop extension vetoed stop with hookReturn " +
                    hookReturn);
            }

            return hookReturn;
        }

        try
        {
            this.freeze(context);

            // If firebug hits a breakpoint in an event handler, which used setCapture
            // the entire browser window is unclickable (see issue 5064)
            context.window.document.releaseCapture();

            // We will pause here until resume is called
            var depth = FBS.enterNestedEventLoop({
                onNest: Obj.bindFixed(this.startDebugging, this, context)
            });

            // For some reason we don't always end up here

            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.stop, nesting depth:"+depth+" jsd.pauseDepth: "+
                    jsd.pauseDepth+" context:"+context.getName());
        }
        catch (exc)
        {
            // Just ignore exceptions that happened while in the nested loop
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("debugger exception in nested event loop: "+exc, exc);
            else
                Debug.ERROR("debugger exception in nested event loop: "+exc+"\n");
        }
        finally
        {
            this.thaw(context);
        }

        this.stopDebugging(context);

        Firebug.connection.dispatch("onResume",[context]);

        if (context.aborted)
        {
            delete context.aborted;
            return RETURN_ABORT;
        }
        else if (Firebug.rerun)
        {
            setTimeout(function reExecute()
            {
                var rerun = context.savedRerun = Firebug.rerun;
                delete Firebug.rerun;

                if (FBTrace.DBG_UI_LOOP)
                    FBTrace.sysout("Firebug.debugger.reExecute ", {rerun: rerun});

                // fire the prestored script
                function successConsoleFunction(result, context)
                {
                    if (FBTrace.DBG_UI_LOOP)
                        FBTrace.sysout("Firebug.debugger.reExecute success", result);
                    Firebug.connection.dispatch( "onRerunComplete", [true, result]);
                }

                function exceptionFunction(result, context)
                {
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("Firebug.debugger.reExecute FAILED "+result, result);
                    Firebug.connection.dispatch( "onRerunComplete", [false, result]);
                }

                Firebug.CommandLine.evaluate("window._firebug.rerunFunction()", context, null,
                    context.window, successConsoleFunction, exceptionFunction);
            });

            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("Firebug.debugger.reExecute return "+RETURN_HOOK_ERROR);

            return RETURN_HOOK_ERROR;
        }
        else
        {
            return RETURN_CONTINUE;
        }
    },

    // on bti
    rerun: function(context)
    {
        if(!context.stopped)
        {
            FBTrace.sysout("debugger.rerun FAILS: not stopped");
            return;
        }

        if (Firebug.rerun)
        {
            FBTrace.sysout("debugger.rerun FAILS: Firebug.rerun in progress");
            return;
        }

        Firebug.rerun = this.getRerun(context);

        // now continue but abort the current call stack.
        this.resume(context);  // the Firebug.rerun will signal abort stack
    },

    // moz
    getRerun: function(context)
    {
        if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.rerun for "+context.getName());
        try
        {
            // walk back to the oldest frame, but not top level
            var frame = context.stoppedFrame;
            while (frame.callingFrame && frame.callingFrame.script.functionName)
            {
                frame = frame.callingFrame;

                if (frame.script.functionName == "_firebugRerun") // re-reRun
                {
                    if (FBTrace.DBG_UI_LOOP)
                        FBTrace.sysout("getRerun re-rerun ", context.savedRerun);
                    return context.savedRerun;
                }
            }

            // In this oldest frame we have element.onclick(event) or window.foo()
            // We want to cause the page to run this again after we abort this call stack.
            function getStoreRerunInfoScript(fnName)
            {
                var str = "if (!window._firebug)window._firebug={};\n";
                str += "window._firebug.rerunThis = this;\n";
                str += "window._firebug.rerunArgs = [];\n";
                str += "if (arguments && arguments.length) for (var i = 0; i < arguments.length; i++) window._firebug.rerunArgs.push(arguments[i]);\n";
                str += "window._firebug.rerunFunctionName = "+fnName+";\n";
                str +="window._firebug.rerunFunction = function _firebugRerun() { "+fnName+".apply(window._firebug.rerunThis, window._firebug.rerunArgs); }";
                return str;
            }

            var rerun = {};

            var fnName = StackFrame.getFunctionName(frame.script, context, frame, true);
            rerun.script = getStoreRerunInfoScript(fnName);
            var jsdFunctionName = frame.script.functionName;

            // now run the script that stores the rerun info in the page
            var result = {};
            var ok = frame.eval(rerun.script, context.window.location + "/RerunScript", 1, result);

            // If the eval goes off somewhere wacky, the frame may be invalid by this point.
            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.rerun "+ok+" and result: "+result+" for "+context.getName(),
                    {result: result, rerun: rerun, functionName: jsdFunctionName});
        }
        catch(exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("debugger.rerun FAILS for "+context.getName()+" because "+exc,
                    {exc:exc, rerun: rerun});
        }

        return rerun;
    },

    // bti
    resume: function(context)
    {
        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("debugger.resume, context.stopped:"+context.stopped+"\n");

        // this will cause us to return to just after the enterNestedEventLoop call
        var depth = FBS.exitNestedEventLoop();


        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("debugger.resume, depth:"+depth+"\n");
    },

    // bti
    abort: function(context)
    {
        if (context.stopped)
        {
            context.aborted = true;
            this.thaw(context);
            this.resume(context);
            FBS.unPause(true);
        }
    },

    // bti
    stepOver: function(context)
    {
        if (!context.stoppedFrame || !context.stoppedFrame.isValid)
            return;

        FBS.step(STEP_OVER, context, this);
        this.resume(context);
    },

    stepInto: function(context)
    {
        if (!context.stoppedFrame || !context.stoppedFrame.isValid)
            return;

        FBS.step(STEP_INTO, context, this);
        this.resume(context);
    },

    stepOut: function(context)
    {
        if (!context.stoppedFrame || !context.stoppedFrame.isValid)
            return;

        FBS.step(STEP_OUT, context, this);
        this.resume(context);
    },

    suspend: function(context)
    {
        if (context.stopped)
            return;

        FBS.suspend(this, context);
    },

    unSuspend: function(context)
    {
        FBS.stopStepping(null, context);  // TODO per context
        FBS.cancelBreakOnNextCall(this, context);
    },

    runUntil: function(context, compilationUnit, lineNo)
    {
        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("runUntil "+lineNo+" @"+compilationUnit);

        if (!context.stoppedFrame || !context.stoppedFrame.isValid)
            return;

        var sourceFile = compilationUnit.sourceFile;
        FBS.runUntil(compilationUnit.sourceFile, lineNo, context.stoppedFrame, this);
        this.resume(context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // moz

    freeze: function(context)
    {
        var executionContext = context.stoppedFrame.executionContext;
        try {
            executionContext.scriptsEnabled = false;
            this.suppressEventHandling(context);
            context.isFrozen = true;

            // https://developer.mozilla.org/en/XUL_Tutorial/Focus_and_Selection#Getting_the_currently_focused_element
            if (context.window && context.window.document.commandDispatcher)
            {
                context.saveFocus = context.window.document.commandDispatcher.focusedElement;
                if (context.saveFocus && !context.discardBlurEvents)
                {
                    context.discardBlurEvents = function blurDiscarder(event)
                    {
                        if (!context.saveFocus)
                        {
                            Events.removeEventListener(context.window, "blur",
                                context.discardBlurEvents, true);
                            delete context.discardBlurEvents;
                        }

                        if (FBTrace.DBG_UI_LOOP)
                        {
                            FBTrace.sysout("debugger.freeze discard blur event " +
                                context.saveFocus + " while focus is " +
                                context.window.document.commandDispatcher.focusedElement,
                                event);
                        }

                        event.preventDefault();
                        event.stopPropagation();
                    },

                    Events.addEventListener(context.window, "blur",
                        context.discardBlurEvents, true);
                }
            }

            if (FBTrace.DBG_UI_LOOP)
            {
                FBTrace.sysout("debugger.freeze context.saveFocus "+context.saveFocus,
                    context.saveFocus);

                FBTrace.sysout("debugger.freeze try to disable scripts "+
                    (context.eventSuppressor?"and events":"but not events")+" in "+
                    context.getName()+" executionContext.tag "+executionContext.tag+
                    ".scriptsEnabled: "+executionContext.scriptsEnabled);
            }
        }
        catch (exc)
        {
            // This attribute is only valid for contexts which implement nsIScriptContext.
            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.freeze, freeze exception " + exc + " in " +
                    context.getName(), exc);
        }
    },

    suppressEventHandling: function(context)
    {
        if (context.window instanceof Ci.nsIInterfaceRequestor)
        {
            context.eventSuppressor = context.window.getInterface(Ci.nsIDOMWindowUtils);
            if (context.eventSuppressor)
                context.eventSuppressor.suppressEventHandling(true);
        }
    },

    thaw: function(context)
    {
        try {
            if (context.isFrozen)
                delete context.isFrozen;
            else
                return; // bail, we did not freeze this context

                var executionContext = context.stoppedFrame.executionContext;
            if (executionContext.isValid)
            {
                this.unsuppressEventHandling(context);

                // Before we release JS, put the focus back
                if (context.saveFocus)
                {
                    context.window.focus();
                    context.saveFocus.focus();
                    delete context.saveFocus;

                    if (FBTrace.DBG_UI_LOOP)
                    {
                        var nowFocused = context.window.document.commandDispatcher ?
                            context.window.document.commandDispatcher.focusedElement : null;
                        FBTrace.sysout("debugger.thaw context.saveFocus "+context.saveFocus+
                            " vs "+nowFocused, context.saveFocus);
                    }
                }

                executionContext.scriptsEnabled = true;
            }
            else
            {
                if (FBTrace.DBG_UI_LOOP)
                    FBTrace.sysout("debugger.thaw "+executionContext.tag+
                        " executionContext is not valid");
            }

            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.thaw try to enable scripts " +
                    (context.eventSuppressor?"with events suppressed":"events enabled")+
                    " in "+context.getName()+" executionContext.tag "+executionContext.tag+
                    ".scriptsEnabled: "+executionContext.scriptsEnabled);
        }
        catch (exc)
        {
            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.stop, scriptsEnabled = true exception:", exc);
        }
    },

    unsuppressEventHandling: function(context)
    {
        if (context.eventSuppressor)
        {
            context.eventSuppressor.suppressEventHandling(false);
            delete context.eventSuppressor;
        }
    },

    // on bti
    toggleFreezeWindow: function(context)
    {
        // then we need to break into debugger to get the executionContext
        if (!context.stopped)
        {
            Firebug.Debugger.halt(function grabContext(frame)
            {
                context.stoppedFrame = frame;
                Firebug.Debugger.doToggleFreezeWindow(context);
                delete context.stoppedFrame;
            });

            Firebug.Debugger.suspend(context);
        }
        else
        {
            Firebug.Debugger.doToggleFreezeWindow(context);
        }
    },

    // moz
    doToggleFreezeWindow: function(context)
    {
        if (context.isFrozen)
            Firebug.Debugger.unsuppressEventHandling(context);
        else
            Firebug.Debugger.suppressEventHandling(context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Breakpoints

    setBreakpoint: function(sourceFile, lineNo)  // TODO: arg should be url
    {
        if (sourceFile instanceof CompilationUnit)
            sourceFile = sourceFile.sourceFile;  // see HACK in tabContext
        FBS.setBreakpoint(sourceFile, lineNo, null, Firebug.Debugger);
    },

    clearBreakpoint: function(sourceFile, lineNo)
    {
        if (sourceFile instanceof CompilationUnit)
            sourceFile = sourceFile.sourceFile;  // see HACK in tabContext
        FBS.clearBreakpoint(sourceFile.href, lineNo);
    },

    setErrorBreakpoint: function(compilationUnit, line)
    {
        FBS.setErrorBreakpoint(compilationUnit.sourceFile, line, Firebug.Debugger);
    },

    clearErrorBreakpoint: function(compilationUnit, line)
    {
        FBS.clearErrorBreakpoint(compilationUnit.getURL(), line, Firebug.Debugger);
    },

    // Called by bti browser.clearAllBreakpoints
    clearAllBreakpoints: function(context)
    {
        if (context)
        {
            var units = context.getAllCompilationUnits();
            FBS.clearAllBreakpoints(units, Firebug.Debugger);
            FBS.clearErrorBreakpoints(units, Firebug.Debugger);
        }
        else
        {
            // null means all urls
            FBS.enumerateBreakpoints(null, {call: function(url, lineNo, bp)
            {
                // skip breakpoints of other debuggers.
                if (bp.debuggerName !== Firebug.Debugger.debuggerName)
                    return;

                FBS.clearBreakpoint(url, lineNo);
            }});

            // and also error breakpoints
            FBS.enumerateErrorBreakpoints(null, {call: function(url, lineNo)
            {
                FBS.clearErrorBreakpoint(url, lineNo, Firebug.Debugger);
            }});
        }
    },

    enableAllBreakpoints: function(context)
    {
        if (FBTrace.DBG_BP)
            FBTrace.sysout("enableAllBreakpoints sourceFileMap:", context.sourceFileMap);

        for (var url in context.sourceFileMap)
        {
            FBS.enumerateBreakpoints(url, {call: function(url, lineNo)
            {
                FBS.enableBreakpoint(url, lineNo);
            }});
        }
    },

    disableAllBreakpoints: function(context)
    {
        for (var url in context.sourceFileMap)
        {
            FBS.enumerateBreakpoints(url, {call: function(url, lineNo)
            {
                FBS.disableBreakpoint(url, lineNo);
            }});
        }
    },

    getBreakpointCount: function(context)
    {
        var count = 0;
        for (var url in context.sourceFileMap)
        {
            FBS.enumerateBreakpoints(url,
            {
                call: function(url, lineNo)
                {
                    ++count;
                }
            });

            FBS.enumerateErrorBreakpoints(url,
            {
                call: function(url, lineNo)
                {
                    ++count;
                }
            });
        }
        return count;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Debugging and monitoring

    traceAll: function(context)
    {
        FBS.traceAll(Firebug.SourceFile.sourceURLsAsArray(context), this);
    },

    untraceAll: function(context)
    {
        FBS.untraceAll(this);
    },

    monitorFunction: function(fn, mode)
    {
        if (typeof(fn) == "function" || fn instanceof Function)
        {
            var script = Firebug.SourceFile.findScriptForFunctionInContext(
                Firebug.currentContext, fn);

            if (script)
            {
                this.monitorScript(fn, script, mode);
            }
            else
            {
                Firebug.Console.logFormatted(
                    ["Firebug unable to locate jsdIScript for function", fn],
                    Firebug.currentContext, "info");
            }
        }
        else
        {
            Firebug.Console.logFormatted(
                ["Firebug.Debugger.monitorFunction requires a function", fn],
                Firebug.currentContext, "info");
        }
    },

    unmonitorFunction: function(fn, mode)
    {
        if (typeof(fn) == "function" || fn instanceof Function)
        {
            var script = Firebug.SourceFile.findScriptForFunctionInContext(
                Firebug.currentContext, fn);

            if (script)
                this.unmonitorScript(fn, script, mode);
        }
    },

    monitorScript: function(fn, script, mode)
    {
        var scriptInfo = Firebug.SourceFile.getSourceFileAndLineByScript(
            Firebug.currentContext, script);

        if (scriptInfo)
        {
            if (mode == "debug")
                Firebug.Debugger.setBreakpoint(scriptInfo.sourceFile, scriptInfo.lineNo);
            else if (mode == "monitor")
                FBS.monitor(scriptInfo.sourceFile, scriptInfo.lineNo, Firebug.Debugger);
        }
    },

    unmonitorScript: function(fn, script, mode)
    {
        var scriptInfo = Firebug.SourceFile.getSourceFileAndLineByScript(
            Firebug.currentContext, script);

        if (scriptInfo)
        {
            if (mode == "debug")
                this.clearBreakpoint(scriptInfo.sourceFile, scriptInfo.lineNo);
            else if (mode == "monitor")
                FBS.unmonitor(scriptInfo.sourceFile.href, scriptInfo.lineNo);
        }
    },

    traceCalls: function(context, fn)
    {
        if (typeof(fn) == "function" || fn instanceof Function)
        {
            var script = Firebug.SourceFile.findScriptForFunctionInContext(context, fn);
            if (script)
                this.traceScriptCalls(context, script);
            else
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("debugger.traceCalls no script found for "+fn, fn);
            }
        }
    },

    untraceCalls: function(context, fn)
    {
        if (typeof(fn) == "function" || fn instanceof Function)
        {
            var script = Firebug.SourceFile.findScriptForFunctionInContext(context, fn);
            if (script)
                this.untraceScriptCalls(context, script);
        }
    },

    traceScriptCalls: function(context, script)
    {
        var scriptInfo = Firebug.SourceFile.getSourceFileAndLineByScript(context, script);
        if (scriptInfo)
            FBS.traceCalls(scriptInfo.sourceFile, scriptInfo.lineNo, Firebug.Debugger);
    },

    untraceScriptCalls: function(context, script)
    {
        var scriptInfo = Firebug.SourceFile.getSourceFileAndLineByScript(context, script);
        if (scriptInfo)
            FBS.untraceCalls(scriptInfo.sourceFile, scriptInfo.lineNo, Firebug.Debugger);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI Stuff

    /*
     * Called when a nestedEventLoop begins
     */
    startDebugging: function(context)
    {
        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("Firebug.Debugger startDebugging enter context.stopped:" +
                context.stopped + " for context: " + context.getName());

        try
        {
            FBS.lockDebugger();

            context.executingSourceFile =
                Firebug.SourceFile.getSourceFileByScript(context, context.stoppedFrame.script);

            // bail out, we don't want the user stuck in debug with out source.
            if (!context.executingSourceFile)
            {
                if (FBTrace.DBG_UI_LOOP)
                    FBTrace.sysout("startDebugging resuming, no sourceFile for "+
                        context.stoppedFrame.script.fileName,
                        context.stoppedFrame.script.functionSource);

                this.resume(context);
                return;
            }

            // Make Firebug.currentContext = context and sync the UI
            if (context != Firebug.currentContext)
                Firebug.selectContext(context);

        }
        catch(exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("Resuming debugger: error during debugging loop: "+exc, exc);

            Firebug.Console.log("Resuming debugger: error during debugging loop: "+exc);

            this.resume(context);
        }

        var frame = StackFrame.getStackFrame(context.stoppedFrame, context);
        Firebug.connection.dispatch( "onStartDebugging", [context, frame]);

        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("startDebugging exit context.stopped:" + context.stopped +
                " for context: " + context.getName());
    },

    /**
     * Called in the main event loop, from jsd, after we have exited the nested event loop
     */
    stopDebugging: function(context)
    {
        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("stopDebugging enter context: " + context.getName());

        try
        {
            FBS.unlockDebugger();

            // If the user reloads the page while the debugger is stopped, then
            // the current context will be destroyed just before
            if (context && !context.aborted)
            {
                delete context.stopped;
                delete context.stoppedFrame;
                delete context.stoppedGlobal;
                delete context.currentFrame;
                context.executingSourceFile = null;
                delete context.breakLineNumber;

                Firebug.connection.dispatch( "onStopDebugging", [context]);

            }
            else
            {
                if (FBTrace.DBG_UI_LOOP)
                    FBTrace.sysout("debugger.stopDebugging else "+context.getName()+" "+
                        Win.safeGetWindowLocation(context.window));
            }
        }
        catch (exc)
        {
            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.stopDebugging FAILS", exc);

            // If the window is closed while the debugger is stopped,
            // then all hell will break loose here
            Debug.ERROR(exc);
        }
    },

    suspendFirebug: function()
    {
        Firebug.suspendFirebug();
    },

    resumeFirebug: function()
    {
        Firebug.resumeFirebug();
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsWindow: function(win)
    {
        if (!this.isAlwaysEnabled())
            return false;

        var context = ((win && Firebug.TabWatcher) ?
            Firebug.TabWatcher.getContextByWindow(win) : null);

        this.breakContext = context;
        return !!context;
    },

    // This is called from fbs for almost all fbs operations
    supportsGlobal: function(frameWin)
    {
        var context = ( (frameWin && Firebug.TabWatcher) ?
            Firebug.TabWatcher.getContextByWindow(frameWin) : null);

        if (!context)
            return false;

        // otherwise we cannot be called.
        context.jsDebuggerCalledUs = true;

        this.breakContext = context;
        //FBTrace.sysout("debugger.js this.breakContext "+this.breakContext.getName());
        return true;
    },

    onLock: function(state)
    {
        // XXXjoe For now, trying to see if it's ok to have multiple contexts
        // debugging simultaneously - otherwise we need this
        //if (this.context != this.debugContext)
        {
            // XXXjoe Disable step/continue buttons
        }
    },

    onBreak: function(frame, type)
    {
        try
        {
            var context = this.breakContext;

            // If the script panel is disabled, Firebug can't break (issue 4290).
            if (!Firebug.PanelActivation.isPanelEnabled("script"))
                return RETURN_CONTINUE;

            if (FBTrace.DBG_BP || (!context && FBTrace.DBG_FBS_ERRORS))
                FBTrace.sysout("debugger.onBreak breakContext: " +
                    (context ? context.getName() : " none!"), StackFrame.getJSDStackDump(frame));

            delete this.breakContext;

            if (!context)
                return RETURN_CONTINUE;

            if (type == TYPE_DEBUGGER_KEYWORD)
            {
                var trace = Wrapper.getContentView(context.window)._firebugStackTrace;
                if (trace == "console-tracer")
                    return this.debuggerTracer(context, frame);
                else
                    this.setDebuggerKeywordCause(context, frame);
                if (!context.breakingCause)
                    return RETURN_CONTINUE;
            }

            return this.stop(context, frame, type);
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS && FBTrace.DBG_BP)
                FBTrace.sysout("debugger.onBreak FAILS", exc);
            throw exc;
        }
    },

    debuggerTracer: function(context, frame)
    {
        var trace = StackFrame.getCorrectedStackTrace(frame, context);
        if (FBTrace.DBG_ERRORLOG)
            FBTrace.sysout("debugger.firebugDebuggerTracer corrected trace.frames "+
                trace.frames.length, trace.frames);

        if (trace)
        {
            // drop the firebugDebuggerTracer and reorder
            //trace.frames = trace.frames.slice(1);

            if (FBTrace.DBG_ERRORLOG)
                FBTrace.sysout("debugger.firebugDebuggerTracer dropped tracer trace.frames "+
                    trace.frames.length, trace.frames);

            // drop one frame see attachConsoleInjector
            //trace.frames = trace.frames.slice(1);
            Firebug.Console.log(trace, context, "stackTrace");
        }

        if (FBTrace.DBG_BP)
            FBTrace.sysout("debugger.onBreak "+(trace?"debugger trace":" debugger no trace!"));

        return RETURN_CONTINUE;
    },

    /**
     * for |debugger;| keyword offer the skip/continue dialog (optionally?)
     */
    setDebuggerKeywordCause: function(context, frame)
    {
        var sourceFile = Firebug.SourceFile.getSourceFileByScript(context, frame.script);
        if (!sourceFile)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("debugger.setDebuggerKeywordCause FAILS, no sourceFile for "+
                    frame.script.tag+"@"+frame.script.fileName+" in "+context.getName());
            return;
        }

        var analyzer = sourceFile.getScriptAnalyzer(frame.script);
        var lineNo = analyzer.getSourceLineFromFrame(context, frame);

        context.breakingCause =
        {
            title: Locale.$STR("debugger keyword"),
            skipActionTooltip: Locale.$STR("firebug.bon.tooltip.disableDebuggerKeyword2"),
            message: Locale.$STR("firebug.bon.cause.disableDebuggerKeyword2"),
            skipAction: function addSkipperAndGo()
            {
                // a breakpoint that never hits, but prevents debugger keyword
                // (see FBS.onDebugger as well)
                var bp = Firebug.Debugger.setBreakpoint(sourceFile, lineNo);
                FBS.disableBreakpoint(sourceFile.href, lineNo);

                if (FBTrace.DBG_BP)
                    FBTrace.sysout("debugger.onBreak converted to disabled bp "+sourceFile.href+
                        "@"+lineNo+" tag: "+frame.script.tag, bp);

                Firebug.Debugger.resume(context);
            },
        };
    },

    onThrow: function(frame, rv)
    {
        // onThrow is called for throw, for catches that do not succeed,
        // and for functions that exceptions pass through.
        var context = this.breakContext;
        delete this.breakContext;

        if (!context)
        {
            if (FBTrace.DBG_BP)
                FBTrace.sysout("debugger.onThrow, no context, try to get from frame\n");
            context = this.getContextByFrame(frame);
        }

        if (FBTrace.DBG_ERRORLOG)
        {
            var lines = [];
            var frames = StackFrame.getCorrectedStackTrace(frame, context).frames;
            for (var i=0; i<frames.length; i++)
                lines.push(frames[i].line + ", " + frames[i].fn);

            FBTrace.sysout("debugger.onThrow context:" + (context ? context.getName() :
                "undefined") + ", " + lines.join("; "), frames);
        }

        if (!context)
            return RETURN_CONTINUE_THROW;

        if (!FBS.showStackTrace)
            return RETURN_CONTINUE_THROW;

        try
        {
            var realThrow = this.isRealThrow(frame, context);
            if (realThrow)
            {
                context.thrownStackTrace = StackFrame.getCorrectedStackTrace(frame, context);

                if (FBTrace.DBG_BP)
                    FBTrace.sysout("debugger.onThrow reset context.thrownStackTrace",
                        context.thrownStackTrace.frames);

                // xxxHonza: this could fix Issue 3276: Track Throw/Catch is not working
                /*if (FBS.trackThrowCatch)
                {
                    var object = {
                        errorMessage: errorObject.value.stringValue,
                        message: errorObject.value.stringValue,
                        sourceName: "",
                        lineNumber: -1,
                        sourceLine: "",
                        category: "javascript",
                        flags: 2,
                        exceptionFlag: 2,
                    };

                    Firebug.Errors.logScriptError(context, object, false);

                    context.thrownStackTrace = StackFrame.getCorrectedStackTrace(frame, context);
                }*/
            }
            else
            {
                if (FBTrace.DBG_BP)
                    FBTrace.sysout("debugger.onThrow not a real throw");
            }
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("onThrow FAILS: " + exc, exc);
        }

        if (Firebug.connection.dispatch("onThrow",[context, frame, rv]))
            return this.stop(context, frame, TYPE_THROW, rv);

        return RETURN_CONTINUE_THROW;
    },

    isRealThrow: function(mozFrame, context)
    {
        // Determine whether the throw was a real one, or just a rethrow of the
        // last exception (probably automatically inserted - which it seems
        // happens for every function an exception passes through - but it
        // could also be manual because there is no simple way to tell them
        // apart). A rethrow is detected when the current stack exists at the
        // end of the previous exception's, except that the current top-most
        // stack frame only has to be in the same function to match.
        if (!context.thrownStackTrace)
            return true;

        var trace = context.thrownStackTrace.frames;
        var findMozFrame = mozFrame.callingFrame, againstFrame = null;
        if (findMozFrame)
        {
            // Verify that the previous exception includes this frame's call
            // site somewhere.
            var findFrameSig = findMozFrame.script.tag + "." + findMozFrame.pc;
            for (var i=1; i<trace.length; i++)
            {
                var preFrameSig = trace[i].signature();

                if (FBTrace.DBG_ERRORS && FBTrace.DBG_STACK)
                {
                    FBTrace.sysout("debugger.isRealThrow " + findFrameSig + "==" +
                        preFrameSig);
                }

                if (findFrameSig === preFrameSig)
                {
                    againstFrame = trace[i-1];
                    break;
                }
            }

            if (!againstFrame)
                return true;
        }
        else
        {
            againstFrame = trace[trace.length-1];
        }

        // Verify that the current frame's function location matches what the
        // exception has above the matched frame.
        if (mozFrame.script !== againstFrame.script)
            return true;

        return false;
    },

    onMonitorScript: function(frame)
    {
        var context = this.breakContext;
        delete this.breakContext;

        if (!context)
            context = this.getContextByFrame(frame);
        if (!context)
            return RETURN_CONTINUE;

        frame = StackFrame.getStackFrame(frame, context);

        Firebug.connection.dispatch("onMonitorScript",[context, frame]);
    },

    onFunctionCall: function(context, frame, depth, calling)
    {
        if (!context)
            context = this.getContextByFrame(frame);

        if (!context)
            return RETURN_CONTINUE;

        frame = StackFrame.getStackFrame(frame, context);

        Firebug.connection.dispatch("onFunctionCall",[context, frame, depth, calling]);

        return context;  // returned as first arg on next call from same trace
    },

    onError: function(frame, error, hitErrorBreakpoint)
    {
        var context = this.breakContext;
        delete this.breakContext;

        // If the script panel is disabled, Firebug can't break on error.
        if (!Firebug.PanelActivation.isPanelEnabled("script"))
            return 0;

        try
        {
            if (FBTrace.DBG_ERRORLOG)
                FBTrace.sysout("debugger.onError: "+error.errorMessage+" in "+
                    (context?context.getName():"no context"), error);

            if (reTooMuchRecursion.test(error.errorMessage))
                frame = FBS.discardRecursionFrames(frame);

            Firebug.errorStackTrace = StackFrame.getCorrectedStackTrace(frame, context);

            if (FBTrace.DBG_ERRORLOG)
                FBTrace.sysout("debugger.onError; break=" + Firebug.breakOnErrors +
                    ", errorStackTrace:", Firebug.errorStackTrace);

            delete context.breakingCause;

            if (Firebug.breakOnErrors || hitErrorBreakpoint)
            {
                var eventOrigin = Wrapper.unwrapIValue(frame.executionContext.globalObject);
                if (!eventOrigin)
                    return 0;

                // Check if the eventOrigin (window) comes from this context.
                var eventOriginIndex = -1;
                for (var i=0; i<context.windows.length; i++)
                {
                    if (Wrapper.getContentView(context.windows[i]) == eventOrigin) {
                        eventOriginIndex = i;
                        break;
                    }
                }

                // Bail out if the event that lead the error is not cause by code in this context.
                if (eventOriginIndex < 0)
                {
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("debugger.onError; error is not from this context: (" +
                            eventOriginIndex + ") " + frame.script.tag+"@"+frame.script.fileName);
                    return 0;
                }

                var sourceFile = Firebug.SourceFile.getSourceFileByScript(context, frame.script);
                if (!sourceFile)
                {
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("debugger.breakon Errors no sourceFile for "+
                            frame.script.tag+"@"+frame.script.fileName);
                    return;
                }

                var analyzer = sourceFile.getScriptAnalyzer(frame.script);
                var lineNo = analyzer.getSourceLineFromFrame(context, frame);

                var doBreak = true;
                FBS.enumerateBreakpoints(sourceFile.href, {call: function(url, line, props, scripts)
                {
                    if (FBTrace.DBG_FBS_BP)
                        FBTrace.sysout("debugger.breakon Errors bp "+url+"@"+line+" scripts "+
                            (scripts?scripts.length:"none"));

                    if (line === lineNo)
                        doBreak = false;
                }});

                if (FBTrace.DBG_BP)
                    FBTrace.sysout("debugger.breakon Errors " + doBreak + " for " +
                        sourceFile.href + "@" + lineNo);

                if (doBreak)
                {
                    context.breakingCause =
                    {
                        title: Locale.$STR("Break on Error"),
                        message: error.message,
                        copyAction: Obj.bindFixed(FirebugReps.ErrorMessage.copyError,
                            FirebugReps.ErrorMessage, error),

                        skipAction: function addSkipperAndGo()
                        {
                            // a breakpoint that never hits, but prevents BON for errors
                            var bp = Firebug.Debugger.setBreakpoint(sourceFile, lineNo);
                            FBS.disableBreakpoint(sourceFile.href, lineNo);

                            if (FBTrace.DBG_BP)
                                FBTrace.sysout("debugger.breakon Errors set "+sourceFile.href+"@"+
                                    lineNo+" tag: "+frame.script.tag, bp);

                            Firebug.Debugger.resume(context);
                        },
                    };
                }
            }
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("debugger.onError getCorrectedStackTrace FAILED: "+exc, exc);
        }

        var hookReturn = Firebug.connection.dispatch("onError",[context, frame, error]);

        if (!context.breakingCause)
            return 0;

        if (Firebug.breakOnErrors)
        {
            // Switch of Break on Next tab lightning.
            //var panel = context.getPanel("console", true);
            //Firebug.Breakpoint.updatePanelTab(panel, false);

            return -1;  // break
        }

        if (hookReturn)
            return hookReturn;

        return -2; /* let firebug service decide to break or not */
    },

    onUncaughtException: function(errorInfo)
    {
        var context = this.breakContext;
        delete this.breakContext;

        Firebug.Errors.logScriptError(context, errorInfo, false);
        return -2;
    },

    onXULScriptCreated: function(frame, outerScript, innerScriptEnumerator)
    {
        try
        {
            var context = this.breakContext;
            delete this.breakContext;

            var sourceFile = context.sourceFileMap[outerScript.fileName];
            if (sourceFile)
            {
                if (FBTrace.DBG_SOURCEFILES)
                    FBTrace.sysout("debugger.onXULScriptCreated reuse sourcefile="+
                        sourceFile.toString()+" -> "+context.getName()+" ("+context.uid+")");

                Firebug.SourceFile.addScriptsToSourceFile(sourceFile, null, innerScriptEnumerator);
            }
            else
            {
                sourceFile = new Firebug.XULSourceFile(outerScript.fileName, outerScript,
                    innerScriptEnumerator);
            }

            this.watchSourceFile(context, sourceFile);

            if (FBTrace.DBG_SOURCEFILES)
                FBTrace.sysout("debugger.onXULScriptCreated script.fileName="+outerScript.fileName+
                    " in "+context.getName()+" "+sourceFile);

            Firebug.connection.dispatch("onXULScriptCreated",[context, frame, sourceFile.href]);
            return sourceFile;
        }
        catch (e)
        {
            if (FBTrace.DBG_TOPLEVEL || FBTrace.DBG_ERRORS)
                FBTrace.sysout("onXULScriptCreated FaILS "+e, e);
        }
    },

    onEvalScriptCreated: function(frame, outerScript, innerScripts)
    {
        try
        {
            if (FBTrace.DBG_EVAL)
                FBTrace.sysout("debugger.onEvalLevelScript script.fileName=" +
                    outerScript.fileName);

            var context = this.breakContext;
            delete this.breakContext;

            var sourceFile = this.getEvalLevelSourceFile(frame, context, innerScripts);

            if (FBTrace.DBG_EVAL)
                FBTrace.sysout("debugger.onEvalScriptCreated url="+sourceFile.href,
                    StackFrame.getCorrectedStackTrace(frame, context));

            Firebug.connection.dispatch("onEvalScriptCreated",[context, frame, sourceFile.href]);
            return sourceFile;
        }
        catch (e)
        {
            if (FBTrace.DBG_EVAL || FBTrace.DBG_ERRORS)
                FBTrace.sysout("onEvalScriptCreated FaILS "+e, e);
        }
    },

    onEventScriptCreated: function(frame, outerScript, innerScripts)
    {
        if (FBTrace.DBG_EVENTS)
            FBTrace.sysout("debugger.onEventScriptCreated script.fileName=" +
                outerScript.fileName, {outerScript: outerScript, script: frame.script});

        var context = this.breakContext;
        delete this.breakContext;

        var script = frame.script;
        var creatorURL = Url.normalizeURL(frame.script.fileName);
        var innerScriptArray = [];

        try
        {
            var source = script.functionSource;

            while (innerScripts.hasMoreElements())
            {
                var inner = innerScripts.getNext();
                source += "\n"+inner.functionSource;
                innerScriptArray.push(inner);
            }
        }
        catch (exc)
        {
            /*Bug 426692 */
            var source = creatorURL + "/"+Obj.getUniqueId();
        }

        var lines = Str.splitLines(source);

        var urlDescribed = this.getDynamicURL(context,
            Url.normalizeURL(frame.script.fileName), lines, "event");

        var handlerName = outerScript.functionName;
        if (handlerName)
            var url = urlDescribed.href + '/' + handlerName;
        else
            var url = urlDescribed.href;

        context.sourceCache.invalidate(url);
        context.sourceCache.storeSplitLines(url, lines);

        var sourceFile = new Firebug.EventSourceFile(url, frame.script, "event:"+
            script.functionName+"."+script.tag, lines, new ArrayEnumerator(innerScriptArray));

        this.watchSourceFile(context, sourceFile);

        if (FBTrace.DBG_EVENTS)
            FBTrace.sysout("debugger.onEventScriptCreated url="+sourceFile.href+"\n");

        if (FBTrace.DBG_EVENTS)
             FBTrace.sysout("debugger.onEventScriptCreated sourceFileMap:", context.sourceFileMap);

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("debugger.onEventScriptCreated sourcefile="+sourceFile.toString()+
                " -> "+context.getName()+"\n");

        Firebug.connection.dispatch("onEventScriptCreated",[context, frame, url]);
        return sourceFile;
    },

    // We just compiled a bunch of JS, eg a script tag in HTML.  We are about to run the outerScript.
    onTopLevelScriptCreated: function(frame, outerScript, innerScripts)
    {
        if (FBTrace.DBG_TOPLEVEL)
            FBTrace.sysout("debugger("+this.debuggerName+").onTopLevelScriptCreated script.fileName="+
                outerScript.fileName+"\n");

        var context = this.breakContext;
        delete this.breakContext;

        // This is our only chance to get the linetable for the outerScript
        // since it will run and be GC next.
        var script = frame.script;
        var url = Url.normalizeURL(script.fileName);

        if (FBTrace.DBG_TOPLEVEL)
            FBTrace.sysout("debugger.onTopLevelScriptCreated frame.script.tag="+frame.script.tag+
                " has url="+url);

        var isInline = false;

        /* The primary purpose here was to deal with http://code.google.com/p/fbug/issues/detail?id=2912
         * This approach could be applied to inline scripts, so I'll leave the code here until we decide.
        Win.iterateWindows(context.window, function isInlineScriptTag(win)
        {
            var location = Win.safeGetWindowLocation(win);
            if (location === url)
            {
                isInline = true;
                return isInline;
            }
        });
        */

        if (FBTrace.DBG_TOPLEVEL)
            FBTrace.sysout("debugger.onTopLevelScriptCreated has inLine:"+isInline+" url="+url);

        if (isInline) // never true see above
        {
            var href = url +"/"+context.dynamicURLIndex++;
            sourceFile = new Firebug.ScriptTagAppendSourceFile(href, script,
                script.lineExtent, innerScripts);
            this.watchSourceFile(context, sourceFile);
            context.pendingScriptTagSourceFile = sourceFile;
        }
        else
        {
            var sourceFile = context.sourceFileMap[url];

            // Multiple script tags in HTML or duplicate .js file names.
            if (sourceFile && (sourceFile instanceof Firebug.TopLevelSourceFile))
            {
                if (FBTrace.DBG_SOURCEFILES)
                    FBTrace.sysout("debugger.onTopLevelScriptCreated reuse sourcefile="+
                        sourceFile.toString()+" -> "+context.getName()+" ("+context.uid+")");

                if (!sourceFile.outerScript || !sourceFile.outerScript.isValid)
                    sourceFile.outerScript = outerScript;

                Firebug.SourceFile.addScriptsToSourceFile(sourceFile, outerScript,
                    innerScripts);
            }
            else
            {
                sourceFile = new Firebug.TopLevelSourceFile(url, script, script.lineExtent,
                    innerScripts);

                if (FBTrace.DBG_SOURCEFILES)
                    FBTrace.sysout("debugger.onTopLevelScriptCreated create sourcefile="+
                        sourceFile.toString()+" -> "+context.getName()+" ("+context.uid+")");
            }

            // If a script is inserted multiple times in HTML, we still need to make
            // sure that meta info is updated (e.g. sourceFileByTag in the context)
            // (see issue 4880)
            this.watchSourceFile(context, sourceFile);
        }

        Firebug.connection.dispatch("onTopLevelScriptCreated",[context, frame, sourceFile.href]);
        return sourceFile;
    },

    getContextByFrame: function(frame)
    {
        if (FBTrace.DBG_BP)
            FBTrace.sysout("debugger.getContextByFrame");

        var win = FBS.getOutermostScope(frame);
        return win ? Firebug.TabWatcher.getContextByWindow(win) : null;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    watchSourceFile: function(context, sourceFile)
    {
        context.addSourceFile(sourceFile);  // store in the context and notify listeners
        //FBS.watchSourceFile(sourceFile);    // tell the service to watch this file

        // Update the Script panel, this script could have been loaded asynchronously
        // and perhaps is the only one that should be displayed (otherwise the panel
        // would show: No Javascript on this page). See issue 4932
        var panel = context.getPanel("script", true);
        if (panel)
            panel.context.invalidatePanels("script");
    },

    unwatchSourceFile: function(context, sourceFile)
    {
        //FBS.unwatchSourceFile(sourceFile);
        context.removeSourceFile(sourceFile);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onToggleBreakpoint: function(url, lineNo, isSet, props)
    {
        if (props.debuggerName != this.debuggerName) // then not for us
        {
            if (FBTrace.DBG_BP)
                FBTrace.sysout("debugger(" + this.debuggerName +
                    ").onToggleBreakpoint ignoring toggle for " +
                    props.debuggerName + " target " + lineNo + "@" + url);
            return;
        }

        var found = false;
        for (var i = 0; i < Firebug.TabWatcher.contexts.length; ++i)
        {
            var context = Firebug.TabWatcher.contexts[i];
            var sourceFile = context.sourceFileMap[url];
            if (sourceFile)
            {
                if (FBTrace.DBG_BP)
                    FBTrace.sysout("debugger(" + this.debuggerName +
                        ").onToggleBreakpoint found context " +
                        context.getName());

                if (!isSet && context.dynamicURLhasBP)
                    this.checkDynamicURLhasBP(context);

                var panel = context.getPanel("script", true);
                if (!panel)
                    continue;

                panel.context.invalidatePanels("breakpoints");

                var sourceBox = panel.getSourceBoxByURL(url);
                if (!sourceBox)
                {
                    if (FBTrace.DBG_BP)
                        FBTrace.sysout("debugger("+this.debuggerName+").onToggleBreakpoint context "+
                            i+" script panel no sourcebox for url: "+url, panel.sourceBoxes);
                    continue;
                }

                var row = sourceBox.getLineNode(lineNo);
                if (FBTrace.DBG_BP)
                    FBTrace.sysout(i+") onToggleBreakpoint getLineNode="+row+" lineNo="+lineNo+
                        " context:"+context.getName());

                if (!row)
                    continue;  // we *should* only be called for lines in the viewport...

                row.setAttribute("breakpoint", isSet);
                if (isSet && props)
                {
                    row.setAttribute("condition", props.condition ? "true" : "false");
                    row.breakpointCondition = props.condition ? props.condition : null;

                    if (props.condition)  // issue 1371
                    {
                        var watchPanel = this.ableWatchSidePanel(context);

                        if (watchPanel)
                        {
                            watchPanel.addWatch(props.condition);
                        }
                        else
                        {
                            if (FBTrace.DBG_ERRORS)
                                FBTrace.sysout("onToggleBreakpoint no watch panel in context "+
                                    context.getName());
                        }
                    }
                    row.setAttribute("disabledBreakpoint", new Boolean(props.disabled).toString());
                }
                else
                {
                    row.removeAttribute("condition");
                    if (props.condition)
                    {
                        var watchPanel = this.ableWatchSidePanel(context);
                        watchPanel.removeWatch(props.condition);
                        watchPanel.rebuild();
                    }
                    row.removeAttribute("disabledBreakpoint");
                }
                Firebug.connection.dispatch( "onToggleBreakpoint", [context, url, lineNo, isSet]);
                found = true;
                continue;
            }
        }

        if (FBTrace.DBG_BP && !found)
            FBTrace.sysout("debugger("+this.debuggerName+").onToggleBreakpoint no find context");
    },

    // xxxHonza, xxxjjb: duplicated in script.js, does it belong here?
    // But onToggleBreakpoint needs it.
    ableWatchSidePanel: function(context)
    {
        // TODO if (commandline is not active, then we should not show the new watch feature)
        var watchPanel = context.getPanel("watches", true);
        if (watchPanel)
            return watchPanel;
    },

    onToggleErrorBreakpoint: function(url, lineNo, isSet)
    {
        for (var i = 0; i < Firebug.TabWatcher.contexts.length; ++i)
        {
            var context = Firebug.TabWatcher.contexts[i];
            var panel = context.getPanel("console", true);
            if (panel)
            {
                panel.context.invalidatePanels("breakpoints");

                for (var row = panel.panelNode.firstChild; row; row = row.nextSibling)
                {
                    var errorMessage = row.getElementsByClassName("objectBox-errorMessage");
                    if (!errorMessage.length)
                        continue;

                    errorMessage = errorMessage[0];
                    var error = errorMessage.repObject;
                    if (error instanceof FirebugReps.ErrorMessageObj && error.href == url &&
                        error.lineNo == lineNo)
                    {
                        if (isSet)
                            Css.setClass(errorMessage, "breakForError");
                        else
                            Css.removeClass(errorMessage, "breakForError");

                        Firebug.connection.dispatch( "onToggleErrorBreakpoint",
                            [context, url, lineNo, isSet]);
                    }
                }
            }
        }
    },

    onToggleMonitor: function(url, lineNo, isSet)
    {
        for (var i = 0; i < Firebug.TabWatcher.contexts.length; ++i)
        {
            var panel = Firebug.TabWatcher.contexts[i].getPanel("console", true);
            if (panel)
                panel.context.invalidatePanels("breakpoints");
        }
    },

    checkDynamicURLhasBP: function (context)
    {
        context.dynamicURLhasBP = false;
        for (var url in context.sourceFileMap)
        {
             var sourceFile = context.sourceFileMap[url];
               if (sourceFile.isEval() || sourceFile.isEvent())
               {
                   FBS.enumerateBreakpoints(url, {call: function setDynamicIfSet(url, lineNo)
                   {
                       context.dynamicURLhasBP = true;
                   }});
               }
               if (context.dynamicURLhasBP)
                   break;
        }
        if (FBTrace.DBG_SOURCEFILES || FBTrace.DBG_BP)
            FBTrace.sysout("debugger.checkDynamicURLhasBP "+context.dynamicURLhasBP);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // XXXjjb this code is not called, because I found the scheme for detecting Function
    // too complex. I'm leaving it here to remind us that we need to support new Function().
    onFunctionConstructor: function(frame, ctor_script)
    {
       try
        {
            var context = this.breakContext;
            delete this.breakContext;

            var sourceFile = this.createSourceFileForFunctionConstructor(frame, ctor_script, context);

            if (FBTrace.DBG_EVAL)
            {
                FBTrace.sysout("debugger.onFunctionConstructor tag=" + ctor_script.tag +
                    " url=" + sourceFile.href);

                FBTrace.sysout(StackFrame.traceToString(
                    StackFrame.getCorrectedStackTrace(frame, context)));
            }

            Firebug.connection.dispatch("onFunctionConstructor",
                [context, frame, ctor_script, sourceFile.href]);

            return sourceFile.href;
        }
        catch(exc)
        {
            Debug.ERROR("debugger.onFunctionConstructor failed: "+exc);

            if (FBTrace.DBG_EVAL)
                FBTrace.sysout("debugger.onFunctionConstructor failed: ",exc);

            return null;
        }

    },

    createSourceFileForFunctionConstructor: function(caller_frame, ctor_script, context)
    {
        var ctor_expr = null; // this.getConstructorExpression(caller_frame, context);
        if (FBTrace.DBG_EVAL)
            FBTrace.sysout("createSourceFileForFunctionConstructor ctor_expr:"+ctor_expr+"\n");

        var source;
        if (ctor_expr)
        {
            source = this.getEvalBody(caller_frame,
                "lib.createSourceFileForFunctionConstructor ctor_expr", 1, ctor_expr);
        }
        else
        {
            source = " bah createSourceFileForFunctionConstructor"; //ctor_script.functionSource;
        }

        if (FBTrace.DBG_EVAL)
            FBTrace.sysout("createSourceFileForFunctionConstructor source:"+source);

        var url = this.getDynamicURL(context, Url.normalizeURL(caller_frame.script.fileName),
            source, "Function");

        var lines = context.sourceCache.store(url.href, source);
        var sourceFile = new Firebug.FunctionConstructorSourceFile(url, caller_frame.script,
            ctor_expr, lines.length);

        this.watchSourceFile(context, sourceFile);

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("debugger.onNewFunction sourcefile="+sourceFile.toString()+" -> "+
                context.getName()+"\n");

        return sourceFile;
    },

    getConstructorExpression: function(caller_frame, context)
    {
        // We believe we are just after the ctor call.
        var decompiled_lineno = getLineAtPC(caller_frame, context);
        if (FBTrace.DBG_EVAL)
            FBTrace.sysout("debugger.getConstructoreExpression decompiled_lineno:"+
                decompiled_lineno+"\n");

        // TODO place in sourceCache?
        var decompiled_lines = Str.splitLines(caller_frame.script.functionSource);
        if (FBTrace.DBG_EVAL)
            FBTrace.sysout("debugger.getConstructoreExpression decompiled_lines:",decompiled_lines);

        var candidate_line = decompiled_lines[decompiled_lineno - 1]; // zero origin
        if (FBTrace.DBG_EVAL)
            FBTrace.sysout("debugger.getConstructoreExpression candidate_line:" + candidate_line);

        if (candidate_line && candidate_line != null)
        {
            var m = reFunction.exec(candidate_line);
            if (m)
                var arguments =  m[1];     // TODO Lame: need to count parens, with escapes and quotes
        }

        if (FBTrace.DBG_EVAL)
            FBTrace.sysout("debugger.getConstructoreExpression arguments:"+arguments+"\n");

        if (arguments) // need to break down commas and get last arg.
        {
            var lastComma = arguments.lastIndexOf(',');
            return arguments.substring(lastComma+1);  // if -1 then 0
        }

        return null;
    },

    // end of guilt trip
    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    // Called by debugger.onEval() to store eval() source.
    // The frame has the blank-function-name script and it is not the top frame.
    // The frame.script.fileName is given by spidermonkey as file of the first eval().
    // The frame.script.baseLineNumber is given by spidermonkey as the line of the first eval() call
    // The source that contains the eval() call is the source of our caller.
    // If our caller is a file, the source of our caller is at frame.script.baseLineNumber
    // If our caller is an eval, the source of our caller is TODO Check Test Case
    getEvalLevelSourceFile: function(frame, context, innerScripts)
    {
        var eval_expr = this.getEvalExpression(frame, context);

        if (FBTrace.DBG_EVAL)
            FBTrace.sysout("getEvalLevelSourceFile eval_expr:"+eval_expr);

        if (eval_expr)
        {
            var source  = this.getEvalBody(frame, "lib.getEvalLevelSourceFile.getEvalBody",
                1, eval_expr);
            var mapType = PCMAP_SOURCETEXT;
        }
        else
        {
            var source = frame.script.functionSource; // XXXms - possible crash on OSX FF2
            var mapType = PCMAP_PRETTYPRINT;
        }

        var lines = Str.splitLines(source);

        if (FBTrace.DBG_EVAL)
            FBTrace.sysout("getEvalLevelSourceFile "+lines.length+ "lines, mapType:"+
                ((mapType==PCMAP_SOURCETEXT)?"SOURCE":"PRETTY")+" source:"+source);

        var url = this.getDynamicURL(context, Url.normalizeURL(frame.script.fileName),
            lines, "eval");

        context.sourceCache.invalidate(url.href);
        context.sourceCache.storeSplitLines(url.href, lines);

        var sourceFile = new Firebug.EvalLevelSourceFile(url, frame.script, eval_expr, lines,
            mapType, innerScripts);

        this.watchSourceFile(context, sourceFile);

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("debugger.getEvalLevelSourceFile sourcefile="+sourceFile.toString()+
                " -> "+context.getName()+"\n");

        return sourceFile;
    },

    getDynamicURL: function(context, callerURL, lines, kind)
    {
        var url = this.getURLFromLastLine(context, lines);
        if (url)
            return url;

        var url = this.getSequentialURL(context, callerURL, kind);
        if (url)
            return url;

        var url = this.getURLFromMD5(callerURL, lines, kind);
        if (url)
            return url;

        var url = this.getDataURLForScript(callerURL, lines);
        if (url)
            return url;

        return url;
    },

    getURLFromLastLine: function(context, lines)
    {
        var url = null;
        // Ignores any trailing whitespace in |source|
        const reURIinComment = /\/\/[@#]\ssourceURL=\s*(\S*?)\s*$/m;
        var m = reURIinComment.exec(lines[lines.length - 1]);

        if (m)
        {
            // add context info to the sourceURL so eval'd sources are grouped
            // correctly in the source file list
            if (m[1] && m[1].indexOf('://') == -1)
            {
                var loc = context.window.location;
                if (m[1].charAt(0) != '/') m[1] = '/'+m[1]; // prepend leading slash if necessary
                m[1] = loc.protocol + '//' + loc.host + m[1]; // prepend protocol and host
            }

            var href = new String(m[1]);
            href = Url.normalizeURL(href);

            url = {href: href, kind: "source"};
            if (FBTrace.DBG_SOURCEFILES)
                FBTrace.sysout("debugger.getURLFromLastLine "+url.href, url);
        }
        else
        {
            if (FBTrace.DBG_SOURCEFILES)
                FBTrace.sysout("debugger.getURLFromLastLine no match"+lines[lines.length - 1]);
        }

        return url;
    },

    getSequentialURL: function(context, callerURL, kind)
    {
        var url = null;
        if (!context.dynamicURLhasBP)
        {
            // If no breakpoints live in dynamic code then we don't need to compare
            // the previous and reloaded source. In that case let's use a cheap Url.
            var href = new String(callerURL + (kind ? "/"+kind+"/" : "/nokind/")+"seq/"
                +(context.dynamicURLIndex++));
            url = {href: href, kind: "seq"};

            if (FBTrace.DBG_SOURCEFILES || isNaN(context.dynamicURLIndex))
                FBTrace.sysout("debugger.getSequentialURL context:"+context.getName()+
                    " url:"+url.href+" index: "+context.dynamicURLIndex, url);
        }
        return url;
    },

    getURLFromMD5: function(callerURL, lines, kind)
    {
        this.hash_service.init(this.nsICryptoHash.MD5);
        var source = lines.join('\n'); // we could double loop, would that be any faster?
        byteArray = [];
        for (var j = 0; j < source.length; j++)
        {
            byteArray.push( source.charCodeAt(j) );
        }
        this.hash_service.update(byteArray, byteArray.length);
        var hash = this.hash_service.finish(true);

        // encoding the hash should be ok, it should be information-preserving?
        // Or at least reversable?
        var href= new String(callerURL + (kind ? "/"+kind+"/" : "/nokind/")+"MD5/" +
            encodeURIComponent(hash));
        url = {href: href, kind: "MD5"};

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("debugger.getURLFromMD5 "+url.href, url);

        return url;
    },

    getDataURLForScript: function(callerURL, lines)
    {
        var url = null;
        var href = null;
        if (!source)
        {
            href = "eval."+script.tag;
        }
        else
        {
            // data:text/javascript;fileName=x%2Cy.js;baseLineNumber=10,<the-url-encoded-data>
            href = new String("data:text/javascript;");
            href += "fileName="+encodeURIComponent(callerURL);
            var source = lines.join('\n');
            //url +=  ";"+ "baseLineNumber="+encodeURIComponent(script.baseLineNumber) +
            href +="," + encodeURIComponent(source);
        }

        url = {href:href, kind:"data"};
        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("debugger.getDataURLForScript "+url.href, url);

        return url;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getEvalExpression: function(frame, context)
    {
        var expr = this.getEvalExpressionFromEval(frame, context);  // eval in eval

        return (expr) ? expr : this.getEvalExpressionFromFile(Url.normalizeURL(frame.script.fileName),
            frame.script.baseLineNumber, context);
    },

    getEvalExpressionFromFile: function(url, lineNo, context)
    {
        if (context && context.sourceCache)
        {
            var in_url = Url.reJavascript.exec(url);
            if (in_url)
            {
                var m = reEval.exec(in_url[1]);
                if (m)
                    return m[1];
                else
                    return null;
            }

            var htm = reHTM.exec(url);
            if (htm)
                lineNo = lineNo + 1; // embedded scripts seem to be off by one?  XXXjjb heuristic

            // Walk backwards from the first line in the function until we find the line which
            // matches the pattern above, which is the eval call
            var line = "";
            for (var i = 0; i < 3; ++i)
            {
                line = context.sourceCache.getLine(url, lineNo-i) + line;
                if (line && line != null)
                {
                    var m = reEval.exec(line);
                    if (m)
                        return m[1];
                }
            }
        }
        return null;
    },

    getEvalExpressionFromEval: function(frame, context)
    {
        var callingFrame = frame.callingFrame;
        var sourceFile = Firebug.SourceFile.getSourceFileByScript(context, callingFrame.script);
        if (sourceFile)
        {
            if (FBTrace.DBG_EVAL)
            {
                FBTrace.sysout("debugger.getEvalExpressionFromEval sourceFile.href=" +
                    sourceFile.href);

                FBTrace.sysout("debugger.getEvalExpressionFromEval callingFrame.pc=" +
                    callingFrame.pc + " callingFrame.script.baseLineNumber=" +
                    callingFrame.script.baseLineNumber);
            }

            var lineNo = callingFrame.script.pcToLine(callingFrame.pc, PCMAP_SOURCETEXT);
            lineNo = lineNo - callingFrame.script.baseLineNumber + 1;
            var url  = sourceFile.href;

            if (FBTrace.DBG_EVAL && !context.sourceCache)
                FBTrace.sysout("debugger.getEvalExpressionFromEval context.sourceCache null??\n");

            // Walk backwards from the first line in the function until we find the line which
            // matches the pattern above, which is the eval call
            var line = "";
            for (var i = 0; i < 3; ++i)
            {
                line = context.sourceCache.getLine(url, lineNo-i) + line;
                if (FBTrace.DBG_EVAL)
                    FBTrace.sysout("debugger.getEvalExpressionFromEval lineNo-i="+lineNo+"-"+i+"="+
                        (lineNo-i)+" line:"+line+"\n");

                if (line && line != null)
                {
                    var m = reEval.exec(line);
                    if (m)
                        return m[1];     // TODO Lame: need to count parens, with escapes and quotes
                }
            }
        }
        return null;
    },

    getEvalBody: function(frame, asName, asLine, evalExpr)
    {
        if (evalExpr)
        {
            var result_src = {};
            var evalThis = "new String("+evalExpr+");";
            var evaled = frame.eval(evalThis, asName, asLine, result_src);

            if (evaled)
            {
                var src = Wrapper.unwrapIValue(result_src.value);
                return src+"";
            }
            else
            {
                // Either we failed, or this was a window.eval() call
                var source;

                if (frame.callingFrame && !this.avoidRecursing)
                {
                    // Try the caller, in case we are in window.eval() where the scope is global
                    this.avoidRecursing = true;
                    source = this.getEvalBody(frame.callingFrame, asName, asLine, evalExpr);
                    delete this.avoidRecursing;

                    if (FBTrace.DBG_EVAL)
                        FBTrace.sysout("callingFrame used to get source ", source);

                    return source;
                }

                if(evalExpr == "function(p,a,c,k,e,r")
                    source = "/packer/ JS compressor detected";
                else
                    source = frame.script.functionSource;

                return source+" /* !eval("+evalThis+")) */";
            }
        }
        else
        {
            return frame.script.functionSource; // XXXms - possible crash on OSX FF2
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Module

    initialize: function()
    {
        Firebug.clientID = this.registerClient(Firebug.JSDebugClient);
        this.nsICryptoHash = Components.interfaces["nsICryptoHash"];

        this.debuggerName =  window.location.href +"-@-"+Obj.getUniqueId();
        this.toString = function() { return this.debuggerName; };

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("debugger.initialize "+ this.debuggerName+" Firebug.clientID "+
                Firebug.clientID);

        this.hash_service = Xpcom.CCSV("@mozilla.org/security/hash;1", "nsICryptoHash");


        this.wrappedJSObject = this;  // how we communicate with fbs

        this.onFunctionCall = Obj.bind(this.onFunctionCall, this);

        ActivableModule.initialize.apply(this, arguments);
    },

    shutdown: function()
    {
        //Firebug.connection.unregisterTool(this.asTool);

        ActivableModule.destroy.apply(this, arguments);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // BTI

    toolName: "script",

    addListener: function(listener)
    {
        Firebug.connection.addListener(listener);
    },

    removeListener: function(listener)
    {
        Firebug.connection.removeListener(listener);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * per-XUL window registration; this method just allows us to keep fbs in this file.
     * @param clientAPI an object that implements functions called by fbs for clients.
     */
    registerClient: function(clientAPI)
    {
        return FBS.registerClient(clientAPI);
    },

    unregisterClient: function(clientAPI)
    {
        FBS.unregisterClient(clientAPI);
    },

    enable: function()
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.Firebug.Debugger.enable; " + this.enabled);
    },

    disable: function()
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.Firebug.Debugger.disable; " + this.enabled);
    },

    selfObserver: {}, // empty listener, registered as observer while Script panel is enabled.

    initializeUI: function()
    {
        ActivableModule.initializeUI.apply(this, arguments);
        this.obeyPrefs();
        this.filterButton = Firebug.chrome.$("fbScriptFilterMenu");  // TODO move to script.js
        this.filterMenuUpdate();
        if (FBS.isJSDActive())  // notify frontend of current state
            Firebug.JSDebugClient.onJSDActivate(true, 'Firebug.Debugger.initializeUI');
    },

    obeyPrefs: function()
    {
        var name = "script.enableSites";
        var value = Firebug.Options.get("script.enableSites");
        this.updateOption(name, value);
    },

    initContext: function(context, persistedState)
    {
        if (persistedState)
            context.dynamicURLhasBP = persistedState.dynamicURLhasBP;

        context.dynamicURLIndex = 1; // any dynamic urls need to be unique to the context.

        context.jsDebuggerCalledUs = false;

        ActivableModule.initContext.apply(this, arguments);
    },

    showContext: function(browser, context)
    {
        // then context was not active during load
        if (context && context.loaded && !context.onLoadWindowContent)
            this.updateScriptFiles(context);
    },

    // scan windows for 'script' tags (only if debugger is not enabled)
    updateScriptFiles: function(context)
    {
        function addFile(url, scriptTagNumber, dependentURL)
        {
            var sourceFile = new Firebug.ScriptTagSourceFile(context, url, scriptTagNumber);
            sourceFile.dependentURL = dependentURL;
            context.addSourceFile(sourceFile);
            return true;
        }

        Win.iterateWindows(context.window, function updateEachWin(win)
        {
            if (FBTrace.DBG_SOURCEFILES)
                FBTrace.sysout("updateScriptFiles Win.iterateWindows: "+win.location.href+
                    " documentElement: "+win.document.documentElement);

            if (!win.document.documentElement)
                return;

            var url = Url.normalizeURL(win.location.href);

            if (url)
            {
                if (!context.sourceFileMap.hasOwnProperty(url))
                {
                    var URLOnly = new Firebug.NoScriptSourceFile(context, url);
                    context.addSourceFile(URLOnly);

                    if (FBTrace.DBG_SOURCEFILES)
                        FBTrace.sysout("updateScriptFiles created NoScriptSourceFile for URL:" +
                            url, URLOnly);
                }
            }

            var baseUrl = win.location.href;
            var bases = win.document.documentElement.getElementsByTagName("base");
            if (bases && bases[0])
            {
                baseUrl = bases[0].href;
            }

            var scripts = win.document.documentElement.getElementsByTagName("script");
            for (var i = 0; i < scripts.length; ++i)
            {
                var scriptSrc = scripts[i].getAttribute('src'); // for XUL use attribute
                var url = scriptSrc ? Url.absoluteURL(scriptSrc, baseUrl) : win.location.href;
                url = Url.normalizeURL(url ? url : win.location.href);
                var added = addFile(url, i, (scriptSrc?win.location.href:null));

                if (FBTrace.DBG_SOURCEFILES)
                    FBTrace.sysout("updateScriptFiles "+(scriptSrc?"inclusion":"inline")+
                        " script #"+i+"/"+scripts.length+(added?" adding ":" readded ")+url+
                        " to context="+context.getName()+"\n");
            }
        });

        if (FBTrace.DBG_SOURCEFILES)
        {
            FBTrace.sysout("updateScriptFiles sourcefiles:",
                Firebug.SourceFile.sourceFilesAsArray(context.sourceFileMap));
        }
    },

    loadedContext: function(context)
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("loadedContext needs to trigger watchpanel updates");

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("debugger("+this.debuggerName+").loadedContext enabled on load: "+
                context.onLoadWindowContent+" context.sourceFileMap", context.sourceFileMap);
    },

    // clean up the source file map in case the frame is being reloaded.
    unwatchWindow: function(context, win)
    {
        var scriptTags = win.document.getElementsByTagName("script");
        for (var i = 0; i < scriptTags.length; i++)
        {
            var src = scriptTags[i].getAttribute("src");
            src = src ? src : Win.safeGetWindowLocation(win);

            // If the src is not in the source map, try to use absolute url.
            if (!context.sourceFileMap[src])
                src = Url.absoluteURL(src, win.location.href);

            delete context.sourceFileMap[src];

            if (FBTrace.DBG_SOURCEFILES)
                FBTrace.sysout("debugger.unWatchWindow; delete sourceFileMap entry for " + src);
        }
        if (scriptTags.length > 0)
            context.invalidatePanels('script');
    },

    destroyContext: function(context, persistedState)
    {
        ActivableModule.destroyContext.apply(this, arguments);

        if (context.stopped)
        {
            // the abort will call resume, but the nestedEventLoop would continue the load...
            this.abort(context);
        }

        if (persistedState)
        {
            if (context.dynamicURLhasBP)
                persistedState.dynamicURLhasBP = context.dynamicURLhasBP;
            else
                delete persistedState.dynamicURLhasBP;
        }
    },

    updateOption: function(name, value)
    {
        if (name == "breakOnErrors")
            Firebug.chrome.getElementById("cmd_firebug_breakOnErrors").setAttribute("checked", value);
    },

    getObjectByURL: function(context, url)
    {
        var sourceFile = Firebug.SourceFile.getSourceFileByHref(url, context);
        if (sourceFile)
            return new SourceLink.SourceLink(sourceFile.href, 0, "js");
    },

    shutdown: function()
    {
        this.unregisterClient(Firebug.JSDebugClient);
        FBS.unregisterDebugger(this);
    },

    /**
     * 1.3.1 safe for multiple calls
     */
    registerDebugger: function()
    {
        // Do not activate JSD on shutdown.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=756267#c12
        if (Firebug.isShutdown)
            return;

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("registerDebugger");

        // this will eventually set 'jsd' on the statusIcon
        var check = FBS.registerDebugger(this);

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.registerDebugger "+check+" debuggers");
    },

    unregisterDebugger: function() // 1.3.1 safe for multiple calls
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.unregisterDebugger");

        // stay registered if we are profiling across a reload.
        if (Firebug.Profiler && Firebug.Profiler.isProfiling())
            return;

        var check = FBS.unregisterDebugger(this);

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.unregisterDebugger: "+check+" debuggers");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends ActivableModule

    onObserverChange: function(observer)
    {
        if (FBTrace.DBG_ACTIVATION)
        {
            var names = [];
            this.observers.forEach(function(ob){names.push(ob.name || ob.dispatchName || ob.toolName);});

            FBTrace.sysout("debugger.onObserverChange "+this.hasObservers()+" "+
                this.observers.length+": "+names.join(','), this.observers);
        }

        if (this.hasObservers())
            this.activateDebugger();
        else
            this.deactivateDebugger();
    },

    activateDebugger: function()
    {
        this.registerDebugger();

        // If jsd is already active, we'll notify true; else we'll get another event
        var isActive = FBS.isJSDActive();
        if (isActive)
            Firebug.JSDebugClient.onJSDActivate(true, 'activated already');

        if (FBTrace.DBG_PANELS || FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.activateDebugger requested; activated already? "+isActive);
    },

    deactivateDebugger: function()
    {
        this.unregisterDebugger();

        var isActive = FBS.isJSDActive();
        if (!isActive)
            Firebug.JSDebugClient.onJSDDeactivate(false, 'deactivate');

        if (FBTrace.DBG_PANELS || FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.deactivate");
    },

    onSuspendingFirebug: function()
    {
        var anyStopped = Firebug.TabWatcher.iterateContexts(function isAnyStopped(context)
        {
            return context.stopped;
        });

        return anyStopped;
    },

    onSuspendFirebug: function()
    {
        if (!Firebug.Debugger.isAlwaysEnabled())
            return;

        // xxxHonza: do not pause the debugger (see issue 6086).

        // can be called multiple times.
        //var paused = FBS.pause(this.debuggerName);

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.onSuspendFirebug paused: "+paused+" isAlwaysEnabled " +
                Firebug.Debugger.isAlwaysEnabled());

        // JSD activation is not per browser-tab, so FBS.pause can return 'not-paused' when
        // Firebug is activated on another tab.
        // The start-button should somehow reflect that JSD can be still active (even if
        // Firebug is suspended for the current tab).
        //if (!paused)  // then we failed to suspend, undo
        //    return true;

        return false;
    },

    onResumeFirebug: function()
    {
        if (!Firebug.Debugger.isAlwaysEnabled())
            return;

        //var unpaused = FBS.unPause();

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("debugger.onResumeFirebug unpaused: "+unpaused+" isAlwaysEnabled " +
                Firebug.Debugger.isAlwaysEnabled());
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Menu in toolbar.

    onScriptFilterMenuTooltipShowing: function(tooltip, context)
    {
        if (FBTrace.DBG_OPTIONS)
            FBTrace.sysout("onScriptFilterMenuTooltipShowing not implemented");
    },

    onScriptFilterMenuCommand: function(event, context)
    {
        var menu = event.target;
        Firebug.Options.set("scriptsFilter", menu.value);
        Firebug.Debugger.filterMenuUpdate();
    },

    menuFullLabel:
    {
        "static": Locale.$STR("ScriptsFilterStatic"),
        evals: Locale.$STR("ScriptsFilterEval"),
        events: Locale.$STR("ScriptsFilterEvent"),
        all: Locale.$STR("ScriptsFilterAll"),
    },

    menuShortLabel:
    {
        "static": Locale.$STR("ScriptsFilterStaticShort"),
        evals: Locale.$STR("ScriptsFilterEvalShort"),
        events: Locale.$STR("ScriptsFilterEventShort"),
        all: Locale.$STR("ScriptsFilterAllShort"),
    },

    onScriptFilterMenuPopupShowing: function(menu, context)
    {
        if (this.menuTooltip)
            this.menuTooltip.fbEnabled = false;

        var items = menu.getElementsByTagName("menuitem");
        var value = this.filterButton.value;

        for (var i=0; i<items.length; i++)
        {
            var option = items[i].value;
            if (!option)
                continue;

            if (option == value)
                items[i].setAttribute("checked", "true");

            items[i].label = Firebug.Debugger.menuFullLabel[option];
        }

        return true;
    },

    onScriptFilterMenuPopupHiding: function(tooltip, context)
    {
        if (this.menuTooltip)
            this.menuTooltip.fbEnabled = true;

        return true;
    },

    filterMenuUpdate: function()
    {
        var value = Firebug.Options.get("scriptsFilter");
        this.filterButton.value = value;
        this.filterButton.label = this.menuShortLabel[value];
        this.filterButton.removeAttribute("disabled");
        this.filterButton.setAttribute("value", value);
        if (FBTrace.DBG_OPTIONS)
            FBTrace.sysout("debugger.filterMenuUpdate value: "+value+" label:"+
                this.filterButton.label+'\n');
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Options

    resetAllOptions: function()
    {
        Firebug.TabWatcher.iterateContexts( function clearBPs(context)
        {
            Firebug.Debugger.clearAllBreakpoints(context);
        });

        var breakpointStore = FBS.getBreakpointStore();
        breakpointStore.clear(true);
    }
});

// ********************************************************************************************* //

Firebug.Debugger.Breakpoint = function(name, href, lineNumber, checked, sourceLine, isFuture)
{
    this.name = name;
    this.href = href;
    this.lineNumber = lineNumber;
    this.checked = checked;
    this.sourceLine = sourceLine;
    this.isFuture = isFuture;
};

// ********************************************************************************************* //

Firebug.DebuggerListener =
{
    onStop: function(context, frame, type, rv)
    {
    },

    onResume: function(context)
    {
    },

    onThrow: function(context, frame, rv)
    {
        return false; /* continue throw */
    },

    onError: function(context, frame, error)
    {
    },

    onEventScriptCreated: function(context, frame, url, sourceFile)
    {
    },

    onTopLevelScriptCreated: function(context, frame, url, sourceFile)
    {
    },

    onEvalScriptCreated: function(context, frame, url, sourceFile)
    {
    },

    onFunctionConstructor: function(context, frame, ctor_script, url, sourceFile)
    {
    }
};

// ********************************************************************************************* //
// Signals from fbs, passed along to our listeners

Firebug.JSDebugClient =
{
    onJSDActivate: function(active, fromMsg)
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("Firebug.JSDebugClient onJSDActivate "+active+" "+fromMsg);
        Firebug.connection.dispatch("onActivateTool", ["script", active]);
    },

    onJSDDeactivate: function(active, fromMsg)
    {
        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("Firebug.JSDebugClient onJSDDeactivate "+active+" "+fromMsg);
        Firebug.connection.dispatch("onActivateTool", ["script", active]);
    },

    onPauseJSDRequested: function(rejection, debuggerName)
    {
        // A debugger client (an instance of Firebug.JSDebugClient) asked to pause JSD.
        // Note that there is one instance of Firebug.JSDebugClient per browser (XUL) window.
        // If the debugger is 'on' in this browser window JSD and the request comes from
        // another window (debugger) JSD should *not* be paused (see issue 4609).
        // So, reject only if the request comes from another browser window and Firebug
        // is resumed in this window.
        if (debuggerName != Firebug.Debugger.debuggerName && !Firebug.getSuspended())
        {
            rejection.push(true);

            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("Firebug.JSDebugClient onPauseJSDRequested rejected to suspend; " +
                    "Current debugger: " + Firebug.Debugger.debuggerName + ", requestor debugger: " +
                    debuggerName);
        }

        //Firebug.connection.dispatch("onPauseJSDRequested", arguments);

        if (FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("Firebug.JSDebugClient onPauseJSDRequested rejection: " +
                rejection.length + ", jsDebuggerOn: " + Firebug.jsDebuggerOn);
    }
};

// Recursively look for obj in container using array of visited objects
function findObjectPropertyPath(containerName, container, obj, visited)
{
    if (!container || !obj || !visited)
        return false;

    var referents = [];
    visited.push(container);
    for (var p in container)
    {
        if (container.hasOwnProperty(p))
        {
            var candidate = null;
            try
            {
                candidate = container[p];
            }
            catch(exc)
            {
                // eg sessionStorage
            }

            if (candidate === obj) // then we found a property pointing to our obj
            {
                referents.push(new Referent(containerName, container, p, obj));
            }
            else // recurse
            {
                var candidateType = typeof (candidate);
                if (candidateType === 'object' || candidateType === 'function')
                {
                    if (visited.indexOf(candidate) === -1)
                    {
                        var refsInChildren = findObjectPropertyPath(p, candidate, obj, visited);
                        if (refsInChildren.length)
                        {
                            // As we unwind the recursion we tack on layers of the path.
                            for (var i = 0; i < refsInChildren.length; i++)
                            {
                                var refInChildren = refsInChildren[i];
                                refInChildren.prependPath(containerName, container);
                                referents.push(refInChildren);

                                FBTrace.sysout(" Did prependPath with p "+p+" gave "+
                                    referents[referents.length - 1].getObjectPathExpression(),
                                    referents[referents.length - 1]);
                            }
                        }
                    }
                    //else we already looked at that object.
                } // else the object has no properties
            }
        }
    }

    FBTrace.sysout(" Returning "+referents.length+ " referents", referents);

    return referents;
}

// ********************************************************************************************* //

function getFrameWindow(frame)
{
    var result = {};
    if (frame.eval("window", "", 1, result))
    {
        var win = Wrapper.unwrapIValue(result.value, Firebug.viewChrome);
        return Win.getRootWindow(win);
    }
}

function ArrayEnumerator(array)
{
    this.index = 0;
    this.array = array;
    this.hasMoreElements = function()
    {
        return (this.index < array.length);
    };
    this.getNext = function()
    {
        return this.array[++this.index];
    };
}

// ********************************************************************************************* //
// Registration

Firebug.registerActivableModule(Firebug.Debugger);

return Firebug.Debugger;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/fbs",
[], function() {

// ********************************************************************************************* //
// Constants

var FBS = {};

// ********************************************************************************************* //

try
{
    // xxxHonza: The entire firebug-service implementation should be here
    Components.utils["import"]("resource://firebug/firebug-service.js", FBS);
}
catch (err)
{
}

// ********************************************************************************************* //

return FBS.fbs;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/scriptPanel",
[
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/chrome/reps",
    "firebug/lib/domplate",
    "arch/javascripttool",
    "arch/compilationunit",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/js/sourceLink",
    "firebug/js/stackFrame",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/chrome/window",
    "firebug/lib/search",
    "firebug/lib/persist",
    "firebug/lib/system",
    "firebug/chrome/menu",
    "firebug/trace/debug",
    "firebug/lib/keywords",
    "firebug/chrome/panelNotification",
    "firebug/lib/options",
    "firebug/editor/editorSelector",
    "firebug/chrome/infotip",
    "firebug/chrome/searchBox",
    "firebug/js/sourceBox",
    "firebug/js/watchPanel",
],
function (Rep, Obj, Firebug, Firefox, FirebugReps, Domplate, JavaScriptTool, CompilationUnit,
    Locale, Events, Url, SourceLink, StackFrame, Css, Dom, Win, Search, Persist, System, Menu,
    Debug, Keywords, PanelNotification, Options) {

// ********************************************************************************************* //
// Script panel

Firebug.ScriptPanel = function() {};

for (var p in Firebug.EditorSelector)
{
    if (Firebug.EditorSelector.hasOwnProperty(p))
        Firebug.ScriptPanel[p] = Firebug.EditorSelector[p];
}

Firebug.ScriptPanel.getEditorOptionKey = function()
{
    return "JSEditor";
};

Firebug.ScriptPanel.reLineNumber = /^[^\\]?#(\d*)$/;

/**
 * object used to markup JavaScript source lines.
 * In the namespace Firebug.ScriptPanel.
 */
Firebug.ScriptPanel.decorator = Obj.extend(new Firebug.SourceBoxDecorator,
{
    decorate: function(sourceBox, unused)
    {
        this.markExecutableLines(sourceBox);
        this.setLineBreakpoints(sourceBox.repObject, sourceBox);
    },

    markExecutableLines: function(sourceBox)
    {
        var compilationUnit = sourceBox.repObject;
        if (FBTrace.DBG_BP || FBTrace.DBG_LINETABLE)
            FBTrace.sysout("script.markExecutableLines START: "+compilationUnit.toString());

        var lineNode;
        var lineNo = sourceBox.firstViewableLine;
        while (lineNode = sourceBox.getLineNode(lineNo))
        {
            if (lineNode.alreadyMarked)
            {
                lineNo++;
                continue;
            }

            var script = compilationUnit.isExecutableLine(lineNo);

            if (FBTrace.DBG_LINETABLE)
                FBTrace.sysout("script.markExecutableLines [" + lineNo + "]=" + script);

            if (script)
                lineNode.setAttribute("executable", "true");
            else
                lineNode.removeAttribute("executable");

            lineNode.alreadyMarked = true;

            if (lineNo > sourceBox.lastViewableLine)
                break;

            lineNo++;
        }

        if (FBTrace.DBG_BP || FBTrace.DBG_LINETABLE)
            FBTrace.sysout("script.markExecutableLines DONE: " + compilationUnit.toString());
    },

    setLineBreakpoints: function(compilationUnit, sourceBox)
    {
        compilationUnit.eachBreakpoint(function setAttributes(line, props)
        {
            var scriptRow = sourceBox.getLineNode(line);
            if (scriptRow)
            {
                scriptRow.setAttribute("breakpoint", "true");
                if (props.disabled)
                    scriptRow.setAttribute("disabledBreakpoint", "true");

                if (props.condition)
                {
                    scriptRow.setAttribute("condition", "true");
                    scriptRow.breakpointCondition = props.condition;
                }
            }

            if (FBTrace.DBG_LINETABLE)
            {
                FBTrace.sysout("script.setLineBreakpoints found " + scriptRow + " for " + line +
                    "@" + compilationUnit.getURL(), props);
            }
        });
    },
});

// ********************************************************************************************* //

Firebug.ScriptPanel.prototype = Obj.extend(Firebug.SourceBoxPanel,
{
    dispatchName: "scriptPanel",

    /**
     * Framework connection
     */
    updateSourceBox: function(sourceBox)
    {
        this.location = sourceBox.repObject;

        this.onUpdateSourceBox(sourceBox);
    },

    /**
     * Framework connection
     */
    getSourceType: function()
    {
        return "js";
    },

    /**
     * Framework connection
     */
    getDecorator: function(sourceBox)
    {
        return Firebug.ScriptPanel.decorator;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // TODO Class method

    onJavaScriptDebugging: function(active)
    {
        // Front side state
        Firebug.jsDebuggerOn = active;

        // If this panel is selected, the change in JSD causes a refresh.
        // Note that onJavaScriptDebugging is called on the prototype.
        var selectedPanel = Firebug.chrome.getSelectedPanel();
        if (selectedPanel && Object.getPrototypeOf(selectedPanel) === this)
            Firebug.chrome.syncPanel(this.name);

        // Front side UI mark
        var firebugStatus = Firefox.getElementById("firebugStatus");
        if (firebugStatus)
        {
            // Use enabled state for the status flag. JSD can be active even if
            // the Script panel itself is deactivated (i.e. because the Console
            // panel is enabled). See issue 2582 for more details.
            var enabled = this.isEnabled();
            firebugStatus.setAttribute("script", (enabled && active) ? "on" : "off");
        }

        if (Firebug.StartButton)
            Firebug.StartButton.resetTooltip();
        else
            FBTrace.sysout("No Firebug.StartButton in onJavaScriptDebugging?");

        if (FBTrace.DBG_ACTIVATION)
        {
            FBTrace.sysout("script.onJavaScriptDebugging " + active + " icon attribute: " +
                Firefox.getElementById("firebugStatus").getAttribute("script"));
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    showFunction: function(fn)
    {
        var sourceLink = Firebug.SourceFile.findSourceForFunction(fn, this.context);
        if (sourceLink)
        {
            this.showSourceLink(sourceLink);
        }
        else
        {
            // Want to avoid the Script panel if possible
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("no sourcelink for function");
        }
    },

    showSourceLink: function(sourceLink, noHighlight)
    {
        var compilationUnit = this.context.getCompilationUnit(sourceLink.href);
        if (compilationUnit)
        {
            this.navigate(compilationUnit);
            if (sourceLink.line)
            {
                var highlighter = noHighlight ? null :
                    this.jumpHighlightFactory(sourceLink.line, this.context);

                this.scrollToLine(sourceLink.href, sourceLink.line, highlighter);

                Events.dispatch(this.fbListeners, "onShowSourceLink", [this, sourceLink.line]);
            }

            // If the source link is selected, clear it so the next link will scroll and highlight.
            if (sourceLink == this.selection)
                this.selection = null;
        }
    },

    /**
     * Some source files (compilation units) can be loaded asynchronously (e.g. when using
     * RequireJS). If this case happens, this method tries it again after a short timeout.
     *
     * @param {Object} sourceLink  Link to the script and line to be displayed.
     * @param {Boolean} noHighlight Do not highlight the line
     * @param {Number} counter  Number of async attempts.
     */
    showSourceLinkAsync: function(sourceLink, noHighlight, counter)
    {
        var compilationUnit = this.context.getCompilationUnit(sourceLink.href);
        if (compilationUnit)
        {
            this.showSourceLink(sourceLink, noHighlight);
        }
        else
        {
            if (typeof(counter) == "undefined")
                counter = 15;

            // Stop trying. The target script is probably not going to appear.
            if (counter < 0)
                return;

            var self = this;
            this.context.setTimeout(function()
            {
                // If JS execution is stopped at a breakpoint, do not restore the previous
                // location. The user wants to see the breakpoint now.
                if (!self.context.stopped)
                    self.showSourceLinkAsync(sourceLink, noHighlight, --counter);
            }, 50);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    highlightingAttribute: "exe_line",

    removeExeLineHighlight: function(sourceBox)
    {
        if (sourceBox.selectedLine)
        {
            sourceBox.selectedLine.removeAttribute(this.highlightingAttribute);

            // Make sure the highlighter for the selected line is removed, too (issue 4359).
            sourceBox.highlighter = null;
        }
    },

    highlightLine: function(lineNumber, context)
    {
        var panel = this;
        return function exeHighlightFactory(sourceBox)
        {
            panel.removeExeLineHighlight(sourceBox);

            // We close over lineNumber
            var lineNode = sourceBox.getLineNode(lineNumber);
            // If null, clears
            sourceBox.selectedLine = lineNode;

            if (sourceBox.selectedLine)
            {
                lineNode.setAttribute(panel.highlightingAttribute, "true");
                if (context.breakingCause && !context.breakingCause.shown)
                {
                    context.breakingCause.shown = true;
                    var cause = context.breakingCause;
                    if (cause && Firebug.showBreakNotification)
                    {
                        var box = new Firebug.Breakpoint.BreakNotification(panel.document, cause);
                        box.show(panel.panelNode);
                        sourceBox.breakCauseBox = box;
                    }
                }
            }

            if (FBTrace.DBG_BP || FBTrace.DBG_STACK || FBTrace.DBG_COMPILATION_UNITS)
            {
                FBTrace.sysout("sourceBox.highlightLine lineNo: "+lineNumber+
                    " sourceBox.selectedLine="+sourceBox.selectedLine+" in "+
                    sourceBox.repObject.getURL());
            }

            // Sticky, if we have a valid line
            return sourceBox.selectedLine;
        };
    },

    showStackFrameXB: function(frameXB)
    {
        if (this.context.stopped)
            this.showStackFrameTrue(frameXB);
        else
            this.showNoStackFrame();
    },

    showStackFrameTrue: function(frame)
    {
        // Make sure the current frame seen by the user is set (issue 4818)
        // xxxHonza: Better solution (important for remoting)
        // Set this.context.currentFrame = frame (meaning frameXB) and pass the value of
        // frameXB during evaluation calls, causing the backend to select the appropriate
        // frame for frame.eval().
        this.context.currentFrame = frame.nativeFrame;

        var url = frame.getURL();
        var lineNo = frame.getLineNumber();

        if (FBTrace.DBG_STACK)
            FBTrace.sysout("showStackFrame: "+url+"@"+lineNo+"\n");

        if (this.context.breakingCause)
            this.context.breakingCause.lineNo = lineNo;

        this.scrollToLine(url, lineNo, this.highlightLine(lineNo, this.context));
        this.context.throttle(this.updateInfoTip, this);
    },

    showNoStackFrame: function()
    {
        if (this.selectedSourceBox)
        {
            this.removeExeLineHighlight(this.selectedSourceBox);

            if (FBTrace.DBG_STACK)
                FBTrace.sysout("showNoStackFrame clear "+this.selectedSourceBox.repObject.url);
        }

        var panelStatus = Firebug.chrome.getPanelStatusElements();
        // Clear the stack on the panel toolbar
        panelStatus.clear();
        this.updateInfoTip();

        var watchPanel = this.context.getPanel("watches", true);
        if (watchPanel)
            watchPanel.showEmptyMembers();
    },

    toggleBreakpoint: function(lineNo)
    {
        var href = this.getSourceBoxURL(this.selectedSourceBox);
        var lineNode = this.selectedSourceBox.getLineNode(lineNo);

        if (!lineNode)
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("script.toggleBreakpoint no lineNode at " + lineNo +
                    " in selectedSourceBox with URL " + href, this.selectedSourceBox);
            }

            return;
        }

        if (FBTrace.DBG_BP)
        {
            FBTrace.sysout("script.toggleBreakpoint lineNo=" + lineNo + " lineNode.breakpoint:" +
                (lineNode ? lineNode.getAttribute("breakpoint") : "(no lineNode)"),
                this.selectedSourceBox);
        }

        if (lineNode.getAttribute("breakpoint") == "true")
            JavaScriptTool.clearBreakpoint(this.context, href, lineNo);
        else
            JavaScriptTool.setBreakpoint(this.context, href, lineNo);
    },

    toggleDisableBreakpoint: function(lineNo)
    {
        var href = this.getSourceBoxURL(this.selectedSourceBox);

        var lineNode = this.selectedSourceBox.getLineNode(lineNo);
        if (lineNode.getAttribute("disabledBreakpoint") == "true")
        {
            JavaScriptTool.enableBreakpoint(this.context, href, lineNo);
        }
        else
        {
            if (lineNode.getAttribute("breakpoint") != "true")
                JavaScriptTool.setBreakpoint(this.context, href, lineNo);

            JavaScriptTool.disableBreakpoint(this.context, href, lineNo);
        }
    },

    editBreakpointCondition: function(lineNo)
    {
        var sourceRow = this.selectedSourceBox.getLineNode(lineNo);
        var sourceLine = Dom.getChildByClass(sourceRow, "sourceLine");
        var condition = JavaScriptTool.getBreakpointCondition(this.context,
            this.location.getURL(), lineNo);

        if (condition)
        {
            var watchPanel = this.context.getPanel("watches", true);
            watchPanel.removeWatch(condition);
            watchPanel.rebuild();
        }

        Firebug.Editor.startEditing(sourceLine, condition);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    addSelectionWatch: function()
    {
        var watchPanel = this.context.getPanel("watches", true);
        if (watchPanel)
        {
            var selection = this.document.defaultView.getSelection();
            var source = this.getSourceLinesFrom(selection);
            watchPanel.addWatch(source);
        }
    },

    copySource: function()
    {
        var selection = this.document.defaultView.getSelection();
        var source = this.getSourceLinesFrom(selection);
        System.copyToClipboard(source);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Info Tips

    updateInfoTip: function()
    {
        var infoTip = this.panelBrowser.infoTip;
        if (infoTip && this.infoTipExpr)
            this.populateInfoTip(infoTip, this.infoTipExpr);
    },

    showInfoTip: function(infoTip, target, x, y, rangeParent, rangeOffset)
    {
        var sourceLine = Dom.getAncestorByClass(target, "sourceLine");
        if (sourceLine)
            return this.populateBreakpointInfoTip(infoTip, sourceLine);

        var frame = this.context.currentFrame;
        if (!frame)
            return;

        var sourceRowText = Dom.getAncestorByClass(target, "sourceRowText");
        if (!sourceRowText)
            return;

        // See http://code.google.com/p/fbug/issues/detail?id=889
        // Idea from: Jonathan Zarate's rikaichan extension (http://www.polarcloud.com/rikaichan/)
        if (!rangeParent)
            return;

        rangeOffset = rangeOffset || 0;
        var expr = getExpressionAt(rangeParent.data, rangeOffset);
        if (!expr || !expr.expr)
            return;

        if (expr.expr == this.infoTipExpr)
            return true;
        else
            return this.populateInfoTip(infoTip, expr.expr);
    },

    populateInfoTip: function(infoTip, expr)
    {
        if (!expr || Keywords.isJavaScriptKeyword(expr))
            return false;

        var self = this;

        // If the evaluate fails, then we report an error and don't show the infotip
        Firebug.CommandLine.evaluate(expr, this.context, null, this.context.getCurrentGlobal(),
            function success(result, context)
            {
                var rep = Firebug.getRep(result, context);
                var tag = rep.shortTag ? rep.shortTag : rep.tag;

                if (FBTrace.DBG_STACK)
                    FBTrace.sysout("populateInfoTip result is "+result, result);

                tag.replace({object: result}, infoTip);

                // If the menu is never displayed, the contextMenuObject is not reset
                // (back to null) and is reused at the next time the user opens the
                // context menu, which is wrong.
                // This line was appended when fixing:
                // http://code.google.com/p/fbug/issues/detail?id=1700
                // The object should be returned by getPopupObject(),
                // that is called when the context menu is showing.
                // The problem is, that the "onContextShowing" event doesn't have the
                // rangeParent field set and so it isn't possible to get the
                // expression under the cursor (see getExpressionAt).
                //Firebug.chrome.contextMenuObject = result;

                self.infoTipExpr = expr;
            },
            function failed(result, context)
            {
                self.infoTipExpr = "";
            }
        );
        return (self.infoTipExpr == expr);
    },

    populateBreakpointInfoTip: function(infoTip, sourceLine)
    {
        var sourceRow = Dom.getAncestorByClass(sourceLine, "sourceRow");
        var condition = sourceRow.getAttribute("condition");
        if (!condition)
            return false;

        var expr = sourceRow.breakpointCondition;
        if (!expr)
            return false;

        if (expr == this.infoTipExpr)
            return true;

        Firebug.ScriptPanel.BreakpointInfoTip.render(infoTip, expr);

        this.infoTipExpr = expr;

        return true;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // UI event listeners

    onMouseDown: function(event)
    {
        // Don't interfere with clicks made into a notification editor.
        if (Dom.getAncestorByClass(event.target, "breakNotification"))
            return;

        var sourceLine = Dom.getAncestorByClass(event.target, "sourceLine");
        if (!sourceLine)
            return;

        var compilationUnit = Dom.getAncestorByClass(sourceLine, "sourceBox").repObject;
        var lineNo = parseInt(sourceLine.textContent);

        if (Events.isLeftClick(event))
        {
            this.toggleBreakpoint(lineNo);
        }
        else if (Events.isShiftClick(event))
        {
            this.toggleDisableBreakpoint(lineNo);
        }
        else if (Events.isControlClick(event) || Events.isMiddleClick(event))
        {
            JavaScriptTool.runUntil(compilationUnit, lineNo);
            Events.cancelEvent(event);
        }
    },

    onContextMenu: function(event)
    {
        var sourceLine = Dom.getAncestorByClass(event.target, "sourceLine");
        if (!sourceLine)
            return;

        var lineNo = parseInt(sourceLine.textContent);
        this.editBreakpointCondition(lineNo);
        Events.cancelEvent(event);
    },

    onMouseOver: function(event)
    {
        var sourceLine = Dom.getAncestorByClass(event.target, "sourceLine");
        if (sourceLine)
        {
            if (this.hoveredLine)
                Css.removeClass(this.hoveredLine.parentNode, "hovered");

            this.hoveredLine = sourceLine;

            if (Dom.getAncestorByClass(sourceLine, "sourceViewport"))
                Css.setClass(sourceLine.parentNode, "hovered");
        }
    },

    onMouseOut: function(event)
    {
        var sourceLine = Dom.getAncestorByClass(event.relatedTarget, "sourceLine");
        if (!sourceLine)
        {
            if (this.hoveredLine)
                Css.removeClass(this.hoveredLine.parentNode, "hovered");

            delete this.hoveredLine;
        }
    },

    onScroll: function(event)
    {
        var scrollingElement = event.target;
        this.reView(scrollingElement);
    },

    onKeyPress: function(event)
    {
        var ch = String.fromCharCode(event.charCode);

        if (ch == "l" && Events.isControl(event))
        {
            var searchBox = Firebug.chrome.$("fbSearchBox");
            searchBox.value = "#";
            searchBox.focus();

            Events.cancelEvent(event);
        }

        if (ch == "w" && Events.isAlt(event))
        {
            this.addSelectionWatch();
            Events.cancelEvent(event);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    name: "script",
    searchable: true,
    searchPlaceholder: "Use_hash_plus_number_to_go_to_line",
    breakable: true,
    enableA11y: true,
    order: 40,

    initialize: function(context, doc)
    {
        this.location = null;

        this.onMouseDown = Obj.bind(this.onMouseDown, this);
        this.onContextMenu = Obj.bind(this.onContextMenu, this);
        this.onMouseOver = Obj.bind(this.onMouseOver, this);
        this.onMouseOut = Obj.bind(this.onMouseOut, this);
        this.onScroll = Obj.bind(this.onScroll, this);
        this.onKeyPress = Obj.bind(this.onKeyPress, this);

        this.panelSplitter = Firebug.chrome.$("fbPanelSplitter");
        this.sidePanelDeck = Firebug.chrome.$("fbSidePanelDeck");

        Firebug.SourceBoxPanel.initialize.apply(this, arguments);
    },

    destroy: function(state)
    {
        // We want the location (compilationUnit) to persist, not the selection (eg stackFrame).
        this.selection = null;

        var sourceBox = this.selectedSourceBox;
        if (sourceBox)
        {
            if (sourceBox.centralLine)
                state.previousCentralLine = sourceBox.centralLine;
            else
                state.scrollTop = sourceBox.scrollTop ? sourceBox.scrollTop : this.lastScrollTop;

            delete this.selectedSourceBox;
        }

        Persist.persistObjects(this, state);

        if (this.location instanceof CompilationUnit)
        {
             state.location = this.location;
        }
        else
        {
            if (FBTrace.DBG_COMPILATION_UNITS)
            {
                FBTrace.sysout("script.destroy had location not a CompilationUnit ",
                    this.location);
            }
        }

        // xxxHonza: why this is here? I don't see addListener.
        //Firebug.connection.removeListener(this);

        // Make sure listeners are removed.
        this.detachListeners(this.context, Firebug.chrome);

        Firebug.SourceBoxPanel.destroy.apply(this, arguments);
    },

    initializeNode: function(oldPanelNode)
    {
        // xxxHonza: is this tooltip still used?
        this.tooltip = this.document.createElement("div");
        Css.setClass(this.tooltip, "scriptTooltip");
        this.tooltip.setAttribute("aria-live", "polite");
        Css.obscure(this.tooltip, true);
        this.panelNode.appendChild(this.tooltip);

        this.initializeNotificationBox();

        Events.addEventListener(this.panelNode, "mousedown", this.onMouseDown, true);
        Events.addEventListener(this.panelNode, "contextmenu", this.onContextMenu, false);
        Events.addEventListener(this.panelNode, "mouseover", this.onMouseOver, false);
        Events.addEventListener(this.panelNode, "mouseout", this.onMouseOut, false);
        Events.addEventListener(this.panelNode, "scroll", this.onScroll, true);

        Firebug.SourceBoxPanel.initializeNode.apply(this, arguments);
    },

    initializeNotificationBox: function()
    {
        var box = this.panelNode.getElementsByClassName("panelNotificationBox");
        if (box.length > 0)
            return;

        var prefName = Options.prefDomain + ".cache.responseLimit";
        var config = {
            message: Locale.$STR("script.SourceLimited"),
            prefName: prefName,
            buttonTooltip: Locale.$STRF("LimitPrefsTitle", [prefName])
        };

        // Render panel notification box (hidden by default).
        this.notificationBox = PanelNotification.render(this.panelNode, config);
        Css.setClass(this.notificationBox, "panelNotificationBox collapsed");
    },

    destroyNode: function()
    {
        if (this.tooltipTimeout)
            clearTimeout(this.tooltipTimeout);

        Events.removeEventListener(this.panelNode, "mousedown", this.onMouseDown, true);
        Events.removeEventListener(this.panelNode, "contextmenu", this.onContextMenu, false);
        Events.removeEventListener(this.panelNode, "mouseover", this.onMouseOver, false);
        Events.removeEventListener(this.panelNode, "mouseout", this.onMouseOut, false);
        Events.removeEventListener(this.panelNode, "scroll", this.onScroll, true);

        Firebug.SourceBoxPanel.destroyNode.apply(this, arguments);
    },

    clear: function()
    {
        Dom.clearNode(this.panelNode);
    },

    showWarning: function()
    {
        // Fill the panel node with a warning if needed
        var aLocation = this.getDefaultLocation();
        var jsEnabled = Options.getPref("javascript", "enabled");

        if (FBTrace.DBG_PANELS)
        {
            FBTrace.sysout("script.showWarning; " + this.context.getName(), {
                jsDebuggerOn: Firebug.jsDebuggerOn,
                jsDebuggerCalledUs: this.context.jsDebuggerCalledUs,
                jsEnabled: jsEnabled,
                aLocation: aLocation,
                activitySuspended: this.context.activitySuspended,
                stopped: this.context.stopped
            });
        }

        var currentURI = Firefox.getCurrentURI();
        var activitySuspended = this.isActivitySuspended();
        if (activitySuspended && !this.context.stopped)
        {
            // Make sure that the content of the panel is restored as soon as
            // the debugger is resumed.
            this.restored = false;
            this.activeWarningTag = WarningRep.showActivitySuspended(this.panelNode);
        }
        else if (!jsEnabled)
        {
            this.activeWarningTag = WarningRep.showNotEnabled(this.panelNode);
        }
        else if (currentURI && (Url.isSystemURL(currentURI.spec) ||
            currentURI.spec.match(Url.reChrome)))
        {
            this.activeWarningTag = WarningRep.showNoDebuggingForSystemSources(this.panelNode);
        }
        else if (this.context.allScriptsWereFiltered)
        {
            this.activeWarningTag = WarningRep.showFiltered(this.panelNode);
        }
        else if (aLocation && !this.context.jsDebuggerCalledUs)
        {
            this.activeWarningTag = WarningRep.showInactive(this.panelNode);
        }
        else if (!Firebug.jsDebuggerOn)  // set asynchronously by jsd in FF 4.0
        {
            this.activeWarningTag = WarningRep.showDebuggerInactive(this.panelNode);
        }
        else if (!aLocation) // they were not filtered, we just had none
        {
            this.activeWarningTag = WarningRep.showNoScript(this.panelNode);
        }
        else
        {
            return false;
        }

        return true;
    },

    isActivitySuspended: function()
    {
        return Win.iterateBrowserWindows("navigator:browser", function(win)
        {
            // Firebug doesn't have to be loaded in every browser window (see delayed load).
            if (!win.Firebug.TabWatcher)
                return false;

            return win.Firebug.TabWatcher.iterateContexts(function(context)
            {
                if (context.stopped)
                     return true;
            });
        });
    },

    show: function(state)
    {
        var enabled = this.isEnabled();
        if (!enabled)
            return;

        var active = !this.showWarning();
        if (active)
        {
            // The box might have been removed by the warning message.
            this.initializeNotificationBox();

            Events.addEventListener(this.panelNode.ownerDocument, "keypress", this.onKeyPress, true);
            Events.addEventListener(this.resizeEventTarget, "resize", this.onResize, true);

            this.location = this.getDefaultLocation();

            if (this.context.loaded)
            {
                if (!this.restored)
                {
                    // remove the default location, if any
                    delete this.location;
                    Persist.restoreLocation(this, state);
                    this.restored = true;
                }
                else
                {
                    // we already restored
                    if (!this.selectedSourceBox)
                    {
                        // but somehow we did not make a sourcebox?
                        this.navigate(this.location);
                    }
                    else
                    {
                        // then we can sync the location to the sourcebox
                        this.updateSourceBox(this.selectedSourceBox);
                    }
                }

                if (state)
                {
                    if (state.location)
                    {
                        var sourceLink = new SourceLink.SourceLink(state.location.getURL(),
                            state.previousCentralLine, "js");

                        // Causes the Script panel to show the proper location.
                        // Do not highlight the line (second argument true), we just want
                        // to restore the position.
                        // Also do it asynchronously, the script doesn't have to be
                        // available immediately.
                        this.showSourceLinkAsync(sourceLink, true);

                        // Do not restore the location again, it could happen during
                        // the single stepping and overwrite the debugger location.
                        delete state.location;
                    }

                    if (state.scrollTop)
                    {
                        this.selectedSourceBox.scrollTop = state.scrollTop;
                    }
                }
            }
            else // show default
            {
                this.navigate(this.location);
            }

            this.highlight(this.context.stopped);

            var breakpointPanel = this.context.getPanel("breakpoints", true);
            if (breakpointPanel)
                breakpointPanel.refresh();

            this.syncCommands(this.context);
            this.ableWatchSidePanel(this.context);
        }

        Dom.collapse(Firebug.chrome.$("fbToolbar"), !active);

        // These buttons are visible only, if debugger is enabled.
        this.showToolbarButtons("fbLocationSeparator", active);
        this.showToolbarButtons("fbDebuggerButtons", active);
        this.showToolbarButtons("fbLocationButtons", active);
        this.showToolbarButtons("fbScriptButtons", active);
        this.showToolbarButtons("fbStatusButtons", active);
        this.showToolbarButtons("fbLocationList", active);

        Firebug.chrome.$("fbRerunButton").setAttribute("tooltiptext",
            Locale.$STRF("firebug.labelWithShortcut", [Locale.$STR("script.Rerun"),
                Locale.getFormattedKey(window, "shift", null, "VK_F8")]));
        Firebug.chrome.$("fbContinueButton").setAttribute("tooltiptext",
            Locale.$STRF("firebug.labelWithShortcut", [Locale.$STR("script.Continue"),
                Locale.getFormattedKey(window, null, null, "VK_F8")]));
        Firebug.chrome.$("fbStepIntoButton").setAttribute("tooltiptext",
            Locale.$STRF("firebug.labelWithShortcut", [Locale.$STR("script.Step_Into"),
                Locale.getFormattedKey(window, null, null, "VK_F11")]));
        Firebug.chrome.$("fbStepOverButton").setAttribute("tooltiptext",
            Locale.$STRF("firebug.labelWithShortcut", [Locale.$STR("script.Step_Over"),
                Locale.getFormattedKey(window, null, null, "VK_F10")]));
        Firebug.chrome.$("fbStepOutButton").setAttribute("tooltiptext",
            Locale.$STRF("firebug.labelWithShortcut", [Locale.$STR("script.Step_Out"),
                Locale.getFormattedKey(window, "shift", null, "VK_F11")]));

        // Additional debugger panels are visible only, if debugger is active.
        this.panelSplitter.collapsed = !active;
        this.sidePanelDeck.collapsed = !active;
    },

    hide: function(state)
    {
        if (this.selectedSourceBox)
            this.lastScrollTop = this.selectedSourceBox.scrollTop;

        this.highlight(this.context.stopped);

        Events.removeEventListener(this.panelNode.ownerDocument, "keypress", this.onKeyPress,
            true);
        Events.removeEventListener(this.resizeEventTarget, "resize", this.onResize, true);

        if (FBTrace.DBG_PANELS)
            FBTrace.sysout("script panel HIDE removed onResize eventhandler");

        var panelStatus = Firebug.chrome.getPanelStatusElements();
        Dom.hide(panelStatus, false);

        delete this.infoTipExpr;
    },

    onUpdateSourceBox: function(sourceBox)
    {
        var url = sourceBox.repObject.url;
        if (!url)
            return;

        var limited = this.context.sourceCache.isLimited(url);
        if (!limited)
            return;

        // Show the notification box, so the user knows the script content has
        // been limited in the cache.
        Css.removeClass(this.notificationBox, "collapsed");
        var view = this.notificationBox.ownerDocument.defaultView;
        var cs = view.getComputedStyle(this.notificationBox);
        this.selectedSourceBox.style.top = cs.height;
    },

    ableWatchSidePanel: function(context)
    {
        // TODO if (commandline is not active, then we should not show the new watch feature)
        var watchPanel = context.getPanel("watches", true);
        if (watchPanel)
            return watchPanel;
    },

    search: function(text, reverse)
    {
        var sourceBox = this.selectedSourceBox;
        if (!text || !sourceBox)
        {
            delete this.currentSearch;
            return false;
        }

        // Check, if the search is for a line number
        var m = Firebug.ScriptPanel.reLineNumber.exec(text);
        if (m)
        {
            if (!m[1])
                return true; // Don't beep, if only a # has been typed

            var lineNo = parseInt(m[1]);
            if (!isNaN(lineNo) && (lineNo > 0) && (lineNo < sourceBox.lines.length) )
            {
                this.scrollToLine(sourceBox.repObject.getURL(), lineNo,
                    this.jumpHighlightFactory(lineNo, this.context));
                return true;
            }
        }

        var curDoc = this.searchCurrentDoc(!Firebug.searchGlobal, text, reverse);
        if (!curDoc && Firebug.searchGlobal)
        {
            return this.searchOtherDocs(text, reverse) ||
                this.searchCurrentDoc(true, text, reverse);
        }
        return curDoc;
    },

    searchOtherDocs: function(text, reverse)
    {
        var scanRE = Firebug.Search.getTestingRegex(text);

        var self = this;

        function scanDoc(compilationUnit)
        {
            var lines = null;

            // TODO The source lines arrive asynchronous in general
            compilationUnit.getSourceLines(-1, -1, function loadSource(unit, firstLineNumber,
                lastLineNumber, linesRead)
            {
                lines = linesRead;
            });

            if (!lines)
                return;

            // We don't care about reverse here as we are just looking for existence.
            // If we do have a result, we will handle the reverse logic on display.
            for (var i = 0; i < lines.length; i++)
            {
                if (scanRE.test(lines[i]))
                    return true;
            }
        }

        if (this.navigateToNextDocument(scanDoc, reverse))
            return this.searchCurrentDoc(true, text, reverse) && "wraparound";
    },

    searchCurrentDoc: function(wrapSearch, text, reverse)
    {
        var sourceBox = this.selectedSourceBox;

        var lineNo = null;
        if (this.currentSearch && text == this.currentSearch.text)
        {
            lineNo = this.currentSearch.findNext(wrapSearch, reverse,
                Firebug.Search.isCaseSensitive(text));
        }
        else
        {
            if (!this.currentSearch || !this.currentSearch.tryToContinueSearch(sourceBox, text))
                this.currentSearch = new Search.SourceBoxTextSearch(sourceBox);

            lineNo = this.currentSearch.find(text, reverse, Firebug.Search.isCaseSensitive(text));
        }

        if (lineNo || lineNo === 0)
        {
            // This lineNo is an zero-based index into sourceBox.lines.
            // Add one for user line numbers
            this.scrollToLine(sourceBox.repObject.getURL(), lineNo,
                this.jumpHighlightFactory(lineNo+1, this.context));

            Events.dispatch(this.fbListeners, "onScriptSearchMatchFound",
                [this, text, sourceBox.repObject, lineNo]);

            return this.currentSearch.wrapped ? "wraparound" : true;
        }
        else
        {
            Events.dispatch(this.fbListeners, "onScriptSearchMatchFound",
                [this, text, null, null]);

            return false;
        }
    },

    getSearchOptionsMenuItems: function()
    {
        return [
            Firebug.Search.searchOptionMenu("search.Case_Sensitive", "searchCaseSensitive",
                "search.tip.Case_Sensitive"),
            Firebug.Search.searchOptionMenu("search.Multiple_Files", "searchGlobal",
                "search.tip.Multiple_Files"),
            Firebug.Search.searchOptionMenu("search.Use_Regular_Expression",
                "searchUseRegularExpression", "search.tip.Use_Regular_Expression")
        ];
    },

    supportsObject: function(object, type)
    {
        if (object instanceof CompilationUnit
            || (object instanceof SourceLink.SourceLink && object.type == "js")
            || typeof(object) == "function"
            || object instanceof StackFrame.StackFrame)
        {
            return 1;
        }

        return 0;
    },

    // Delete any sourceBoxes that are not in sync with compilationUnits
    refresh: function()
    {
        var previousCentralLine;
        var previousUrl;

        for (var url in this.sourceBoxes)
        {
            if (this.sourceBoxes.hasOwnProperty(url))
            {
                var sourceBox = this.sourceBoxes[url];
                var compilationUnit = this.context.getCompilationUnit(url);

                // then out of sync
                if (!compilationUnit || compilationUnit != sourceBox.repObject)
                {
                    var victim = this.sourceBoxes[url];
                    delete this.sourceBoxes[url];
                    if (this.selectedSourceBox == victim)
                    {
                        previousCentralLine = this.selectedSourceBox.centralLine;
                        previousUrl = this.getSourceBoxURL(this.selectedSourceBox);

                        Dom.collapse(this.selectedSourceBox, true);
                        delete this.selectedSourceBox;
                    }

                    if (FBTrace.DBG_COMPILATION_UNITS)
                        FBTrace.sysout("script.refresh deleted sourceBox for " + url);
                }
            }
        }

        // If selectedSourceBox is undefined, then show() has not run,
        // but we have to refresh, so do the default.
        if (!this.selectedSourceBox)
        {
            // If the current source-box has been deleted because it's out of sync
            // (the victim, see above), we need to navigate again to the same URL.
            // Otherwise the script panel would coincidentally switch to another script.
            // (see issue 5134)
            var object;
            if (previousUrl)
                object = this.context.getCompilationUnit(previousUrl);

            this.navigate(object);

            // Restore the scroll position (issue 5111)
            if (this.selectedSourceBox)
            {
                var url = this.getSourceBoxURL(this.selectedSourceBox);
                if (this.selectedSourceBox && url == previousUrl)
                    this.scrollToLine(null, previousCentralLine);
            }
        }
    },

    updateLocation: function(compilationUnit)
    {
        // XXXjjb do we need to show a blank?
        if (!compilationUnit)
            return;

        if (!(compilationUnit instanceof CompilationUnit))
        {
            FBTrace.sysout("Script panel location not a CompilationUnit: ", compilationUnit);
            throw new Error("Script panel location not a CompilationUnit: " + compilationUnit);
        }

        // Since our last use of the compilationUnit we may have compiled or
        // recompiled the source
        var updatedCompilationUnit = this.context.getCompilationUnit(compilationUnit.getURL());
        if (!updatedCompilationUnit)
            updatedCompilationUnit = this.getDefaultLocation();

        if (!updatedCompilationUnit)
            return;

        if (this.activeWarningTag)
        {
            Dom.clearNode(this.panelNode);
            delete this.activeWarningTag;

            // The user was seeing the warning, but selected a file to show in the Script panel.
            // The removal of the warning leaves the panel without a clientHeight, so
            //  the old sourcebox will be out of sync. Just remove it and start over.
            this.removeAllSourceBoxes();
            // we are not passing state so I guess we could miss a restore
            this.show();

            // If show() reset the flag, obey it
            if (this.activeWarningTag)
                return;
        }

        this.showSource(updatedCompilationUnit.getURL());
        Events.dispatch(this.fbListeners, "onUpdateScriptLocation", [this, updatedCompilationUnit]);
    },

    updateSelection: function(object)
    {
        if (FBTrace.DBG_PANELS)
        {
            FBTrace.sysout("script updateSelection object:" + object + " of type " +
                typeof(object), object);

            if (object instanceof CompilationUnit)
                FBTrace.sysout("script updateSelection this.navigate(object)", object);
            else if (object instanceof SourceLink.SourceLink)
                FBTrace.sysout("script updateSelection this.showSourceLink(object)", object);
            else if (typeof(object) == "function")
                FBTrace.sysout("script updateSelection this.showFunction(object)", object);
            else if (object instanceof StackFrame.StackFrame)
                FBTrace.sysout("script updateSelection this.showStackFrameXB(object)", object);
            else
                FBTrace.sysout("script updateSelection this.showStackFrame(null)", object);
        }

        if (object instanceof CompilationUnit)
            this.navigate(object);
        else if (object instanceof SourceLink.SourceLink)
            this.showSourceLink(object);
        else if (typeof(object) == "function")
            this.showFunction(object);
        else if (object instanceof StackFrame.StackFrame)
            this.showStackFrameXB(object);
    },

    showThisCompilationUnit: function(compilationUnit)
    {
        if (compilationUnit.getURL().lastIndexOf("chrome://", 0) === 0)
            return false;

        if (compilationUnit.getKind() === CompilationUnit.EVAL && !this.showEvals)
            return false;

        if (compilationUnit.getKind() === CompilationUnit.BROWSER_GENERATED && !this.showEvents)
            return false;

        return true;
    },

    getLocationList: function()
    {
        var context = this.context;

        var allSources = context.getAllCompilationUnits();

        if (!allSources.length)
            return [];

        var filter = Options.get("scriptsFilter");
        this.showEvents = (filter == "all" || filter == "events");
        this.showEvals = (filter == "all" || filter == "evals");

        var list = [];
        for (var i = 0; i < allSources.length; i++)
        {
            if (this.showThisCompilationUnit(allSources[i]))
            {
                list.push(allSources[i]);
            }
            else if (FBTrace.DBG_COMPILATION_UNITS)
            {
                FBTrace.sysout("scrpt.getLocationList filtered "+allSources[i].getURL(),
                    allSources[i]);
            }
        }

        if (!list.length && allSources.length)
            this.context.allScriptsWereFiltered = true;
        else
            delete this.context.allScriptsWereFiltered;

        if (FBTrace.DBG_COMPILATION_UNITS)
        {
            FBTrace.sysout("script.getLocationList enabledOnLoad:" + context.onLoadWindowContent +
                " all:" + allSources.length + " filtered:" + list.length + " allFiltered: " +
                this.context.allScriptsWereFiltered, list);
        }

        return list;
    },

    getDefaultLocation: function()
    {
        var compilationUnits = this.getLocationList();
        if (!compilationUnits.length)
            return null;

        if (this.context)
        {
            var url = this.context.getWindowLocation();
            for (var i = 0; i < compilationUnits.length; i++)
            {
                if (url == compilationUnits[i].getURL())
                    return compilationUnits[i];
            }
        }

        return compilationUnits[0];
    },

    getDefaultSelection: function()
    {
        return this.getDefaultLocation();
    },

    getTooltipObject: function(target)
    {
        // Target should be an element with class = sourceLine
        if (Css.hasClass(target, "sourceLine"))
            return null; // TODO

        return null;
    },

    getPopupObject: function(target)
    {
        // Don't show the popup over the line numbers. We show the conditional breakpoint
        // editor there instead
        if (Dom.getAncestorByClass(target, "sourceLine"))
            return;

        var sourceRow = Dom.getAncestorByClass(target, "sourceRow");
        if (!sourceRow)
            return;

        var lineNo = parseInt(sourceRow.firstChild.textContent);
        var scripts = Firebug.SourceFile.findScripts(this.context, this.location.getURL(), lineNo);

        // Gee I wonder what will happen?
        return scripts;
    },

    getObjectPath: function(frame)
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("script.getObjectPath "+frame, frame);

        if (!frame || !frame.getStackNewestFrame) // then its probably not a frame after all
            return;

        var frames = [];
        frame = frame.getStackNewestFrame();
        for (; frame; frame = frame.getCallingFrame())
            frames.push(frame);

        return frames;
    },

    getObjectLocation: function(compilationUnit)
    {
        return compilationUnit.getURL();
    },

    // return.path: group/category label, return.name: item label
    getObjectDescription: function(compilationUnit)
    {
        return Url.splitURLBase(compilationUnit.getURL());
    },

    getSourceLink: function(target, object)
    {
        var sourceRow = Dom.getAncestorByClass(target, "sourceRow");
        if (!sourceRow)
            return;

        var sourceLine = Dom.getChildByClass(sourceRow, "sourceLine");
        var lineNo = parseInt(sourceLine.textContent);
        return new SourceLink.SourceLink(this.location.url, lineNo, "js");
    },

    getOptionsMenuItems: function()
    {
        var context = this.context;

        return [
            // 1.2: always check last line; optionMenu("UseLastLineForEvalName", "useLastLineForEvalName"),
            // 1.2: always use MD5 optionMenu("UseMD5ForEvalName", "useMD5ForEvalName")
            Menu.optionMenu("script.option.Track_Throw_Catch", "trackThrowCatch",
                "script.option.tip.Track_Throw_Catch"),
            //"-",
            //1.2 option on toolbar this.optionMenu("DebuggerEnableAlways", enableAlwaysPref)
            Menu.optionMenu("firebug.breakpoint.showBreakNotifications", "showBreakNotification",
                "firebug.breakpoint.tip.Show_Break_Notifications")
        ];
    },

    optionMenu: function(label, option)
    {
        var checked = Options.get(option);
        return {
            label: label, type: "checkbox", checked: checked,
            command: function()
            {
                var checked = this.hasAttribute("checked");
                Options.set(option, checked);
            }
        };
    },

    getContextMenuItems: function(fn, target)
    {
        if (Dom.getAncestorByClass(target, "sourceLine"))
            return;

        var sourceRow = Dom.getAncestorByClass(target, "sourceRow");
        if (!sourceRow)
            return;

        var sourceLine = Dom.getChildByClass(sourceRow, "sourceLine");
        var lineNo = parseInt(sourceLine.textContent);

        var items = [];

        var selection = this.document.defaultView.getSelection();
        if (selection.toString())
        {
            items.push(
                {
                    label: "CopySourceCode",
                    tooltiptext: "script.tip.Copy_Source_Code",
                    command: Obj.bind(this.copySource, this)
                },
                "-",
                {
                    label: "AddWatch",
                    tooltiptext: "watch.tip.Add_Watch",
                    acceltext: Locale.getFormattedKey(window, "alt", "W"),
                    command: Obj.bind(this.addSelectionWatch, this)
                }
            );
        }

        var hasBreakpoint = sourceRow.getAttribute("breakpoint") == "true";

        items.push(
            "-",
            {
                label: "SetBreakpoint",
                tooltiptext: "script.tip.Set_Breakpoint",
                type: "checkbox",
                checked: hasBreakpoint,
                command: Obj.bindFixed(this.toggleBreakpoint, this, lineNo)
            }
        );

        if (hasBreakpoint)
        {
            var isDisabled = JavaScriptTool.isBreakpointDisabled(this.context, this.location.href,
                lineNo);
            items.push(
                {
                    label: "breakpoints.Disable_Breakpoint",
                    tooltiptext: "breakpoints.tip.Disable_Breakpoint",
                    type: "checkbox",
                    checked: isDisabled,
                    command: Obj.bindFixed(this.toggleDisableBreakpoint, this, lineNo)
                }
            );
        }

        items.push(
            {
                label: "EditBreakpointCondition",
                tooltiptext: "breakpoints.tip.Edit_Breakpoint_Condition",
                command: Obj.bindFixed(this.editBreakpointCondition, this, lineNo)
            }
        );

        if (this.context.stopped)
        {
            var sourceRow = Dom.getAncestorByClass(target, "sourceRow");
            if (sourceRow)
            {
                var compilationUnit = Dom.getAncestorByClass(sourceRow, "sourceBox").repObject;
                var lineNo = parseInt(sourceRow.firstChild.textContent);

                var debuggr = this;
                items.push(
                    "-",
                    {
                        label: "script.Rerun",
                        tooltiptext: "script.tip.Rerun",
                        id: "contextMenuRerun",
                        command: Obj.bindFixed(debuggr.rerun, debuggr, this.context),
                        acceltext: Locale.getFormattedKey(window, "shift", null, "VK_F8")
                    },
                    {
                        label: "script.Continue",
                        tooltiptext: "script.tip.Continue",
                        id: "contextMenuContinue",
                        command: Obj.bindFixed(debuggr.resume, debuggr, this.context),
                        acceltext: Locale.getFormattedKey(window, null, null, "VK_F8")
                    },
                    {
                        label: "script.Step_Over",
                        tooltiptext: "script.tip.Step_Over",
                        id: "contextMenuStepOver",
                        command: Obj.bindFixed(debuggr.stepOver, debuggr, this.context),
                        acceltext: Locale.getFormattedKey(window, null, null, "VK_F10")
                    },
                    {
                        label: "script.Step_Into",
                        tooltiptext: "script.tip.Step_Into",
                        id: "contextMenuStepInto",
                        command: Obj.bindFixed(debuggr.stepInto, debuggr, this.context),
                        acceltext: Locale.getFormattedKey(window, null, null, "VK_F11")
                    },
                    {
                        label: "script.Step_Out",
                        tooltiptext: "script.tip.Step_Out",
                        id: "contextMenuStepOut",
                        command: Obj.bindFixed(debuggr.stepOut, debuggr, this.context),
                        acceltext: Locale.getFormattedKey(window, "shift", null, "VK_F11")
                    },
                    {
                        label: "firebug.RunUntil",
                        tooltiptext: "script.tip.Run_Until",
                        id: "contextMenuRunUntil",
                        command: Obj.bindFixed(debuggr.runUntil, debuggr, this.context,
                            compilationUnit, lineNo)
                    }
                );
            }
        }

        return items;
    },

    getEditor: function(target, value)
    {
        if (!this.conditionEditor)
            this.conditionEditor = new Firebug.Breakpoint.ConditionEditor(this.document);

        return this.conditionEditor;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsBreakOnNext: function()
    {
        return this.breakable && Firebug.jsDebuggerOn;
    },

    breakOnNext: function(enabled)
    {
        if (enabled)
            JavaScriptTool.breakOnNext(this.context, true);
        else
            JavaScriptTool.breakOnNext(this.context, false);
    },

    getBreakOnNextTooltip: function(armed)
    {
        return (armed ?
            Locale.$STR("script.Disable Break On Next") : Locale.$STR("script.Break On Next"));
    },

    shouldBreakOnNext: function()
    {
        return !!this.context.breakOnNextHook;  // TODO BTI
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends ActivablePanel

    /**
     * Support for panel activation.
     */
    onActivationChanged: function(enable)
    {
        JavaScriptTool.setActivation(enable);

        if (enable)
            Firebug.TabCacheModel.addObserver(this);
        else
            Firebug.TabCacheModel.removeObserver(this);

        // If the Script is disabled make sure the BON tab flag (orange background)
        // is properly updated.
        Firebug.Breakpoint.updatePanelTabs(Firebug.currentContext);
    },

    // implements Tool
    onActiveTool: function(isActive)
    {
        this.onJavaScriptDebugging(isActive, "onActiveTool");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Toolbar functions

    attachListeners: function(context, chrome)
    {
        this.keyListeners =
        [
            chrome.keyCodeListen("F8", Events.isShift, Obj.bind(this.rerun, this, context), true),
            chrome.keyCodeListen("F8", null, Obj.bind(this.resume, this, context), true),
            chrome.keyCodeListen("F10", null, Obj.bind(this.stepOver, this, context), true),
            chrome.keyCodeListen("F11", null, Obj.bind(this.stepInto, this, context)),
            chrome.keyCodeListen("F11", Events.isShift, Obj.bind(this.stepOut, this, context))
        ];
    },

    detachListeners: function(context, chrome)
    {
        if (this.keyListeners)
        {
            for (var i = 0; i < this.keyListeners.length; ++i)
                chrome.keyIgnore(this.keyListeners[i]);
            delete this.keyListeners;
        }
    },

    syncListeners: function(context)
    {
        var chrome = Firebug.chrome;

        if (context.stopped)
            this.attachListeners(context, chrome);
        else
            this.detachListeners(context, chrome);
    },

    syncCommands: function(context)
    {
        var chrome = Firebug.chrome;
        if (!chrome)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("debugger.syncCommand, context with no chrome", context);
            return;
        }

        if (context.stopped)
        {
            chrome.setGlobalAttribute("fbDebuggerButtons", "stopped", "true");
            chrome.setGlobalAttribute("cmd_firebug_rerun", "disabled", "false");
            chrome.setGlobalAttribute("cmd_firebug_resumeExecution", "disabled", "false");
            chrome.setGlobalAttribute("cmd_firebug_stepOver", "disabled", "false");
            chrome.setGlobalAttribute("cmd_firebug_stepInto", "disabled", "false");
            chrome.setGlobalAttribute("cmd_firebug_stepOut", "disabled", "false");
        }
        else
        {
            chrome.setGlobalAttribute("fbDebuggerButtons", "stopped", "false");
            chrome.setGlobalAttribute("cmd_firebug_rerun", "disabled", "true");
            chrome.setGlobalAttribute("cmd_firebug_stepOver", "disabled", "true");
            chrome.setGlobalAttribute("cmd_firebug_stepInto", "disabled", "true");
            chrome.setGlobalAttribute("cmd_firebug_stepOut", "disabled", "true");
            chrome.setGlobalAttribute("cmd_firebug_resumeExecution", "disabled", "true");
        }
    },

    rerun: function(context)
    {
        JavaScriptTool.rerun(context);
    },

    resume: function(context)
    {
        JavaScriptTool.resumeJavaScript(context);
    },

    stepOver: function(context)
    {
        JavaScriptTool.stepOver(context);
    },

    stepInto: function(context)
    {
        JavaScriptTool.stepInto(context);
    },

    stepOut: function(context)
    {
        JavaScriptTool.stepOut(context);
    },

    runUntil: function(context, compilationUnit, lineNo)
    {
        JavaScriptTool.runUntil(compilationUnit, lineNo);
    },

    onStartDebugging: function(frame)
    {
        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("script.startDebugging enter context: " + this.context.getName());

        try
        {
            var currentBreakable = Firebug.chrome.getGlobalAttribute("cmd_firebug_toggleBreakOn",
                "breakable");

            if (FBTrace.DBG_BP)
            {
                FBTrace.sysout("debugger.startDebugging; currentBreakable " + currentBreakable +
                    " in " + this.context.getName() + " currentContext " +
                    Firebug.currentContext.getName());
            }

            // If currentBreakable is false, then we are armed, but we broke
            if (currentBreakable == "false")
                Firebug.chrome.setGlobalAttribute("cmd_firebug_toggleBreakOn", "breakable", "true");

            // If Firebug is minimized, open the UI to show we are stopped
            if (Firebug.isMinimized())
                Firebug.unMinimize();

            this.syncCommands(this.context);
            this.syncListeners(this.context);

            // Update Break on Next lightning
            Firebug.Breakpoint.updatePanelTab(this, false);
            Firebug.chrome.select(frame, "script", null, true);
            Firebug.chrome.syncPanel("script");  // issue 3463 and 4213
            Firebug.chrome.focus();
        }
        catch(exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("Resuming debugger: error during debugging loop: " + exc, exc);

            Firebug.Console.log("Resuming debugger: error during debugging loop: " + exc);
            this.resume(this.context);
        }

        if (FBTrace.DBG_UI_LOOP)
        {
            FBTrace.sysout("script.onStartDebugging exit context.stopped:" +
                this.context.stopped + " for context: " + this.context.getName());
        }
    },

    onStopDebugging: function()
    {
        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("script.onStopDebugging enter context: " + this.context.getName());

        try
        {
            var chrome = Firebug.chrome;

            if (this.selectedSourceBox && this.selectedSourceBox.breakCauseBox)
            {
                this.selectedSourceBox.breakCauseBox.hide();
                delete this.selectedSourceBox.breakCauseBox;
            }

            this.syncCommands(this.context);
            this.syncListeners(this.context);
            this.highlight(false);

            // After main panel is completely updated
            chrome.syncSidePanels();
        }
        catch (exc)
        {
            if (FBTrace.DBG_UI_LOOP)
                FBTrace.sysout("debugger.stopDebugging FAILS", exc);

            // If the window is closed while the debugger is stopped,
            // then all hell will break loose here
            Debug.ERROR(exc);
        }
    },

});

// ********************************************************************************************* //

const reWord = /([A-Za-z_$0-9]+)(\.([A-Za-z_$0-9]+)|\[([A-Za-z_$0-9]+|["'].+?["'])\])*/;

function getExpressionAt(text, charOffset)
{
    var offset = 0;
    for (var m = reWord.exec(text); m; m = reWord.exec(text.substr(offset)))
    {
        var word = m[0];
        var wordOffset = offset+m.index;
        if (charOffset >= wordOffset && charOffset <= wordOffset+word.length)
        {
            var innerOffset = charOffset-wordOffset;
            m = word.substr(innerOffset+1).match(/\.|\]|\[|$/);
            var end = m.index + innerOffset + 1, start = 0;

            var openBr = word.lastIndexOf('[', innerOffset);
            var closeBr = word.lastIndexOf(']', innerOffset);

            if (openBr == innerOffset)
                end++;
            else if (closeBr < openBr)
            {
                if (/['"\d]/.test(word[openBr+1]))
                    end++;
                else
                    start = openBr + 1;
            }

            word = word.substring(start, end);

            if (/^\d+$/.test(word) && word[0] != '0')
                word = '';

            return {expr: word, offset: wordOffset-start};
        }
        offset = wordOffset+word.length;
    }

    return {expr: null, offset: -1};
};

// ********************************************************************************************* //
// Domplate Templates

with (Domplate) {

/**
 * @domplate Displays various warning messages within the Script panel.
 */
Firebug.ScriptPanel.WarningRep = domplate(Rep,
{
    tag:
        DIV({"class": "disabledPanelBox"},
            H1({"class": "disabledPanelHead"},
                SPAN("$pageTitle")
            ),
            P({"class": "disabledPanelDescription", style: "margin-top: 15px;"},
                SPAN("$suggestion")
            )
        ),

    enableScriptTag:
        SPAN({"class": "objectLink", onclick: "$onEnableScript", style: "color: blue"},
            Locale.$STR("script.button.enable_javascript")
        ),

    focusDebuggerTag:
        SPAN({"class": "objectLink", onclick: "$onFocusDebugger", style: "color: blue"},
            Locale.$STR("script.button.Go to that page")
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onEnableScript: function(event)
    {
        Options.setPref("javascript", "enabled", true);

        Firebug.TabWatcher.reloadPageFromMemory(Firebug.currentContext);
    },

    onFocusDebugger: function(event)
    {
        Win.iterateBrowserWindows("navigator:browser", function(win)
        {
            return win.Firebug.TabWatcher.iterateContexts(function(context)
            {
                if (context.stopped)
                {
                    // Focus browser window with active debugger and select the Script panel
                    win.Firebug.focusBrowserTab(context.window);
                    win.Firebug.chrome.selectPanel("script");
                    return true;
                }
            });
        });

        // No context is stopped
        if (FBTrace.DBG_UI_LOOP)
            FBTrace.sysout("script.onFocusDebugger FAILED");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    showInactive: function(parentNode)
    {
        var args = {
            pageTitle: Locale.$STR("script.warning.inactive_during_page_load"),
            suggestion: Locale.$STR("script.suggestion.inactive_during_page_load2")
        };

        var box = this.tag.replace(args, parentNode, this);
        var description = box.getElementsByClassName("disabledPanelDescription").item(0);
        FirebugReps.Description.render(args.suggestion, description,
            Obj.bindFixed(Firebug.TabWatcher.reloadPageFromMemory,  Firebug.TabWatcher,
            Firebug.currentContext));

        return box;
    },

    showNotEnabled: function(parentNode)
    {
        var args = {
            pageTitle: Locale.$STR("script.warning.javascript_not_enabled"),
            suggestion: Locale.$STR("script.suggestion.javascript_not_enabled")
        };

        var box = this.tag.replace(args, parentNode, this);
        this.enableScriptTag.append({}, box, this);

        return box;
    },

    showDebuggerInactive: function(parentNode)
    {
        var args = {
            pageTitle: Locale.$STR("script.warning.debugger_not_activated"),
            suggestion: Locale.$STR("script.suggestion.debugger_not_activated")
        };

        var box = this.tag.replace(args, parentNode, this);

        return box;
    },

    showFiltered: function(parentNode)
    {
        var args = {
            pageTitle: Locale.$STR("script.warning.all_scripts_filtered"),
            suggestion: Locale.$STR("script.suggestion.all_scripts_filtered")
        };
        return this.tag.replace(args, parentNode, this);
    },

    showNoScript: function(parentNode)
    {
        var args = {
            pageTitle: Locale.$STR("script.warning.no_javascript"),
            suggestion: Locale.$STR("script.suggestion.no_javascript2")
        };
        return this.tag.replace(args, parentNode, this);
    },

    showNoDebuggingForSystemSources: function(parentNode)
    {
        var args = {
            pageTitle: Locale.$STR("script.warning.no_system_source_debugging"),
            suggestion: Locale.$STR("script.suggestion.no_system_source_debugging")
        };

        var box = this.tag.replace(args, parentNode, this);
        var description = box.getElementsByClassName("disabledPanelDescription").item(0);
        FirebugReps.Description.render(args.suggestion, description,
            Obj.bindFixed(Firebug.chrome.visitWebsite, this, "issue5110"));

        return box;
    },

    showActivitySuspended: function(parentNode)
    {
        var args = {
            pageTitle: Locale.$STR("script.warning.debugger_active"),
            suggestion: Locale.$STR("script.suggestion.debugger_active")
        };

        var box = this.tag.replace(args, parentNode, this);
        this.focusDebuggerTag.append({}, box, this);

        return box;
    }
});

var WarningRep = Firebug.ScriptPanel.WarningRep;

// ********************************************************************************************* //

Firebug.ScriptPanel.BreakpointInfoTip = domplate(Rep,
{
    tag:
        DIV("$expr"),

    render: function(parentNode, expr)
    {
        this.tag.replace({expr: expr}, parentNode, this);
    }
});

// ********************************************************************************************* //

}; // END with (Domplate)

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(Firebug.ScriptPanel);

return Firebug.ScriptPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/sourceBox",
[
    "firebug/chrome/activablePanel",
    "firebug/chrome/measureBox",
    "firebug/lib/object",
    "firebug/firebug",
    "arch/compilationunit",
    "firebug/lib/events",
    "firebug/js/sourceLink",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/string",
],
function(ActivablePanel, MeasureBox, Obj, Firebug, CompilationUnit, Events, SourceLink, Css, Dom,
    Str) {

// ********************************************************************************************* //

/**
 * @class Defines the API for SourceBoxDecorator and provides the default implementation.
 * Decorators are passed the source box on construction, called to create the HTML,
 * and called whenever the user scrolls the view.
 */
Firebug.SourceBoxDecorator = function(sourceBox)
{
};

Firebug.SourceBoxDecorator.sourceBoxCounter = 0;

Firebug.SourceBoxDecorator.prototype =
/** @lends Firebug.SourceBoxDecorator */
{
    onSourceBoxCreation: function(sourceBox)
    {
        // allow panel-document unique ids to be generated for lines.
        sourceBox.uniqueId = ++Firebug.SourceBoxDecorator.sourceBoxCounter;
    },

    /**
     * called on a delay after the view port is updated, eg vertical scroll
     * The sourceBox will contain lines from firstRenderedLine to lastRenderedLine
     * The user will be able to see sourceBox.firstViewableLine to sourceBox.lastViewableLine
     */
    decorate: function(sourceBox, compilationUnit)
    {
        return;
    },

    /**
     * called once as each line is being rendered.
     * @param lineNo integer 1-maxLineNumbers
     */
    getUserVisibleLineNumber: function(sourceBox, lineNo)
    {
        return lineNo;
    },

    /**
     *  call once as each line is being rendered.
     * @param lineNo integer 1-maxLineNumbers
     */
    getLineHTML: function(sourceBox, lineNo)
    {
        var line = sourceBox.lines[lineNo-1];

        // Crop huge lines.
        if (Firebug.maxScriptLineLength > 0)
        {
            if (line.length > Firebug.maxScriptLineLength)
                line = Str.cropString(line, Firebug.maxScriptLineLength);
        }

        var html = Str.escapeForSourceLine(line);

        // If the pref says so, replace tabs by corresponding number of spaces.
        if (Firebug.replaceTabs > 0)
        {
            var space = new Array(Firebug.replaceTabs + 1).join(" ");
            html = html.replace(/\t/g, space);
        }

        return html;
    },

    /**
     * @return a string unique to the sourcebox and line number, valid in getElementById()
     */
    getLineId: function(sourceBox, lineNo)
    {
        return 'sb' + sourceBox.uniqueId + '-L' + lineNo;
    }
};

// ********************************************************************************************* //

/**
 * @panel Firebug.SourceBoxPanel: Intermediate level class for showing lines of source, eg Script Panel
 * Implements a 'viewport' to render only the lines the user is viewing or has recently viewed.
 * Scroll events or scrollToLine calls are converted to viewableRange line number range.
 * The range of lines is rendered, skipping any that have already been rendered. Then if the
 * new line range overlaps the old line range, done; else delete the old range.
 * That way the lines kept contiguous.
 * The rendering details are delegated to SourceBoxDecorator; each source line may be expanded into
 * more rendered lines.
 */
Firebug.SourceBoxPanel = function() {};

var SourceBoxPanelBase = Obj.extend(MeasureBox, ActivablePanel);
Firebug.SourceBoxPanel = Obj.extend(SourceBoxPanelBase,
/** @lends Firebug.SourceBoxPanel */
{
    initialize: function(context, doc)
    {
        this.onResize =  Obj.bind(this.resizer, this);
        this.sourceBoxes = {};
        this.decorator = this.getDecorator();

        ActivablePanel.initialize.apply(this, arguments);
    },

    initializeNode: function(panelNode)
    {
        this.resizeEventTarget = Firebug.chrome.$('fbContentBox');
        Events.addEventListener(this.resizeEventTarget, "resize", this.onResize, true);
        this.attachToCache();

        ActivablePanel.initializeNode.apply(this, arguments);
    },

    destroyNode: function()
    {
        if (this.resizeEventTarget)
        {
            Events.removeEventListener(this.resizeEventTarget, "resize", this.onResize, true);
        }
        else
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("sourceBox.destroyNode; ERROR this.resizeEventTarget is NULL " +
                    this, this);
        }

        this.detachFromCache();

        ActivablePanel.destroyNode.apply(this, arguments);
    },

    attachToCache: function()
    {
        this.context.sourceCache.addListener(this);
    },

    detachFromCache: function()
    {
        this.context.sourceCache.removeListener(this);
    },

    onTextSizeChange: function(zoom)
    {
        this.refresh();
    },

    removeAllSourceBoxes: function()
    {
        for (var url in this.sourceBoxes)
        {
            var sourceBox = this.sourceBoxes[url];
            if (sourceBox)
            {
                try
                {
                    this.panelNode.removeChild(sourceBox);
                }
                catch (err)
                {
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("sourceBox.removeAllSourceBoxes; EXCEPTION " + err, err);
                }
            }
            else if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("sourceBoxPanel ERROR no sourceBox at "+url+" in context "+
                    this.context.getName());
            }
        }

        this.sourceBoxes = {};

        delete this.selectedSourceBox;
        delete this.location;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    //  TabCache listener implementation

    onStartRequest: function(context, request)
    {

    },

    onStopRequest: function(context, request, responseText)
    {
        if (context === this.context)
        {
            var url = request.URI.spec;
            var compilationUnit = context.getCompilationUnit(url);

            // The compilation unit is created when JSD is compiling the script
            // (e.g. onTopLevelScriptCreated), but onStopRequest can be triggered
            // before (by a response channel listener) and so, the compilation
            // unit doesn't have to exist at this moment
            // However it should be ok, since the UI shouldn't exist before compilation
            // and so, there shouldn't be what to update.
            if (compilationUnit)
                this.removeSourceBoxByCompilationUnit(compilationUnit);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Panel extension point.
     * Called just before box is shown
     */
    updateSourceBox: function(sourceBox)
    {

    },

    /* Panel extension point. Called on panel initialization
     * @return Must implement SourceBoxDecorator API.
     */
    getDecorator: function()
    {
        return new Firebug.SourceBoxDecorator();
    },

     /* Panel extension point
      * @return string eg "js" or "css"
      */
    getSourceType: function()
    {
        throw "SourceBox.getSourceType: Need to override in extender ";
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    disablePanel: function(module)
    {
        this.sourceBoxes = {};  // clear so we start fresh if enabled
        ActivablePanel.disablePanel.apply(this, arguments);
    },

    getSourceLinesFrom: function(selection)
    {
        // https://developer.mozilla.org/en/DOM/Selection
        if (selection.isCollapsed)
            return "";

        var anchorSourceRow = Dom.getAncestorByClass(selection.anchorNode, "sourceRow");
        var focusSourceRow = Dom.getAncestorByClass(selection.focusNode, "sourceRow");
        if (anchorSourceRow == focusSourceRow)
        {
            return selection.toString();// trivial case
        }

        var buf = this.getSourceLine(anchorSourceRow, selection.anchorOffset);
        var currentSourceRow = anchorSourceRow.nextSibling;

        while(currentSourceRow && (currentSourceRow != focusSourceRow) &&
            Css.hasClass(currentSourceRow, "sourceRow"))
        {
            buf += this.getSourceLine(currentSourceRow);
            currentSourceRow = currentSourceRow.nextSibling;
        }

        buf += this.getSourceLine(focusSourceRow, 0, selection.focusOffset);
        return buf;
    },

    getSourceLine: function(sourceRow, beginOffset, endOffset)
    {
        var source = Dom.getChildByClass(sourceRow, "sourceRowText").textContent;
        if (endOffset)
            source = source.substring(beginOffset, endOffset);
        else if (beginOffset)
            source = source.substring(beginOffset);

        return source;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getSourceBoxByCompilationUnit: function(compilationUnit)
    {
        if (compilationUnit.getURL())
        {
            var sourceBox = this.getSourceBoxByURL(compilationUnit.getURL());
            if (sourceBox && sourceBox.repObject == compilationUnit)
                return sourceBox;
            else
                return null;  // cause a new one to be created
        }
    },

    getCompilationUnit: function()
    {
        if (this.selectedSourceBox)
            return this.seletedSourceBox.repObject;
    },

    getSourceBoxByURL: function(url)
    {
        if (!this.sourceBoxes)
            return null;

        return url ? this.sourceBoxes[url] : null;
    },

    removeSourceBoxByCompilationUnit: function(compilationUnit)
    {
        var sourceBox = this.getSourceBoxByCompilationUnit(compilationUnit);
        if (sourceBox)  // else we did not create one for this compilationUnit
        {
            delete this.sourceBoxes[compilationUnit.getURL()];

            if (sourceBox.parentNode === this.panelNode)
                this.panelNode.removeChild(sourceBox);

            if (this.selectedSourceBox === sourceBox) // need to update the view
            {
                delete this.selectedSourceBox;
                delete this.location;
                this.showSource(compilationUnit.getURL());
            }
        }
    },

    renameSourceBox: function(oldURL, newURL)
    {
        var sourceBox = this.sourceBoxes[oldURL];
        if (sourceBox)
        {
            delete this.sourceBoxes[oldURL];
            this.sourceBoxes[newURL] = sourceBox;
        }
    },

    showSource: function(url)
    {
        var sourceBox = this.getOrCreateSourceBox(url);
        this.showSourceBox(sourceBox);
    },

    getOrCreateSourceBox: function(url)
    {
        var compilationUnit = this.context.getCompilationUnit(url);

        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("firebug.showSource: "+url, compilationUnit);

        if (!compilationUnit)
            return;

        var sourceBox = this.getSourceBoxByCompilationUnit(compilationUnit);
        if (!sourceBox)
            sourceBox = this.createSourceBox(compilationUnit);

        return sourceBox;
    },

    /**
     * Assumes that locations are compilationUnits, TODO lower class
     */
    showSourceLink: function(sourceLink)
    {
        var sourceBox = this.getOrCreateSourceBox(sourceLink.href);

        if (sourceBox)
        {
            if (sourceLink.line)
            {
                this.showSourceBox(sourceBox, sourceLink.line);
                this.scrollToLine(sourceLink.href, sourceLink.line,
                    this.jumpHighlightFactory(sourceLink.line, this.context));
            }
            else
            {
                this.showSourceBox(sourceBox);
            }

            Events.dispatch(this.fbListeners, "onShowSourceLink", [this, sourceLink.line]);
        }

        // then clear it so the next link will scroll and highlight.
        if (sourceLink == this.selection)
            this.selection = null;
    },

    showSourceBox: function(sourceBox, lineNo)
    {
        if (this.selectedSourceBox)
            Dom.collapse(this.selectedSourceBox, true);

        if (this.selectedSourceBox !== sourceBox)
            delete this.currentSearch;

        this.selectedSourceBox = sourceBox;

        if (sourceBox)
        {
            sourceBox.targetedLineNumber = lineNo; // signal reView to put this line in the center
            Dom.collapse(sourceBox, false);
            this.reView(sourceBox);
            this.updateSourceBox(sourceBox);
        }
    },

    /**
     * Private, do not call outside of this object
     * A sourceBox is a div with additional operations and state.
     * @param compilationUnit there is at most one sourceBox for each compilationUnit
     */
    createSourceBox: function(compilationUnit)  // decorator(compilationUnit, sourceBox)
    {
        var sourceBox = this.initializeSourceBox(compilationUnit);

        sourceBox.decorator = this.decorator;

        // Framework connection
        sourceBox.decorator.onSourceBoxCreation(sourceBox);

        this.sourceBoxes[compilationUnit.getURL()] = sourceBox;

        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("firebug.createSourceBox with " + sourceBox.maximumLineNumber +
                " lines for "+compilationUnit+(compilationUnit.getURL()?" sourceBoxes":" anon "),
                sourceBox);

        this.panelNode.appendChild(sourceBox);
        this.setSourceBoxLineSizes(sourceBox);

        return sourceBox;
    },

    getSourceBoxURL: function(sourceBox)
    {
        return sourceBox.repObject.getURL();
    },

    initializeSourceBox: function(compilationUnit)
    {
        var sourceBox = this.document.createElement("div");
        Css.setClass(sourceBox, "sourceBox");
        Dom.collapse(sourceBox, true);
        sourceBox.repObject = compilationUnit;
        compilationUnit.sourceBox = sourceBox;

        sourceBox.getLineNode =  function(lineNo)
        {
            // XXXjjb this method is supposed to return null if the lineNo is not in the viewport
            return this.ownerDocument.getElementById(this.decorator.getLineId(this, lineNo));
        };

        var paddedSource =
            "<div class='topSourcePadding'>" +
                "<div class='sourceRow'><div class='sourceLine'></div><div class='sourceRowText'></div></div>"+
            "</div>"+
            "<div class='sourceViewport'></div>"+
            "<div class='bottomSourcePadding'>"+
                "<div class='sourceRow'><div class='sourceLine'></div><div class='sourceRowText'></div></div>"+
            "</div>";

        Dom.appendInnerHTML(sourceBox, paddedSource);

        sourceBox.viewport = Dom.getChildByClass(sourceBox, 'sourceViewport');
        return sourceBox;
    },

    onSourceLinesAvailable: function(compilationUnit, firstLineAvailable, lastLineAvailable, lines)
    {
        var sourceBox = compilationUnit.sourceBox;
        var requestedLines = compilationUnit.pendingViewRange;
        delete compilationUnit.pendingViewRange;

        if (requestedLines) // then are viewing a range
        {
            if (firstLineAvailable > requestedLines.firstLine)
                requestedLines.firstLine = firstLineAvailable;

            if (lastLineAvailable < requestedLines.lastLine)
                requestedLines.lastLine = lastLineAvailable;
        }
        else // then no range was given, render all.
        {
            requestedLines = {firstLine: firstLineAvailable, lastLine: lastLineAvailable};
        }

        sourceBox.lines = lines;  // an array indexed from firstLineAvailable to lastLineAvailable

        sourceBox.maximumLineNumber = compilationUnit.getNumberOfLines();
        sourceBox.maxLineNoChars = (sourceBox.maximumLineNumber + "").length;

        this.setSourceBoxLineSizes(sourceBox);

        this.reViewOnSourceLinesAvailable(sourceBox, requestedLines);
    },

    setSourceBoxLineSizes: function(sourceBox)
    {
        var view = sourceBox.viewport;

        var lineNoCharsSpacer = "";
        for (var i = 0; i < sourceBox.maxLineNoChars; i++)
              lineNoCharsSpacer += "0";

        this.startMeasuring(view);
        var size = this.measureText(lineNoCharsSpacer);
        this.stopMeasuring();

        sourceBox.lineHeight = size.height + 1;
        sourceBox.lineNoWidth = size.width;

        var view = sourceBox.viewport; // TODO some cleaner way
        view.previousSibling.firstChild.firstChild.style.width = sourceBox.lineNoWidth + "px";
        view.nextSibling.firstChild.firstChild.style.width = sourceBox.lineNoWidth + "px";

        if (FBTrace.DBG_COMPILATION_UNITS)
        {
            FBTrace.sysout("setSourceBoxLineSizes size for lineNoCharsSpacer " +
                lineNoCharsSpacer, size);
            FBTrace.sysout("firebug.setSourceBoxLineSizes, sourceBox.scrollTop " +
                sourceBox.scrollTop+ " sourceBox.lineHeight: "+sourceBox.lineHeight+
                " sourceBox.lineNoWidth:"+sourceBox.lineNoWidth);
        }
    },

    /**
     * @return SourceLink to currently selected source file
     */
    getSourceLink: function(lineNo)
    {
        if (!this.selectedSourceBox)
            return;

        if (!lineNo)
            lineNo = this.getCentralLine(this.selectedSourceBox);

        return new SourceLink.SourceLink(this.selectedSourceBox.repObject.href, lineNo,
            this.getSourceType());
    },

    /**
     * Select sourcebox with href, scroll lineNo into center, highlight lineNo with
     * highlighter given
     * 
     * @param href a Url, null means the selected compilationUnit
     * @param lineNo integer 1 - maximumLineNumber
     * @param highlighter callback, a function(sourceBox). sourceBox.centralLine will be lineNo
     */
    scrollToLine: function(href, lineNo, highlighter)
    {
        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("SourceBoxPanel.scrollToLine: "+lineNo+"@"+href+" with highlighter "+
                highlighter, highlighter);

        if (this.context.scrollTimeout)
        {
            this.context.clearTimeout(this.context.scrollTimeout);
            delete this.context.scrollTimeout;
        }

        if (href)
        {
            var sourceBox = this.getOrCreateSourceBox(href);
            this.showSourceBox(sourceBox, lineNo);
        }

        if (!this.skipScrolling(lineNo))
        {
            var viewRange = this.getViewRangeFromTargetLine(this.selectedSourceBox, lineNo);
            this.selectedSourceBox.newScrollTop = this.getScrollTopFromViewRange(
                this.selectedSourceBox, viewRange);

            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("SourceBoxPanel.scrollTimeout: newScrollTop "+
                    this.selectedSourceBox.newScrollTop+" vs old "+
                    this.selectedSourceBox.scrollTop+" for "+this.selectedSourceBox.repObject.href);

            // *may* cause scrolling
            this.selectedSourceBox.scrollTop = this.selectedSourceBox.newScrollTop;
        }

        this.context.scrollTimeout = this.context.setTimeout(Obj.bindFixed(function()
        {
            if (!this.selectedSourceBox)
            {
                if (FBTrace.DBG_COMPILATION_UNITS)
                    FBTrace.sysout("SourceBoxPanel.scrollTimeout no selectedSourceBox");
                return;
            }

            if (this.selectedSourceBox.highlighter)
                this.applyDecorator(this.selectedSourceBox); // may need to highlight even if we don't scroll

            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("SourceBoxPanel.scrollTimeout: scrollTo "+lineNo+
                        " this.selectedSourceBox.highlighter: "+this.selectedSourceBox.highlighter);
        }, this));

        this.selectedSourceBox.highlighter = highlighter;  // clears if null
    },

    skipScrolling: function(lineNo)
    {
        var skipScrolling = false;
        var firstViewRangeElement = this.selectedSourceBox.getLineNode(
            this.selectedSourceBox.firstViewableLine);
        var scrollTopOffset = this.selectedSourceBox.scrollTop - firstViewRangeElement.offsetTop;

        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("SourceBoxPanel.skipScrolling scrollTopOffset "+
                Math.abs(scrollTopOffset) + " > " + firstViewRangeElement.offsetHeight);

        if (Math.abs(scrollTopOffset) > firstViewRangeElement.offsetHeight)
            return skipScrolling;

        if (this.selectedSourceBox.firstViewableLine && this.selectedSourceBox.lastViewableLine)
        {
            var linesFromTop = lineNo - this.selectedSourceBox.firstViewableLine;
            var linesFromBot = this.selectedSourceBox.lastViewableLine - lineNo;
            skipScrolling = (linesFromTop > 3 && linesFromBot > 3);
            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("SourceBoxPanel.skipScrolling: skipScrolling: "+skipScrolling+
                    " fromTop:"+linesFromTop+" fromBot:"+linesFromBot);
        }
        else  // the selectedSourceBox has not been built
        {
            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("SourceBoxPanel.skipScrolling, no viewable lines",
                    this.selectedSourceBox);
        }

        return skipScrolling;
    },

    /**
     * @return a highlighter function(sourceBox) that puts a class on the line for a time slice
     */
    jumpHighlightFactory: function(lineNo, context)
    {
        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("sourceBox.jumpHighlightFactory; highlighter created for " + lineNo);

        return function jumpHighlightIfInView(sourceBox)
        {
            var  lineNode = sourceBox.getLineNode(lineNo);

            if (context.highlightedRow)
                Css.cancelClassTimed(context.highlightedRow, "jumpHighlight", context);

            if (lineNode)
            {
                Css.setClassTimed(lineNode, "jumpHighlight", context);

                context.highlightedRow = lineNode;

                if (FBTrace.DBG_COMPILATION_UNITS)
                {
                    FBTrace.sysout("jumpHighlightFactory on line "+lineNo+" lineNode:"+
                        lineNode.getElementsByClassName("sourceRowText")[0].textContent);
                }
            }
            else
            {
                if (FBTrace.DBG_COMPILATION_UNITS)
                    FBTrace.sysout("jumpHighlightFactory no node at line "+lineNo, sourceBox);
            }

            return false; // not sticky
        };
    },

    /*
     * resize and scroll event handler
     */
    resizer: function(event)
    {
        // The resize target is Firebug as a whole. But most of the UI needs no special
        // code for resize.
        // But our SourceBoxPanel has viewport that will change size.
        if (this.selectedSourceBox && this.visible)
        {
            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("resizer event: "+event.type+" in panel "+this.name+" for "+
                    this.context.getName(), event);

            this.reView(this.selectedSourceBox);
        }
    },

    // called for all scroll events, including any time sourcebox.scrollTop is set
    reView: function(sourceBox, clearCache)
    {
        var viewRange = null;
        if (sourceBox.targetedLineNumber) // then we requested a certain line
        {
            viewRange = this.getViewRangeFromTargetLine(sourceBox, sourceBox.targetedLineNumber);
            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("reView got viewRange from target line: "+
                    sourceBox.targetedLineNumber, viewRange);

            // We've positioned on the targeted line. Now the user may scroll
            delete sourceBox.targetedLineNumber;

            // our current scrolltop is not useful, so clear the saved value to avoid comparing below.
            delete sourceBox.lastScrollTop;
        }
        else  // no special line, assume scrolling
        {
            viewRange = this.getViewRangeFromScrollTop(sourceBox, sourceBox.scrollTop);
            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("reView got viewRange from scrollTop: "+sourceBox.scrollTop, viewRange);
        }

        if (clearCache)
        {
            this.clearSourceBox(sourceBox);
        }
        else if (sourceBox.scrollTop === sourceBox.lastScrollTop && sourceBox.clientHeight &&
            sourceBox.clientHeight === sourceBox.lastClientHeight)
        {
            if (sourceBox.firstRenderedLine <= viewRange.firstLine &&
                sourceBox.lastRenderedLine >= viewRange.lastLine)
            {
                if (FBTrace.DBG_COMPILATION_UNITS)
                    FBTrace.sysout("reView skipping sourceBox "+sourceBox.scrollTop+
                        "=scrollTop="+sourceBox.lastScrollTop+", "+ sourceBox.clientHeight+
                        "=clientHeight="+sourceBox.lastClientHeight, sourceBox);

                // skip work if nothing changes.
                return;
            }
        }

        var compilationUnit = sourceBox.repObject;
        compilationUnit.pendingViewRange = viewRange;
        compilationUnit.getSourceLines(viewRange.firstLine, viewRange.lastLine,
            Obj.bind(this.onSourceLinesAvailable, this));
    },

    reViewOnSourceLinesAvailable: function(sourceBox, viewRange)
    {
        // XXXjjb TODO where should this be?
        Events.dispatch(this.fbListeners, "onBeforeViewportChange", [this]);

        this.buildViewAround(sourceBox, viewRange);

        if (Firebug.uiListeners.length > 0)
        {
            var link = new SourceLink.SourceLink(sourceBox.repObject.href, sourceBox.centralLine,
                this.getSourceType());

            Events.dispatch(Firebug.uiListeners, "onViewportChange", [link]);
        }

        sourceBox.lastScrollTop = sourceBox.scrollTop;
        sourceBox.lastClientHeight = sourceBox.clientHeight;

        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("sourceBox.reViewOnSourceLinesAvailable sourceBox.lastScrollTop "+
                sourceBox.lastScrollTop+" sourceBox.lastClientHeight "+sourceBox.lastClientHeight);
    },

    buildViewAround: function(sourceBox, viewRange)
    {
        try
        {
            this.updateViewportCache(sourceBox, viewRange);
        }
        catch(exc)
        {
            if(FBTrace.DBG_ERRORS)
                FBTrace.sysout("buildViewAround updateViewportCache FAILS "+exc, exc);
        }

        Dom.collapse(sourceBox, false); // the elements must be visible for the offset values
        this.setViewportPadding(sourceBox, viewRange);

        sourceBox.centralLine = Math.ceil((viewRange.lastLine + viewRange.firstLine)/2);

        this.applyDecorator(sourceBox);

        return;
    },

    updateViewportCache: function(sourceBox, viewRange)
    {
        var cacheHit = this.insertedLinesOverlapCache(sourceBox, viewRange);

        if (!cacheHit)
        {
            this.clearSourceBox(sourceBox);  // no overlap, remove old range
            sourceBox.firstRenderedLine = viewRange.firstLine; // reset cached range
            sourceBox.lastRenderedLine = viewRange.lastLine;
        }
        else  // cache overlap, expand range of cache
        {
            sourceBox.firstRenderedLine = Math.min(viewRange.firstLine, sourceBox.firstRenderedLine);
            sourceBox.lastRenderedLine = Math.max(viewRange.lastLine, sourceBox.lastRenderedLine);
        }

        // todo actually check that these are viewable
        sourceBox.firstViewableLine = viewRange.firstLine;
        sourceBox.lastViewableLine = viewRange.lastLine;
        sourceBox.numberOfRenderedLines = sourceBox.lastRenderedLine - sourceBox.firstRenderedLine + 1;

        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("buildViewAround viewRange: "+viewRange.firstLine+"-"+
                viewRange.lastLine+" rendered: "+sourceBox.firstRenderedLine+"-"+
                sourceBox.lastRenderedLine, sourceBox);
    },

    /*
     * Add lines from viewRange, but do not adjust first/lastRenderedLine.
     * @return true if viewRange overlaps first/lastRenderedLine
     */
    insertedLinesOverlapCache: function(sourceBox, viewRange)
    {
        var topCacheLine = null;
        var cacheHit = false;
        for (var line = viewRange.firstLine; line <= viewRange.lastLine; line++)
        {
            if (line >= sourceBox.firstRenderedLine && line <= sourceBox.lastRenderedLine )
            {
                cacheHit = true;
                continue;
            }

            var lineHTML = this.getSourceLineHTML(sourceBox, line);

            var ref = null;
            if (line < sourceBox.firstRenderedLine)   // prepend if we are above the cache
            {
                if (!topCacheLine)
                    topCacheLine = sourceBox.getLineNode(sourceBox.firstRenderedLine);
                ref = topCacheLine;
            }

            Dom.appendInnerHTML(sourceBox.viewport, lineHTML, ref);
        }
        return cacheHit;
    },

    clearSourceBox: function(sourceBox)
    {
        if (sourceBox.firstRenderedLine)
        {
            var topMostCachedElement = sourceBox.getLineNode(sourceBox.firstRenderedLine);  // eg 1
            var totalCached = sourceBox.lastRenderedLine - sourceBox.firstRenderedLine + 1;   // eg 20 - 1 + 1 = 19
            if (topMostCachedElement && totalCached)
                this.removeLines(sourceBox, topMostCachedElement, totalCached);
        }
        sourceBox.lastRenderedLine = 0;
        sourceBox.firstRenderedLine = 0;
        sourceBox.numberOfRenderedLines = 0;
    },

    getSourceLineHTML: function(sourceBox, i)
    {
        var lineNo = sourceBox.decorator.getUserVisibleLineNumber(sourceBox, i);
        var lineHTML = sourceBox.decorator.getLineHTML(sourceBox, i);

        // decorator lines may not have ids
        var lineId = sourceBox.decorator.getLineId(sourceBox, i);

        var lineNoText = this.getTextForLineNo(lineNo, sourceBox.maxLineNoChars);

        var theHTML =
            '<div '
               + (lineId ? ('id="' + lineId + '"') : "")
               + ' class="sourceRow" role="presentation"><a class="'
               + 'sourceLine' + '" role="presentation">'
               + lineNoText
               + '</a><span class="sourceRowText" role="presentation">'
               + lineHTML
               + '</span></div>';

        return theHTML;
    },

    getTextForLineNo: function(lineNo, maxLineNoChars)
    {
        // Make sure all line numbers are the same width (with a fixed-width font)
        var lineNoText = lineNo + "";
        while (lineNoText.length < maxLineNoChars)
            lineNoText = " " + lineNoText;

        return lineNoText;
    },

    removeLines: function(sourceBox, firstRemoval, totalRemovals)
    {
        for(var i = 1; i <= totalRemovals; i++)
        {
            var nextSourceLine = firstRemoval;
            firstRemoval = firstRemoval.nextSibling;
            sourceBox.viewport.removeChild(nextSourceLine);
        }
    },

    getCentralLine: function(sourceBox)
    {
        return sourceBox.centralLine;
    },

    getViewRangeFromTargetLine: function(sourceBox, targetLineNumber)
    {
        var viewRange = {firstLine: 1, centralLine: targetLineNumber, lastLine: 1};

        var averageLineHeight = this.getAverageLineHeight(sourceBox);
        var panelHeight = this.panelNode.clientHeight;
        // We never want viewableLines * lineHeight > clientHeight
        // So viewableLines <= clientHeight / lineHeight
        //
        // In some cases when Script panel is restored flooring the result can cause
        // loosing one line and so, the Script panel is not properly restored
        // (the top line is less by one)
        // Math.floor changed to Math.round
        // So, 'viewableLines * lineHeight' can be a bit higher than 'clientHeight'.
        var linesPerViewport = Math.round((panelHeight / averageLineHeight));

        viewRange.firstLine = Math.round(targetLineNumber - linesPerViewport / 2);

        if (viewRange.firstLine <= 0)
            viewRange.firstLine = 1;

        viewRange.lastLine = viewRange.firstLine + linesPerViewport;

        if (viewRange.lastLine > sourceBox.maximumLineNumber)
            viewRange.lastLine = sourceBox.maximumLineNumber;

        return viewRange;
    },

    /**
     * Use the average height of source lines in the cache to estimate where the scroll bar
     * points based on scrollTop
     */
    getViewRangeFromScrollTop: function(sourceBox, scrollTop)
    {
        var viewRange = {};
        var averageLineHeight = this.getAverageLineHeight(sourceBox);
        // If the scrollTop comes in zero, then we better pick line 1. (0 / 14) + 1 = 1
        // If the scrollTop is in the middle of line 2, pick line 2. (20 / 14) + 1 = 2.43 ==> 2
        viewRange.firstLine = Math.floor((scrollTop / averageLineHeight) + 1);

        var panelHeight = this.panelNode.clientHeight;

        // then we probably have not inserted the elements yet and the clientHeight is bogus
        if (panelHeight === 0)
            panelHeight = this.panelNode.ownerDocument.documentElement.clientHeight;

        // Set minimum height of the panel (in case Firebug UI is set to minimum using
        // the splitter) such that the source box can be properly created (issue 4417).
        panelHeight = (panelHeight < 100) ? 100 : panelHeight;

        // see getViewRangeFromTargetLine
        var viewableLines = Math.round((panelHeight / averageLineHeight));
        viewRange.lastLine = viewRange.firstLine + viewableLines - 1;  // 15 = 1 + 15 - 1;

        if (viewRange.lastLine > sourceBox.maximumLineNumber)
            viewRange.lastLine = sourceBox.maximumLineNumber;

        viewRange.centralLine = Math.ceil((viewRange.lastLine - viewRange.firstLine)/2);

        if (FBTrace.DBG_COMPILATION_UNITS)
        {
            FBTrace.sysout("getViewRangeFromScrollTop scrollTop:"+scrollTop+" viewRange: "+
                viewRange.firstLine+"-"+viewRange.lastLine+" max: "+sourceBox.maximumLineNumber+
                " panelHeight "+panelHeight);

            if (!this.noRecurse)
            {
                this.noRecurse = true;
                var testScrollTop = this.getScrollTopFromViewRange(sourceBox, viewRange);
                delete this.noRecurse;

                FBTrace.sysout("getViewRangeFromScrollTop "+((scrollTop==testScrollTop)?
                    "checks":(scrollTop+"=!scrollTop!="+testScrollTop)));
            }
        }

        return viewRange;
    },

    /**
     * inverse of the getViewRangeFromScrollTop.
     * If the viewRange was set by targetLineNumber, then this value become the new scroll top
     *    else the value will be the same as the scrollbar's given value of scrollTop.
     */
    getScrollTopFromViewRange: function(sourceBox, viewRange)
    {
        var averageLineHeight = this.getAverageLineHeight(sourceBox);
        // If the fist line is 1, scrollTop should be 0   14 * (1 - 1) = 0
        // If the first line is 2, scrollTop would be lineHeight    14 * (2 - 1) = 14

        var scrollTop = averageLineHeight * (viewRange.firstLine - 1);

        if (FBTrace.DBG_COMPILATION_UNITS)
        {
            FBTrace.sysout("getScrollTopFromViewRange viewRange:"+viewRange.firstLine+"-"+
                viewRange.lastLine+" averageLineHeight: "+averageLineHeight+" scrollTop "+scrollTop);

            if (!this.noRecurse)
            {
                this.noRecurse = true;
                var testViewRange = this.getViewRangeFromScrollTop(sourceBox, scrollTop);
                delete this.noRecurse;
                var vrStr = viewRange.firstLine+"-"+viewRange.lastLine;
                var tvrStr = testViewRange.firstLine+"-"+testViewRange.lastLine;

                FBTrace.sysout("getScrollTopFromViewRange "+
                    ((vrStr==tvrStr)? "checks" : vrStr+"=!viewRange!="+tvrStr));
            }
        }

        return scrollTop;
    },

    /**
     * The virtual sourceBox height is the averageLineHeight * max lines
     * @return float
     */
    getAverageLineHeight: function(sourceBox)
    {
        var averageLineHeight = sourceBox.lineHeight;  // fall back to single line height

        var renderedViewportHeight = sourceBox.viewport.clientHeight;
        var numberOfRenderedLines = sourceBox.numberOfRenderedLines;
        if (renderedViewportHeight && numberOfRenderedLines)
            averageLineHeight = renderedViewportHeight / numberOfRenderedLines;

        return averageLineHeight;
    },

    /**
     * The virtual sourceBox = topPadding + sourceBox.viewport + bottomPadding
     * The viewport grows as more lines are added to the cache
     * The virtual sourceBox height is estimated from the average height lines in the
     * viewport cache
     */
    getTotalPadding: function(sourceBox)
    {
        var numberOfRenderedLines = sourceBox.numberOfRenderedLines;
        if (!numberOfRenderedLines)
            return 0;

        var max = sourceBox.maximumLineNumber;
        var averageLineHeight = this.getAverageLineHeight(sourceBox);
        // total box will be the average line height times total lines
        var virtualSourceBoxHeight = Math.floor(max * averageLineHeight);

        // the total - view-taken-up - scrollbar
        // clientHeight excludes scrollbar
        var totalPadding = virtualSourceBoxHeight < sourceBox.clientHeight ?
            sourceBox.clientHeight - 1 : virtualSourceBoxHeight;
        totalPadding -= sourceBox.viewport.clientHeight;

        if (FBTrace.DBG_COMPILATION_UNITS)
        {
            FBTrace.sysout("getTotalPadding clientHeight:"+sourceBox.viewport.clientHeight+
                "  max: "+max+" gives total padding "+totalPadding);
        }

        return totalPadding;
    },

    setViewportPadding: function(sourceBox, viewRange)
    {
        var firstRenderedLineElement = sourceBox.getLineNode(sourceBox.firstRenderedLine);
        if (!firstRenderedLineElement)
        {
            // It's not an error if the panel is disabled.
            if (FBTrace.DBG_ERRORS && this.isEnabled())
                FBTrace.sysout("setViewportPadding FAILS, no line at "+
                    sourceBox.firstRenderedLine, sourceBox);
            return;
        }

        var averageLineHeight = this.getAverageLineHeight(sourceBox);
        // At this point our rendered range should surround our viewRange
        var linesOfPadding = sourceBox.firstRenderedLine;  // above our viewRange.firstLine might be some rendered lines in the buffer.
        var topPadding = (linesOfPadding - 1) * averageLineHeight;  // pixels
        // Because of rounding when converting from pixels to lines, topPadding can be +/- lineHeight/2, round up
        linesOfPadding = Math.floor( (topPadding + averageLineHeight)/ averageLineHeight);
        var topPadding = (linesOfPadding - 1)* averageLineHeight;

        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("setViewportPadding topPadding = "+topPadding+
                " = (linesOfPadding - 1)* averageLineHeight = ("+linesOfPadding+" - 1)* "+
                averageLineHeight);

        // we want the bottomPadding to take up the rest

        var totalPadding = this.getTotalPadding(sourceBox);
        var bottomPadding = totalPadding < 0 ?
            Math.abs(totalPadding) : Math.floor(totalPadding - topPadding);

        if (bottomPadding < 0)
            bottomPadding = 0;

        var view = sourceBox.viewport;

        // Set the size on the line number field so the padding is filled with
        // same style as source lines.
        view.previousSibling.style.height = topPadding + "px";
        view.nextSibling.style.height = bottomPadding + "px";

        //sourceRow
        view.previousSibling.firstChild.style.height = topPadding + "px";
        view.nextSibling.firstChild.style.height = bottomPadding + "px";

        //sourceLine
        view.previousSibling.firstChild.firstChild.style.height = topPadding + "px";
        view.nextSibling.firstChild.firstChild.style.height = bottomPadding + "px";


        if(FBTrace.DBG_COMPILATION_UNITS)
        {
            var firstViewRangeElement = sourceBox.getLineNode(viewRange.firstLine);
            var scrollTopOffset = sourceBox.scrollTop - firstViewRangeElement.offsetTop;
            FBTrace.sysout("setViewportPadding viewport offsetHeight: "+
                sourceBox.viewport.offsetHeight+", clientHeight "+sourceBox.viewport.clientHeight);
            FBTrace.sysout("setViewportPadding sourceBox, offsetHeight: "+
                sourceBox.offsetHeight+", clientHeight "+sourceBox.clientHeight+
                ", scrollHeight: "+sourceBox.scrollHeight);
            FBTrace.sysout("setViewportPadding scrollTopOffset: "+scrollTopOffset+
                " firstLine "+viewRange.firstLine+" bottom: "+bottomPadding+" top: "+topPadding);
        }

    },

    applyDecorator: function(sourceBox)
    {
        if (this.context.sourceBoxDecoratorTimeout)
        {
            this.context.clearTimeout(this.context.sourceBoxDecoratorTimeout);
            delete this.context.sourceBoxDecoratorTimeout;
        }

        // Run source code decorating on 150ms timeout, which is bigger than
        // the period in which scroll events are fired. So, if the user is moving
        // scroll-bar thumb (or quickly clicking on scroll-arrows), the source code is
        // not decorated (the timeout cleared by the code above) and the scrolling is fast.
        this.context.sourceBoxDecoratorTimeout = this.context.setTimeout(
            Obj.bindFixed(this.asyncDecorating, this, sourceBox), 150);

        if (this.context.sourceBoxHighlighterTimeout)
        {
            this.context.clearTimeout(this.context.sourceBoxHighlighterTimeout);
            delete this.context.sourceBoxHighlighterTimeout;
        }

        // Source code highlighting is using different timeout: 0ms. When searching
        // within the Script panel, the user expects immediate response.
        this.context.sourceBoxHighlighterTimeout = this.context.setTimeout(
            Obj.bindFixed(this.asyncHighlighting, this, sourceBox));

        if (FBTrace.DBG_COMPILATION_UNITS)
            FBTrace.sysout("applyDecorator "+sourceBox.repObject.url+" sourceBox.highlighter "+
                sourceBox.highlighter, sourceBox);
    },

    asyncDecorating: function(sourceBox)
    {
        try
        {
            sourceBox.decorator.decorate(sourceBox, sourceBox.repObject);

            if (Firebug.uiListeners.length > 0)
                Events.dispatch(Firebug.uiListeners, "onApplyDecorator", [sourceBox]);

            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("sourceBoxDecoratorTimeout "+sourceBox.repObject, sourceBox);
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("sourcebox applyDecorator FAILS "+exc, exc);
        }
    },

    asyncHighlighting: function(sourceBox)
    {
        try
        {
            if (FBTrace.DBG_COMPILATION_UNITS)
                FBTrace.sysout("asyncHighlighting "+sourceBox.repObject.url+
                    " sourceBox.highlighter "+sourceBox.highlighter, sourceBox);

            if (sourceBox.highlighter)
            {
                // If the sticky flag is false, the highlight is removed, eg the search
                // and sourcelink highlights.
                // else the highlight must be removed by the caller, eg breakpoint
                // hit executable line.
                var sticky = sourceBox.highlighter(sourceBox);
                if (FBTrace.DBG_COMPILATION_UNITS)
                    FBTrace.sysout("asyncHighlighting highlighter sticky:"+sticky,
                        sourceBox.highlighter);

                if (!sticky)
                    delete sourceBox.highlighter;
                // else we delete these when we get highlighting call with invalid line (eg -1)
            }
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("sourcebox highlighter FAILS "+exc, exc);
        }
    }
});

// ********************************************************************************************* //
// Registration

return Firebug.SourceBoxPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/sourceCache",
[
    "firebug/chrome/eventSource",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/xpcom",
    "firebug/lib/url",
    "firebug/lib/http",
    "firebug/lib/string"
],
function(EventSource, Obj, Firebug, Xpcom, Url, Http, Str) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const nsIIOService = Ci.nsIIOService;
const nsIRequest = Ci.nsIRequest;
const nsICachingChannel = Ci.nsICachingChannel;
const nsIScriptableInputStream = Ci.nsIScriptableInputStream;
const nsIUploadChannel = Ci.nsIUploadChannel;
const nsIHttpChannel = Ci.nsIHttpChannel;

const IOService = Cc["@mozilla.org/network/io-service;1"];
const ioService = IOService.getService(nsIIOService);
const ScriptableInputStream = Cc["@mozilla.org/scriptableinputstream;1"];
const chromeReg = Xpcom.CCSV("@mozilla.org/chrome/chrome-registry;1", "nsIToolkitChromeRegistry");

const LOAD_FROM_CACHE = nsIRequest.LOAD_FROM_CACHE;
const LOAD_BYPASS_LOCAL_CACHE_IF_BUSY = nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;

const NS_BINDING_ABORTED = 0x804b0002;

// ********************************************************************************************* //

Firebug.SourceCache = function(context)
{
    this.context = context;
    this.cache = {};
};

Firebug.SourceCache.prototype = Obj.extend(new EventSource(),
{
    isCached: function(url)
    {
        return (this.cache[url] ? true : false);
    },

    loadText: function(url, method, file)
    {
        var lines = this.load(url, method, file);
        return lines ? lines.join("") : null;
    },

    load: function(url, method, file)
    {
        if (FBTrace.DBG_CACHE)
        {
            FBTrace.sysout("sourceCache.load: " + url);

            if (!this.cache.hasOwnProperty(url) && this.cache[url])
                FBTrace.sysout("sourceCache.load; ERROR - hasOwnProperty returns false, " +
                    "but the URL is cached: " + url, this.cache[url]);
        }

        // xxxHonza: sometimes hasOwnProperty return false even if the URL is obviously there.
        //if (this.cache.hasOwnProperty(url))
        var response = this.cache[this.removeAnchor(url)];
        if (response)
            return response;

        if (FBTrace.DBG_CACHE)
        {
            var urls = [];
            for (var prop in this.cache)
                urls.push(prop);

            FBTrace.sysout("sourceCache.load: Not in the Firebug internal cache", urls);
        }

        var d = Url.splitDataURL(url);  //TODO the RE should not have baseLine
        if (d)
        {
            var src = d.encodedContent;
            var data = decodeURIComponent(src);
            var lines = Str.splitLines(data);
            this.cache[url] = lines;

            return lines;
        }

        var j = Url.reJavascript.exec(url);
        if (j)
        {
            var src = url.substring(Url.reJavascript.lastIndex);
            var lines = Str.splitLines(src);
            this.cache[url] = lines;

            return lines;
        }

        var c = Url.reChrome.test(url);
        if (c)
        {
            if (Firebug.filterSystemURLs)
                return ["Filtered chrome url "+url];  // ignore chrome

            // If the chrome.manifest has  xpcnativewrappers=no, platform munges the url
            var reWrapperMunge = /(\S*)\s*->\s*(\S*)/;
            var m = reWrapperMunge.exec(url);
            if (m)
            {
                url = m[2];

                if (FBTrace.DBG_CACHE)
                {
                    FBTrace.sysout("sourceCache found munged xpcnativewrapper url " +
                        "and set it to " + url + " m " + m + " m[0]:" + m[0] + " [1]" +
                        m[1], m);
                }
            }

            var chromeURI = Url.makeURI(url);
            if (!chromeURI)
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("sourceCache.load failed to convert chrome to local: " + url);

                return ["sourceCache failed to make URI from " + url];
            }

            var localURI = chromeReg.convertChromeURL(chromeURI);
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("sourceCache.load converting chrome to local: " + url,
                    " -> "+localURI.spec);

            return this.loadFromLocal(localURI.spec);
        }

        c = Url.reFile.test(url);
        if (c)
        {
            return this.loadFromLocal(url);
        }

        if (Str.hasPrefix(url, 'resource://'))
        {
            var fileURL = Url.resourceToFile(url);
            return this.loadFromLocal(url);
        }

        // Unfortunately, the URL isn't available, so let's try to use FF cache.
        // Note that an additional network request to the server could be made
        // in this method (a double-load).
        return this.loadFromCache(url, method, file);
    },

    store: function(url, text)
    {
        var tempURL = this.removeAnchor(url);

        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("sourceCache for " + this.context.getName() + " store url=" +
                url + ((tempURL != url) ? " -> " + tempURL : ""), text);

        var lines = Str.splitLines(text);
        return this.storeSplitLines(tempURL, lines);
    },

    removeAnchor: function(url)
    {
        if (FBTrace.DBG_ERRORS && !url)
            FBTrace.sysout("sourceCache.removeAnchor; ERROR url must not be null");

        var index = url ? url.indexOf("#") : -1;
        if (index < 0)
            return url;

        return url.substr(0, index);
    },

    loadFromLocal: function(url)
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.loadFromLocal url: " + url);

        // if we get this far then we have either a file: or chrome: url converted to file:
        var src = Http.getResource(url);
        if (src)
        {
            var lines = Str.splitLines(src);

            // Don't cache locale files to get latest version (issue 1328)
            // Local files can be currently fetched any time.
            //this.cache[url] = lines;

            return lines;
        }
    },

    loadFromCache: function(url, method, file)
    {
        if (FBTrace.DBG_CACHE) FBTrace.sysout("sourceCache.loadFromCache url:"+url);

        var doc = this.context.window.document;
        if (doc)
            var charset = doc.characterSet;
        else
            var charset = "UTF-8";

        var channel;
        try
        {
            channel = ioService.newChannel(url, null, null);
            channel.loadFlags |= LOAD_FROM_CACHE | LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;

            if (method && (channel instanceof nsIHttpChannel))
            {
                var httpChannel = Xpcom.QI(channel, nsIHttpChannel);
                httpChannel.requestMethod = method;
            }
        }
        catch (exc)
        {
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("sourceCache for url:" + url + " window=" +
                    this.context.window.location.href + " FAILS:", exc);
            return;
        }

        if (url == this.context.browser.contentWindow.location.href)
        {
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("sourceCache.load content window href");

            if (channel instanceof nsIUploadChannel)
            {
                var postData = getPostStream(this.context);
                if (postData)
                {
                    var uploadChannel = Xpcom.QI(channel, nsIUploadChannel);
                    uploadChannel.setUploadStream(postData, "", -1);

                    if (FBTrace.DBG_CACHE)
                        FBTrace.sysout("sourceCache.load uploadChannel set");
                }
            }

            if (channel instanceof nsICachingChannel)
            {
                var cacheChannel = Xpcom.QI(channel, nsICachingChannel);
                cacheChannel.cacheKey = getCacheKey(this.context);
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("sourceCache.load cacheChannel key" + cacheChannel.cacheKey);
            }
        }
        else if ((method == "POST" || method == "PUT" || method == "PATCH") && file)
        {
            if (channel instanceof nsIUploadChannel)
            {
                // In case of PUT and POST, don't forget to use the original body.
                var postData = getPostText(file, this.context);
                if (postData)
                {
                    var postDataStream = Http.getInputStreamFromString(postData);
                    var uploadChannel = Xpcom.QI(channel, nsIUploadChannel);
                    uploadChannel.setUploadStream(postDataStream,
                        "application/x-www-form-urlencoded", -1);

                    if (FBTrace.DBG_CACHE)
                        FBTrace.sysout("sourceCache.load uploadChannel set");
                }
            }
        }

        var stream;
        try
        {
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("sourceCache.load url:" + url + " with charset" + charset);

            stream = channel.open();
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
            {
                var isCache = (channel instanceof nsICachingChannel) ?
                    "nsICachingChannel" : "NOT caching channel";
                var isUp = (channel instanceof nsIUploadChannel) ?
                    "nsIUploadChannel" : "NOT nsIUploadChannel";

                FBTrace.sysout(url + " vs " + this.context.browser.contentWindow.location.href +
                    " and " + isCache + " " + isUp);
                FBTrace.sysout("sourceCache.load fails channel.open for url=" + url +
                    " cause:", exc);
                FBTrace.sysout("sourceCache.load fails channel=", channel);
            }

            return ["sourceCache.load FAILS for url=" + url, exc.toString()];
        }

        try
        {
            var data = Http.readFromStream(stream, charset);
            var lines = Str.splitLines(data);
            this.cache[url] = lines;
            return lines;
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("sourceCache.load FAILS, url="+url, exc);
            return ["sourceCache.load FAILS for url="+url, exc.toString()];
        }
        finally
        {
            stream.close();
        }
    },

    storeSplitLines: function(url, lines)
    {
        if (FBTrace.DBG_CACHE)
        {
            FBTrace.sysout("sourceCache for window=" + this.context.getName() +
                " store url=" + url);
        }

        return this.cache[url] = lines;
    },

    invalidate: function(url)
    {
        url = this.removeAnchor(url);

        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("sourceCache.invalidate; " + url);

        delete this.cache[url];
    },

    getLine: function(url, lineNo)
    {
        var lines;

        try
        {
            lines = this.load(url);
        }
        catch (e)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("sourceCache.getLine; EXCEPTION " + e, e);
        }

        if (!lines)
            return "(no source for " + url + ")";

        if (lineNo <= lines.length)
        {
            return lines[lineNo-1];
        }
        else
        {
            return (lines.length == 1) ?
                lines[0] : "(" + lineNo + " out of range " + lines.length + ")";
        }
    }
});

// xxxHonza getPostText and Http.readPostTextFromRequest are copied from
// net.js. These functions should be removed when this cache is
// refactored due to the double-load problem.
function getPostText(file, context)
{
    if (!file.postText)
        file.postText = Http.readPostTextFromPage(file.href, context);

    if (!file.postText)
        file.postText = Http.readPostTextFromRequest(file.request, context);

    return file.postText;
}

// ********************************************************************************************* //

function getPostStream(context)
{
    try
    {
        var webNav = context.browser.webNavigation;
        var descriptor = Xpcom.QI(webNav, Ci.nsIWebPageDescriptor).currentDescriptor;
        var entry = Xpcom.QI(descriptor, Ci.nsISHEntry);

        if (entry.postData)
        {
            // Seek to the beginning, or it will probably start reading at the end
            var postStream = Xpcom.QI(entry.postData, Ci.nsISeekableStream);
            postStream.seek(0, 0);
            return postStream;
        }
     }
     catch (exc)
     {
     }
}

function getCacheKey(context)
{
    try
    {
        var webNav = context.browser.webNavigation;
        var descriptor = Xpcom.QI(webNav, Ci.nsIWebPageDescriptor).currentDescriptor;
        var entry = Xpcom.QI(descriptor, Ci.nsISHEntry);
        return entry.cacheKey;
     }
     catch (exc)
     {
     }
}

// ********************************************************************************************* //
// Registration

return Firebug.SourceCache;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/sourceFile",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/url",
    "firebug/js/sourceLink",
    "firebug/js/stackFrame",
],
function(Obj, Firebug, Url, SourceLink, StackFrame) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const PCMAP_SOURCETEXT = Ci.jsdIScript.PCMAP_SOURCETEXT;
const PCMAP_PRETTYPRINT = Ci.jsdIScript.PCMAP_PRETTYPRINT;

var jsd = Cc["@mozilla.org/js/jsd/debugger-service;1"].getService(Ci.jsdIDebuggerService);

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

/**
 * SourceFile one for every compilation unit.
 * Unique URL for each. (href)
 * Unique outerScript, the statements outside of any function definition
 * sourceCache keyed by href has source for this compilation unit
 * Stored by href in context.
 * Contains array of jsdIScript for functions (scripts) defined in this unit
 * May contain line table (for sources viewed)
 */
Firebug.SourceFile = function (compilation_unit_type)
{
    this.compilation_unit_type = compilation_unit_type;
};

Firebug.SourceFile.prototype =
{
    getBaseLineOffset: function()
    {
        return 0;
    },

    getURL: function()
    {
        return this.href;
    },

    toString: function()
    {
        var str = (this.compilation_unit_type?this.compilation_unit_type + " " : "") +
            this.href + " script.tags( ";

        if (this.outerScript)
            str += (this.outerScript.isValid?this.outerScript.tag:"X") +"| ";

        if (this.innerScripts)
        {
            var numberInvalid = 0;
            for (var p in this.innerScripts)
            {
                var script = this.innerScripts[p];
                if (script.isValid)
                    str += p+" ";
                else
                    numberInvalid++;
            }
        }

        str += ")" + (numberInvalid ? "(" + numberInvalid + " invalid)" : "");
        return str;
    },

    forEachScript: function(callback)
    {
         if (this.outerScript)
             callback(this.outerScript);

         if (this.innerScripts)
         {
             for (var p in this.innerScripts)
             {
                 var script = this.innerScripts[p];
                 var rc = callback(script);
                 if (rc)
                     return rc;
             }
         }
    },

    getLineRanges: function()
    {
        var str = "";
        this.forEachScript(function appendARange(script)
        {
            var endLineNumber = script.baseLineNumber + script.lineExtent;
            str += " "+script.baseLineNumber +"-("+script.tag+")-"+endLineNumber;
        });

        return str;
    },

    getSourceLength: function()
    {
        return this.sourceLength;
    },

    getLine: function(context, lineNo)
    {
        return context.sourceCache.getLine(this.href, lineNo);
    },

    addToLineTable: function(script)
    {
        if (!script || !script.isValid)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("addToLineTable got invalid script " +
                    (script ? script.tag : "null"));
            return;
        }

        // For outer scripts, a better algorithm would loop over PC, use pcToLine to mark the lines.
        // This assumes there are fewer PCs in an outer script than lines, probably true for large
        // systems.
        // And now addToLineTable is only used for outerScripts (eval and top-level).
        // But since we can't know the range of PC values we cannot use that approach.

        if (!this.outerScriptLineMap)
            this.outerScriptLineMap = [];

        var lineCount = script.lineExtent + 1;
        var offset = this.getBaseLineOffset();

        if (FBTrace.DBG_LINETABLE)
        {
            FBTrace.sysout("lib.SourceFile.addToLineTable script.tag:" + script.tag +
                " lineExtent=" + lineCount + " baseLineNumber=" + script.baseLineNumber +
                " offset=" + offset + " for " + this.compilation_unit_type);
            var startTime = new Date().getTime();
        }

        // isLineExecutable requires about 1ms per line, so it can only be called for toy programs
        if (lineCount > 100)
            lineCount = 100;

        for (var i = 0; i <= lineCount; i++)
        {
            // the max is (i + script.baseLineNumber + script.lineExtent)
            var scriptLineNo = i + script.baseLineNumber;
            var mapLineNo = scriptLineNo - offset;
            try
            {
                if (script.isLineExecutable(scriptLineNo, this.pcmap_type))
                    this.outerScriptLineMap.push(mapLineNo);
            }
            catch (e)
            {
                // I guess not...
            }

            if (FBTrace.DBG_LINETABLE)
            {
                var pcFromLine = script.lineToPc(scriptLineNo, this.pcmap_type);
                var lineFromPC = script.pcToLine(pcFromLine, this.pcmap_type);

                if (this.outerScriptLineMap.indexOf(mapLineNo) != -1)
                {
                    FBTrace.sysout("lib.SourceFile.addToLineTable ["+mapLineNo+"]="+script.tag+
                        " for scriptLineNo="+scriptLineNo+" vs "+lineFromPC+
                        "=lineFromPC; lineToPc="+pcFromLine+" with map="+
                        (this.pcmap_type==PCMAP_PRETTYPRINT?"PP":"SOURCE"));
                }
                else
                {
                    FBTrace.sysout("lib.SourceFile.addToLineTable not executable scriptLineNo="+
                        scriptLineNo+" vs "+lineFromPC+"=lineFromPC; lineToPc="+pcFromLine);
                }
            }
        }

        if (FBTrace.DBG_LINETABLE)
        {
            var endTime = new Date().getTime();
            var delta = endTime - startTime;
            if (delta > 0)
            {
                FBTrace.sysout("SourceFile.addToLineTable processed "+lineCount+" lines in "+
                    delta+" millisecs "+Math.round(lineCount/delta)+" lines per millisecond");
            }

            FBTrace.sysout("SourceFile.addToLineTable: "+this.toString());
        }
     },

     addToLineTableByPCLoop: function(script)
     {
        // This code is not called; it crashes FF3pre
        // https://bugzilla.mozilla.org/show_bug.cgi?id=430205
        if (!this.outerScriptLineMap)
            this.outerScriptLineMap = {};

        var lineCount = script.lineExtent;
        var offset = this.getBaseLineOffset();
        if (FBTrace.DBG_LINETABLE)
        {
            FBTrace.sysout("lib.SourceFile.addToLineTableByPCLoop script.tag:"+script.tag+
                " lineCount="+lineCount+" offset="+offset+" for "+this.compilation_unit_type);
            var startTime = new Date().getTime();
        }

        for (var i = 0; i <= 10*lineCount; i++)
        {
            var lineFromPC = script.pcToLine(i, this.pcmap_type);
            //FBTrace.sysout("lib.SourceFile.addToLineTableByPCLoop pc="+i+" line: "+lineFromPC+"\n");
            this.outerScriptLineMap[lineFromPC] = script;
            if (lineFromPC >= lineCount)
                break;
        }

        if (FBTrace.DBG_LINETABLE)
        {
            FBTrace.sysout("SourceFile.addToLineTableByPCLoop: "+this.toString()+"\n");
            var endTime = new Date().getTime();
            var delta = endTime - startTime;

            if (delta > 0)
            {
                FBTrace.sysout("SourceFileaddToLineTableByPCLoop processed "+lineCount+
                    " lines in "+delta+" millisecs "+Math.round(lineCount/delta)+
                    " lines per millisecond\n");
            }
        }
    },

    hasScriptAtLineNumber: function(lineNo, mustBeExecutableLine)
    {
        var offset = this.getBaseLineOffset();

        if (!this.innerScripts)
            return; // eg URLOnly

        // lineNo is user-viewed number, targetLineNo is jsd number
        var targetLineNo = lineNo + offset;

        var scripts = [];
        for (var p in this.innerScripts)
        {
            var script = this.innerScripts[p];
            if (mustBeExecutableLine && !script.isValid)
                continue;

            this.addScriptAtLineNumber(scripts, script, targetLineNo,
                mustBeExecutableLine, offset);

            if (scripts.length)
                return true;
        }

        if (this.outerScript && !(mustBeExecutableLine && !this.outerScript.isValid))
        {
            this.addScriptAtLineNumber(scripts, this.outerScript, targetLineNo,
                mustBeExecutableLine, offset);
        }

        return (scripts.length > 0);
    },

    getScriptsAtLineNumber: function(lineNo, mustBeExecutableLine)
    {
        var offset = this.getBaseLineOffset();

        if (!this.innerScripts)
            return; // eg URLOnly

        // lineNo is user-viewed number, targetLineNo is jsd number
        var targetLineNo = lineNo + offset;

        var scripts = [];
        for (var p in this.innerScripts)
        {
            var script = this.innerScripts[p];
            if (mustBeExecutableLine && !script.isValid)
                continue;

            this.addScriptAtLineNumber(scripts, script, targetLineNo,
                mustBeExecutableLine, offset);
        }

        if (this.outerScript && !(mustBeExecutableLine && !this.outerScript.isValid))
        {
            this.addScriptAtLineNumber(scripts, this.outerScript, targetLineNo,
                mustBeExecutableLine, offset);
        }

        if (FBTrace.DBG_LINETABLE)
        {
            if (scripts.length < 1)
            {
                FBTrace.sysout("lib.getScriptsAtLineNumber no targetScript at "+lineNo,
                    " for sourceFile:"+this.toString());
                return false;
            }
            else
            {
                FBTrace.sysout("getScriptsAtLineNumber offset "+offset+" for sourcefile: "+
                    this.toString());
            }
        }

        return (scripts.length > 0) ? scripts : false;
     },

     addScriptAtLineNumber: function(scripts, script, targetLineNo, mustBeExecutableLine, offset)
     {
        // script.isValid will be true.
        if (FBTrace.DBG_LINETABLE)
            FBTrace.sysout("addScriptAtLineNumber trying "+script.tag+", is "+
                script.baseLineNumber+" <= "+targetLineNo +" <= "+ (script.baseLineNumber +
                script.lineExtent)+"? using offset = "+offset+"\n");

        if (targetLineNo >= script.baseLineNumber)
        {
            if ((script.baseLineNumber + script.lineExtent) >= targetLineNo)
            {
                if (mustBeExecutableLine)
                {
                    try
                    {
                        if (!script.isLineExecutable(targetLineNo, this.pcmap_type) )
                        {
                            if (FBTrace.DBG_LINETABLE)
                                FBTrace.sysout("getScriptsAtLineNumber tried "+script.tag+
                                    ", not executable at targetLineNo:"+targetLineNo+" pcmap:"+
                                    this.pcmap_type);
                            return;
                        }
                    }
                    catch (e)
                    {
                        // Component returned failure code: 0x80040111 (NS_ERROR_NOT_AVAILABLE)
                        // [jsdIScript.isLineExecutable]
                        return;
                    }
                }

                scripts.push(script);

                if (FBTrace.DBG_LINETABLE)
                {
                    var checkExecutable = "";
                    if (mustBeExecutableLine)
                        checkExecutable = " isLineExecutable: "+
                        script.isLineExecutable(targetLineNo, this.pcmap_type)+"@pc:"+
                        script.lineToPc(targetLineNo, this.pcmap_type);

                    FBTrace.sysout("getScriptsAtLineNumber found "+script.tag+", isValid: "+
                        script.isValid+" targetLineNo:"+targetLineNo+checkExecutable);
                }
            }
        }
    },

    scriptsIfLineCouldBeExecutable: function(lineNo)  // script may not be valid
    {
        var scripts = this.getScriptsAtLineNumber(lineNo, true);

        if (FBTrace.DBG_LINETABLE && !scripts)
            FBTrace.sysout("lib.scriptsIfLineCouldBeExecutable this.outerScriptLineMap",
                this.outerScriptLineMap);

        if (!scripts && this.outerScriptLineMap && (this.outerScriptLineMap.indexOf(lineNo) != -1))
            return [this.outerScript];

        return scripts;
    },

    isExecutableLine: function(lineNo)  // script may not be valid
    {
        if (this.hasScriptAtLineNumber(lineNo, true))
           return true;

        if (this.outerScriptLineMap && (this.outerScriptLineMap.indexOf(lineNo) != -1))
            return true;

        return false;
    },

    hasScript: function(script)
    {
        if (this.outerScript && (this.outerScript.tag == script.tag) )
            return true;

        // XXXjjb Don't use indexOf or similar tests that rely on ===, since we are really
        // working with wrappers around jsdIScript, not script themselves.  I guess.

        return (this.innerScripts && this.innerScripts.hasOwnProperty(script.tag));
    },

    // these objects map JSD's values to correct values
    getScriptAnalyzer: function(script)
    {
        if (script && this.outerScript && (script.tag == this.outerScript.tag) )
            return this.getOuterScriptAnalyzer();

        return new Firebug.SourceFile.NestedScriptAnalyzer(this);
    },

    // return.path: group/category label, return.name: item label
    getObjectDescription: function()
    {
        return Url.splitURLBase(this.href);
    },

    isEval: function()
    {
        return (this.compilation_unit_type == "eval-level") ||
            (this.compilation_unit_type == "newFunction");
    },

    isEvent: function()
    {
        return (this.compilation_unit_type == "event");
    },

    loadScriptLines: function(context)  // array of lines
    {
        if (this.source)
            return this.source;
        else if (context.sourceCache)
            return context.sourceCache.load(this.href);
        else if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("sourceFile.loadScriptLines FAILS no sourceCache "+
                context.getName(), context);
    },

    getOuterScriptAnalyzer: function()
    {
        FBTrace.sysout("getOuterScriptAnalyzer not overridden for "+sourceFile, this);
    }
};

Firebug.SourceFile.summarizeSourceLineArray = function(sourceLines, size)
{
    var buf  = "";
    for (var i = 0; i < sourceLines.length; i++)
     {
         var aLine = sourceLines[i].substr(0,240);  // avoid huge lines
         buf += aLine.replace(/\s/, " ", "g");
         if (buf.length > size || aLine.length > 240)
             break;
     }
     return buf.substr(0, size);
};


Firebug.SourceFile.NestedScriptAnalyzer = function(sourceFile)
{
    this.sourceFile = sourceFile;
};

Firebug.SourceFile.NestedScriptAnalyzer.prototype =
{
    // Adjust JSD line numbers based on origin of script
    getSourceLineFromFrame: function(context, frame)
    {
        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("NestedScriptAnalyzer in "+this.sourceFile.compilation_unit_type+
                ": frame.line  - this.sourceFile.getBaseLineOffset() "+
                frame.line +" - "+this.sourceFile.getBaseLineOffset());

        return frame.line - (this.sourceFile.getBaseLineOffset());
    },

    // Interpret frame to give fn(args)
    getFunctionDescription: function(script, context, frame)
    {
        if (frame)
        {
            var name = frame.name;
            var args = StackFrame.getFunctionArgValues(frame);
        }
        else
        {
            var name = script.functionName;
            var args = [];
        }

        if (name == "anonymous")
        {
            var name = StackFrame.guessFunctionName(this.sourceFile.href,
                this.getBaseLineNumberByScript(script), context);
        }

        return {name: name, args: args};
    },

    // link to source for this script.
    getSourceLinkForScript: function (script)
    {
        var line = this.getBaseLineNumberByScript(script);
        return new SourceLink.SourceLink(this.sourceFile.href, line, "js");
    },

    getBaseLineNumberByScript: function(script)
    {
        // Do not subtract 1 (see issue 6566)
        return script.baseLineNumber - (this.sourceFile.getBaseLineOffset()/* - 1*/);
    }
};

Firebug.SourceFile.addScriptsToSourceFile = function(sourceFile, outerScript, innerScripts)
{
    // Attach the innerScripts for use later
    if (!sourceFile.innerScripts)
         sourceFile.innerScripts = {};

    var total = 0;
    while (innerScripts.hasMoreElements())
    {
        var script = innerScripts.getNext();
        if (!script || ((script instanceof Ci.jsdIScript) && !script.tag))
        {
            if (FBTrace.DBG_SOURCEFILES)
                FBTrace.sysout("addScriptsToSourceFile innerScripts.getNext FAILS "+
                    sourceFile, script);
            continue;
        }

        sourceFile.innerScripts[script.tag] = script;

        if (FBTrace.DBG_SOURCEFILES)
            total++;
    }

    if (FBTrace.DBG_SOURCEFILES)
    {
        FBTrace.sysout("addScriptsToSourceFile "+ total +" scripts, sourcefile="+
            sourceFile.toString(), sourceFile);
    }
};

// ********************************************************************************************* //

Firebug.EvalLevelSourceFile = function(url, script, eval_expr, source, mapType,
    innerScriptEnumerator)
{
    this.href = url.href;
    this.hrefKind = url.kind;
    this.outerScript = script;
    this.containingURL = script.fileName;
    this.evalExpression = eval_expr;
    this.sourceLength = source.length;
    this.source = source;
    this.pcmap_type = mapType;
    Firebug.SourceFile.addScriptsToSourceFile(this, script, innerScriptEnumerator);
};

Firebug.EvalLevelSourceFile.prototype =
    Obj.descend(new Firebug.SourceFile("eval-level"), // shared prototype
{
    getLine: function(context, lineNo)
    {
        return this.source[lineNo - 1];
    },

    getBaseLineOffset: function()
    {
        // baseLineNumber always valid even after jsdIscript isValid false
        return this.outerScript.baseLineNumber - 1;
    },

    getObjectDescription: function()
    {
        if (this.hrefKind == "source" || this.hrefKind == "data")
            return Url.splitURLBase(this.href);

        if (!this.summary)
        {
            if (this.evalExpression)
                this.summary = Firebug.SourceFile.summarizeSourceLineArray(
                    this.evalExpression.substr(0, 240), 120);

            if (!this.summary)
                this.summary = "";

            if (this.summary.length < 120)
                this.summary = "eval("+this.summary + "...)=" +
                    Firebug.SourceFile.summarizeSourceLineArray(this.source,
                        120 - this.summary.length);
        }

        var containingFileDescription = Url.splitURLBase(this.containingURL);

        if (FBTrace.DBG_SOURCEFILES)
            FBTrace.sysout("EvalLevelSourceFile this.evalExpression.substr(0, 240):"+
                (this.evalExpression?this.evalExpression.substr(0, 240):"null")+" summary",
                this.summary);

        return {
            path: containingFileDescription.path,
            name: containingFileDescription.name+"/eval: "+this.summary
        };
    },

    getOuterScriptAnalyzer: function()
    {
        return new Firebug.EvalLevelSourceFile.OuterScriptAnalyzer(this);
    },
});

Firebug.EvalLevelSourceFile.OuterScriptAnalyzer = function(sourceFile)
{
    this.sourceFile = sourceFile;
};

Firebug.EvalLevelSourceFile.OuterScriptAnalyzer.prototype =
{
    // Adjust JSD line numbers based on origin of script
    getSourceLineFromFrame: function(context, frame)
    {
        return frame.line - this.sourceFile.getBaseLineOffset();
    },

    // Interpret frame to give fn(args)
    getFunctionDescription: function(script, context, frame)
    {
        return {name: "eval", args: [this.evalExpression] };
    },

    getSourceLinkForScript: function (script)
    {
        return new SourceLink.SourceLink(this.sourceFile.href, 1, "js");
    }
};

// ********************************************************************************************* //

Firebug.EventSourceFile = function(url, script, title, source, innerScriptEnumerator)
{
     this.href = url;
     this.outerScript = script;
     this.containingURL = script.fileName;
     this.title = title;
     this.source = source; // points to the sourceCache lines
     this.sourceLength = source.length;
     this.pcmap_type = PCMAP_PRETTYPRINT;

     Firebug.SourceFile.addScriptsToSourceFile(this, script, innerScriptEnumerator);
};

Firebug.EventSourceFile.prototype = Obj.descend(new Firebug.SourceFile("event"),
{
    getLine: function(context, lineNo)
    {
        return this.source[lineNo - 1];
    },

    getBaseLineOffset: function()
    {
        return 1;
    },

    getObjectDescription: function()
    {
        if (!this.summary)
             this.summary = Firebug.SourceFile.summarizeSourceLineArray(this.source, 120);

        var containingFileDescription = Url.splitURLBase(this.containingURL);

        return {
            path: containingFileDescription.path,
            name: containingFileDescription.name+"/event: "+this.summary
        };
    },

    getOuterScriptAnalyzer: function()
    {
        return new Firebug.EventSourceFile.OuterScriptAnalyzer(this);
    },
});

Firebug.EventSourceFile.OuterScriptAnalyzer = function(sourceFile)
{
    this.sourceFile = sourceFile;
};

Firebug.EventSourceFile.OuterScriptAnalyzer.prototype =
{
    // Adjust JSD line numbers based on origin of script
    getSourceLineFromFrame: function(context, frame)
    {
        var script = frame.script;
        var line = script.pcToLine(frame.pc, PCMAP_PRETTYPRINT);
        return line - 1;
    },

    // Interpret frame to give fn(args)
    getFunctionDescription: function(script, context, frame)
    {
        var name = script.functionName;
        if (!name)
            name = "jsdbug_NoScriptFunctionName";

        if (frame)
        {
            var args = StackFrame.getFunctionArgValues(frame);
        }
        else
        {
            var args = [];
        }
        return {name: name, args: args};
    },

    getSourceLinkForScript: function (script)
    {
        return new SourceLink.SourceLink(this.sourceFile.href, 1, "js");
    }
};

// ********************************************************************************************* //

Firebug.SourceFile.CommonBase =
{
    getSourceLength: function()
    {
        if (!this.sourceLength)
            this.sourceLength = this.context.sourceCache.load(this.href).length;
        return this.sourceLength;
    },

    getOuterScriptAnalyzer: function()
    {
        return Firebug.TopLevelSourceFile.OuterScriptAnalyzer;
    }
};

// ********************************************************************************************* //

Firebug.TopLevelSourceFile = function(url, outerScript, sourceLength, innerScriptEnumerator)
{
    this.href = url;
    this.outerScript = outerScript;  // Beware may not be valid after we return!!
    this.sourceLength = sourceLength;
    this.pcmap_type = PCMAP_SOURCETEXT;

    Firebug.SourceFile.addScriptsToSourceFile(this, outerScript, innerScriptEnumerator);
};

Firebug.TopLevelSourceFile.prototype = Obj.descend(new Firebug.SourceFile("top-level"),
    Firebug.SourceFile.CommonBase);

Firebug.TopLevelSourceFile.OuterScriptAnalyzer =
{
    // Adjust JSD line numbers based on origin of script
    getSourceLineFromFrame: function(context, frame)
    {
        return frame.line;
    },

    // Interpret frame to give fn(args)
    getFunctionDescription: function(script, context, frame)
    {
        // this is more useful that just "top_level"
        var file_name = Url.getFileName(Url.normalizeURL(script.fileName));
        file_name = file_name ? file_name: "__top_level__";
        return {name: file_name, args: []};
    },

    getSourceLinkForScript: function (script)
    {
        return SourceLink.SourceLink(Url.normalizeURL(script.fileName),
            script.baseLineNumber, "js");
    }
};

// ********************************************************************************************* //

// we don't have the outer script and we delay source load.
Firebug.EnumeratedSourceFile = function(url)
{
    // may not be outerScript file name, eg this could be an enumerated eval
    this.href = new String(url);
    this.innerScripts = {};
    this.pcmap_type = PCMAP_SOURCETEXT;
};

Firebug.EnumeratedSourceFile.prototype = Obj.descend(
    new Firebug.SourceFile("enumerated"),
    Firebug.SourceFile.CommonBase);

// ********************************************************************************************* //

Firebug.NoScriptSourceFile = function(context, url) // Somehow we got the Url, but not the script
{
    this.href = url;  // we know this much
    this.innerScripts = {};
};

Firebug.NoScriptSourceFile.prototype = Obj.descend(
    new Firebug.SourceFile("URLOnly"),
    Firebug.SourceFile.CommonBase);

// ********************************************************************************************* //
// javascript in a .xul or .xml file, no outerScript

Firebug.XULSourceFile = function(url, outerScript, innerScriptEnumerator)
{
    this.href = url;
    this.pcmap_type = PCMAP_SOURCETEXT;
    this.outerScript = outerScript;  // Beware may not be valid after we return!!

    Firebug.SourceFile.addScriptsToSourceFile(this, outerScript, innerScriptEnumerator);
};

Firebug.XULSourceFile.prototype = Obj.descend(
    new Firebug.SourceFile("xul"),
    Firebug.SourceFile.CommonBase);

// ********************************************************************************************* //

// element.appendChild(scriptTag)
Firebug.ScriptTagAppendSourceFile = function(url, outerScript, sourceLength, innerScriptEnumerator)
{
    this.href = url;
    this.outerScript = outerScript;  // Beware may not be valid after we return!!
    this.sourceLength = sourceLength;
    this.pcmap_type = PCMAP_SOURCETEXT;

    Firebug.SourceFile.addScriptsToSourceFile(this, outerScript, innerScriptEnumerator);
};

Firebug.ScriptTagAppendSourceFile.prototype = Obj.descend(
    new Firebug.SourceFile("scriptTagAppend"),
    Firebug.SourceFile.CommonBase);

// ********************************************************************************************* //

// we don't have the outer script and we delay source load
Firebug.ScriptTagSourceFile = function(context, url, scriptTagNumber)
{
    this.context = context;
    this.href = url;  // we know this is not an eval
    this.scriptTagNumber = scriptTagNumber;
    this.innerScripts = {};
    this.pcmap_type = PCMAP_SOURCETEXT;
};

Firebug.ScriptTagSourceFile.prototype = Obj.descend(
    new Firebug.SourceFile("scriptTag"),
    Firebug.SourceFile.CommonBase);

// ********************************************************************************************* //

Firebug.SourceFile.getSourceFileByScript = function(context, script)
{
    if (!context.sourceFileMap)
         return null;

    // Other algorithms are possible:
    //   We could store an index, context.sourceFileByTag
    //   Or we could build a tree keyed by url, with SpiderMonkey script.fileNames at the top
    //   and our urls below

    // we won't be lucky for file:/ urls, no normalizeURL applied
    var lucky = context.sourceFileMap[script.fileName];
    if (FBTrace.DBG_SOURCEFILES && lucky)
        FBTrace.sysout("getSourceFileByScript trying to be lucky for "+
            script.tag + " in "+lucky, script);

    if (lucky && lucky.hasScript(script))
        return lucky;

    if (FBTrace.DBG_SOURCEFILES)
        FBTrace.sysout("getSourceFileByScript looking for "+script.tag+"@"+script.fileName+" in "+
            context.getName()+": ", context.sourceFileMap);

    for (var url in context.sourceFileMap)
    {
        var sourceFile = context.sourceFileMap[url];
        if (sourceFile.hasScript(script))
            return sourceFile;
    }
};

Firebug.SourceFile.getScriptAnalyzer = function(context, script)
{
    var sourceFile = Firebug.SourceFile.getSourceFileByScript(context, script);
    if (FBTrace.DBG_STACK)
         FBTrace.sysout("getScriptAnalyzer "+ (sourceFile?"finds sourceFile: ":
            "FAILS to find sourceFile"), sourceFile);

    if (sourceFile)
    {
        var analyzer = sourceFile.getScriptAnalyzer(script);
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("getScriptAnalyzer finds analyzer: ", analyzer);

        return analyzer;
    }

    return undefined;
};

Firebug.SourceFile.getSourceFileAndLineByScript= function(context, script, frame)
{
    var sourceFile = Firebug.SourceFile.getSourceFileByScript(context, script);
    if (sourceFile)
    {
        if (sourceFile.pcmap_type)
            var line = script.pcToLine(1, sourceFile.pcmap_type);
        else
            var line = 1;

        return { sourceFile: sourceFile, lineNo: line };
    }
};

Firebug.SourceFile.guessEnclosingFunctionName = function(url, line, context)
{
    var sourceFile = context.sourceFileMap[url];
    if (sourceFile)
    {
        var scripts = sourceFile.getScriptsAtLineNumber(line);
        if (scripts)
        {
            // TODO try others?
            var script = scripts[0];
            var analyzer = sourceFile.getScriptAnalyzer(script);

            // Some analyzers don't implement this method.
            if (analyzer.getBaseLineNumberByScript)
                line = analyzer.getBaseLineNumberByScript(script);
        }
    }

    // Do not subtract 1 (see issue 6566)
    return StackFrame.guessFunctionName(url, line/*-1*/+1, context);
};

// ********************************************************************************************* //
// Functions

Firebug.SourceFile.findScripts = function(context, url, line)
{
    var sourceFile = context.sourceFileMap[url];
    if (sourceFile)
    {
        var scripts = sourceFile.scriptsIfLineCouldBeExecutable(line);
    }
    else
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("lib.findScript, no sourceFile in context for url=", url);
    }
    return scripts;
};

Firebug.SourceFile.findScriptForFunctionInContext = function(context, fn)
{
    var found = null;

    if (!fn || typeof(fn) !== "function")
        return found;

    try
    {
        var wrapped = jsd.wrapValue(fn);
        found = wrapped.script;
        if (!found)
            found = wrapped.jsParent.script;

        if (!found && FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("findScriptForFunctionInContext ",
                {fn: fn, wrapValue: jsd.wrapValue(fn), found: found});
        }
    }
    catch (err)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("sourceFile.findScriptForFunctionInContext; EXCEPTION " + err, err);
    }

    if (FBTrace.DBG_FUNCTION_NAMES)
        FBTrace.sysout("findScriptForFunctionInContext found " + (found ? found.tag : "none"));

    return found;
};

Firebug.SourceFile.findSourceForFunction = function(fn, context)
{
    var script = Firebug.SourceFile.findScriptForFunctionInContext(context, fn);
    return script ? Firebug.SourceFile.getSourceLinkForScript(script, context) : null;
};

Firebug.SourceFile.getSourceLinkForScript = function(script, context)
{
    var sourceFile = Firebug.SourceFile.getSourceFileByScript(context, script);
    if (sourceFile)
    {
        var scriptAnalyzer = sourceFile.getScriptAnalyzer(script);
        if (scriptAnalyzer)
        {
            return scriptAnalyzer.getSourceLinkForScript(script);
        }
        else
        {
            // no-op for detrace
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("getSourceLineForScript FAILS no scriptAnalyser for sourceFile " +
                    sourceFile);
            }
        }
    }
};

// ********************************************************************************************* //
// Source Files

Firebug.SourceFile.getSourceFileByHref = function(url, context)
{
    return context.sourceFileMap[url];
};

Firebug.SourceFile.sourceURLsAsArray = function(context)
{
    var urls = [];
    var sourceFileMap = context.sourceFileMap;
    for (var url in sourceFileMap)
        urls.push(url);

    if (FBTrace.DBG_SOURCEFILES)
        FBTrace.sysout("sourceURLsAsArray urls="+urls.length+" in context "+context.getName());

    return urls;
};

// deprecated, use mapAsArray
Firebug.SourceFile.sourceFilesAsArray = function(sourceFileMap)
{
    var sourceFiles = [];
    for (var url in sourceFileMap)
        sourceFiles.push(sourceFileMap[url]);

    if (FBTrace.DBG_SOURCEFILES)
        FBTrace.sysout("sourceFilesAsArray sourcefiles="+sourceFiles.length, sourceFiles);

    return sourceFiles;
};

Firebug.SourceFile.mapAsArray = function(map)
{
    var entries = [];
    for (var url in map)
        entries.push(map[url]);

    return entries;
};

// ********************************************************************************************* //

return Firebug.SourceFile;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/sourceLink",
[], function() {

// ********************************************************************************************* //
// Constants

function SourceLink(url, line, type, object, instance, col)
{
    this.href = url;
    this.instance = instance;
    this.line = line;
    this.type = type;
    this.object = object;
    this.col = col;
};

SourceLink.prototype =
{
    toString: function()
    {
        return this.href+"@"+(this.line || '?');
    },

    toJSON: function() // until 3.1...
    {
        return "{\"href\":\""+this.href+"\", "+
            (this.line?("\"line\":"+this.line+","):"")+
            (this.type?(" \"type\":\""+this.type+"\","):"")+
                    "}";
    }
};

// ********************************************************************************************* //
// Registration

return {
    SourceLink: SourceLink
};

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/stackFrame",
[
    "firebug/lib/trace",
    "firebug/lib/url",
    "firebug/lib/locale",
    "firebug/lib/wrapper",
    "firebug/js/sourceLink",
    "firebug/lib/deprecated",
    "firebug/lib/options",
],
function (FBTrace, Url, Locale, Wrapper, SourceLink, Deprecated, Options) {

// ********************************************************************************************* //
// Constants

// ********************************************************************************************* //
// Implementation

var StackFrame = {};

StackFrame.getStackTrace = Deprecated.deprecated("name change for self-documentation",
    StackFrame.getCorrectedStackTrace);

/**
 * Converts a Mozilla stack frame to a frameXB
 */
StackFrame.getCorrectedStackTrace = function(frame, context)
{
    var trace = null;
    try
    {
        trace = new StackFrame.StackTrace();
        var newestFrame = null;
        var nextOlderFrame = null;
        for (; frame && frame.isValid; frame = frame.callingFrame)
        {
            var skip = Options.get("filterSystemURLs") &&
                Url.isSystemURL(Url.normalizeURL(frame.script.fileName));
            if (!skip)
            {
                var stackFrame = StackFrame.getStackFrame(frame, context, newestFrame);
                if (stackFrame)
                {
                    if (!newestFrame)
                        newestFrame = stackFrame;

                    if (context.currentFrame && context.currentFrame === frame)
                        trace.currentFrameIndex = trace.length;

                    stackFrame.setCallingFrame(nextOlderFrame, trace.frames.length);
                    nextOlderFrame = stackFrame;
                    trace.frames.push(stackFrame);
                }
            }
            else
            {
                if (FBTrace.DBG_STACK)
                    FBTrace.sysout("lib.getCorrectedStackTrace isSystemURL frame.script.fileName "+
                        frame.script.fileName+"\n");
            }
        }

        if (trace.frames.length > 100)  // TODO in the loop above
        {
            var originalLength = trace.frames.length;
            trace.frames.splice(50, originalLength - 100, null);
            var excuse = "(eliding "+(originalLength - 100)+" frames)";

            trace.frames[50] = new StackFrame.StackFrame({href: excuse}, 0, excuse,
                [], null, null, context, newestFrame);
        }

    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("getCorrectedStackTrace FAILS "+exc, exc);
    }
    return trace;
};

/*
 * Converts from Mozilla stack frame to frameXB
 */
StackFrame.getStackFrame = function(frame, context, newestFrameXB)
{
    if (frame.isNative || frame.isDebugger)
    {
        var excuse = (frame.isNative) ?  "(native)" : "(debugger)";
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("lib.getStackFrame "+excuse+" frame\n");

        return new StackFrame.StackFrame({href: excuse}, 0, excuse, [],
            null, null, context, newestFrameXB);
    }
    try
    {
        var sourceFile = Firebug.SourceFile.getSourceFileByScript(context, frame.script);
        if (sourceFile)
        {
            var url = sourceFile.href;
            var analyzer = sourceFile.getScriptAnalyzer(frame.script);

            var lineNo = analyzer.getSourceLineFromFrame(context, frame);
            var fncSpec = analyzer.getFunctionDescription(frame.script, context, frame);
            if (!fncSpec.name || fncSpec.name === "anonymous")
            {
                fncSpec.name = StackFrame.guessFunctionName(url, frame.script.baseLineNumber, context);
                if (!fncSpec.name)
                    fncSpec.name = "?";
            }

            if (FBTrace.DBG_STACK)
                FBTrace.sysout("lib.getStackFrame "+fncSpec.name, {sourceFile: sourceFile,
                    script: frame.script, fncSpec: fncSpec, analyzer: analyzer});

            return new StackFrame.StackFrame(sourceFile, lineNo, fncSpec.name, fncSpec.args, frame,
                frame.pc, sourceFile.context, newestFrameXB);
        }
        else
        {
            if (FBTrace.DBG_STACK)
                FBTrace.sysout("lib.getStackFrame NO sourceFile tag@file:"+frame.script.tag+
                    "@"+frame.script.fileName, frame.script.functionSource);

            var script = frame.script;
            return new StackFrame.StackFrame({href: Url.normalizeURL(script.fileName)}, frame.line,
                script.functionName, [], frame, frame.pc, context, newestFrameXB);
        }
    }
    catch (exc)
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("getStackFrame fails: "+exc, exc);
        return null;
    }
};

// ********************************************************************************************* //
// frameXB, cross-browser frame

StackFrame.StackFrame = function(sourceFile, lineNo, functionName, args, nativeFrame, pc,
    context, newestFrame)
{
    // Essential fields
    this.sourceFile = sourceFile;
    this.line = lineNo;

    var fn = StackFrame.getDisplayName(nativeFrame ? nativeFrame.scope : null);
    this.fn = fn || functionName;  // cache?

    this.context = context;

    // the newest frame in the stack containing 'this' frame
    this.newestFrame = (newestFrame ? newestFrame : this);

    // optional
    this.args = args;

    // Derived from sourceFile
    this.href = sourceFile.href;

    // Mozilla
    this.nativeFrame = nativeFrame;
    this.pc = pc;
    this.script = nativeFrame ? nativeFrame.script : null;  // TODO-XB
};

StackFrame.StackFrame.prototype =
{
    getURL: function()
    {
        return this.href;
    },

    getCompilationUnit: function()
    {
        return this.context.getCompilationUnit(this.href);
    },

    getStackNewestFrame: function()
    {
        return this.newestFrame;
    },

    getFunctionName: function()
    {
        return this.fn;
    },

    toSourceLink: function()
    {
        return new SourceLink.SourceLink(this.sourceFile.href, this.line, "js");
    },

    toString: function()
    {
        return this.fn+", "+this.sourceFile.href+"@"+this.line;
    },

    setCallingFrame: function(caller, frameIndex)
    {
        this.callingFrame = caller;
        this.frameIndex = frameIndex;
    },

    getCallingFrame: function()
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("getCallingFrame "+this, this);

        if (!this.callingFrame && this.nativeFrame && this.nativeFrame.isValid)
        {
            var nativeCallingFrame = this.nativeFrame.callingFrame;
            if (nativeCallingFrame)
                this.callingFrame = StackFrame.getStackFrame(nativeCallingFrame, this.context,
                    this.newestFrame);
        }
        return this.callingFrame;
    },

    getFrameIndex: function()
    {
        return this.frameIndex;
    },

    getLineNumber: function()
    {
        return this.line;
    },

    destroy: function()
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("StackFrame destroyed:"+this.uid+"\n");

        this.script = null;
        this.nativeFrame = null;
        this.context = null;
    },

    signature: function()
    {
        return this.script.tag + "." + this.pc;
    },

    getThisValue: function()
    {
        if (this.nativeFrame && !this.thisVar)
            this.thisVar = Wrapper.unwrapIValue(this.nativeFrame.thisValue, Firebug.viewChrome);
        return this.thisVar;
    },

    getScopes: function(viewChrome)
    {
        if (this.nativeFrame && !this.scope)
            this.scope = this.generateScopeChain(this.nativeFrame.scope, viewChrome);
        return this.scope;
    },

    clearScopes: function(viewChrome)
    {
        // Clears cached scope chain, so that it regenerates the next time
        // getScopes() is executed.
        this.scope = null;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Private

    generateScopeChain: function (scope, viewChrome)
    {
        var ret = [];
        while (scope)
        {
            var scopeVars;

            // getWrappedValue will not contain any variables for closure
            // scopes, so we want to special case this to get all variables
            // in all cases.
            if (scope.jsClassName == "Call")
            {
                scopeVars = Wrapper.unwrapIValueObject(scope, viewChrome);
                scopeVars.toString = function() { return Locale.$STR("Closure Scope"); };
            }
            else if (scope.jsClassName == "Block")
            {
                scopeVars = Wrapper.unwrapIValueObject(scope, viewChrome);
                scopeVars.toString = function() { return Locale.$STR("Block Scope"); };
            }
            else
            {
                scopeVars = Wrapper.unwrapIValue(scope, Firebug.viewChrome);
                if (!scopeVars || !scopeVars.hasOwnProperty)
                {
                    // XXXsimon not sure if this ever happens
                    // do not trace scopeVars, you will get a uncatchable exception
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("dom .generateScopeChain: bad scopeVars for " +
                            "scope.jsClassName:" + scope.jsClassName);

                    scopeVars = {error: "Mozilla error: invalid scope variables"};
                }
            }

            if (scopeVars)
                ret.push(scopeVars);

            scope = scope.jsParent;
        }

        ret.toString = function()
        {
            return Locale.$STR("Scope Chain");
        };

        return ret;
    },
};

//-----------------------111111----222222-----33---444  1 All 'Not a (' followed by (; 2 All 'Not a )' followed by a ); 3 text between @ and : digits

var reErrorStackLine = /^(.*)@(.*):(\d*)$/;
var reErrorStackLine2 = /^([^\(]*)\((.*)\)$/;

StackFrame.parseToStackFrame = function(line, context) // function name (arg, arg, arg)@fileName:lineNo
{
    var last255 = line.length - 255;
    if (last255 > 0)
        line = line.substr(last255);   // avoid regexp on monster compressed source (issue 4135)

    var m = reErrorStackLine.exec(line);
    if (m)
    {
        var m2 = reErrorStackLine2.exec(m[1]);
        if (m2)
        {
            var params = m2[2].split(',');
            //FBTrace.sysout("parseToStackFrame",{line:line,paramStr:m2[2],params:params});
            //var params = JSON.parse("["+m2[2]+"]");
            return new StackFrame.StackFrame({href:m[2]}, m[3], m2[1], params, null, null, context);
        }
        else
        {
            // Firefox 14 removes arguments from <exception-object>.stack.toString()
            // That's why the m2 reg doesn't match
            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=744842
            return new StackFrame.StackFrame({href:m[2]}, m[3], m[1], [], null, null, context);
        }
    }
};

StackFrame.parseToStackTrace = function(stack, context)
{
    var lines = stack.split('\n');
    var trace = new StackFrame.StackTrace();
    for (var i = 0; i < lines.length; i++)
    {
        var frame = StackFrame.parseToStackFrame(lines[i],context);

        if (FBTrace.DBG_STACK)
            FBTrace.sysout("parseToStackTrace i "+i+" line:"+lines[i]+ "->frame: "+frame, frame);

        if (frame)
            trace.frames.push(frame);
    }
    return trace;
};

StackFrame.cleanStackTraceOfFirebug = function(trace)
{
    if (trace && trace.frames)
    {
        while (trace.frames.length && /^_[fF]irebug/.test(trace.frames[trace.frames.length - 1].fn))
        {
            trace.frames.pop();
        }
        if (trace.frames.length == 0)
            trace = undefined;
    }
    return trace;
};

StackFrame.getStackDump = function()
{
    var lines = [];
    for (var frame = Components.stack; frame; frame = frame.caller)
        lines.push(frame.filename + " (" + frame.lineNumber + ")");

    return lines.join("\n");
};

StackFrame.getJSDStackDump = function(newestFrame)
{
    var lines = [];
    for (var frame = newestFrame; frame; frame = frame.callingFrame)
        lines.push(frame.script.fileName + " (" + frame.line + ")");

    return lines.join("\n");
};

StackFrame.getStackSourceLink = function()
{
    for (var frame = Components.stack; frame; frame = frame.caller)
    {
        if (frame.filename && frame.filename.indexOf("://firebug/") > 0)
        {
            for (; frame; frame = frame.caller)
            {
                var firebugComponent = "/modules/firebug-";
                if (frame.filename && frame.filename.indexOf("://firebug/") < 0 &&
                    frame.filename.indexOf(firebugComponent) == -1)
                    break;
            }
            break;
        }
    }
    return StackFrame.getFrameSourceLink(frame);
};

StackFrame.getFrameSourceLink = function(frame)
{
    if (frame && frame.filename && frame.filename.indexOf("XPCSafeJSObjectWrapper") == -1)
        return new SourceLink.SourceLink(frame.filename, frame.lineNumber, "js");
    else
        return null;
};

// TODO delete this, it's unused
StackFrame.getStackFrameId = function()
{
    for (var frame = Components.stack; frame; frame = frame.caller)
    {
        if (frame.languageName == "JavaScript"
            && !(frame.filename && frame.filename.indexOf("://firebug/") > 0))
        {
            return frame.filename + "/" + frame.lineNumber;
        }
    }
    return null;
};

// ********************************************************************************************* //

StackFrame.StackTrace = function(adoptFrames)
{
    this.frames = adoptFrames || [];
};

StackFrame.StackTrace.prototype =
{
    toString: function()
    {
        var trace = "<top>\n";
        for (var i = 0; i < this.frames.length; i++)
        {
            trace += "[" + i + "]"+ this.frames[i]+"\n";
        }
        trace += "<bottom>\n";
        return trace;
    },

    reverse: function()
    {
        this.frames.reverse();
        return this;
    },

    destroy: function()
    {
        for (var i = 0; i < this.frames.length; i++)
            this.frames[i].destroy();

        if (FBTrace.DBG_STACK)
            FBTrace.sysout("lib.StackTrace destroy "+this.uid+"\n");
    },

    toSourceLink: function()
    {
        if (this.frames.length > 0)
            return this.frames[0];
    }
};

// ********************************************************************************************* //

StackFrame.traceToString = function(trace)
{
    var str = "<top>";
    for(var i = 0; i < trace.frames.length; i++)
        str += "\n" + trace.frames[i];
    str += "\n<bottom>";
    return str;
};

StackFrame.buildStackTrace = function(frame)
{
    var trace = new StackFrame.StackTrace();
    while (frame)
    {
        trace.frames.push(frame);
        frame.frameIndex = trace.frames.length;
        frame = frame.getCallingFrame();
    }

    // Set the first frame (the one passed into this function) as the current one (issue 4249).
    if (trace.frames.length > 0)
        trace.currentFrameIndex = 1;

    return trace;
};

// ********************************************************************************************* //

StackFrame.getFunctionName = function(script, context, frame, noArgs)
{
    if (!script)
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("stackFrame.getFunctionName FAILS typeof(script)="+typeof(script)+"\n");
        return "(no script)";
    }

    var name = this.getDisplayName(frame ? frame.scope : null, script);
    if (name)
        return name;

    name = script.functionName;
    if (!name || (name == "anonymous"))
    {
        name = null;
        var analyzer = Firebug.SourceFile.getScriptAnalyzer(context, script);
        if (analyzer && frame)
        {
            if (FBTrace.DBG_STACK)
                FBTrace.sysout("getFunctionName analyzer.sourceFile:", analyzer.sourceFile);

            var functionSpec = analyzer.getFunctionDescription(script, context, frame);
            if (functionSpec.name)
                name = functionSpec.name + (noArgs ? "" : "("+functionSpec.args.join(',')+")");
        }

        if (!name || name == "anonymous")
        {
            if (FBTrace.DBG_STACK)
                FBTrace.sysout("getFunctionName no analyzer, "+script.baseLineNumber+"@"+
                    script.fileName+"\n");
            name = StackFrame.guessFunctionName(Url.normalizeURL(script.fileName),
                script.baseLineNumber, context);
        }
    }

    if (FBTrace.DBG_STACK)
        FBTrace.sysout("getFunctionName "+script.tag+" ="+name+"\n");

    return name;
};

StackFrame.getDisplayName = function(scope, script)
{
    try
    {
        if (scope)
        {
            return Wrapper.unwrapIValue(scope).arguments.callee.displayName;
        }
        else if (script)
        {
            var fnObj = Wrapper.unwrapIValue(script.functionObject);
            return (fnObj && fnObj.displayName) ? fnObj.displayName : script.functionName;
        }
    }
    catch (err)
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("stackFrame.getDisplayName; EXCEPTION " + err, err);
    }
};

StackFrame.guessFunctionName = function(url, lineNo, context)
{
    if (context)
    {
        if (context.sourceCache)
            return StackFrame.guessFunctionNameFromLines(url, lineNo, context.sourceCache);
    }
    return "? in "+Url.getFileName(url)+"@"+lineNo;
};

var reGuessFunction = /['"]?([$0-9A-Za-z_]+)['"]?\s*[:=]\s*(function|eval|new Function)/;
var reFunctionArgNames = /function ([^(]*)\(([^)]*)\)/;
StackFrame.guessFunctionNameFromLines = function(url, lineNo, sourceCache)
{
    // Walk backwards from the first line in the function until we find the line which
    // matches the pattern above, which is the function definition
    var line = "";
    if (FBTrace.DBG_FUNCTION_NAMES)
        FBTrace.sysout("getFunctionNameFromLines for line@URL=" + lineNo + "@" + url);

    for (var i=0; i<4; ++i)
    {
        line = sourceCache.getLine(url, lineNo-i) + line;
        if (line != undefined)
        {
            var m = reGuessFunction.exec(line);
            if (m)
            {
                return m[1];
            }
            else
            {
                if (FBTrace.DBG_FUNCTION_NAMES)
                {
                    FBTrace.sysout("lib.guessFunctionName re failed for lineNo-i=" + lineNo +
                        "-" + i + " line=" + line);
                }
            }

            m = reFunctionArgNames.exec(line);
            if (m && m[1])
                return m[1];
        }
    }

    return "(?)";
};

StackFrame.guessFunctionArgNamesFromSource = function(source)
{
    // XXXsimon: This fails with ES6 destructuring and parentheses in default parameters.
    // We'd need a proper JavaScript parser for that.
    var m = /[^\(]*\(([^\)]*)\)/.exec(source);
    if (!m)
        return null;
    var args = m[1].split(",");
    for (var i = 0; i < args.length; i++)
    {
        var arg = args[i];
        if (arg.indexOf("=") !== -1)
            arg = arg.substr(0, arg.indexOf("="));
        arg = arg.trim();
        if (!/^[a-zA-Z$_][a-zA-Z$_0-9]*$/.test(arg))
            return null;
        args[i] = arg;
    }
    return args;
};

// Mozilla
StackFrame.getFunctionArgValues = function(frame)
{
    var values = (frame.isValid && frame.scope.jsClassName == "Call") ?
        StackFrame.getArgumentsFromCallScope(frame) :
        StackFrame.getArgumentsFromObjectScope(frame);

    if (FBTrace.DBG_STACK)
        FBTrace.sysout("stackFrame.getFunctionArgValues "+frame+" scope: "+frame.scope.jsClassName,
            {values: values});

    return values;
};

// Mozilla
StackFrame.getArgumentsFromObjectScope = function(frame)
{
    var argNames = frame.script.getParameterNames();
    var scope = Wrapper.unwrapIValue(frame.scope, Firebug.viewChrome);

    var values = [];

    for (var i = 0; i < argNames.length; ++i)
    {
        var argName = argNames[i];
        if (scope)
        {
            var pvalue = scope[argName];
            //?? XXXjjb why are we unwrapping here, scope is a normal object
            //var value = pvalue ? Wrapper.unwrapIValue(pvalue.value) : undefined;
            values.push({name: argName, value: pvalue});
        }
        else
        {
            values.push({name: argName});
        }
    }

    return values;
};

StackFrame.getArgumentsFromCallScope = function(frame)
{
    var argNames = frame.script.getParameterNames();
    var scope = frame.scope;
    var values = [];
    for (var i = 0; i < argNames.length; ++i)
    {
        var argName = argNames[i];
        var pvalue = scope.getProperty(argName); // jsdIValue in jsdIDebuggerService
        var value = pvalue ? Wrapper.unwrapIValue(pvalue.value, Firebug.viewChrome) : undefined;
        values.push({name: argName, value: value});
    }

    return values;
};

// ********************************************************************************************* //

var saveShowStackTrace;

/**
 * use in the try{} around a call to getInterface to prevent fbs from generating stack traces
 */
StackFrame.suspendShowStackTrace = function()
{
    saveShowStackTrace = Firebug.showStackTrace;
    Firebug.showStackTrace = false;
};

/**
 * use in the finally{} to undo the suspendShowStackTrace
 */
StackFrame.resumeShowStackTrace = function()
{
    if (saveShowStackTrace)
    {
        Firebug.showStackTrace = saveShowStackTrace;
        saveShowStackTrace = null;
    }
};

// ********************************************************************************************* //
// Registration

return StackFrame;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/tabCache",
[
    "firebug/chrome/activableModule",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/xpcom",
    "firebug/net/requestObserver",
    "firebug/net/responseObserver",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/lib/http",
    "firebug/lib/string",
    "firebug/chrome/window",
    "firebug/net/jsonViewer",
    "firebug/trace/traceModule",
    "firebug/trace/traceListener",
    "firebug/lib/options",
    "firebug/js/sourceCache"
],
function(ActivableModule, Obj, Firebug, Xpcom, HttpRequestObserver, HttpResponseObserver, Locale,
    Events, Url, Http, Str, Win, JSONViewerModel, TraceModule, TraceListener, Options) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const ioService = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);

// List of text content types. These content-types are cached.
var contentTypes =
{
    "text/plain": 1,
    "text/html": 1,
    "text/xml": 1,
    "text/xsl": 1,
    "text/xul": 1,
    "text/css": 1,
    "text/sgml": 1,
    "text/rtf": 1,
    "text/x-setext": 1,
    "text/richtext": 1,
    "text/javascript": 1,
    "text/jscript": 1,
    "text/tab-separated-values": 1,
    "text/rdf": 1,
    "text/xif": 1,
    "text/ecmascript": 1,
    "text/vnd.curl": 1,
    "text/x-json": 1,
    "text/x-js": 1,
    "text/js": 1,
    "text/vbscript": 1,
    "view-source": 1,
    "view-fragment": 1,
    "application/xml": 1,
    "application/xhtml+xml": 1,
    "application/atom+xml": 1,
    "application/rss+xml": 1,
    "application/mathml+xml": 1,
    "application/rdf+xml": 1,
    "application/vnd.mozilla.maybe.feed": 1,
    "application/vnd.mozilla.xul+xml": 1,
    "application/javascript": 1,
    "application/x-javascript": 1,
    "application/x-httpd-php": 1,
    "application/rdf+xml": 1,
    "application/ecmascript": 1,
    "application/http-index-format": 1,
    "application/json": 1,
    "application/x-js": 1,
    "multipart/mixed" : 1,
    "multipart/x-mixed-replace" : 1,
    "image/svg+xml" : 1
};

// ********************************************************************************************* //
// Model implementation

/**
 * Implementation of cache model. The only purpose of this object is to register an HTTP
 * observer, so that HTTP communication can be intercepted and all incoming data stored
 * within a cache.
 */
Firebug.TabCacheModel = Obj.extend(ActivableModule,
{
    dispatchName: "tabCache",
    contentTypes: contentTypes,
    fbListeners: [],

    initialize: function()
    {
        ActivableModule.initialize.apply(this, arguments);

        this.traceListener = new TraceListener("tabCache.", "DBG_CACHE", false);
        TraceModule.addListener(this.traceListener);
    },

    initializeUI: function(owner)
    {
        ActivableModule.initializeUI.apply(this, arguments);

        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.initializeUI;");

        // Read additional text MIME types from preferences.
        var mimeTypes = Options.get("cache.mimeTypes");
        if (mimeTypes)
        {
            var list = mimeTypes.split(" ");
            for (var i=0; i<list.length; i++)
                contentTypes[list[i]] = 1;
        }

        // Merge with JSON types
        var jsonTypes = JSONViewerModel.contentTypes;
        for (var p in jsonTypes)
            contentTypes[p] = 1;
    },

    onObserverChange: function(observer)
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.onObserverChange; hasObservers: " + this.hasObservers());

        // If Firebug is in action, we need to test to see if we need to addObserver
        if (!Firebug.getSuspended())
            this.onResumeFirebug();
    },

    onResumeFirebug: function()
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.onResumeFirebug; hasObsevers: " + this.hasObservers());

        if (this.hasObservers() && !this.observing)
        {
            HttpRequestObserver.addObserver(this, "firebug-http-event", false);
            this.observing = true;
        }
    },

    onSuspendFirebug: function()
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.onSuspendFirebug; hasObsevers: " + this.hasObservers());

        if (this.observing)
        {
            HttpRequestObserver.removeObserver(this, "firebug-http-event");
            this.observing = false;
        }
    },

    shutdown: function()
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.shutdown; Cache model destroyed.");

        TraceModule.removeListener(this.traceListener);

        if (this.observing)
            HttpRequestObserver.removeObserver(this, "firebug-http-event");
    },

    initContext: function(context)
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.initContext for: " + context.getName());
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // nsIObserver

    observe: function(subject, topic, data)
    {
        try
        {
            if (!(subject instanceof Ci.nsIHttpChannel))
                return;

            // XXXjjb this same code is in net.js, better to have it only once
            var win = Http.getWindowForRequest(subject);
            if (!win)
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("tabCache.observe; " + topic + ", NO WINDOW");
                return;
            }

            if (topic == "http-on-modify-request")
                this.onModifyRequest(subject, win);
            else if (topic == "http-on-examine-response")
                this.onExamineResponse(subject, win);
            else if (topic == "http-on-examine-cached-response")
                this.onCachedResponse(subject, win);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("tabCache.observe EXCEPTION", err);
        }
    },

    onModifyRequest: function(request, win)
    {
    },

    onExamineResponse: function(request, win)
    {
        this.registerStreamListener(request, win);
    },

    onCachedResponse: function(request, win)
    {
        this.registerStreamListener(request, win);
    },

    registerStreamListener: function(request, win, forceRegister)
    {
        if (Firebug.getSuspended() && !forceRegister)
        {
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("tabCache.registerStreamListener; DO NOT TRACK, " +
                    "Firebug suspended for: " + Http.safeGetRequestName(request));
            return;
        }

        if (!this.hasObservers())
            return;

        try
        {
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("tabCache.registerStreamListener; " +
                    Http.safeGetRequestName(request));

            HttpResponseObserver.register(win, request, new ChannelListenerProxy(win));
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("tabCache.Register Traceable Listener EXCEPTION", err);
        }
    },

    shouldCacheRequest: function(request)
    {
        if (!(request instanceof Ci.nsIHttpChannel))
            return;

        // Allow to customize caching rules.
        if (Events.dispatch2(this.fbListeners, "shouldCacheRequest", [request]))
            return true;

        // Cache only text responses for now.
        var contentType = request.contentType;
        if (contentType)
            contentType = contentType.split(";")[0];

        contentType = Str.trim(contentType);
        if (contentTypes[contentType])
            return true;

        // Hack to work around application/octet-stream for js files (see issue 2063).
        // Let's cache all files with js extensions.
        var extension = Url.getFileExtension(Http.safeGetRequestName(request));
        if (extension == "js")
            return true;

        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.shouldCacheRequest; Request not cached: " +
                request.contentType + ", " + Http.safeGetRequestName(request));

        return false;
    },
});

// ********************************************************************************************* //
// Tab Cache

/**
 * This cache object is intended to cache all responses made by a specific tab.
 * The implementation is based on nsITraceableChannel interface introduced in
 * Firefox 3.0.4. This interface allows to intercept all incoming HTTP data.
 *
 * This object replaces the SourceCache, which still exist only for backward
 * compatibility.
 *
 * The object is derived from SourceCache, so the same interface and most of the
 * implementation is used.
 */
Firebug.TabCache = function(context)
{
    if (FBTrace.DBG_CACHE)
        FBTrace.sysout("tabCache.TabCache Created for: " + context.getName());

    Firebug.SourceCache.call(this, context);

    // Set of HTTP responses (URLs) that has been limited in the cache.
    // Used by the UI to notify the user.
    this.limitedResponses = {};
};

Firebug.TabCache.prototype = Obj.extend(Firebug.SourceCache.prototype,
{
    // Responses in progress
    responses: [],

    storePartialResponse: function(request, responseText, win, offset)
    {
        if (!offset)
            offset = 0;

        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.storePartialResponse " + Http.safeGetRequestName(request),
                request.contentCharset);

        var url = Http.safeGetRequestName(request);
        var response = this.getResponse(request);

        // Skip any response data that we have received before (f ex when
        // response packets are repeated due to quirks in how authentication
        // requests are projected to the channel listener)
        var newRawSize = offset + responseText.length;
        var addRawBytes = newRawSize - response.rawSize;

        if (responseText.length > addRawBytes)
            responseText = responseText.substr(responseText.length - addRawBytes);

        try
        {
            responseText = Str.convertToUnicode(responseText, win.document.characterSet);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS || FBTrace.DBG_CACHE)
                FBTrace.sysout("tabCache.storePartialResponse EXCEPTION " +
                    Http.safeGetRequestName(request), err);

            // Even responses that are not converted are stored into the cache.
            // return false;
        }

        // Size of each response is limited.
        var limitNotReached = true;
        var responseSizeLimit = Options.get("cache.responseLimit");
        if (response.size + responseText.length >= responseSizeLimit)
        {
            limitNotReached = false;
            responseText = responseText.substr(0, responseSizeLimit - response.size);

            this.limitedResponses[url] = true;

            if (FBTrace.DBG_CACHE)
            {
                FBTrace.sysout("tabCache.storePartialResponse; Maximum response limit " +
                    "reached for: " + url);
            }
        }

        response.size += responseText.length;
        response.rawSize = newRawSize;

        // Store partial content into the cache.
        this.store(url, responseText);

        // Return false if furhter parts of this response should be ignored.
        return limitNotReached;
    },

    isLimited: function(url)
    {
        return this.limitedResponses[url];
    },

    getResponse: function(request)
    {
        var url = Http.safeGetRequestName(request);
        var response = this.responses[url];
        if (!response)
        {
            this.invalidate(url);
            this.responses[url] = response = {
                request: request,
                size: 0,
                rawSize: 0
            };
        }

        return response;
    },

    storeSplitLines: function(url, lines)
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.storeSplitLines: " + url, lines);

        var currLines = this.cache[url];
        if (!currLines)
            currLines = this.cache[url] = [];

        // Join the last line with the new first one to make the source code
        // lines properly formatted...
        if (currLines.length && lines.length)
        {
            // ... but only if the last line isn't already completed.
            var lastLine = currLines[currLines.length-1];
            if (lastLine && lastLine.search(/\r|\n/) == -1)
                currLines[currLines.length-1] += lines.shift();
        }

        // Append new lines (if any) into the array for specified url.
        if (lines.length)
            this.cache[url] = currLines.concat(lines);

        return this.cache[url];
    },

    loadFromCache: function(url, method, file)
    {
        // The ancestor implementation (SourceCache) uses ioService.newChannel, which
        // can result in additional request to the server (in case the response can't
        // be loaded from the Firefox cache) - known as the double-load problem.
        // This new implementation (TabCache) uses nsITraceableChannel, so all responses
        // should be already cached.

        // xxxHonza: TODO entire implementation of this method should be removed in Firebug 1.5
        // xxxHonza: let's try to get the response from the cache till #449198 is fixed.
        var stream;
        var responseText;
        try
        {
            if (!url)
                return responseText;

            if (url === "<unknown>")
                return [Locale.$STR("message.sourceNotAvailableFor") + ": " + url];

            var channel = ioService.newChannel(url, null, null);

            // These flag combination doesn't repost the request.
            channel.loadFlags = Ci.nsIRequest.LOAD_FROM_CACHE |
                Ci.nsICachingChannel.LOAD_ONLY_FROM_CACHE |
                Ci.nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY;

            var charset = "UTF-8";

            if (!this.context.window)
            {
                if (FBTrace.DBG_ERRORS)
                {
                    FBTrace.sysout("tabCache.loadFromCache; ERROR this.context.window " +
                        "is undefined");
                }
            }

            var doc = this.context.window ? this.context.window.document : null;
            if (doc)
                charset = doc.characterSet;

            stream = channel.open();

            // The response doesn't have to be in the browser cache.
            if (!stream.available())
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("tabCache.loadFromCache; Failed to load source for: " + url);

                stream.close();
                return [Locale.$STR("message.sourceNotAvailableFor") + ": " + url];
            }

            // Don't load responses that shouldn't be cached.
            if (!Firebug.TabCacheModel.shouldCacheRequest(channel))
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("tabCache.loadFromCache; The resource from this URL is not text: " + url);

                stream.close();
                return [Locale.$STR("message.The resource from this URL is not text") + ": " + url];
            }

            responseText = Http.readFromStream(stream, charset);

            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("tabCache.loadFromCache (response coming from FF Cache) " +
                    url, responseText);

            responseText = this.store(url, responseText);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS || FBTrace.DBG_CACHE)
                FBTrace.sysout("tabCache.loadFromCache EXCEPTION on url \'" + url +"\'", err);
        }
        finally
        {
            if (stream)
                stream.close();
        }

        return responseText;
    },

    // nsIStreamListener - callbacks from channel stream listener component.
    onStartRequest: function(request, requestContext)
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.channel.startRequest: " + Http.safeGetRequestName(request));

        // Make sure the response-entry (used to count total response size) is properly
        // initialized (cleared) now. If no data is received, the response entry remains empty.
        var response = this.getResponse(request);

        Events.dispatch(Firebug.TabCacheModel.fbListeners, "onStartRequest", [this.context, request]);
        Events.dispatch(this.fbListeners, "onStartRequest", [this.context, request]);
    },

    onDataAvailable: function(request, requestContext, inputStream, offset, count)
    {
        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.channel.onDataAvailable: " + Http.safeGetRequestName(request));

        // If the stream is read a new one must be provided (the stream doesn't implement
        // nsISeekableStream).
        var stream = {
            value: inputStream
        };

        Events.dispatch(Firebug.TabCacheModel.fbListeners, "onDataAvailable",
            [this.context, request, requestContext, stream, offset, count]);
        Events.dispatch(this.fbListeners, "onDataAvailable", [this.context,
            request, requestContext, stream, offset, count]);

        return stream.value;
    },

    onStopRequest: function(request, requestContext, statusCode)
    {
        // The response has been received; remove the request from the list of
        // current responses.
        var url = Http.safeGetRequestName(request);
        delete this.responses[url];

        var lines = this.cache[this.removeAnchor(url)];
        var responseText = lines ? lines.join("") : "";

        if (FBTrace.DBG_CACHE)
            FBTrace.sysout("tabCache.channel.stopRequest: " + Http.safeGetRequestName(request),
                responseText);

        Events.dispatch(Firebug.TabCacheModel.fbListeners, "onStopRequest",
            [this.context, request, responseText]);
        Events.dispatch(this.fbListeners, "onStopRequest", [this.context, request, responseText]);
    }
});

// ********************************************************************************************* //
// Proxy Listener

function ChannelListenerProxy(win)
{
    this.window = win;
}

ChannelListenerProxy.prototype =
{
    onStartRequest: function(request, requestContext)
    {
        var context = this.getContext();
        if (context)
            context.sourceCache.onStartRequest(request, requestContext);
    },

    onDataAvailable: function(request, requestContext, inputStream, offset, count)
    {
        var context = this.getContext();
        if (!context)
            return null;

        return context.sourceCache.onDataAvailable(request, requestContext,
            inputStream, offset, count);
    },

    onStopRequest: function(request, requestContext, statusCode)
    {
        var context = this.getContext();
        if (context)
            context.sourceCache.onStopRequest(request, requestContext, statusCode);
    },

    onCollectData: function(request, data, offset)
    {
        var context = this.getContext();
        if (!context)
        {
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("tabCache.channel.onCollectData: NO CONTEXT " +
                    Http.safeGetRequestName(request), data);

            return false;
        }

        // Store received data into the cache as they come. If the method returns
        // false, the rest of the response is ignored (not cached). This is used
        // to limit size of a cached response.
        return context.sourceCache.storePartialResponse(request, data, this.window, offset);
    },

    getContext: function()
    {
        try
        {
            return Firebug.connection.getContextByWindow(this.window);
        }
        catch (e)
        {
        }
        return null;
    },

    shouldCacheRequest: function(request)
    {
        try
        {
            return Firebug.TabCacheModel.shouldCacheRequest(request);
        }
        catch (err)
        {
        }
        return false;
    }
};

// ********************************************************************************************* //
// Registration

Firebug.registerActivableModule(Firebug.TabCacheModel);

return Firebug.TabCacheModel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/js/watchPanel",
[
    "firebug/lib/object",
    "firebug/chrome/firefox",
    "firebug/firebug",
    "firebug/dom/toggleBranch",
    "firebug/lib/events",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/js/stackFrame",
    "firebug/lib/locale",
    "firebug/lib/string",
    "firebug/dom/domPanel",     // Firebug.DOMBasePanel, Firebug.DOMPanel.DirTable
],
function(Obj, Firefox, Firebug, ToggleBranch, Events, Dom, Css, StackFrame, Locale, Str) {

// ********************************************************************************************* //
// Watch Panel

Firebug.WatchPanel = function()
{
};

/**
 * Represents the Watch side panel available in the Script panel.
 */
Firebug.WatchPanel.prototype = Obj.extend(Firebug.DOMBasePanel.prototype,
/** @lends Firebug.WatchPanel */
{
    tag: Firebug.DOMPanel.DirTable.watchTag,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // extends Panel

    name: "watches",
    order: 0,
    parentPanel: "script",
    enableA11y: true,
    deriveA11yFrom: "console",

    initialize: function()
    {
        this.onMouseDown = Obj.bind(this.onMouseDown, this);
        this.onMouseOver = Obj.bind(this.onMouseOver, this);
        this.onMouseOut = Obj.bind(this.onMouseOut, this);

        Firebug.registerUIListener(this);

        Firebug.DOMBasePanel.prototype.initialize.apply(this, arguments);
    },

    destroy: function(state)
    {
        state.watches = this.watches;

        Firebug.unregisterUIListener(this);

        Firebug.DOMBasePanel.prototype.destroy.apply(this, arguments);
    },

    show: function(state)
    {
        if (state && state.watches)
            this.watches = state.watches;
    },

    initializeNode: function(oldPanelNode)
    {
        Events.addEventListener(this.panelNode, "mousedown", this.onMouseDown, false);
        Events.addEventListener(this.panelNode, "mouseover", this.onMouseOver, false);
        Events.addEventListener(this.panelNode, "mouseout", this.onMouseOut, false);

        Firebug.DOMBasePanel.prototype.initializeNode.apply(this, arguments);
    },

    destroyNode: function()
    {
        Events.removeEventListener(this.panelNode, "mousedown", this.onMouseDown, false);
        Events.removeEventListener(this.panelNode, "mouseover", this.onMouseOver, false);
        Events.removeEventListener(this.panelNode, "mouseout", this.onMouseOut, false);

        Firebug.DOMBasePanel.prototype.destroyNode.apply(this, arguments);
    },

    refresh: function()
    {
        this.rebuild(true);
    },

    updateSelection: function(frame)
    {
        // this method is called while the debugger has halted JS,
        // so failures don't show up in FBS_ERRORS
        try
        {
            this.doUpdateSelection(frame);
        }
        catch (exc)
        {
            if (FBTrace.DBG_ERRORS && FBTrace.DBG_STACK)
                FBTrace.sysout("updateSelection FAILS " + exc, exc);
        }
    },

    doUpdateSelection: function(frame)
    {
        if (FBTrace.DBG_STACK)
            FBTrace.sysout("dom watch panel updateSelection frame " + frame, frame);

        Events.dispatch(this.fbListeners, "onBeforeDomUpdateSelection", [this]);

        var newFrame = frame && ("signature" in frame) &&
            (frame.signature() != this.frameSignature);

        if (newFrame)
        {
            this.toggles = new ToggleBranch.ToggleBranch();
            this.frameSignature = frame.signature();
        }

        var scopes;
        if (frame instanceof StackFrame.StackFrame)
            scopes = frame.getScopes(Firebug.viewChrome);
        else
            scopes = [this.context.getCurrentGlobal()];

        if (FBTrace.DBG_STACK)
            FBTrace.sysout("dom watch frame isStackFrame " +
                (frame instanceof StackFrame.StackFrame) +
                " updateSelection scopes " + scopes.length, scopes);

        var members = [];

        var context = this.context;
        if (this.watches)
        {
            for (var i = 0; i < this.watches.length; ++i)
            {
                var expr = this.watches[i];
                var value = null;

                Firebug.CommandLine.evaluate(expr, context, null, context.getCurrentGlobal(),
                    function success(result, context)
                    {
                        value = result;
                    },
                    function failed(result, context)
                    {
                        var exc = result;
                        value = new FirebugReps.ErrorCopy(exc+"");
                    }
                );

                this.addMember(scopes[0], "watch", members, expr, value, 0);

                if (FBTrace.DBG_DOM)
                {
                    FBTrace.sysout("watch.updateSelection \"" + expr + "\"",
                        {expr: expr, value: value, members: members});
                }
            }
        }

        if (frame && frame instanceof StackFrame.StackFrame)
        {
            var thisVar = frame.getThisValue();
            if (thisVar)
                this.addMember(scopes[0], "user", members, "this", thisVar, 0);

            // locals, pre-expanded
            members.push.apply(members, this.getMembers(scopes[0], 0));

            for (var i=1; i<scopes.length; i++)
            {
                var scope = scopes[i];
                var name = (scope.hasOwnProperty("toString") ? scope.toString() :
                    Object.prototype.toString.call(scope));

                // Some objects are stringified as [object ClassName]; extract
                // the [[Class]] from those.
                var re = /\[object (.*)\]/.exec(name);
                if (re)
                {
                    if (re[1] === "Window")
                        name = Locale.$STR("Window_Scope");
                    else
                        name = re[1];
                }

                this.addMember(scope, "scopes", members, name, scope, 0);
            }
        }

        this.expandMembers(members, this.toggles, 0, 0);
        this.showMembers(members, false);

        if (FBTrace.DBG_STACK)
            FBTrace.sysout("dom watch panel updateSelection members " + members.length, members);
    },

    rebuild: function()
    {
        if (FBTrace.DBG_WATCH)
            FBTrace.sysout("Firebug.WatchPanel.rebuild", this.selection);

        this.updateSelection(this.selection);
    },

    showEmptyMembers: function()
    {
        var domTable = this.tag.replace({domPanel: this, toggles: new ToggleBranch.ToggleBranch()},
            this.panelNode);

        // The direction needs to be adjusted according to the direction
        // of the user agent. See issue 5073.
        // TODO: Set the direction at the <body> to allow correct formatting of all relevant parts.
        // This requires more adjustments related for rtl user agents.
        var mainFrame = Firefox.getElementById("fbMainFrame");
        var cs = mainFrame.ownerDocument.defaultView.getComputedStyle(mainFrame);
        var watchRow = domTable.getElementsByClassName("watchNewRow").item(0);
        watchRow.style.direction = cs.direction;
    },

    addWatch: function(expression)
    {
        expression = Str.trim(expression);

        if (FBTrace.DBG_WATCH)
            FBTrace.sysout("Firebug.WatchPanel.addWatch; expression: "+expression);

        if (!this.watches)
            this.watches = [];

        for (var i=0; i<this.watches.length; i++)
        {
            if (expression == this.watches[i])
                return;
        }

        this.watches.splice(0, 0, expression);
        this.rebuild(true);
    },

    removeWatch: function(expression)
    {
        if (FBTrace.DBG_WATCH)
            FBTrace.sysout("Firebug.WatchPanel.removeWatch; expression: " + expression);

        if (!this.watches)
            return;

        var index = this.watches.indexOf(expression);
        if (index != -1)
            this.watches.splice(index, 1);
    },

    editNewWatch: function(value)
    {
        if (FBTrace.DBG_WATCH)
            FBTrace.sysout("Firebug.WatchPanel.editNewWatch; value: " + value);

        var watchNewRow = this.panelNode.getElementsByClassName("watchNewRow").item(0);
        if (watchNewRow)
            this.editProperty(watchNewRow, value);
    },

    setWatchValue: function(row, value)
    {
        if (FBTrace.DBG_WATCH)
            FBTrace.sysout("Firebug.WatchPanel.setWatchValue", {row: row, value: value});

        var rowIndex = getWatchRowIndex(row);
        this.watches[rowIndex] = value;
        this.rebuild(true);
    },

    deleteWatch: function(row)
    {
        if (FBTrace.DBG_WATCH)
            FBTrace.sysout("Firebug.WatchPanel.deleteWatch", row);

        var rowIndex = getWatchRowIndex(row);
        this.watches.splice(rowIndex, 1);
        this.rebuild(true);

        this.context.setTimeout(Obj.bindFixed(function()
        {
            var watchRow = this.panelNode.getElementsByClassName("watchRow")[rowIndex];
            this.showToolbox(watchRow);
        }, this));
    },

    // deletes all the watches
    deleteAllWatches: function()
    {
        if (FBTrace.DBG_WATCH)
            FBTrace.sysout("Firebug.WatchPanel.deleteAllWatches");
        this.watches = [];
        this.rebuild(true);
        this.context.setTimeout(Obj.bindFixed(function()
        {
            this.showToolbox(null);
        }, this));
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    showToolbox: function(row)
    {
        var toolbox = this.getToolbox();
        if (row)
        {
            if (Css.hasClass(row, "editing"))
                return;

            toolbox.watchRow = row;

            var offset = Dom.getClientOffset(row);
            toolbox.style.top = offset.y + "px";
            this.panelNode.appendChild(toolbox);
        }
        else
        {
            delete toolbox.watchRow;

            if (toolbox.parentNode)
                toolbox.parentNode.removeChild(toolbox);
        }
    },

    getToolbox: function()
    {
        if (!this.toolbox)
        {
            this.toolbox = Firebug.DOMBasePanel.ToolboxPlate.tag.replace(
                {domPanel: this}, this.document);
        }

        return this.toolbox;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onMouseDown: function(event)
    {
        var watchNewRow = Dom.getAncestorByClass(event.target, "watchNewRow");
        if (watchNewRow)
        {
            this.editProperty(watchNewRow);
            Events.cancelEvent(event);
        }
    },

    onMouseOver: function(event)
    {
        var watchRow = Dom.getAncestorByClass(event.target, "watchRow");
        if (watchRow)
            this.showToolbox(watchRow);
    },

    onMouseOut: function(event)
    {
        if (Dom.isAncestor(event.relatedTarget, this.getToolbox()))
            return;

        var watchRow = Dom.getAncestorByClass(event.relatedTarget, "watchRow");
        if (!watchRow)
            this.showToolbox(null);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Context Menu

    /**
     * Creates "Add Watch" menu item within DOM and Watch panel context menus.
     */
    onContextMenu: function(items, object, target, context, panel, popup)
    {
        // Ignore events from other contexts.
        if (this.context != context)
            return;

        if (panel.name != "dom" && panel.name != "watches")
            return;

        var row = Dom.getAncestorByClass(target, "memberRow");
        if (!row || row.domObject.ignoredPath)
            return;

        var path = this.getPropertyPath(row);
        if (!path || !path.length)
            return;

        // Ignore top level variables in the Watch panel.
        if (panel.name == "watches" && path.length == 1)
            return;

        items.push({
           id: "fbAddWatch",
           label: "AddWatch",
           tooltiptext: "watch.tip.Add_Watch",
           command: Obj.bindFixed(this.addWatch, this, path.join(""))
        });
    },

    getContextMenuItems: function(object, target)
    {
        var items = Firebug.DOMBasePanel.prototype.getContextMenuItems.apply(this, arguments);

        if (!this.watches || this.watches.length == 0)
            return items;

        // find the index of "DeletePropery" in the items:
        var deleteWatchIndex = items.map(function(item)
        {
            return item.id;
        }).indexOf("DeleteProperty");

        // if DeleteWatch was found, we insert DeleteAllWatches after it
        // otherwise, we insert the item at the beginning of the menu
        var deleteAllWatchesIndex = (deleteWatchIndex >= 0) ? deleteWatchIndex + 1 : 0;

        if (FBTrace.DBG_WATCH)
            FBTrace.sysout("insert DeleteAllWatches at: "+ deleteAllWatchesIndex);

        // insert DeleteAllWatches after DeleteWatch
        items.splice(deleteAllWatchesIndex, 0, {
            id: "fbDeleteAllWatches",
            label: "DeleteAllWatches",
            tooltiptext: "watch.tip.Delete_All_Watches",
            command: Obj.bindFixed(this.deleteAllWatches, this)
        });

        return items;
    }
});

// ********************************************************************************************* //
// Local Helpers

function getWatchRowIndex(row)
{
    var index = -1;
    for (; row; row = row.previousSibling)
    {
        if (Css.hasClass(row, "watchRow"))
            ++index;
    }
    return index;
}

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(Firebug.WatchPanel);

return Firebug.WatchPanel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/array",
[
    "firebug/lib/trace",
],
function(FBTrace) {

// ********************************************************************************************* //
// Constants

const Ci = Components.interfaces;
const Cu = Components.utils;
var Arr = {};

// ********************************************************************************************* //
// Arrays

Arr.isArray = Array.isArray;

Arr.isArrayLike = function(obj)
{
    try
    {
        if (!obj || typeof obj !== "object")
            return false;
        if (!isFinite(obj.length))
            return false;
        if (Array.isArray(obj))
            return true;
        if (typeof obj.splice === "function") // jQuery etc.
            return true;
        var str = Object.prototype.toString.call(obj);
        if (str === "[object HTMLCollection]" || str === "[object NodeList]" ||
            str === "[object DOMTokenList]" || str === "[object Arguments]")
        {
            return true;
        }
    }
    catch (exc) {}
    return false;
};

// At least sometimes the keys will be on user-level window objects
Arr.keys = function(map)
{
    var keys = [];
    try
    {
        for (var name in map)  // enumeration is safe
            keys.push(name);   // name is string, safe
    }
    catch (exc)
    {
        // Sometimes we get exceptions trying to iterate properties
    }

    return keys;  // return is safe
};

Arr.values = function(map)
{
    var values = [];
    try
    {
        for (var name in map)
        {
            try
            {
                values.push(map[name]);
            }
            catch (exc)
            {
                // Sometimes we get exceptions trying to access properties
                if (FBTrace.DBG_ERRORS)
                    FBTrace.dumpPropreties("lib.values FAILED ", exc);
            }
        }
    }
    catch (exc)
    {
        // Sometimes we get exceptions trying to iterate properties
        if (FBTrace.DBG_ERRORS)
            FBTrace.dumpPropreties("lib.values FAILED ", exc);
    }

    return values;
};

Arr.remove = function(list, item)
{
    for (var i = 0; i < list.length; ++i)
    {
        if (list[i] == item)
        {
            list.splice(i, 1);
            return true;
        }
    }
    return false;
};

Arr.sliceArray = function(array, index)
{
    var slice = [];
    for (var i = index; i < array.length; ++i)
        slice.push(array[i]);

    return slice;
};

Arr.cloneArray = function(array, fn)
{
   var newArray = [], len = array.length;

   if (fn)
       for (var i = 0; i < len; ++i)
           newArray.push(fn(array[i]));
   else
       for (var i = 0; i < len; ++i)
           newArray.push(array[i]);

   return newArray;
};

Arr.extendArray = function(array, array2)
{
   var newArray = [];
   newArray.push.apply(newArray, array);
   newArray.push.apply(newArray, array2);
   return newArray;
};

Arr.arrayInsert = function(array, index, other)
{
    // Prepare arguments for Array.splice()
    // 1) index: at which to start inserting the 'other' array.
    // 2) howMany: elements to remove (none in this case)
    // 3-N) elements: to insert
    var args = [index, 0];
    args.push.apply(args, other);

    // Insert 'other' array into 'array'
    array.splice.apply(array, args);

    return array;
};

// xxxFlorent: [ES6-SET] [ES6-SPREAD]
/**
 * Filter out unique values of an array, saving only the first occurrence of
 * every value. In case the array is sorted, a faster path is taken.
 */
Arr.unique = function(ar, sorted)
{
    var ret = [], len = ar.length;
    if (sorted)
    {
        for (var i = 0; i < len; ++i)
        {
            // Skip duplicated entries
            if (i && ar[i-1] === ar[i])
                continue;
            ret.push(ar[i]);
        }
    }
    else
    {
        var set = new Set();
        for (var i = 0; i < len; ++i)
        {
            if (!set.has(ar[i]))
            {
                ret.push(ar[i]);
                set.add(ar[i]);
            }
        }
    }
    return ret;
};

/**
 * Sort an array and eliminate duplicates from it.
 */
Arr.sortUnique = function(ar, sortFunc)
{
    return Arr.unique(ar.slice().sort(sortFunc), true);
};

/**
 * Merge together two arrays, sort the result, and eliminate any duplicates.
 */
Arr.merge = function(arr1, arr2, sortFunc)
{
    return Arr.sortUnique(arr1.concat(arr2), sortFunc);
};

// ********************************************************************************************* //

return Arr;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/css",
[
    "firebug/lib/trace",
    "firebug/lib/url",
    "firebug/lib/options",
    "firebug/chrome/window",
    "firebug/lib/xml",
    "firebug/lib/http",
    "firebug/lib/xpath"
],
function(FBTrace, Url, Options, Win, Xml, Http, Xpath) {

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;
var Cc = Components.classes;

// ********************************************************************************************* //
// Module Implementation

var Css = {};

// ********************************************************************************************* //
// CSS

var cssKeywordMap = {};
var cssPropNames = {};
var cssColorNames = null;
var imageRules = null;
var domUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);

Css.getCSSKeywordsByProperty = function(nodeType, propName, avoid)
{
    if (!cssKeywordMap[nodeType])
    {
        cssKeywordMap[nodeType] = {};

        for (var name in Css.cssInfo[nodeType])
        {
            var list = [];

            var types = Css.cssInfo[nodeType][name];
            for (var i = 0; i < types.length; ++i)
            {
                var keywords = Css.cssKeywords[types[i]];
                if (keywords)
                    list.push.apply(list, keywords);
                else
                    list.push(types[i]);
            }

            cssKeywordMap[nodeType][name] = list;
        }
    }

    propName = propName.toLowerCase();

    if (avoid)
        return getCSSPropertyKeywordsExcludingCategories(nodeType, propName, avoid);

    return cssKeywordMap[nodeType][propName] || [];
};

function getCSSPropertyKeywordsExcludingCategories(nodeType, propName, avoid)
{
    if (!(nodeType in Css.cssInfo) || !(propName in Css.cssInfo[nodeType]))
        return [];

    var list = [];
    var types = Css.cssInfo[nodeType][propName];
    for (var i = 0; i < types.length; ++i)
    {
        var type = types[i];
        if (avoid.indexOf(type) !== -1)
            continue;
        var keywords = Css.cssKeywords[type];
        if (keywords)
            list.push.apply(list, keywords);
        else
            list.push(type);
    }
    return list;
}

Css.getCSSPropertyNames = function(nodeType)
{
    if (!cssPropNames[nodeType])
    {
        cssPropNames[nodeType] = [];

        for (var name in Css.cssInfo[nodeType])
            cssPropNames[nodeType].push(name);
    }

    return cssPropNames[nodeType];
};

Css.getCSSShorthandCategory = function(nodeType, shorthandProp, keyword)
{
    if (!(nodeType in Css.cssInfo) || !(shorthandProp in Css.cssInfo[nodeType]))
        return null;

    var category = null;
    var types = Css.cssInfo[nodeType][shorthandProp];
    for (var i = 0; i < types.length; ++i)
    {
        var type = types[i];
        var keywords = Css.cssKeywords[type];
        if (keywords ? (keywords.indexOf(keyword) !== -1) : (type === keyword))
        {
            // Set this as the matched category, or if there is one already
            // bail out (we don't have a unique one).
            if (category)
                return null;
            category = type;
        }
    }
    return category;
};

/**
 * Parses the CSS properties of a CSSStyleRule
 * @param {Object} style CSSStyleRule to get the properties of
 * @param {Object} element Element to which the style applies. Needed for parsing
 *      shorthand properties correctly.
 *
 * @returns {Array} Properties represented by {name, value, priority, longhandProps}
 */
Css.parseCSSProps = function(style, element)
{
    var props = [];

    if (!element)
    {
        for (var i = 0, len = style.length; i < len; ++i)
        {
            var prop = style.item(i);
            props.push({name: prop,
                value: style.getPropertyValue(prop),
                priority: style.getPropertyPriority(longhandProp)});
        }
    }
    else
    {
        var lineRE = /(?:[^;\(]*(?:\([^\)]*?\))?[^;\(]*)*;?/g;
        var propRE = /\s*([^:\s]*)\s*:\s*(.*?)\s*(?:! (important))?;?$/;
        var lines = style.cssText.match(lineRE);
        for (var i = 0, len = lines.length; i < len; ++i)
        {
            var match = propRE.exec(lines[i]);
            if (!match)
                continue;

            if (match[2])
            {
                var prop = {name: match[1], value: match[2], priority: match[3] || ""};

                // Add longhand properties to shorthand property
                var doc = element.ownerDocument;
                var dummyElement = doc.createElementNS(element.namespaceURI, element.tagName);
                var dummyStyle = dummyElement.style;
                dummyStyle.cssText = "";
                dummyStyle.setProperty(prop.name, prop.value, prop.priority);

                if (dummyStyle.length > 1)
                {
                    prop.longhandProps = [];
                    for (var j = 0, propLen = dummyStyle.length; j < propLen; ++j)
                    {
                        var longhandProp = dummyStyle.item(j);
                        prop.longhandProps.push({name: longhandProp,
                            value: dummyStyle.getPropertyValue(longhandProp),
                            priority: dummyStyle.getPropertyPriority(longhandProp)});
                    }
                }

                props.push(prop);
            }
        }
    }

    return props;
};

Css.isColorKeyword = function(keyword)
{
    if (keyword == "transparent")
        return false;

    if (!cssColorNames)
    {
        cssColorNames = [];

        var colors = Css.cssKeywords["color"];
        for (var i = 0; i < colors.length; ++i)
            cssColorNames.push(colors[i].toLowerCase());
    }

    return cssColorNames.indexOf(keyword.toLowerCase()) != -1;
};

Css.isImageRule = function(nodeType,rule)
{
    if (!imageRules)
    {
        imageRules = [];

        for (var i in Css.cssInfo[nodeType])
        {
            var r = i.toLowerCase();
            var suffix = "image";
            if (r.match(suffix + "$") == suffix || r == "background")
                imageRules.push(r);
        }
    }

    return imageRules.indexOf(rule.toLowerCase()) != -1;
};

Css.copyTextStyles = function(fromNode, toNode, style)
{
    var view = fromNode ? fromNode.ownerDocument.defaultView : null;
    if (view)
    {
        if (!style)
            style = view.getComputedStyle(fromNode, "");

        toNode.style.fontFamily = style.fontFamily;
        toNode.style.fontSize = style.fontSize;
        toNode.style.fontWeight = style.fontWeight;
        toNode.style.fontStyle = style.fontStyle;
        toNode.style.fontSizeAdjust = style.fontSizeAdjust;
        toNode.style.fontStretch = style.fontStretch;
        toNode.style.fontVariant = style.fontVariant;
        toNode.style.MozFontFeatureSettings = style.MozFontFeatureSettings;

        return style;
    }
};

Css.copyBoxStyles = function(fromNode, toNode, style)
{
    var view = fromNode.ownerDocument.defaultView;
    if (view)
    {
        if (!style)
            style = view.getComputedStyle(fromNode, "");

        toNode.style.marginTop = style.marginTop;
        toNode.style.marginRight = style.marginRight;
        toNode.style.marginBottom = style.marginBottom;
        toNode.style.marginLeft = style.marginLeft;
        toNode.style.borderTopWidth = style.borderTopWidth;
        toNode.style.borderRightWidth = style.borderRightWidth;
        toNode.style.borderBottomWidth = style.borderBottomWidth;
        toNode.style.borderLeftWidth = style.borderLeftWidth;
        toNode.style.unicodeBidi = style.unicodeBidi;

        return style;
    }
};

Css.readBoxStyles = function(style)
{
    const styleNames = {
        "margin-top": "marginTop", "margin-right": "marginRight",
        "margin-left": "marginLeft", "margin-bottom": "marginBottom",
        "border-top-width": "borderTop", "border-right-width": "borderRight",
        "border-left-width": "borderLeft", "border-bottom-width": "borderBottom",
        "padding-top": "paddingTop", "padding-right": "paddingRight",
        "padding-left": "paddingLeft", "padding-bottom": "paddingBottom",
        "z-index": "zIndex"
    };

    var styles = {};
    for (var styleName in styleNames)
        styles[styleNames[styleName]] = parseInt(style.getPropertyCSSValue(styleName).cssText) || 0;

    if (FBTrace.DBG_INSPECT)
        FBTrace.sysout("readBoxStyles ", styles);

    return styles;
};

Css.getBoxFromStyles = function(style, element)
{
    var args = Css.readBoxStyles(style);
    args.width = element.offsetWidth
        - (args.paddingLeft+args.paddingRight+args.borderLeft+args.borderRight);
    args.height = element.offsetHeight
        - (args.paddingTop+args.paddingBottom+args.borderTop+args.borderBottom);
    return args;
};

Css.getElementCSSSelector = function(element)
{
    if (!element || !element.localName)
        return "null";

    var label = Xml.getLocalName(element);
    if (element.id)
        label += "#" + element.id;

    if (element.classList)
    {
        for (var i=0, len=element.classList.length; i<len; ++i)
            label += "." + element.classList[i];
    }

    return label;
};

Css.getElementCSSPath = function(element)
{
    var paths = [];

    for (; element && element.nodeType == Node.ELEMENT_NODE; element = element.parentNode)
    {
        var selector = Css.getElementCSSSelector(element);
        paths.splice(0, 0, selector);
    }

    return paths.length ? paths.join(" ") : null;
};

// ********************************************************************************************* //
// CSS classes

var classNameReCache={};

Css.hasClass = function(node, name)
{
    if (!node || node.nodeType != Node.ELEMENT_NODE || !node.className || !name)
        return false;

    if (name.indexOf(" ") != -1)
    {
        var classes = name.split(" "), len = classes.length, found=false;
        for (var i = 0; i < len; i++)
        {
            var cls = classes[i].trim();
            if (cls != "")
            {
                if (Css.hasClass(node, cls) == false)
                    return false;
                found = true;
            }
        }
        return found;
    }

    var re;
    if (name.indexOf("-") == -1)
        re = classNameReCache[name] = classNameReCache[name] || new RegExp('(^|\\s)' + name + '(\\s|$)', "g");
    else // XXXsroussey don't cache these, they are often setting values. Should be using setUserData/getUserData???
        re = new RegExp('(^|\\s)' + name + '(\\s|$)', "g");
    return node.className.search(re) != -1;
};

Css.setClass = function(node, name)
{
    if (!node || node.nodeType != Node.ELEMENT_NODE || name == '')
        return;

    if (name.indexOf(" ") != -1)
    {
        var classes = name.split(" "), len = classes.length;
        for (var i = 0; i < len; i++)
        {
            var cls = classes[i].trim();
            if (cls != "")
            {
                Css.setClass(node, cls);
            }
        }
        return;
    }
    if (!Css.hasClass(node, name))
        node.className = node.className.trim() + " " + name;
};

Css.getClassValue = function(node, name)
{
    var re = new RegExp(name+"-([^ ]+)");
    var m = re.exec(node.className);
    return m ? m[1] : "";
};

Css.removeClass = function(node, name)
{
    if (!node || node.nodeType != Node.ELEMENT_NODE || node.className == '' || name == '')
        return;

    if (name.indexOf(" ") != -1)
    {
        var classes = name.split(" "), len = classes.length;
        for (var i = 0; i < len; i++)
        {
            var cls = classes[i].trim();
            if (cls != "")
            {
                if (Css.hasClass(node, cls) == false)
                    Css.removeClass(node, cls);
            }
        }
        return;
    }

    var re;
    if (name.indexOf("-") == -1)
        re = classNameReCache[name] = classNameReCache[name] || new RegExp('(^|\\s)' + name + '(\\s|$)', "g");
    else // XXXsroussey don't cache these, they are often setting values. Should be using setUserData/getUserData???
        re = new RegExp('(^|\\s)' + name + '(\\s|$)', "g");

    node.className = node.className.replace(re, " ");

};

Css.toggleClass = function(elt, name)
{
    if (Css.hasClass(elt, name))
        Css.removeClass(elt, name);
    else
        Css.setClass(elt, name);
};

Css.obscure = function(elt, obscured)
{
    if (obscured)
        Css.setClass(elt, "obscured");
    else
        Css.removeClass(elt, "obscured");
};

Css.setClassTimed = function(elt, name, context, timeout)
{
    if (FBTrace.DBG_HTML || FBTrace.DBG_SOURCEFILES)
    {
        FBTrace.sysout("css.setClassTimed elt.__setClassTimeout: "+elt.__setClassTimeout+
                " Xml.isVisible(elt): "+Xml.isVisible(elt)+
                " elt.__invisibleAtSetPoint: "+elt.__invisibleAtSetPoint);
    }

    if (!timeout)
        timeout = 1300;

    if (elt.__setClassTimeout)  // then we are already waiting to remove the class mark
        context.clearTimeout(elt.__setClassTimeout);  // reset the timer
    else                        // then we are not waiting to remove the mark
        Css.setClass(elt, name);

    if (!Xml.isVisible(elt))
    {
        if (elt.__invisibleAtSetPoint)
            elt.__invisibleAtSetPoint--;
        else
            elt.__invisibleAtSetPoint = 5;
    }
    else
    {
        delete elt.__invisibleAtSetPoint;
    }

    elt.__setClassTimeout = context.setTimeout(function()
    {
        delete elt.__setClassTimeout;

        if (elt.__invisibleAtSetPoint)  // then user can't see it, try again later
            Css.setClassTimed(elt, name, context, timeout);
        else
        {
            delete elt.__invisibleAtSetPoint;  // may be zero
            Css.removeClass(elt, name);
        }
    }, timeout);
};

Css.cancelClassTimed = function(elt, name, context)
{
    if (elt.__setClassTimeout)
    {
        Css.removeClass(elt, name);
        context.clearTimeout(elt.__setClassTimeout);
        delete elt.__setClassTimeout;
    }
};

Css.safeGetCSSRules = function(styleSheet)
{
    try
    {
        return styleSheet.cssRules;
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("safeGetCSSRules "+e, e);
    }

    return null;
};

Css.isValidStylesheet = function(styleSheet)
{
    try
    {
        var dummy = styleSheet.cssRules; // Mozilla throws
        return true;
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("isValidStylesheet "+e, e);
    }

    return false;
};

// ********************************************************************************************* //
// Stylesheet API

Css.shouldIgnoreSheet = function(sheet)
{
    // Ignore by the regular method, except for default stylesheets that are
    // used in case there is no other stylesheet.
    if (sheet.defaultStylesheet)
        return false;
    return (sheet.ownerNode && Firebug.shouldIgnore(sheet.ownerNode));
};

Css.createStyleSheet = function(doc, url)
{
    var style = doc.createElementNS("http://www.w3.org/1999/xhtml", "style");
    style.setAttribute("charset", "utf-8");
    style.setAttribute("type", "text/css");

    var cssText = url ? Http.getResource(url) : null;
    if (cssText)
    {
        var index = url.lastIndexOf("/");
        var absURL = url.substr(0, index+1);

        // Replace all relative URLs with absolute (using the passed url).
        // Note that stylesheets can come from various extensions and the source can
        // be even used in a browser env where relative URLs make more sense.
        var expr = /url\(([\'"]?)(?![\'"]?(?:[a-z]+:|\/))/gi;
        cssText = cssText.replace(expr, "url($1" + absURL);

        style.textContent = cssText;
    }

    Firebug.setIgnored(style);
    return style;
};

Css.addStyleSheet = function(doc, style)
{
    var heads = doc.getElementsByTagName("head");
    if (heads.length)
    {
        heads[0].appendChild(style);
    }
    else if (doc.documentElement)
    {
        doc.documentElement.appendChild(style);
    }
    else
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("css.addStyleSheet; ERROR to append a stylesheet");
    }
};

Css.appendStylesheet = function(doc, uri)
{
    // Make sure the stylesheet is not appended twice.
    var styleSheet = doc.getElementById(uri);
    if (styleSheet)
        return styleSheet;

    var styleSheet = Css.createStyleSheet(doc, uri);
    styleSheet.setAttribute("id", uri);
    Css.addStyleSheet(doc, styleSheet);

    return styleSheet;
},

Css.getStyleSheetByHref = function(url, context)
{
    if (!context.styleSheetMap)
        Css.createStyleSheetMap(context);  // fill cache

    // hasOwnProperty is called to prevent possible conflicts with prototype extensions
    // and strict mode warnings
    return context.styleSheetMap.hasOwnProperty(url) ? context.styleSheetMap[url] : undefined;
};

Css.createStyleSheetMap = function(context)
{
    context.styleSheetMap = {};

    function addSheet(sheet)
    {
        var sheetURL = Css.getURLForStyleSheet(sheet);
        context.styleSheetMap[sheetURL] = sheet;

        // recurse for imported sheets

        for (var i = 0; i < sheet.cssRules.length; ++i)
        {
            var rule = sheet.cssRules[i];
            if (rule instanceof CSSStyleRule)
            {
                if (rule.type == CSSRule.STYLE_RULE)  // once we get here no more imports
                    return;
            }
            else if (rule instanceof CSSImportRule)
            {
                addSheet(rule.styleSheet);
            }
        }
    }

    Win.iterateWindows(context.window, function(subwin)
    {
        var rootSheets = subwin.document.styleSheets;
        if (!rootSheets)
            return; // XUL?

        for (var i = 0; i < rootSheets.length; ++i)
        {
            try
            {
                addSheet(rootSheets[i]);
            }
            catch (err)
            {
                //if (FBTrace.DBG_ERRORS)
                //    FBTrace.sysout("css.createStyleSheetMap; EXCEPTION " + err, err);
            }
        }
    });

    if (FBTrace.DBG_ERRORS && FBTrace.DBG_CSS)
        FBTrace.sysout("css.createStyleSheetMap for "+context.getName(), context.styleSheetMap);

    return context.styleSheetMap;
};

Css.getAllStyleSheets = function(context)
{
    if (!context)
        return [];

    var styleSheets = [];

    var showUACSS = Options.get("showUserAgentCSS");
    function addSheet(sheet)
    {
        var sheetLocation =  Css.getURLForStyleSheet(sheet);

        if (!showUACSS && Url.isSystemURL(sheetLocation))
            return;

        if (Css.shouldIgnoreSheet(sheet))
            return;

        styleSheets.push(sheet);

        try
        {
            for (var i = 0; i < sheet.cssRules.length; ++i)
            {
                var rule = sheet.cssRules[i];
                if (rule instanceof window.CSSImportRule)
                    addSheet(rule.styleSheet);
            }
        }
        catch(e)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("getAllStyleSheets sheet.cssRules FAILS for "+
                    (sheet?sheet.href:"null sheet")+e, e);
        }
    }

    Win.iterateWindows(context.window, function(subwin)
    {
        var rootSheets = subwin.document.styleSheets;
        for (var i = 0; i < rootSheets.length; ++i)
            addSheet(rootSheets[i]);
    });

    return styleSheets;
};

Css.getURLForStyleSheet = function(styleSheet)
{
    // http://www.w3.org/TR/DOM-Level-2-Style/stylesheets.html#StyleSheets-StyleSheet.
    // For inline style sheets, the value of this attribute is null.
    if (!styleSheet.href && !styleSheet.ownerNode)
        return null;

    return (styleSheet.href ? styleSheet.href : styleSheet.ownerNode.ownerDocument.documentURI);
};

/**
 * Retrieves the instance number for a given style sheet. The instance number
 * is sheet's index within the set of all other sheets whose URL is the same.
 */
Css.getInstanceForStyleSheet = function(styleSheet, ownerDocument)
{
    // ownerDocument is an optional hint for performance
    if (FBTrace.DBG_CSS)
    {
        FBTrace.sysout("getInstanceForStyleSheet href:" + styleSheet.href + " mediaText:" +
            styleSheet.media.mediaText + " path to ownerNode" +
            (styleSheet.ownerNode && Xpath.getElementXPath(styleSheet.ownerNode)), ownerDocument);
    }

    ownerDocument = ownerDocument || Css.getDocumentForStyleSheet(styleSheet);
    if (!ownerDocument)
        return;

    var ret = 0,
        styleSheets = ownerDocument.styleSheets,
        href = styleSheet.href;

    for (var i = 0; i < styleSheets.length; i++)
    {
        var curSheet = styleSheets[i];

        if (FBTrace.DBG_CSS)
        {
            FBTrace.sysout("getInstanceForStyleSheet: compare href " + i +
                " " + curSheet.href + " " + curSheet.media.mediaText + " " +
                (curSheet.ownerNode && Xpath.getElementXPath(curSheet.ownerNode)));
        }

        if (Css.shouldIgnoreSheet(curSheet))
            break;

        if (curSheet == styleSheet)
            break;

        if (curSheet.href == href)
            ret++;
    }
    return ret;
};

Css.getDocumentForStyleSheet = function(styleSheet)
{
    if (!styleSheet)
        return;

    while (styleSheet.parentStyleSheet && !styleSheet.ownerNode)
        styleSheet = styleSheet.parentStyleSheet;

    if (styleSheet.ownerNode)
        return styleSheet.ownerNode.ownerDocument;
};

// ********************************************************************************************* //

Css.stripUnits = function(value)
{
    // remove units from '0px', '0em' etc. leave non-zero units in-tact.
    return value.replace(/(url\(.*?\)|[^0]\S*\s*)|0(%|em|ex|px|in|cm|mm|pt|pc)(\s|$)/gi,
        function(_, skip, remove, whitespace)
        {
            return skip || ('0' + whitespace);
        }
    );
};

Css.extractURLs = function(value)
{
    var urls = [];
    var urlValues = value.match(/url\((["']).*?\1\)/g);

    for (var i in urlValues)
        urls.push(urlValues[i].replace(/url\((["'])(.*?)\1\)/, "$2"));

    return urls;
};

Css.colorNameToRGB = function(value)
{
    if (!domUtils.colorNameToRGB)
        return value;

    var reSplit = /(\(|,|\)|\s)/;
    var parts = value.split(reSplit);

    var newValue = "";
    for (var i=0, len=parts.length; i<len; ++i)
    {
        var part = parts[i];
        if (part === "transparent")
        {
            newValue += "rgba(0, 0, 0, 0)";
        }
        else
        {
            if (Css.isColorKeyword(part))
            {
                try
                {
                    var rgbValue = domUtils.colorNameToRGB(part);
                    newValue += "rgb(" + rgbValue.r + ", " + rgbValue.g + ", " + rgbValue.b + ")";
                }
                catch(e)
                {
                    // Color keyword is a system color, which can't be resolved by
                    // domUtils.colorNameToRGB(), so just return the keyword itself
                    // (see issue 6753)
                    newValue += part;
                }
            }
            else
            {
                newValue += part;
            }
        }
    }

    return newValue;
};

Css.rgbToHex = function(value)
{
    function convertRGBToHex(r, g, b)
    {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + (b << 0)).
            toString(16).substr(-6).toUpperCase();
    }

    value = Css.colorNameToRGB(value);

    return value.replace(/\brgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)/gi,
        function(_, r, g, b) {
            return convertRGBToHex(r, g, b);
        });
};

Css.rgbToHSL = function(value)
{
    function convertRGBToHSL(r, g, b, a)
    {
        r = parseInt(r);
        g = parseInt(g);
        b = parseInt(b);

        var gray = (r == g && g == b);

        r /= 255;
        g /= 255;
        b /= 255;

        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);

        var h = 0;
        var s = 0;
        var l = (max+min)/2;

        if (!gray)
        {
            var delta = max - min;
            s = l > 0.5 ? delta/(2-max-min) : delta/(max+min);

            switch (max)
            {
                case r:
                    h = (g-b)/delta + (g < b ? 6 : 0);
                    break;

                case g:
                    h = (b-r)/delta + 2;
                    break;

                case b:
                    h = (r-g)/delta + 4;
                    break;
            }
        }

        h = Math.round(h * 60);
        s = Math.round(s * 100);
        l = Math.round(l * 100);

        if (a)
            return "hsla("+h+", "+s+"%, "+l+"%, "+a+")";
        else
            return "hsl("+h+", "+s+"%, "+l+"%)";
    }

    value = Css.colorNameToRGB(value);

    return value.replace(/\brgba?\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})(,\s*(\d.\d+|\d))?\)/gi,
        function(_, r, g, b, _, a)
        {
            return convertRGBToHSL(r, g, b, a);
        });
};

// ********************************************************************************************* //
// CSS Info

Css.cssInfo = {};
Css.cssInfo.html =
{
    "animation": [],
    "animation-delay": [],
    "animation-direction": ["normal", "alternate", "reverse", "alternate-reverse"],
    "animation-duration": [],
    "animation-iteration-count": ["infinite"],
    "animation-name" : ["none"],
    "animation-play-state": ["running", "paused"],
    "animation-timing-function": [],
    "animation-fill-mode": ["none", "forwards", "backwards", "both"],

    "background": ["bgRepeat", "bgAttachment", "position", "color", "image", "none", "boxModels"],
    "background-attachment": ["bgAttachment"],
    "background-color": ["color"],
    "background-image": ["image", "none"],
    "background-position": ["position", "length"],
    "background-repeat": ["bgRepeat"],
    "background-size": ["bgSize", "length"],
    "background-clip": ["boxModels"], // FF 4.0
    "background-origin": ["boxModels"], // FF 4.0

    "border": ["borderStyle", "thickness", "color"],
    "border-top": ["borderStyle", "borderCollapse", "color"],
    "border-right": ["borderStyle", "borderCollapse", "color"],
    "border-bottom": ["borderStyle", "borderCollapse", "color"],
    "border-left": ["borderStyle", "borderCollapse", "color"],
    "border-collapse": ["borderCollapse"],
    "border-color": ["color"],
    "border-top-color": ["color"],
    "border-right-color": ["color"],
    "border-bottom-color": ["color"],
    "border-left-color": ["color"],
    "border-spacing": ["length"],
    "border-style": ["borderStyle"],
    "border-top-style": ["borderStyle"],
    "border-right-style": ["borderStyle"],
    "border-bottom-style": ["borderStyle"],
    "border-left-style": ["borderStyle"],
    "border-width": ["thickness", "length"],
    "border-top-width": ["thickness", "length"],
    "border-right-width": ["thickness", "length"],
    "border-bottom-width": ["thickness", "length"],
    "border-left-width": ["thickness", "length"],
    "border-radius": ["length"], // FF 4.0
    "border-top-left-radius": ["length"], // FF 4.0
    "border-top-right-radius": ["length"], // FF 4.0
    "border-bottom-right-radius": ["length"], // FF 4.0
    "border-bottom-left-radius": ["length"], // FF 4.0
    "border-image": ["borderImageRepeat", "thickness", "url()", "none"], // FF 15.0
    "border-image-outset": ["length"], // FF 15.0
    "border-image-repeat": ["borderImageRepeat"], // FF 15.0
    "border-image-slice": ["fill"],
    "border-image-source": ["image", "none"],
    "border-image-width": ["auto", "length"], // FF 15.0

    "top": ["auto", "length"],
    "right": ["auto", "length"],
    "bottom": ["auto", "length"],
    "left": ["auto", "length"],
    "height": ["auto", "length"],
    "caption-side": ["captionSide"],
    "clear": ["clear", "none"],
    "clip": ["shape", "auto"],
    "color": ["color"],
    "content": ["string", "none", "normal"],
    "counter-increment": ["none"],
    "counter-reset": ["none"],
    "cursor": ["cursor", "url()", "none"],
    "direction": ["direction"],
    "display": ["display"],
    "empty-cells": ["emptyCells"],
    "float": ["float"],

    "align-items": ["alignItems"],
    "align-self": ["alignSelf"],
    "flex": ["flexBasis"],
    "flex-basis": ["flexBasis"],
    "flex-direction": ["flexDirection"],
    "flex-grow": [],
    "flex-shrink": [],
    "justify-content": ["justifyContent"],
    "order": [],

    // specification of font families in "font" is special-cased
    "font": ["fontStyle", "fontVariant", "namedFontWeight", "fontSize", "lineHeight", "mozFont"],
    "font-family": ["fontFamily"],
    "font-size": ["fontSize", "length"],
    "font-size-adjust": ["none"],
    "font-stretch": ["fontStretch"],
    "font-style": ["fontStyle"],
    "font-variant": ["fontVariant"],
    "font-weight": ["fontWeight"],

    "ime-mode": ["imeMode"], // FF 3.0
    "letter-spacing": ["normal", "length"],
    "line-height": ["lineHeight", "length"],
    "word-break": ["wordBreak"],

    "list-style": ["listStyleType", "listStylePosition"],
    "list-style-image": ["url()", "none"],
    "list-style-position": ["listStylePosition"],
    "list-style-type": ["listStyleType"],

    "margin": ["auto", "length"],
    "margin-top": ["auto", "length"],
    "margin-right": ["auto", "length"],
    "margin-bottom": ["auto", "length"],
    "margin-left": ["auto", "length"],

    "marker-offset": ["auto", "length"],
    "min-height": ["length"],
    "max-height": ["none", "length"],
    "min-width": ["width", "length"],
    "max-width": ["width", "none", "length"],

    "opacity": [],

    "outline": ["color", "borderStyle", "thickness", "auto"],
    "outline-color": ["color"],
    "outline-style": ["borderStyle", "auto"],
    "outline-width": ["thickness", "length"],
    "outline-offset": ["length"],

    "overflow": ["overflow", "auto"],
    "overflow-x": ["overflow", "auto"],
    "overflow-y": ["overflow", "auto"],

    "padding": ["length"],
    "padding-top": ["length"],
    "padding-right": ["length"],
    "padding-bottom": ["length"],
    "padding-left": ["length"],

    "page-break-after": ["pageBreak"],
    "page-break-before": ["pageBreak"],
    "pointer-events": ["auto", "none"],
    "position": ["elPosition"],
    "quotes": ["none"],
    "resize": ["resize"], // FF 4.0
    "table-layout": ["tableLayout"],
    "text-align": ["textAlign"],
    "-moz-text-align-last": ["textAlign"], // FF 12.0
    "box-shadow": ["boxShadow", "color", "none", "length"], // FF 4.0
    "text-decoration": ["textDecoration"],
    "text-indent": ["length"],
    "text-rendering": ["textRendering"],
    "text-shadow": ["color", "length"],
    "text-transform": ["textTransform"],
    "transition": ["transitionProperty", "timingFunction"],
    "transition-property": ["transitionProperty"],
    "transition-duration": [],
    "transition-timing-function": ["timingFunction"],
    "transition-delay": [],
    "transform": ["transformFunction", "none", "length"],
    "transform-origin": ["position", "length"],
    "transform-style": ["transformStyle"],
    "unicode-bidi": ["unicodeBidi"],
    "vertical-align": ["verticalAlign", "length"],
    "visibility": ["visibility"],
    "white-space": ["whiteSpace"],
    "width": ["width", "length", "auto"],
    "word-spacing": ["normal", "length"],
    "word-wrap": ["wordWrap"], // FF 3.5
    "z-index": ["auto"],

    "-moz-appearance": ["mozAppearance"],
    "-moz-backface-visibility": ["mozBackfaceVisibility"], // FF 10.0
    "-moz-border-top-colors": ["color"],
    "-moz-border-right-colors": ["color"],
    "-moz-border-bottom-colors": ["color"],
    "-moz-border-left-colors": ["color"],
    "-moz-border-start": ["borderStyle", "borderCollapse", "color", "none"],
    "-moz-border-end": ["borderStyle", "borderCollapse", "color", "none"],
    "-moz-border-start-color": ["color"],
    "-moz-border-end-color": ["color"],
    "-moz-border-start-style": ["borderStyle"],
    "-moz-border-end-style": ["borderStyle"],
    "-moz-border-start-width": ["thickness"],
    "-moz-border-end-width": ["thickness"],
    "-moz-box-align": ["mozBoxAlign"],
    "-moz-box-direction": ["mozBoxDirection"],
    "-moz-box-flex": [],
    "-moz-box-ordinal-group": [],
    "-moz-box-orient": ["mozBoxOrient"],
    "-moz-box-pack": ["mozBoxPack"],
    "-moz-box-sizing": ["mozBoxSizing"],
    "-moz-user-focus": ["userFocus", "none"],
    "-moz-user-input": ["userInput", "none"],
    "-moz-user-modify": ["mozUserModify"],
    "-moz-user-select": ["userSelect", "none"],
    "-moz-background-inline-policy": [],
    "-moz-binding": ["url()", "none"],
    "-moz-columns": ["auto", "length"],
    "-moz-column-count": ["auto"],
    "-moz-column-gap": ["normal", "length"],
    "-moz-column-rule": ["thickness", "borderStyle", "color"],
    "-moz-column-rule-width": ["thickness", "length"],
    "-moz-column-rule-style": ["borderStyle"],
    "-moz-column-rule-color": ["color"],
    "-moz-column-width": ["auto", "length"],
    "-moz-image-region": ["rect()"],
    "-moz-font-feature-settings": ["mozFontFeatureSettings"], // FF 4.0
    "-moz-font-language-override": ["normal"],
    "-moz-tab-size": [], // FF 4.0,
    "orient": ["horizontal", "vertical"], // FF 6.0
    "-moz-text-blink": ["none", "blink"], // FF 6.0
    "-moz-text-decoration-color": ["color"], // FF 6.0
    "-moz-text-decoration-line": ["mozTextDecorationLine"], // FF 6.0
    "-moz-text-decoration-style": ["mozTextDecorationStyle"], // FF 6.0
    "-moz-hyphens": ["mozHyphens"], // FF 6.0
    "text-overflow": ["textOverflow"], // FF 7.0
    "-moz-perspective": ["none", "length"], // FF 10.0
    "-moz-perspective-origin": ["position", "length"] // FF 10.0
};

// ::-moz-progress-bar  // FF 6 TODO

Css.cssInfo.svg =
{
    "alignment-baseline": ["svgAlignmentBaseline"],
    "baseline-shift": ["baselineShift"],
    "clip": ["auto", "length"],
    "clip-path": ["url()", "none"],
    "clip-rule": ["clipRule"],
    "color": ["color"],
    "color-interpolation": ["colorInterpolation"],
    "color-interpolation-filters": ["colorInterpolation"],
    "color-profile": ["colorProfile"],
    "color-rendering": ["colorRendering"],
    "cursor": ["cursor", "url()"],
    "direction": ["direction"],
    "display": ["display"],
    "dominant-baseline": ["dominantBaseline"],
    "enable-background": ["accumulate"],
    "fill": ["clipRule"],
    "fill-opacity": [],
    "fill-rule": ["clipRule"],
    "filter": ["url()", "none"],
    "flood-color": ["currentColor"],
    "flood-opacity": [],
    "font": ["fontStyle", "fontSize", "fontVariant", "namedFontWeight"],
    "font-family": ["fontFamily"],
    "font-size": ["fontSize"],
    "font-size-adjust": [],
    "font-stretch": ["fontStretch"],
    "font-style": ["fontStyle"],
    "font-variant": ["fontVariant"],
    "font-weight": ["fontWeight"],
    "glyph-orientation-horizontal": [],
    "glyph-orientation-vertical": ["auto"],
    "image-rendering": ["imageRendering"], // FF 3.6
    "kerning": ["auto"],
    "letter-spacing": ["normal"],
    "lighting-color": ["currentColor"],
    "marker": ["none"],
    "marker-end": ["none"],
    "mask": ["url()", "none"],
    "opacity": [],
    "overflow": ["auto", "svgOverflow"],
    "pointer-events": ["pointerEvents"], // FF 1.5/3.6
    "shape-rendering": ["auto", "shapeRendering"],
    "stop-color": ["currentColor"],
    "stop-opacity": [],
    "stroke": [],
    "stroke-dasharray": ["none"],
    "stroke-dashoffset": [],
    "stroke-linecap": ["strokeLinecap"],
    "stroke-linejoin": ["strokeLinejoin"],
    "stroke-miterlimit": [],
    "stroke-opacity": [],
    "stroke-width": [],
    "text-anchor": ["mozBoxPack"],
    "text-decoration": ["textDecoration"],
    "text-rendering": ["textRendering"],
    "unicode-bidi": ["unicodeBidi"],
    "visibility": ["visibility"],
    "word-spacing": ["normal"],
    "writing-mode": ["writingMode"]
};

Css.multiValuedProperties =
{
    "animation": 1,
    "background": 1,
    "background-position": 1,
    "border": 1,
    "border-color": 1,
    "border-style": 1,
    "border-width": 1,
    "border-radius": 1,
    "box-shadow": 1,
    "font": 1,
    "font-family": 1,
    "margin": 1,
    "padding": 1
};

Css.unitlessProperties =
{
    "counter-increment": 1,
    "counter-reset": 1,
    "font-size-adjust": 1,
    "font-weight": 1,
    "line-height": 1,
    "opacity": 1,
    "orphans": 1,
    "widows": 1,
    "z-index": 1,
    "-moz-column-count": 1
};

Css.cssKeywords =
{
    "mozAppearance":
    [
        "none",
        "button",
        "button-arrow-down",
        "button-arrow-next",
        "button-arrow-previous",
        "button-arrow-up",
        "button-bevel",
        "button-focus",
        "caret",
        "checkbox",
        "checkbox-container",
        "checkbox-label",
        "checkmenuitem",
        "dualbutton",
        "groupbox",
        "listbox",
        "listitem",
        "menuarrow",
        "menubar",
        "menucheckbox",
        "menuimage",
        "menuitem",
        "menuitemtext",
        "menulist",
        "menulist-button",
        "menulist-text",
        "menulist-textfield",
        "menupopup",
        "menuradio",
        "menuseparator",
        "meterbar",
        "meterchunk",
        "progressbar",
        "progressbar-vertical",
        "progresschunk",
        "progresschunk-vertical",
        "radio",
        "radio-container",
        "radio-label",
        "radiomenuitem",
        "resizer",
        "resizerpanel",
        "scale-horizontal",
        "scalethumbend",
        "scalethumb-horizontal",
        "scalethumbstart",
        "scalethumbtick",
        "scalethumb-vertical",
        "scale-vertical",
        "scrollbarbutton-down",
        "scrollbarbutton-left",
        "scrollbarbutton-right",
        "scrollbarbutton-up",
        "scrollbarthumb-horizontal",
        "scrollbarthumb-vertical",
        "scrollbartrack-horizontal",
        "scrollbartrack-vertical",
        "searchfield",
        "separator",
        "sheet",
        "spinner",
        "spinner-downbutton",
        "spinner-textfield",
        "spinner-upbutton",
        "splitter",
        "statusbar",
        "statusbarpanel",
        "tab",
        "tabpanel",
        "tabpanels",
        "tab-scroll-arrow-back",
        "tab-scroll-arrow-forward",
        "textfield",
        "textfield-multiline",
        "toolbar",
        "toolbarbutton",
        "toolbarbutton-dropdown",
        "toolbargripper",
        "toolbox",
        "tooltip",
        "treeheader",
        "treeheadercell",
        "treeheadersortarrow",
        "treeitem",
        "treeline",
        "treetwisty",
        "treetwistyopen",
        "treeview",

        "-moz-mac-unified-toolbar",
        "-moz-win-borderless-glass", // FF 4.0
        "-moz-win-browsertabbar-toolbox",
        "-moz-win-communicationstext",
        "-moz-win-communications-toolbox",
        "-moz-win-exclude-glass", // FF 6.0
        "-moz-win-glass",
        "-moz-win-mediatext",
        "-moz-win-media-toolbox",
        "-moz-window-button-box",
        "-moz-window-button-box-maximized",
        "-moz-window-button-close",
        "-moz-window-button-maximize",
        "-moz-window-button-minimize",
        "-moz-window-button-restore",
        "-moz-window-frame-bottom",
        "-moz-window-frame-left",
        "-moz-window-frame-right",
        "-moz-window-titlebar",
        "-moz-window-titlebar-maximized"
    ],

    "mozBackfaceVisibility":
    [
        "visible",
        "hidden"
    ],

    "color":
    [
        // Color functions
        "rgb()",
        "rgba()",
        "hsl()",
        "hsla()",

        // Color keywords
        "aliceblue",
        "antiquewhite",
        "aqua",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "black",
        "blanchedalmond",
        "blue",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkgrey",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkslategrey",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dimgrey",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "fuchsia",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "gray",
        "green",
        "greenyellow",
        "grey",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightgrey",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightslategrey",
        "lightsteelblue",
        "lightyellow",
        "lime",
        "limegreen",
        "linen",
        "magenta",
        "maroon",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "navy",
        "oldlace",
        "olive",
        "olivedrab",
        "orange",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "purple",
        "red",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "silver",
        "skyblue",
        "slateblue",
        "slategray",
        "slategrey",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "teal",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "white",
        "whitesmoke",
        "yellow",
        "yellowgreen",

        // Special color keywords
        "transparent",
        "currentColor",

        // System colors
        "ActiveBorder",
        "ActiveCaption",
        "AppWorkspace",
        "Background",
        "ButtonFace",
        "ButtonHighlight",
        "ButtonShadow",
        "ButtonText",
        "CaptionText",
        "GrayText",
        "Highlight",
        "HighlightText",
        "InactiveBorder",
        "InactiveCaption",
        "InactiveCaptionText",
        "InfoBackground",
        "InfoText",
        "Menu",
        "MenuText",
        "Scrollbar",
        "ThreeDDarkShadow",
        "ThreeDFace",
        "ThreeDHighlight",
        "ThreeDLightShadow",
        "ThreeDShadow",
        "Window",
        "WindowFrame",
        "WindowText",

        // Mozilla system color extensions
        "-moz-ButtonDefault",
        "-moz-ButtonHoverFace",
        "-moz-ButtonHoverText",
        "-moz-CellHighlight",
        "-moz-CellHighlightText",
        "-moz-Combobox",
        "-moz-ComboboxText",
        "-moz-Dialog",
        "-moz-DialogText",
        "-moz-dragtargetzone",
        "-moz-EvenTreeRow",
        "-moz-Field",
        "-moz-FieldText",
        "-moz-html-CellHighlight",
        "-moz-html-CellHighlightText",
        "-moz-mac-accentdarkestshadow",
        "-moz-mac-accentdarkshadow",
        "-moz-mac-accentface",
        "-moz-mac-accentlightesthighlight",
        "-moz-mac-accentlightshadow",
        "-moz-mac-accentregularhighlight",
        "-moz-mac-accentregularshadow",
        "-moz-mac-chrome-active",
        "-moz-mac-chrome-inactive",
        "-moz-mac-focusring",
        "-moz-mac-menuselect",
        "-moz-mac-menushadow",
        "-moz-mac-menutextselect",
        "-moz-MenuHover",
        "-moz-MenuHoverText",
        "-moz-MenuBarText",
        "-moz-MenuBarHoverText",
        "-moz-nativehyperlinktext",
        "-moz-OddTreeRow",
        "-moz-win-communicationstext",
        "-moz-win-mediatext",

        // Mozilla color preference extensions
        "-moz-activehyperlinktext",
        "-moz-default-background-color", // FF 5.0
        "-moz-default-color", // FF 5.0
        "-moz-hyperlinktext",
        "-moz-visitedhyperlinktext"
    ],

    "auto":
    [
        "auto"
    ],

    "none":
    [
        "none"
    ],

    "normal":
    [
        "normal"
    ],

    "captionSide":
    [
        "top",
        "bottom",
        "left",
        "right"
    ],

    "emptyCells":
    [
        "show",
        "hide",
        "-moz-show-background"
    ],

    "alignItems":
    [
        "flex-start",
        "flex-end",
        "center",
        "baseline",
        "stretch"
    ],

    "alignSelf":
    [
        "auto",
        "flex-start",
        "flex-end",
        "center",
        "baseline",
        "stretch"
    ],

    "flexBasis":
    [
        "initial",
        "auto"
    ],

    "flexDirection":
    [
        "row",
        "row-reverse",
        "column",
        "column-reverse"
    ],

    "justifyContent":
    [
        "flex-start",
        "flex-end",
        "center",
        "space-between",
        "space-around"
    ],

    "clear":
    [
        "left",
        "right",
        "both"
    ],

    "cursor":
    [
        "auto",
        "default",
        "pointer",
        "text",
        "crosshair",
        "move",
        "help",
        "no-drop",
        "not-allowed",
        "none", // FF 3.0
        "-moz-grab",
        "-moz-grabbing",
        "-moz-zoom-in",
        "-moz-zoom-out",
        "e-resize",
        "all-scroll",
        "ne-resize",
        "nw-resize",
        "n-resize",
        "se-resize",
        "sw-resize",
        "s-resize",
        "w-resize",
        "ew-resize",
        "ns-resize",
        "nesw-resize",
        "nwse-resize",
        "col-resize",
        "row-resize",
        "cell",
        "context-menu",
        "progress",
        "vertical-text",
        "wait",
        "copy",
        "alias"
    ],

    "boxModels": // FF 4.0
    [
        "padding-box",
        "border-box",
        "content-box"
    ],

    "direction":
    [
        "ltr",
        "rtl"
    ],

    "bgAttachment":
    [
        "scroll",
        "fixed"
    ],

    "position":
    [
        "top",
        "center",
        "bottom",
        "left",
        "right"
    ],

    "bgRepeat":
    [
        "repeat",
        "repeat-x",
        "repeat-y",
        "no-repeat"
    ],

    "bgSize": // FF 4.0
    [
        "auto",
        "cover",
        "contain"
    ],

    "borderStyle":
    [
        "solid",
        "none",
        "dotted",
        "dashed",
        "double",
        "hidden",
        "groove",
        "ridge",
        "inset",
        "outset",
        "-moz-bg-inset",
        "-moz-bg-outset",
        "-moz-bg-solid"
    ],

    "borderCollapse":
    [
        "collapse",
        "separate"
    ],

    "overflow":
    [
        "visible",
        "hidden",
        "scroll",
        "auto",
        "-moz-hidden-unscrollable"
    ],

    "listStyleType":
    [
        "none",
        "disc",
        "circle",
        "square",
        "decimal",
        "decimal-leading-zero",
        "lower-roman",
        "upper-roman",
        "lower-greek",
        "lower-alpha",
        "lower-latin",
        "upper-alpha",
        "upper-latin",
        "armenian",
        "georgian",
        "hebrew",
        "cjk-ideographic",
        "hiragana",
        "katakana",
        "hiragana-iroha",
        "katakana-iroha",
        "-moz-arabic-indic",
        "-moz-bengali",
        "-moz-cjk-earthly-branch",
        "-moz-cjk-heavenly-stem",
        "-moz-devanagari",
        "-moz-ethiopic-halehame",
        "-moz-ethiopic-halehame-am",
        "-moz-ethiopic-halehame-ti-er",
        "-moz-ethiopic-halehame-ti-et",
        "-moz-ethiopic-numeric",
        "-moz-gujarati",
        "-moz-gurmukhi",
        "-moz-hangul",
        "-moz-hangul-consonant",
        "-moz-japanese-formal",
        "-moz-japanese-informal",
        "-moz-kannada",
        "-moz-khmer",
        "-moz-lao",
        "-moz-malayalam",
        "-moz-myanmar",
        "-moz-oriya",
        "-moz-persian",
        "-moz-simp-chinese-formal",
        "-moz-simp-chinese-informal",
        "-moz-tamil",
        "-moz-telugu",
        "-moz-thai",
        "-moz-trad-chinese-formal",
        "-moz-trad-chinese-informal",
        "-moz-urdu"
    ],

    "listStylePosition":
    [
        "inside",
        "outside"
    ],

    "string":
    [
        "open-quote",
        "close-quote",
        "no-open-quote",
        "no-close-quote",
        "url()",
        "attr()",
        "counter()",
        "counters()"
    ],

    "fontStyle":
    [
        "normal",
        "italic",
        "oblique"
    ],

    "fontVariant":
    [
        "normal",
        "small-caps"
    ],

    // Named font-weight values, worth completing in "font"
    "namedFontWeight":
    [
        // Absolute keywords
        "normal",
        "bold",

        // Relative keywords
        "bolder",
        "lighter"
    ],

    "fontWeight":
    [
        // Absolute keywords
        "normal",
        "bold",

        // Relative keywords
        "bolder",
        "lighter",

        // Numeric values
        "100",
        "200",
        "300",
        "400",
        "500",
        "600",
        "700",
        "800",
        "900"
    ],

    "fontSize":
    [
        // Absolute size keywords
        "xx-small",
        "x-small",
        "small",
        "medium",
        "large",
        "x-large",
        "xx-large",

        // Relative size keywords
        "smaller",
        "larger"
    ],

    "lineHeight":
    [
        "normal"
    ],

    "wordBreak":
    [
        "normal",
        "break-all",
        "keep-all"
    ],

    "fontFamily":
    [
        // Common font families
        "Arial",
        "Comic Sans MS",
        "Georgia",
        "Tahoma",
        "Verdana",
        "Times New Roman",
        "Trebuchet MS",
        "Lucida Console",
        "Lucida Grande",
        "Helvetica",

        // Generic font families
        "serif",
        "sans-serif",
        "cursive",
        "fantasy",
        "monospace",

        // Additional font families
        "caption",
        "icon",
        "menu",
        "message-box",
        "small-caption",
        "status-bar",
        "-moz-fixed"
    ],

    "mozFont":
    [
        "-moz-button",
        "-moz-info",
        "-moz-desktop",
        "-moz-dialog",
        "-moz-document",
        "-moz-workspace",
        "-moz-window",
        "-moz-list",
        "-moz-pull-down-menu",
        "-moz-field"
    ],

    "display":
    [
        "block",
        "none",
        "inline",
        "inline-block",
        "list-item",
        "flex",
        "inline-flex",
        "marker",
        "run-in",
        "compact",
        "table",
        "inline-table",
        "table-row-group",
        "table-column",
        "table-column-group",
        "table-header-group",
        "table-footer-group",
        "table-row",
        "table-cell",
        "table-caption",
        "-moz-box",
        "-moz-compact",
        "-moz-deck",
        "-moz-grid",
        "-moz-grid-group",
        "-moz-grid-line",
        "-moz-groupbox",
        "-moz-inline-box",
        "-moz-inline-grid",
        "-moz-inline-stack",
        "-moz-marker",
        "-moz-popup",
        "-moz-stack"
    ],

    "elPosition":
    [
        "static",
        "relative",
        "absolute",
        "fixed"
    ],

    "float":
    [
        "left",
        "right",
        "none"
    ],

    "textAlign":
    [
        "left",
        "right",
        "center",
        "justify",
        "start",
        "end", // FF 3.6

        "-moz-center",
        "-moz-left",
        "-moz-right"
    ],

    "tableLayout":
    [
        "fixed",
        "auto"
    ],

    "textDecoration":
    [
        "none",
        "underline",
        "overline",
        "line-through",
        "blink",
        "-moz-anchor-decoration"
    ],

    "textTransform":
    [
        "capitalize",
        "lowercase",
        "uppercase",
        "none"
    ],

    "unicodeBidi":
    [
        "normal",
        "embed",
        "bidi-override",
        "-moz-isolate", // FF 10.0
        "-moz-plaintext" // FF 10.0
    ],

    "visibility":
    [
        "visible",
        "hidden",
        "collapse"
    ],

    "whiteSpace":
    [
        "normal",
        "pre",
        "nowrap",
        "pre-wrap", // FF 3.0
        "pre-line" // FF 3.5
    ],

    "verticalAlign":
    [
        "baseline",
        "sub",
        "super",
        "top",
        "middle",
        "bottom",
        "text-top",
        "text-bottom"
    ],

    "thickness":
    [
        "thin",
        "medium",
        "thick"
    ],

    "shape":
    [
        "rect()"
    ],

    "userFocus":
    [
        "ignore",
        "normal"
    ],

    "userInput":
    [
        "disabled",
        "enabled"
    ],

    "mozUserModify":
    [
        "read-only",
        "read-write",
        "write-only"
    ],

    "userSelect":
    [
        "text",
        "-moz-none",
        "all",
        "element"
    ],

    "mozBoxSizing":
    [
        "content-box",
        "padding-box",
        "border-box"
    ],

    "mozBoxAlign":
    [
        "start",
        "center",
        "end",
        "baseline",
        "stretch"
    ],

    "mozBoxDirection":
    [
        "normal",
        "reverse"
    ],

    "mozBoxOrient":
    [
        "horizontal",
        "vertical",
        "inline-axis",
        "block-axis"
    ],

    "mozBoxPack":
    [
        "start",
        "center",
        "end",
        "justify"
    ],

    "boxShadow":
    [
        "inset"
    ],

    "borderImageRepeat":
    [
        "stretch",
        "round",
        "repeat",
        "space"
    ],

    "image":
    [
        "url()",
        "linear-gradient()",
        "radial-gradient()",
        "repeating-linear-gradient()",
        "repeating-radial-gradient()",
        "-moz-linear-gradient()",
        "-moz-radial-gradient()",
        "-moz-repeating-linear-gradient()",
        "-moz-repeating-radial-gradient()",
        "-moz-image-rect()",
        "-moz-element()",
    ],

    "length":
    [
        "calc()"
    ],

    "transformFunction":
    [
        "matrix()",
        "matrix3d()",
        "rotate()",
        "rotateX()",
        "rotateY()",
        "rotateZ()",
        "scale()",
        "scaleX()",
        "scaleY()",
        "scaleZ()",
        "scale3d()",
        "scaleZ()",
        "skewX()",
        "skewY()",
        "translate()",
        "translateX()",
        "translateY()",
        "translateZ()"
    ],

    "mozFontFeatureSettings":
    [
        "normal",
        "on",
        "off",

        // Font features
        // Doesn't include cv01-cv99
        "\"aalt\"",
        "\"abvf\"",
        "\"abvm\"",
        "\"abvs\"",
        "\"afrc\"",
        "\"akhn\"",
        "\"blwf\"",
        "\"blwm\"",
        "\"blws\"",
        "\"calt\"",
        "\"case\"",
        "\"ccmp\"",
        "\"cfar\"",
        "\"cjct\"",
        "\"clig\"",
        "\"cpct\"",
        "\"cpsp\"",
        "\"cswh\"",
        "\"curs\"",
        "\"c2pc\"",
        "\"c2sc\"",
        "\"dist\"",
        "\"dlig\"",
        "\"dnom\"",
        "\"expt\"",
        "\"falt\"",
        "\"fin2\"",
        "\"fin3\"",
        "\"fina\"",
        "\"frac\"",
        "\"fwid\"",
        "\"half\"",
        "\"haln\"",
        "\"halt\"",
        "\"hist\"",
        "\"hkna\"",
        "\"hlig\"",
        "\"hngl\"",
        "\"hojo\"",
        "\"hwid\"",
        "\"init\"",
        "\"isol\"",
        "\"ital\"",
        "\"jalt\"",
        "\"jp78\"",
        "\"jp83\"",
        "\"jp90\"",
        "\"jp04\"",
        "\"kern\"",
        "\"lfbd\"",
        "\"liga\"",
        "\"ljmo\"",
        "\"lnum\"",
        "\"locl\"",
        "\"ltra\"",
        "\"ltrm\"",
        "\"mark\"",
        "\"med2\"",
        "\"medi\"",
        "\"mgrk\"",
        "\"mkmk\"",
        "\"mset\"",
        "\"nalt\"",
        "\"nlck\"",
        "\"nukt\"",
        "\"numr\"",
        "\"onum\"",
        "\"opbd\"",
        "\"ordn\"",
        "\"ornm\"",
        "\"palt\"",
        "\"pcap\"",
        "\"pkna\"",
        "\"pnum\"",
        "\"pref\"",
        "\"pres\"",
        "\"pstf\"",
        "\"psts\"",
        "\"pwid\"",
        "\"qwid\"",
        "\"rand\"",
        "\"rkrf\"",
        "\"rlig\"",
        "\"rphf\"",
        "\"rtbd\"",
        "\"rtla\"",
        "\"rtlm\"",
        "\"ruby\"",
        "\"salt\"",
        "\"sinf\"",
        "\"size\"",
        "\"smcp\"",
        "\"smpl\"",
        "\"ss01\"",
        "\"ss02\"",
        "\"ss03\"",
        "\"ss04\"",
        "\"ss05\"",
        "\"ss06\"",
        "\"ss07\"",
        "\"ss08\"",
        "\"ss09\"",
        "\"ss10\"",
        "\"ss11\"",
        "\"ss12\"",
        "\"ss13\"",
        "\"ss14\"",
        "\"ss15\"",
        "\"ss16\"",
        "\"ss17\"",
        "\"ss18\"",
        "\"ss19\"",
        "\"ss20\"",
        "\"subs\"",
        "\"sups\"",
        "\"swsh\"",
        "\"titl\"",
        "\"tjmo\"",
        "\"tnam\"",
        "\"tnum\"",
        "\"trad\"",
        "\"twid\"",
        "\"unic\"",
        "\"valt\"",
        "\"vatu\"",
        "\"vert\"",
        "\"vhal\"",
        "\"vjmo\"",
        "\"vkna\"",
        "\"vkrn\"",
        "\"vpal\"",
        "\"vrt2\"",
        "\"zero\""
    ],

    // FF 10.0
    "transformStyle":
    [
        "preserve-3d",
        "flat"
    ],

    // FF 4.0
    "transitionProperty":
    [
        "none",
        "all",
        "background-color",
        "background-image",
        "background-position",
        "background-size",
        "border-color",
        "border-radius",
        "border-width",
        "border-spacing",
        "bottom",
        "box-shadow",
        "color",
        "clip",
        "fill",
        "fill-opacity",
        "flood-color",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-weight",
        "height",
        "left",
        "letter-spacing",
        "lighting-color",
        "line-height",
        "margin ",
        "marker-offset",
        "max-height",
        "max-width",
        "min-height",
        "min-width",
        "opacity",
        "outline-color",
        "outline-offset",
        "outline-width",
        "padding",
        "right",
        "stop-color",
        "stop-opacity",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-indent",
        "text-shadow",
        "top",
        "transform-origin",
        "transform",
        "vertical-align",
        "visibility",
        "width",
        "word-spacing",
        "z-index",
        "-moz-box-flex",
        "-moz-column-count",
        "-moz-column-gap",
        "-moz-column-rule-color",
        "-moz-column-rule-width",
        "-moz-column-width",
        "-moz-image-region",
        "-moz-outline-radius"
    ],

    "timingFunction": // FF 4.0
    [
        "cubic-bezier()",
        "ease",
        "ease-in",
        "ease-in-out",
        "ease-out",
        "linear",
        "step-start",
        "step-end",
        "steps()"
    ],

    "mozTextDecorationLine": // FF 6.0
    [
        "underline",
        "overline",
        "line-through",
        "none"
    ],

    "mozTextDecorationStyle": // FF 6.0
    [
        "solid",
        "double",
        "dotted",
        "dashed",
        "wavy"
    ],

    "mozHyphens": // FF 6.0
    [
        "none",
        "manual",
        "auto"
    ],

    // FF 7.0
    "textOverflow":
    [
       "clip",
       "ellipsis"
    ],

    // FF 3.0
    "width":
    [
        "-moz-max-content",
        "-moz-min-content",
        "-moz-fit-content",
        "-moz-available"
    ],

    "imeMode":
    [
        "auto",
        "normal",
        "active",
        "inactive",
        "disabled"
    ],

    // FF 3.0
    "textRendering":
    [
        "auto",
        "optimizeSpeed",
        "optimizeLegibility",
        "geometricPrecision"
    ],

    "wordWrap":
    [
        "normal",
        "break-word"
    ],

    "pageBreak":
    [
        "auto",
        "always",
        "avoid",
        "left",
        "right"
    ],

    // start SVG specific

    "alignmentBaseline":
    [
        "auto",
        "baseline",
        "before-edge",
        "text-before-edge",
        "middle",
        "central",
        "after-edge",
        "text-after-edge",
        "ideographic",
        "alphabetic",
        "hanging",
        "mathematical"
    ],

    "baselineShift":
    [
        "baseline",
        "sub",
        "super"
    ],

    "colorInterpolation":
    [
        "auto",
        "sRGB",
        "linearRGB"
    ],

    "clipRule":
    [
        "nonzero",
        "evenodd"
    ],

    "colorProfile":
    [
        "auto",
        "sRGB"
    ],

    "colorRendering":
    [
        "auto",
        "optimizeSpeed",
        "optimizeQuality"
    ],

    "dominantBaseline":
    [
        "auto",
        "use-script",
        "no-change",
        "reset-size",
        "ideographic",
        "alphabetic",
        "hanging",
        "mathematical",
        "central",
        "middle",
        "text-after-edge",
        "text-before-edge"
    ],

    "accumulate":
    [
        "accumulate"
    ],

    "fontStretch":
    [
        "normal",
        "wider",
        "narrower",
        "ultra-condensed",
        "extra-condensed",
        "condensed",
        "semi-condensed",
        "semi-expanded",
        "expanded",
        "extra-expanded",
        "ultra-expanded"
    ],

    "imageRendering":
    [
        "auto",
        "optimizespeed",
        "optimizequality",
        "-moz-crisp-edges"
    ],

    "svgOverflow":
    [
        "visible",
        "hidden",
        "scroll"
    ],

    "pointerEvents":
    [
        "none",
        "all",
        "auto",
        "visiblePainted",
        "visibleFill",
        "visibleStroke",
        "visible",
        "painted",
        "fill",
        "stroke"
    ],

    "shapeRendering":
    [
        "optimizeSpeed",
        "crispEdges",
        "geometricPrecision"
    ],

    "strokeLinecap":
    [
        "butt",
        "round",
        "square"
    ],

    "strokeLinejoin":
    [
        "miter",
        "round",
        "bevel"
    ],

    "writingMode":
    [
        "lr-tb",
        "rl-tb",
        "tb-rl",
        "lr",
        "rl",
        "tb"
    ],

    "resize":
    [
        "none",
        "both",
        "horizontal",
        "vertical"
    ]
};

// Most common supported charsets according to http://en.wikipedia.org/wiki/Character_encoding
Css.charsets =
[
    "Big5",
    "Big5-HKSCS",
    "EUC-JP",
    "EUC-KR",
    "GB18030",
    "GB2312",
    "GBK",
    "ISO-2022-JP",
    "ISO-2022-JP-2",
    "ISO-2022-KR",
    "ISO-8859-1",
    "ISO-8859-2",
    "ISO-8859-3",
    "ISO-8859-4",
    "ISO-8859-5",
    "ISO-8859-6",
    "ISO-8859-7",
    "ISO-8859-8",
    "ISO-8859-9",
    "ISO-8859-10",
    "JIS_Encoding",
    "KOI8-R",
    "KOI8-U",
    "Shift_JIS",
    "TSCII",
    "UTF-8",
    "US-ASCII",
    "VISCII",
    "Windows-1250",
    "Windows-1251",
    "Windows-1252",
    "Windows-1253",
    "Windows-1254",
    "Windows-1255",
    "Windows-1256",
    "Windows-1257",
    "Windows-1258"
];

// http://www.w3.org/TR/CSS21/media.html#media-types
Css.mediaTypes =
[
    "all",
    "aural",
    "braille",
    "embossed",
    "handheld",
    "print",
    "projection",
    "screen",
    "tty",
    "tv"
];

// https://developer.mozilla.org/en-US/docs/CSS/@document
Css.documentConditions =
[
    "url()",
    "url-prefix()",
    "domain()",
    "regexp()"
];

// https://developer.mozilla.org/en-US/docs/CSS/@keyframes#Values
Css.keyframeKeys =
{
    "from": "0%",
    "to": "100%"
};

// http://mxr.mozilla.org/mozilla-central/source/layout/style/nsCSSPseudoClassList.h
// Also http://mxr.mozilla.org/mozilla-central/source/layout/style/nsCSSAnonBoxList.h
// but that's not relevant for our purposes.
Css.pseudoClasses =
[
    ":active",
    ":checked",
    ":default",
    ":disabled",
    ":empty",
    ":enabled",
    ":first-child",
    ":first-of-type",
    ":focus",
    ":hover",
    ":indeterminate",
    ":in-range",
    ":invalid",
    ":lang()",
    ":last-child",
    ":last-of-type",
    ":link",
    ":not()",
    ":nth-child()",
    ":nth-last-child()",
    ":nth-last-of-type()",
    ":nth-of-type()",
    ":only-child",
    ":only-of-type",
    ":optional",
    ":out-of-range",
    ":required",
    ":root",
    ":target",
    ":valid",
    ":visited",
    ":-moz-any()",
    ":-moz-any-link",
    ":-moz-bound-element",
    ":-moz-broken",
    ":-moz-drag-over",
    ":-moz-empty-except-children-with-localname()",
    ":-moz-first-node",
    ":-moz-focusring",
    ":-moz-full-screen",
    ":-moz-full-screen-ancestor",
    ":-moz-handler-blocked",
    ":-moz-handler-clicktoplay",
    ":-moz-handler-crashed",
    ":-moz-handler-disabled",
    ":-moz-has-handlerref",
    ":-moz-is-html",
    ":-moz-last-node",
    ":-moz-loading",
    // ":-moz-locale-dir(ltr)", // http://bugzil.la/588996
    // ":-moz-locale-dir(rtl)",
    ":-moz-lwtheme",
    ":-moz-lwtheme-brighttext",
    ":-moz-lwtheme-darktext",
    ":-moz-math-increment-script-level",
    ":-moz-meter-optimum",
    ":-moz-meter-sub-optimum",
    ":-moz-meter-sub-sub-optimum",
    ":-moz-only-whitespace",
    ":-moz-placeholder",
    ":-moz-read-only",
    ":-moz-read-write",
    ":-moz-submit-invalid",
    ":-moz-suppressed",
    ":-moz-system-metric(images-in-menus)",
    ":-moz-system-metric(mac-graphite-theme)",
    ":-moz-system-metric(scrollbar-end-backward)",
    ":-moz-system-metric(scrollbar-end-forward)",
    ":-moz-system-metric(scrollbar-start-backward)",
    ":-moz-system-metric(scrollbar-start-forward)",
    ":-moz-system-metric(scrollbar-thumb-proportional)",
    ":-moz-system-metric(touch-enabled)",
    ":-moz-system-metric(windows-default-theme)",
    ":-moz-table-border-nonzero",
    ":-moz-type-unsupported",
    ":-moz-ui-invalid",
    ":-moz-ui-valid",
    ":-moz-user-disabled",
    ":-moz-window-inactive"
];

// https://developer.mozilla.org/en-US/docs/CSS/CSS_Reference/Mozilla_Extensions#Pseudo-elements_and_pseudo-classes
// http://mxr.mozilla.org/mozilla-central/source/browser/devtools/styleinspector/CssLogic.jsm
Css.pseudoElements =
[
    "::after",
    "::before",
    "::first-letter",
    "::first-line",
    "::-moz-focus-inner",
    "::-moz-focus-outer",
    "::-moz-list-bullet",
    "::-moz-list-number",
    "::-moz-math-anonymous",
    "::-moz-math-stretchy",
    "::-moz-placeholder",
    "::-moz-progress-bar",
    "::-moz-selection"
];

Css.nonEditableTags =
{
    "HTML": 1, "html": 1,
    "HEAD": 1, "head": 1
};

Css.innerEditableTags =
{
    "BODY": 1, "body": 1
};

Css.nonDeletableTags =
{
    "HTML": 1, "html": 1,
    "HEAD": 1, "head": 1,
    "BODY": 1, "body": 1
};

// ********************************************************************************************* //
// Registration

return Css;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/deprecated",
[
    "firebug/lib/trace"
],
function(FBTrace) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

var consoleService = Cc["@mozilla.org/consoleservice;1"].getService(Ci["nsIConsoleService"]);

// ********************************************************************************************* //
// Module implementation

var Deprecated = {};
Deprecated.deprecated = function(msg, fnc, args)
{
    return function deprecationWrapper()
    {
        if (!this.nagged)
        {
            // drop frame with deprecated()
            var caller = Components.stack.caller;
            var explain = "Deprecated function, " + msg;

            if (typeof(FBTrace) !== undefined)
            {
                FBTrace.sysout(explain, getStackDump());

                //if (exc.stack)
                //    exc.stack = exc.stack.split("\n");

                FBTrace.sysout(explain + " " + caller.toString());
            }

            if (consoleService)
                consoleService.logStringMessage(explain + " " + caller.toString());

            this.nagged = true;
        }

        return fnc.apply(this, args || arguments);
    };
};

// ********************************************************************************************* //
// Local helpers

function getStackDump()
{
    var lines = [];
    for (var frame = Components.stack; frame; frame = frame.caller)
        lines.push(frame.filename + " (" + frame.lineNumber + ")");

    return lines.join("\n");
};

// ********************************************************************************************* //
// Registration

return Deprecated;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/dom",
[
    "firebug/lib/trace",
    "firebug/lib/deprecated",
    "firebug/lib/css",
    "firebug/lib/array",
    "firebug/lib/xml",
    "firebug/lib/wrapper",
],
function(FBTrace, Deprecated, Css, Arr, Xml, Wrapper) {

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;
var Cc = Components.classes;

var Dom = {};
var domMemberCache = null;
var domMemberMap = {};
var domMappedData = new WeakMap();

Dom.domUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);

// ********************************************************************************************* //
// DOM APIs

Dom.getChildByClass = function(node) // ,classname, classname, classname...
{
    if (!node)
    {
        FBTrace.sysout("dom.getChildByClass; ERROR, no parent node!");
        return null;
    }

    for (var i = 1; i < arguments.length; ++i)
    {
        var className = arguments[i];
        var child = node.firstChild;
        node = null;
        for (; child; child = child.nextSibling)
        {
            if (Css.hasClass(child, className))
            {
                node = child;
                break;
            }
        }
    }

    return node;
};

Dom.getAncestorByClass = function(node, className)
{
    for (var parent = node; parent; parent = parent.parentNode)
    {
        if (Css.hasClass(parent, className))
            return parent;
    }

    return null;
};

Dom.getAncestorByTagName = function(node, tagName)
{
    for (var parent = node; parent; parent = parent.parentNode)
    {
        if (parent.localName && parent.tagName.toLowerCase() == tagName)
            return parent;
    }

    return null;
};

/* @Deprecated  Use native Firefox: node.getElementsByClassName(names).item(0) */
Dom.getElementByClass = function(node, className)  // className, className, ...
{
    return Dom.getElementsByClass.apply(this,arguments).item(0);
};

/* @Deprecated  Use native Firefox: node.getElementsByClassName(names) */
Dom.getElementsByClass = function(node, className)  // className, className, ...
{
    var args = Arr.cloneArray(arguments); args.splice(0, 1);
    return node.getElementsByClassName(args.join(" "));
};

Dom.getElementsByAttribute = function(node, attrName, attrValue)
{
    function iteratorHelper(node, attrName, attrValue, result)
    {
        // xxxFlorent: sadly, Documents and DocumentFragments do not have firstElementChild
        // properties currently.
        for (var child = node.firstChild; child; child = child.nextSibling)
        {
            if (child.nodeType !== document.ELEMENT_NODE)
                continue;

            if (child.getAttribute(attrName) == attrValue)
                result.push(child);

            iteratorHelper(child, attrName, attrValue, result);
        }
    }

    var result = [];
    iteratorHelper(node, attrName, attrValue, result);
    return result;
};

Dom.isAncestor = function(node, potentialAncestor)
{
    for (var parent = node; parent; parent = parent.parentNode)
    {
        if (parent == potentialAncestor)
            return true;
    }

    return false;
};

Dom.getNextElement = function(node)
{
    while (node && node.nodeType != Node.ELEMENT_NODE)
        node = node.nextSibling;

    return node;
};

Dom.getPreviousElement = function(node)
{
    while (node && node.nodeType != Node.ELEMENT_NODE)
        node = node.previousSibling;

    return node;
};

Dom.getBody = function(doc)
{
    if (doc.body)
        return doc.body;

    var body = doc.getElementsByTagName("body")[0];
    if (body)
        return body;

    return doc.documentElement;  // For non-HTML docs
};

Dom.getNonFrameBody = function(elt)
{
    if (Dom.isRange(elt))
        elt = elt.commonAncestorContainer;

    var body = Dom.getBody(elt.ownerDocument);
    return (body.localName && body.localName.toUpperCase() === "FRAMESET") ? null : body;
}

// ********************************************************************************************* //
// DOM Modification

Dom.insertAfter = function(newNode, referenceNode)
{
    if (referenceNode.parentNode)
        referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
};

Dom.addScript = function(doc, id, src)
{
    var element = doc.createElementNS("http://www.w3.org/1999/xhtml", "html:script");
    element.setAttribute("type", "text/javascript");
    element.setAttribute("id", id);

    if (!FBTrace.DBG_CONSOLE)
        Firebug.setIgnored(element);

    element.textContent = src;

    if (doc.documentElement)
    {
        doc.documentElement.appendChild(element);
    }
    else
    {
        // See issue 1079, the svg test case gives this error
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("lib.addScript doc has no documentElement (" +
                doc.readyState + ") " + doc.location, doc);
        return;
    }
    return element;
};

Dom.setOuterHTML = function(element, html)
{
    try
    {
        var fragment = Dom.markupToDocFragment(html, element);

        var first = fragment.firstChild;
        var last = fragment.lastChild;
        element.parentNode.replaceChild(fragment, element);
        return [first, last];
    }
    catch (e)
    {
        return [element, element];
    }
};

Dom.markupToDocFragment = function(markup, parent)
{
    var doc = parent.ownerDocument;
    var range = doc.createRange();
    range.selectNode(parent || doc.documentElement);

    return range.createContextualFragment(markup);
};

Dom.appendInnerHTML = function(element, html, referenceElement)
{
    var doc = element.ownerDocument;
    var range = doc.createRange();  // a helper object
    range.selectNodeContents(element); // the environment to interpret the html

    var fragment = range.createContextualFragment(html);  // parse
    var firstChild = fragment.firstChild;
    element.insertBefore(fragment, referenceElement);

    return firstChild;
};

Dom.insertTextIntoElement = function(element, text)
{
    var command = "cmd_insertText";

    var controller = element.controllers.getControllerForCommand(command);
    if (!controller || !controller.isCommandEnabled(command))
        return;

    var params = Cc["@mozilla.org/embedcomp/command-params;1"].createInstance(Ci.nsICommandParams);
    params.setStringValue("state_data", text);

    if (controller instanceof Ci.nsICommandController)
        controller.doCommandWithParams(command, params);
};

// ********************************************************************************************* //

Dom.collapse = function(elt, collapsed)
{
    if (!elt)
    {
        FBTrace.sysout("Dom.collapse; ERROR null element.");
        return;
    }

    elt.setAttribute("collapsed", collapsed ? "true" : "false");
};

Dom.isCollapsed = function(elt)
{
    return (elt.getAttribute("collapsed") == "true") ? true : false;
};

Dom.hide = function(elt, hidden)
{
    elt.style.visibility = hidden ? "hidden" : "visible";
};

Dom.clearNode = function(node)
{
    node.textContent = "";
};

Dom.eraseNode = function(node)
{
    while (node.lastChild)
        node.removeChild(node.lastChild);
};

// ********************************************************************************************* //

Dom.isNode = function(o)
{
    try {
        return o && o instanceof window.Node;
    }
    catch (ex) {
        return false;
    }
};

Dom.isElement = function(o)
{
    try {
        return o && o instanceof window.Element;
    }
    catch (ex) {
        return false;
    }
};

Dom.isRange = function(o)
{
    try {
        return o && o instanceof window.Range;
    }
    catch (ex) {
        return false;
    }
};

Dom.hasChildElements = function(node)
{
    if (node.contentDocument) // iframes
        return true;

    for (var child = node.firstChild; child; child = child.nextSibling)
    {
        if (child.nodeType == Node.ELEMENT_NODE)
            return true;
    }

    return false;
};

// ********************************************************************************************* //

Dom.getNextByClass = function(root, state)
{
    function iter(node) { return node.nodeType == Node.ELEMENT_NODE && Css.hasClass(node, state); }
    return Dom.findNext(root, iter);
};

Dom.getPreviousByClass = function(root, state)
{
    function iter(node) { return node.nodeType == Node.ELEMENT_NODE && Css.hasClass(node, state); }
    return Dom.findPrevious(root, iter);
};

Dom.findNextDown = function(node, criteria)
{
    if (!node)
        return null;

    for (var child = node.firstChild; child; child = child.nextSibling)
    {
        if (criteria(child))
            return child;

        var next = Dom.findNextDown(child, criteria);
        if (next)
            return next;
    }
};

Dom.findPreviousUp = function(node, criteria)
{
    if (!node)
        return null;

    for (var child = node.lastChild; child; child = child.previousSibling)
    {
        var next = Dom.findPreviousUp(child, criteria);
        if (next)
            return next;

        if (criteria(child))
            return child;
    }
};

Dom.findNext = function(node, criteria, upOnly, maxRoot)
{
    if (!node)
        return null;

    if (!upOnly)
    {
        var next = Dom.findNextDown(node, criteria);
        if (next)
            return next;
    }

    for (var sib = node.nextSibling; sib; sib = sib.nextSibling)
    {
        if (criteria(sib))
            return sib;

        var next = Dom.findNextDown(sib, criteria);
        if (next)
            return next;
    }

    if (node.parentNode && node.parentNode != maxRoot)
    {
        return Dom.findNext(node.parentNode, criteria, true, maxRoot);
    }
    return null;
};

Dom.findPrevious = function(node, criteria, downOnly, maxRoot)
{
    if (!node)
        return null;

    for (var sib = node.previousSibling; sib; sib = sib.previousSibling)
    {
        var prev = Dom.findPreviousUp(sib, criteria);
        if (prev)
            return prev;

        if (criteria(sib))
            return sib;
    }

    if (!downOnly)
    {
        var next = Dom.findPreviousUp(node, criteria);
        if (next)
            return next;
    }

    if (node.parentNode && node.parentNode != maxRoot)
    {
        if (criteria(node.parentNode))
            return node.parentNode;

        return Dom.findPrevious(node.parentNode, criteria, true, maxRoot);
    }
    return null;
};

// ********************************************************************************************* //
// Graphics

/**
 * Gets the absolute offset of an element
 * @param {Element} elt Element to get the info for
 * @returns {Object} x and y offset of the element
 */
Dom.getClientOffset = function(elt)
{
    function addOffset(elt, coords, view)
    {
        var p = elt.offsetParent;

        var style = view.getComputedStyle(elt, "");

        if (elt.offsetLeft)
            coords.x += elt.offsetLeft + parseInt(style.borderLeftWidth);
        if (elt.offsetTop)
            coords.y += elt.offsetTop + parseInt(style.borderTopWidth);

        if (p)
        {
            if (p.nodeType == Node.ELEMENT_NODE)
                addOffset(p, coords, view);
        }
        else if (elt.ownerDocument.defaultView.frameElement)
        {
            addOffset(elt.ownerDocument.defaultView.frameElement, coords,
                elt.ownerDocument.defaultView);
        }
    }

    var coords = {x: 0, y: 0};
    if (elt)
    {
        var view = elt.ownerDocument.defaultView;
        addOffset(elt, coords, view);
    }

    return coords;
};

/**
 * Gets layout info about an element
 * @param {Object} elt Element to get the info for
 * @returns {Object} Layout information including "left", "top", "right", "bottom",
 *     "width" and "height"
 */
Dom.getLTRBWH = function(elt)
{
    var bcrect;
    var dims = {"left": 0, "top": 0, "right": 0, "bottom": 0, "width": 0, "height": 0};

    if (elt)
    {
        bcrect = elt.getBoundingClientRect();
        dims.left = bcrect.left;
        dims.top = bcrect.top;
        dims.right = bcrect.right;
        dims.bottom = bcrect.bottom;

        if (bcrect.width)
        {
            dims.width = bcrect.width;
            dims.height = bcrect.height;
        }
        else
        {
            dims.width = dims.right - dims.left;
            dims.height = dims.bottom - dims.top;
        }
    }
    return dims;
};

/**
 * Gets the offset of an element relative to an ancestor
 * @param {Element} elt Element to get the info for
 * @param {Element} ancestor Ancestor element used as origin
 */
Dom.getAncestorOffset = function(elt, ancestor)
{
    var offset = {x: 0, y: 0};
    var offsetParent = elt;
    do
    {
        offset.x += offsetParent.offsetLeft;
        offset.y += offsetParent.offsetTop;
        offsetParent = offsetParent.offsetParent;
    } while (offsetParent && offsetParent !== ancestor);

    return offset;
};

/**
 * Gets the offset size of an element
 * @param {Object} elt Element to move
 * @returns {Object} Offset width and height of the element
 */
Dom.getOffsetSize = function(elt)
{
    return {width: elt.offsetWidth, height: elt.offsetHeight};
};

/**
 * Get the next scrollable ancestor
 * @param {Object} element Element to search the ancestor for
 * @returns {Object} Scrollable ancestor
 */
Dom.getOverflowParent = function(element)
{
    for (var scrollParent = element.parentNode; scrollParent;
        scrollParent = scrollParent.offsetParent)
    {
        if (scrollParent.scrollHeight > scrollParent.offsetHeight)
            return scrollParent;
    }
};

/**
 * Checks whether an element is scrolled to the bottom
 * @param {Object} element Element to check
 * @returns {Boolean} True, if element is scrolled to the bottom, otherwise false
 */
Dom.isScrolledToBottom = function(element)
{
    var onBottom = (element.scrollTop + element.offsetHeight) == element.scrollHeight;

    if (FBTrace.DBG_CONSOLE)
    {
        FBTrace.sysout("Dom.isScrolledToBottom offsetHeight: " + element.offsetHeight +
            ", scrollTop: " + element.scrollTop + ", scrollHeight: " + element.scrollHeight +
            ", onBottom: " + onBottom);
    }

    return onBottom;
};

/**
 * Scrolls a scrollable element to the bottom
 * @param {Object} element Element to scroll
 * @returns {Boolean} True, if the element could be scrolled to the bottom, otherwise false
 */
Dom.scrollToBottom = function(element)
{
    element.scrollTop = element.scrollHeight;

    if (FBTrace.DBG_CONSOLE)
    {
        FBTrace.sysout("scrollToBottom reset scrollTop " + element.scrollTop + " = " +
            element.scrollHeight);

        if (element.scrollHeight == element.offsetHeight)
        {
            FBTrace.sysout("scrollToBottom attempt to scroll non-scrollable element " +
                element, element);
        }
    }

    return (element.scrollTop == element.scrollHeight);
};

/**
 * Moves an element
 * @param {Object} element Element to move
 * @param {Number} x New horizontal position
 * @param {Number} y New vertical position
 */
Dom.move = function(element, x, y)
{
    element.style.left = x + "px";
    element.style.top = y + "px";
};

/**
 * Resizes an element
 * @param {Object} element Element to resize
 * @param {Number} w New width
 * @param {Number} h New height
 */
Dom.resize = function(element, w, h)
{
    element.style.width = w + "px";
    element.style.height = h + "px";
};

Dom.linesIntoCenterView = function(element, scrollBox)  // {before: int, after: int}
{
    if (!scrollBox)
        scrollBox = Dom.getOverflowParent(element);

    if (!scrollBox)
        return;

    var offset = Dom.getClientOffset(element);

    var topSpace = offset.y - scrollBox.scrollTop;
    var bottomSpace = (scrollBox.scrollTop + scrollBox.clientHeight) -
        (offset.y + element.offsetHeight);

    if (topSpace < 0 || bottomSpace < 0)
    {
        var split = (scrollBox.clientHeight/2);
        var centerY = offset.y - split;
        scrollBox.scrollTop = centerY;
        topSpace = split;
        bottomSpace = split - element.offsetHeight;
    }

    return {
        before: Math.round((topSpace/element.offsetHeight) + 0.5),
        after: Math.round((bottomSpace/element.offsetHeight) + 0.5)
    };
};

/**
 * Scrolls an element into view
 * @param {Object} element Element to scroll to
 * @param {Object} scrollBox Scrolled element (Must be an ancestor of "element" or
 *     null for automatically determining the ancestor) 
 * @param {String} alignmentX Horizontal alignment for the element
 *     (valid values: "centerOrLeft", "left", "middle", "right", "none")
 * @param {String} alignmentY Vertical alignment for the element
 *     (valid values: "centerOrTop", "top", "middle", "bottom", "none")
 * @param {Boolean} scrollWhenVisible Specifies whether "scrollBox" should be scrolled even when
 *     "element" is completely visible
 */
Dom.scrollTo = function(element, scrollBox, alignmentX, alignmentY, scrollWhenVisible)
{
    if (!element)
        return;

    if (!scrollBox)
        scrollBox = Dom.getOverflowParent(element);

    if (!scrollBox)
        return;

    var offset = Dom.getAncestorOffset(element, scrollBox);

    if (!alignmentX)
        alignmentX = "centerOrLeft";

    if (!alignmentY)
        alignmentY = "centerOrTop";

    if (alignmentY)
    {
        var topSpace = offset.y - scrollBox.scrollTop;
        var bottomSpace = (scrollBox.scrollTop + scrollBox.clientHeight) -
            (offset.y + element.offsetHeight);

        // Element is vertically not completely visible or scrolling is enforced
        if (topSpace < 0 || bottomSpace < 0 || scrollWhenVisible)
        {
            switch (alignmentY)
            {
                case "top":
                    scrollBox.scrollTop = offset.y;
                    break;

                case "center":
                case "centerOrTop":
                    var elementFitsIntoScrollBox = element.offsetHeight <= scrollBox.clientHeight;
                    var y = elementFitsIntoScrollBox || alignmentY != "centerOrTop" ?
                        offset.y - (scrollBox.clientHeight - element.offsetHeight) / 2 :
                        offset.y;
                    scrollBox.scrollTop = y;
                    break;

                case "bottom":
                    var y = offset.y + element.offsetHeight - scrollBox.clientHeight;
                    scrollBox.scrollTop = y;
                    break;
            }
        }
    }

    if (alignmentX)
    {
        var leftSpace = offset.x - scrollBox.scrollLeft;
        var rightSpace = (scrollBox.scrollLeft + scrollBox.clientWidth) -
            (offset.x + element.clientWidth);

        // Element is horizontally not completely visible or scrolling is enforced
        if (leftSpace < 0 || rightSpace < 0 || scrollWhenVisible)
        {
            switch (alignmentX)
            {
                case "left":
                    scrollBox.scrollLeft = offset.x;
                    break;

                case "center":
                case "centerOrLeft":
                    var elementFitsIntoScrollBox = element.offsetWidth <= scrollBox.clientWidth;
                    var x = elementFitsIntoScrollBox || alignmentX != "centerOrLeft" ?
                        offset.x - (scrollBox.clientWidth - element.offsetWidth) / 2 :
                        offset.x;
                    scrollBox.scrollLeft = x;
                    break;

                case "right":
                    var x = offset.x + element.offsetWidth - scrollBox.clientWidth;
                    scrollBox.scrollLeft = x;
                    break;
            }
        }
    }

    if (FBTrace.DBG_PANELS)
        FBTrace.sysout("dom.scrollTo", element);
};

/**
 * Centers an element inside a scrollable area
 * @param {Object} element Element to scroll to
 * @param {Object} scrollBox Scrolled element (Must be an ancestor of "element" or
 *     null for automatically determining the ancestor) 
 * @param {Boolean} notX Specifies whether the element should be centered horizontally
 * @param {Boolean} notY Specifies whether the element should be centered vertically
 */
Dom.scrollIntoCenterView = function(element, scrollBox, notX, notY)
{
    Dom.scrollTo(element, scrollBox, notX ? "none" : "centerOrLeft",
        notY ? "none" : "centerOrTop");
};

Dom.scrollMenupopup = function(popup, item)
{
    var doc = popup.ownerDocument;
    var box = doc.getAnonymousNodes(popup)[0];
    var scrollBox = doc.getAnonymousNodes(box)[1];

    if (item == undefined)
    {
        scrollBox.scrollTop = scrollBox.scrollHeight + 100;
    }
    else if (item == 0)
    {
        scrollBox.scrollTop = 0;
    }
    else
    {
        var popupRect = popup.getBoundingClientRect();
        var itemRect = item.getBoundingClientRect();

        if (itemRect.top < popupRect.top + itemRect.height)
        {
            scrollBox.scrollTop += itemRect.top - popupRect.top - itemRect.height;
        }
        else if (itemRect.bottom + itemRect.height > popupRect.bottom)
        {
            scrollBox.scrollTop -= popupRect.bottom - itemRect.bottom - itemRect.height;
        }
    }
};

// ********************************************************************************************* //
// MappedData

function getElementData(element)
{
    var elementData;

    // force element to be wrapped:
    element = new XPCNativeWrapper(element);

    if (!domMappedData.has(element))
    {
        elementData = {};
        domMappedData.set(element, elementData);
    }
    else
        elementData = domMappedData.get(element);

    return elementData;
}

Dom.getMappedData = function(element, key)
{
    var elementData = getElementData(element);
    return elementData[key];
};

Dom.setMappedData = function(element, key, value)
{
    if (!Dom.isNode(element))
        throw new TypeError("expected an element as the first argument");

    if (typeof key !== "string")
        throw new TypeError("the key argument must be a string");

    var elementData = getElementData(element);
    elementData[key] = value;
};

Dom.deleteMappedData = function(element, key)
{
    var elementData = getElementData(element);
    delete elementData[key];
};

// ********************************************************************************************* //
// DOM Members

Dom.getDOMMembers = function(object)
{
    if (!domMemberCache)
    {
        domMemberCache = {};

        for (var name in domMemberMap)
        {
            var builtins = domMemberMap[name];
            var cache = domMemberCache[name] = {};

            for (var i = 0; i < builtins.length; ++i)
                cache[builtins[i]] = i;
        }
    }

    if (object instanceof Window)
        { return domMemberCache.Window; }
    else if (object instanceof Document)
        { return domMemberCache.Document; }
    else if (object instanceof Location)
        { return domMemberCache.Location; }
    else if (object instanceof HTMLImageElement)
        { return domMemberCache.HTMLImageElement; }
    else if (object instanceof HTMLAnchorElement)
        { return domMemberCache.HTMLAnchorElement; }
    else if (object instanceof HTMLInputElement)
        { return domMemberCache.HTMLInputElement; }
    else if (object instanceof HTMLButtonElement)
        { return domMemberCache.HTMLButtonElement; }
    else if (object instanceof HTMLFormElement)
        { return domMemberCache.HTMLFormElement; }
    else if (object instanceof HTMLBodyElement)
        { return domMemberCache.HTMLBodyElement; }
    else if (object instanceof HTMLHtmlElement)
        { return domMemberCache.HTMLHtmlElement; }
    else if (object instanceof HTMLScriptElement)
        { return domMemberCache.HTMLScriptElement; }
    else if (object instanceof HTMLTableElement)
        { return domMemberCache.HTMLTableElement; }
    else if (object instanceof HTMLTableRowElement)
        { return domMemberCache.HTMLTableRowElement; }
    else if (object instanceof HTMLTableCellElement)
        { return domMemberCache.HTMLTableCellElement; }
    else if (object instanceof HTMLIFrameElement)
        { return domMemberCache.HTMLIFrameElement; }
    else if (object instanceof SVGSVGElement)
        { return domMemberCache.SVGSVGElement; }
    else if (object instanceof SVGElement)
        { return domMemberCache.SVGElement; }
    else if (object instanceof Element)
        { return domMemberCache.Element; }
    else if (object instanceof Text || object instanceof CDATASection)
        { return domMemberCache.Text; }
    else if (object instanceof Attr)
        { return domMemberCache.Attr; }
    else if (object instanceof Node)
        { return domMemberCache.Node; }
    else if (object instanceof Event || object instanceof Dom.EventCopy)
        { return domMemberCache.Event; }
    else if (Array.isArray(object))
        { return domMemberCache.Array; }

    return null;
};

Dom.isDOMMember = function(object, propName)
{
    // We use "in" here instead of "hasOwnProperty" so that things on Object.prototype
    // also get treated as DOM members.
    // XXXsimon: Non-DOM objects should also get this behavior.
    var members = Dom.getDOMMembers(object);
    return members && propName in members;
};

Dom.isDOMConstant = function(object, name)
{
    if (!Dom.domConstantMap.hasOwnProperty(name))
        return false;

    try
    {
        // Test for nativeness. This is a fragile piece of dark magic, and might be
        // equivalent to |Cu.isXrayWrapper(XPCNativeWrapper(object))| in >= Fx 20.
        object = XPCNativeWrapper.unwrap(object);
        var isNative = (XPCNativeWrapper(object).toString !== XPCNativeWrapper(object.toString));
        return (isNative ||
            object instanceof window.Event ||
            object instanceof Dom.EventCopy);
    }
    catch (exc)
    {
        return false;
    }
};

Dom.isInlineEventHandler = function(name)
{
    return !!Dom.domInlineEventHandlersMap[name];
};

Dom.EventCopy = function(event)
{
    // Because event objects are destroyed arbitrarily by Gecko, we must make a copy of them to
    // represent them long term in the inspector.
    for (var name in event)
    {
        try {
            this[name] = event[name];
        } catch (exc) { }
    }
};

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

// Note: Missing HTML elements:
// <tbody>, <object>, <embed>, <video>, <audio>, <source>, <option>, <select>, <textarea>, <br>,
// <frame>, <iframe>, <frameset>, <link>, <meta>, <style>, probably more
// Instead of adding them, effort should rather be spent on automatic scanning.

domMemberMap.Window =
[
    "document",
    "frameElement",

    "innerWidth",
    "innerHeight",
    "outerWidth",
    "outerHeight",
    "screenX",
    "screenY",
    "mozInnerScreenX",
    "mozInnerScreenY",
    "pageXOffset",
    "pageYOffset",
    "scrollX",
    "scrollY",
    "scrollMaxX",
    "scrollMaxY",

    "URL", //FF4.0
    "mozAnimationStartTime", //FF4.0
    "mozPaintCount", //FF4.0
    "mozRequestAnimationFrame", //FF4.0
    "mozCancelAnimationFrame",
    "mozCancelRequestAnimationFrame",

    "mozCancelAnimationFrame",
    "mozCancelRequestAnimationFrame",
    "indexedDB",

    "status",
    "defaultStatus",

    "parent",
    "opener",
    "top",
    "window",
    "content",
    "self",

    "location",
    "history",
    "frames",
    "navigator",
    "screen",
    "menubar",
    "toolbar",
    "locationbar",
    "personalbar",
    "statusbar",
    "directories",
    "scrollbars",
    "fullScreen",
    "netscape",
    "console",
    "Components",
    "controllers",
    "closed",
    "crypto",
    "pkcs11",

    "name",
    "property",
    "length",

    "sessionStorage",

    "setTimeout",
    "setInterval",
    "clearTimeout",
    "clearInterval",
    "addEventListener",
    "removeEventListener",
    "dispatchEvent",
    "getComputedStyle",
    "captureEvents",
    "releaseEvents",
    "routeEvent",
    "enableExternalCapture",
    "disableExternalCapture",
    "moveTo",
    "moveBy",
    "resizeTo",
    "resizeBy",
    "scroll",
    "scrollTo",
    "scrollBy",
    "scrollByLines",
    "scrollByPages",
    "sizeToContent",
    "setResizable",
    "getSelection",
    "open",
    "openDialog",
    "close",
    "alert",
    "confirm",
    "prompt",
    "dump",
    "focus",
    "blur",
    "find",
    "back",
    "forward",
    "home",
    "stop",
    "print",
    "atob",
    "btoa",
    "updateCommands",
    "XPCNativeWrapper",
    "applicationCache",      // FF3
    "postMessage",
    "localStorage",  // FF3.5
    "showModalDialog", // FF 3.0, MS IE4

    "InstallTrigger",

    "performance",
    "matchMedia",

    "getInterface",

    "BarProp",
    "Controllers",
    "Crypto",
    "DOMException",
    "DOMStringList",
    "EventTarget",
    "History",
    "MimeTypeArray",
    "Navigator",
    "NodeList",
    "OfflineResourceList",
    "Screen",
    "Storage",
    "XULControllers",
    "Document",
    "Element",
    "Attr",
    "CharacterData",
    "DOMTokenList",
    "Text",
    "Proxy",
    "Blob",
    "File",
    "Image",
    "Option",

    "HTMLDocument",
    "HTMLByteRanges",
    "HTMLCollection",
    "HTMLOptionsCollection",
    "HTMLPropertiesCollection",

    "HTMLElement",
    "HTMLUnknownElement",
    "HTMLAnchorElement",
    "HTMLAppletElement",
    "HTMLAreaElement",
    "HTMLAudioElement",
    "HTMLBaseElement",
    "HTMLBodyElement",
    "HTMLBRElement",
    "HTMLButtonElement",
    "HTMLCanvasElement",
    "HTMLCommandElement",
    "HTMLDataListElement",
    "HTMLDirectoryElement",
    "HTMLDivElement",
    "HTMLDListElement",
    "HTMLEmbedElement",
    "HTMLFieldSetElement",
    "HTMLFontElement",
    "HTMLFormElement",
    "HTMLFrameElement",
    "HTMLFrameSetElement",
    "HTMLHeadElement",
    "HTMLHeadingElement",
    "HTMLHRElement",
    "HTMLHtmlElement",
    "HTMLHtmlElement",
    "HTMLIFrameElement",
    "HTMLImageElement",
    "HTMLInputElement",
    "HTMLLabelElement",
    "HTMLLegendElement",
    "HTMLLIElement",
    "HTMLLinkElement",
    "HTMLMapElement",
    "HTMLMediaElement",
    "HTMLMenuElement",
    "HTMLMenuItemElement",
    "HTMLMetaElement",
    "HTMLMeterElement",
    "HTMLModElement",
    "HTMLObjectElement",
    "HTMLOListElement",
    "HTMLOptGroupElement",
    "HTMLOptionElement",
    "HTMLOutputElement",
    "HTMLParagraphElement",
    "HTMLParamElement",
    "HTMLPreElement",
    "HTMLProgressElement",
    "HTMLQuoteElement",
    "HTMLScriptElement",
    "HTMLSelectElement",
    "HTMLSourceElement",
    "HTMLSpanElement",
    "HTMLStyleElement",
    "HTMLTableCaptionElement",
    "HTMLTableCellElement",
    "HTMLTableColElement",
    "HTMLTableElement",
    "HTMLTableRowElement",
    "HTMLTableSectionElement",
    "HTMLTextAreaElement",
    "HTMLTitleElement",
    "HTMLUListElement",
    "HTMLVideoElement",

    "JSON",
    "Location",
    "Math",
    "Node",
    "StopIteration",
    "Window",
    "XULElement",
    "CSS2Properties",
    "CSSStyleDeclaration",
    "Error",
    "EvalError",
    "InternalError",
    "Namespace",
    "QName",
    "RangeError",
    "ReferenceError",
    "SyntaxError",
    "TypeError",
    "URIError",
    "Array",
    "ArrayBuffer",
    "Boolean",
    "DataView",
    "Date",
    "Float32Array",
    "Float64Array",
    "Function",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "Iterator",
    "Map",
    "Number",
    "Object",
    "ParallelArray",
    "QueryInterface",
    "RegExp",
    "Set",
    "String",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "WeakMap",
    "XML",
    "XMLList",
    "decodeURI",
    "decodeURIComponent",
    "dumpProfile",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "isFinite",
    "isNaN",
    "isXMLName",
    "parseFloat",
    "parseInt",
    "pauseProfilers",
    "resumeProfilers",
    "startProfiling",
    "stopProfiling",
    "unescape",
    "uneval",
    "Performance",
    "PerformanceNavigation",
    "PerformanceTiming",

    "AnimationEvent",
    "BeforeUnloadEvent",
    "CommandEvent",
    "CompositionEvent",
    "DataContainerEvent",
    "DataErrorEvent",
    "DeviceMotionEvent",
    "DragEvent",
    "IDBVersionChangeEvent",
    "KeyEvent",
    "KeyboardEvent",
    "LSProgressEvent",
    "MessageEvent",
    "MouseScrollEvent",
    "MozSmsEvent",
    "MutationEvent",
    "NSEvent",
    "NotifyAudioAvailableEvent",
    "NotifyPaintEvent",
    "SVGEvent",
    "SVGZoomEvent",
    "ScrollAreaEvent",
    "SimpleGestureEvent",
    "SmartCardEvent",
    "TimeEvent",
    "TransitionEvent",
    "USSDReceivedEvent",
    "XMLHttpProgressEvent",
    "XULCommandEvent",

    "Event",
    "CloseEvent",
    "CustomEvent",
    "DOMTransactionEvent",
    "DeviceLightEvent",
    "DeviceOrientationEvent",
    "DeviceProximityEvent",
    "DeviceStorageChangeEvent",
    "HashChangeEvent",
    "MouseEvent",
    "MozApplicationEvent",
    "MozContactChangeEvent",
    "MozSettingsEvent",
    "PageTransitionEvent",
    "PopStateEvent",
    "PopupBlockedEvent",
    "ProgressEvent",
    "StorageEvent",
    "UIEvent",
    "UserProximityEvent",
    "WheelEvent",

    "AsyncScrollEventDetail",
    "BatteryManager",
    "BoxObject",
    "CRMFObject",
    "CSSCharsetRule",
    "CSSConditionRule",
    "CSSFontFaceRule",
    "CSSGroupRuleRuleList",
    "CSSGroupingRule",
    "CSSImportRule",
    "CSSMediaRule",
    "CSSMozDocumentRule",
    "CSSNameSpaceRule",
    "CSSPageRule",
    "CSSRect",
    "CSSRule",
    "CSSRuleList",
    "CSSStyleRule",
    "CSSStyleSheet",
    "CSSSupportsRule",
    "CSSUnknownRule",
    "CameraCapabilities",
    "CameraControl",
    "CameraManager",
    "CanvasGradient",
    "CanvasPattern",
    "ChromeWindow",
    "ClientInformation",
    "ClientRect",
    "Contact",
    "ContactAddress",
    "ContactField",
    "ContactFindOptions",
    "ContactManager",
    "ContactProperties",
    "ContactTelField",
    "Counter",
    "CryptoDialogs",
    "DOMError",
    "DOMRequest",
    "DataChannel",
    "DataTransfer",
    "DesktopNotification",
    "DesktopNotificationCenter",
    "DeviceAcceleration",
    "DeviceRotationRate",
    "DeviceStorage",
    "DeviceStorageCursor",
    "DeviceStorageStat",
    "DocumentTouch",
    "DocumentXBL",
    "ElementCSSInlineStyle",
    "ElementTimeControl",
    "EventListener",
    "EventListenerInfo",
    "FileRequest",
    "FontFace",
    "FontFaceList",
    "GeoGeolocation",
    "GeoPosition",
    "GeoPositionCallback",
    "GeoPositionCoords",
    "GeoPositionError",
    "GeoPositionErrorCallback",
    "GetSVGDocument",
    "GetUserMediaErrorCallback",
    "GetUserMediaSuccessCallback",
    "GlobalObjectConstructor",
    "GlobalPropertyInitializer",
    "IDBCursor",
    "IDBCursorWithValue",
    "IDBDatabase",
    "IDBFactory",
    "IDBIndex",
    "IDBKeyRange",
    "IDBObjectStore",
    "IDBOpenDBRequest",
    "IDBRequest",
    "IDBTransaction",
    "ImageDocument",
    "JSWindow",
    "LinkStyle",
    "LoadStatus",
    "LocalMediaStream",
    "LockedFile",
    "MediaError",
    "MediaList",
    "MediaQueryList",
    "MediaQueryListListener",
    "MediaStream",
    "MimeType",
    "ModalContentWindow",
    "MozAlarmsManager",
    "MozBrowserFrame",
    "MozCSSKeyframeRule",
    "MozCSSKeyframesRule",
    "MozCanvasPrintState",
    "MozConnection",
    "MozNavigatorNetwork",
    "MozNavigatorSms",
    "MozPowerManager",
    "MozSmsCursor",
    "MozSmsManager",
    "MozSmsMessage",
    "MozSmsRequest",
    "MozSmsSegmentInfo",
    "MozWakeLock",
    "MozWakeLockListener",
    "NSEditableElement",
    "NSXPathExpression",
    "NamedNodeMap",
    "NavigatorCamera",
    "NavigatorDesktopNotification",
    "NavigatorDeviceStorage",
    "NavigatorGeolocation",
    "NavigatorUserMedia",
    "NodeFilter",
    "NodeIterator",
    "NodeSelector",
    "OpenWindowEventDetail",
    "Parser",
    "PermissionSettings",
    "Pkcs11",
    "Plugin",
    "PluginArray",
    "RTCIceCandidate",
    "RTCPeerConnection",
    "RTCSessionDescription",
    "Range",
    "RequestService",
    "Selection",
    "Serializer",
    "SettingsLock",
    "SettingsManager",
    "StorageIndexedDB",
    "StorageItem",
    "StorageManager",
    "StorageObsolete",
    "StyleSheet",
    "StyleSheetList",
    "TCPSocket",
    "TextMetrics",
    "TimeRanges",
    "ToString",
    "TreeColumn",
    "TreeColumns",
    "TreeContentView",
    "TreeSelection",
    "TreeWalker",
    "UserDataHandler",
    "ValidityState",
    "WindowCollection",
    "WindowInternal",
    "WindowPerformance",
    "WindowUtils",
    "XMLDocument",
    "XMLStylesheetProcessingInstruction",
    "XPathExpression",
    "XPathNSResolver",
    "XPathNamespace",
    "XPathResult",

    "Audio",
    "AudioBuffer",
    "AudioBufferSourceNode",
    "AudioDestinationNode",
    "AudioListener",
    "AudioNode",
    "AudioParam",
    "AudioSourceNode",
    "BiquadFilterNode",
    "CDATASection",
    "CSSPrimitiveValue",
    "CSSValue",
    "CSSValueList",
    "CanvasRenderingContext2D",
    "CaretPosition",
    "ClientRectList",
    "Comment",
    "DOMImplementation",
    "DOMParser",
    "DOMSettableTokenList",
    "DelayNode",
    "DocumentFragment",
    "DocumentType",
    "DynamicsCompressorNode",
    "EventSource",
    "FileHandle",
    "FileList",
    "FileReader",
    "FormData",
    "GainNode",
    "ImageData",
    "MozSmsFilter",
    "MutationObserver",
    "MutationRecord",
    "PaintRequest",
    "PaintRequestList",
    "PannerNode",
    "ProcessingInstruction",
    "PropertyNodeList",
    "RGBColor",
    "Rect",
    "TextDecoder",
    "TextEncoder",
    "WebGLActiveInfo",
    "WebGLRenderingContext",
    "WebGLShaderPrecisionFormat",
    "WebSocket",
    "XMLHttpRequest",
    "XMLHttpRequestUpload",
    "XMLSerializer",
    "XPathEvaluator",
    "XSLTProcessor",

    "SVGAElement",
    "SVGAltGlyphElement",
    "SVGAngle",
    "SVGAnimatedAngle",
    "SVGAnimatedBoolean",
    "SVGAnimatedEnumeration",
    "SVGAnimatedInteger",
    "SVGAnimatedLength",
    "SVGAnimatedLengthList",
    "SVGAnimatedNumber",
    "SVGAnimatedNumberList",
    "SVGAnimatedPathData",
    "SVGAnimatedPoints",
    "SVGAnimatedPreserveAspectRatio",
    "SVGAnimatedRect",
    "SVGAnimatedString",
    "SVGAnimatedTransformList",
    "SVGAnimateElement",
    "SVGAnimateMotionElement",
    "SVGAnimateTransformElement",
    "SVGAnimationElement",
    "SVGCircleElement",
    "SVGClipPathElement",
    "SVGComponentTransferFunctionElement",
    "SVGDefsElement",
    "SVGDescElement",
    "SVGDocument",
    "SVGElement",
    "SVGEllipseElement",
    "SVGFEBlendElement",
    "SVGFEColorMatrixElement",
    "SVGFEComponentTransferElement",
    "SVGFECompositeElement",
    "SVGFEConvolveMatrixElement",
    "SVGFEDiffuseLightingElement",
    "SVGFEDisplacementMapElement",
    "SVGFEDistantLightElement",
    "SVGFEFloodElement",
    "SVGFEFuncAElement",
    "SVGFEFuncBElement",
    "SVGFEFuncGElement",
    "SVGFEFuncRElement",
    "SVGFEGaussianBlurElement",
    "SVGFEImageElement",
    "SVGFEMergeElement",
    "SVGFEMergeNodeElement",
    "SVGFEMorphologyElement",
    "SVGFEOffsetElement",
    "SVGFEPointLightElement",
    "SVGFESpecularLightingElement",
    "SVGFESpotLightElement",
    "SVGFETileElement",
    "SVGFETurbulenceElement",
    "SVGFilterElement",
    "SVGFilterPrimitiveStandardAttributes",
    "SVGFitToViewBox",
    "SVGForeignObjectElement",
    "SVGGElement",
    "SVGGradientElement",
    "SVGGraphicsElement",
    "SVGImageElement",
    "SVGLength",
    "SVGLengthList",
    "SVGLinearGradientElement",
    "SVGLineElement",
    "SVGLocatable",
    "SVGLocatableElement",
    "SVGMarkerElement",
    "SVGMaskElement",
    "SVGMatrix",
    "SVGMetadataElement",
    "SVGMpathElement",
    "SVGMPathElement",
    "SVGNumber",
    "SVGNumberList",
    "SVGPathElement",
    "SVGPathSeg",
    "SVGPathSegArcAbs",
    "SVGPathSegArcRel",
    "SVGPathSegClosePath",
    "SVGPathSegCurvetoCubicAbs",
    "SVGPathSegCurvetoCubicRel",
    "SVGPathSegCurvetoCubicSmoothAbs",
    "SVGPathSegCurvetoCubicSmoothRel",
    "SVGPathSegCurvetoQuadraticAbs",
    "SVGPathSegCurvetoQuadraticRel",
    "SVGPathSegCurvetoQuadraticSmoothAbs",
    "SVGPathSegCurvetoQuadraticSmoothRel",
    "SVGPathSegLinetoAbs",
    "SVGPathSegLinetoHorizontalAbs",
    "SVGPathSegLinetoHorizontalRel",
    "SVGPathSegLinetoRel",
    "SVGPathSegLinetoVerticalAbs",
    "SVGPathSegLinetoVerticalRel",
    "SVGPathSegList",
    "SVGPathSegMovetoAbs",
    "SVGPathSegMovetoRel",
    "SVGPatternElement",
    "SVGPoint",
    "SVGPointList",
    "SVGPolygonElement",
    "SVGPolylineElement",
    "SVGPreserveAspectRatio",
    "SVGRadialGradientElement",
    "SVGRect",
    "SVGRectElement",
    "SVGScriptElement",
    "SVGSetElement",
    "SVGStopElement",
    "SVGStringList",
    "SVGStyleElement",
    "SVGSVGElement",
    "SVGSwitchElement",
    "SVGSymbolElement",
    "SVGTests",
    "SVGTextContentElement",
    "SVGTextElement",
    "SVGTextPathElement",
    "SVGTextPositioningElement",
    "SVGTitleElement",
    "SVGTransform",
    "SVGTransformable",
    "SVGTransformableElement",
    "SVGTransformList",
    "SVGTSpanElement",
    "SVGUnitTypes",
    "SVGURIReference",
    "SVGUseElement",
    "SVGViewElement",

    "XULButtonElement",
    "XULCheckboxElement",
    "XULCommandDispatcher",
    "XULContainerElement",
    "XULContainerItemElement",
    "XULControlElement",
    "XULDescriptionElement",
    "XULDocument",
    "XULImageElement",
    "XULLabelElement",
    "XULLabeledControlElement",
    "XULMenuListElement",
    "XULMultiSelectControlElement",
    "XULPopupElement",
    "XULRelatedElement",
    "XULSelectControlElement",
    "XULSelectControlItemElement",
    "XULTemplateBuilder",
    "XULTextBoxElement",
    "XULTreeBuilder",
    "XULTreeElement",

    "mozAudioContext",
    "BrowserFeedWriter",
    "CSS",
    "DOMStringMap",
    "WebGLBuffer",
    "WebGLFramebuffer",
    "WebGLProgram",
    "WebGLRenderbuffer",
    "WebGLShader",
    "WebGLTexture",
    "WebGLUniformLocation",
    "mozContact",
    "mozRTCIceCandidate",
    "mozRTCPeerConnection",
    "mozRTCSessionDescription",

    "devicePixelRatio",
    "external",
    "mozIndexedDB",
    "sidebar",
    "getDefaultComputedStyle",

    "Infinity",
    "NaN",
    "undefined",
    "eval",

    "speechSynthesis",
    "requestAnimationFrame",
];

domMemberMap.Location =
[
    "href",
    "protocol",
    "host",
    "hostname",
    "port",
    "pathname",
    "search",
    "hash",

    "assign",
    "reload",
    "replace",

    "QueryInterface"
];

domMemberMap.Node =
[
    "id",
    "className",

    "nodeType",
    "tagName",
    "nodeName",
    "localName",
    "prefix",
    "namespaceURI",
    "nodeValue",

    "ownerDocument",
    "parentNode",
    "parentElement",
    "offsetParent",
    "nextSibling",
    "previousSibling",
    "firstChild",
    "lastChild",
    "childNodes",
    "attributes",
    "contains",

    "dir",
    "baseURI",
    "textContent",
    "innerHTML",

    "addEventListener",
    "removeEventListener",
    "dispatchEvent",
    "cloneNode",
    "appendChild",
    "insertBefore",
    "replaceChild",
    "removeChild",
    "compareDocumentPosition",
    "hasAttributes",
    "hasChildNodes",
    "lookupNamespaceURI",
    "lookupPrefix",
    "normalize",
    "isDefaultNamespace",
    "isEqualNode",
    "isSameNode",
    "isSupported",
    "getFeature",
    "getUserData",
    "setUserData",

    "QueryInterface"
];

domMemberMap.Document = Arr.extendArray(domMemberMap.Node,
[
    "documentElement",
    "body",
    "head",
    "title",
    "location",
    "referrer",
    "cookie",
    "contentType",
    "lastModified",
    "characterSet",
    "inputEncoding",
    "xmlEncoding",
    "xmlStandalone",
    "xmlVersion",
    "strictErrorChecking",
    "documentURI",
    "URL",

    "defaultView",
    "doctype",
    "implementation",
    "styleSheets",
    "images",
    "links",
    "forms",
    "anchors",
    "embeds",
    "plugins",
    "applets",

    "width",
    "height",

    "designMode",
    "compatMode",
    "async",
    "readyState",

    "preferredStyleSheetSet",
    "lastStyleSheetSet",
    "styleSheetSets",
    "selectedStyleSheetSet",
    "enableStyleSheetsForSet",

    "elementFromPoint",
    "hasFocus",
    "activeElement",

    "getElementsByClassName",
    "querySelector",
    "querySelectorAll",

    "alinkColor",
    "linkColor",
    "vlinkColor",
    "bgColor",
    "fgColor",
    "domain",

    "addEventListener",
    "removeEventListener",
    "dispatchEvent",
    "captureEvents",
    "releaseEvents",
    "routeEvent",
    "clear",
    "open",
    "close",
    "execCommand",
    "execCommandShowHelp",
    "getElementsByName",
    "getSelection",
    "queryCommandEnabled",
    "queryCommandIndeterm",
    "queryCommandState",
    "queryCommandSupported",
    "queryCommandText",
    "queryCommandValue",
    "write",
    "writeln",
    "adoptNode",
    "appendChild",
    "removeChild",
    "renameNode",
    "cloneNode",
    "compareDocumentPosition",
    "createAttribute",
    "createAttributeNS",
    "createCDATASection",
    "createComment",
    "createDocumentFragment",
    "createElement",
    "createElementNS",
    "createEntityReference",
    "createEvent",
    "createExpression",
    "createNSResolver",
    "createNodeIterator",
    "createProcessingInstruction",
    "createRange",
    "createTextNode",
    "createTreeWalker",
    "domConfig",
    "evaluate",
    "evaluateFIXptr",
    "evaluateXPointer",
    "getAnonymousElementByAttribute",
    "getAnonymousNodes",
    "addBinding",
    "removeBinding",
    "getBindingParent",
    "getBoxObjectFor",
    "setBoxObjectFor",
    "getElementById",
    "getElementsByTagName",
    "getElementsByTagNameNS",
    "hasAttributes",
    "hasChildNodes",
    "importNode",
    "insertBefore",
    "isDefaultNamespace",
    "isEqualNode",
    "isSameNode",
    "isSupported",
    "load",
    "loadBindingDocument",
    "lookupNamespaceURI",
    "lookupPrefix",
    "normalize",
    "normalizeDocument",
    "getFeature",
    "getUserData",
    "setUserData",

    "hidden",
    "mozFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozHidden",
    "mozPointerLockElement",
    "mozSyntheticDocument",
    "mozVisibilityState",
    "currentScript",
    "scripts",
    "visibilityState",
    "caretPositionFromPoint",
    "getItems",
    "mozCancelFullScreen",
    "mozExitPointerLock",
    "mozSetImageElement",
    "releaseCapture"
]);

domMemberMap.Element = Arr.extendArray(domMemberMap.Node,
[
    "clientWidth",
    "clientHeight",
    "offsetLeft",
    "offsetTop",
    "offsetWidth",
    "offsetHeight",
    "scrollLeft",
    "scrollTop",
    "scrollWidth",
    "scrollHeight",

    "style",

    "tabIndex",
    "title",
    "lang",
    "align",
    "spellcheck",

    "addEventListener",
    "removeEventListener",
    "dispatchEvent",
    "focus",
    "blur",
    "click",
    "cloneNode",
    "appendChild",
    "insertBefore",
    "replaceChild",
    "removeChild",
    "compareDocumentPosition",
    "getElementsByTagName",
    "getElementsByTagNameNS",
    "getAttribute",
    "getAttributeNS",
    "getAttributeNode",
    "getAttributeNodeNS",
    "setAttribute",
    "setAttributeNS",
    "setAttributeNode",
    "setAttributeNodeNS",
    "removeAttribute",
    "removeAttributeNS",
    "removeAttributeNode",
    "hasAttribute",
    "hasAttributeNS",
    "hasAttributes",
    "hasChildNodes",
    "lookupNamespaceURI",
    "lookupPrefix",
    "normalize",
    "isDefaultNamespace",
    "isEqualNode",
    "isSameNode",
    "isSupported",
    "getFeature",
    "getUserData",
    "setUserData",

    "childElementCount",
    "children",
    "classList",
    "clientLeft",
    "clientTop",
    "contentEditable",
    "draggable",
    "firstElementChild",
    "lastElementChild",
    "nextElementSibling",
    "previousElementSibling",

    "getBoundingClientRect",
    "getClientRects",
    "getElementsByClassName",
    "mozMatchesSelector",
    "querySelector",
    "querySelectorAll",
    "scrollIntoView",

    "isContentEditable",
    "dataset",
    "contextMenu",
    "accessKey",
    "accessKeyLabel",
    "outerHTML",
    "properties",
    "scrollLeftMax",
    "scrollTopMax",
    "insertAdjacentHTML",
    "mozRequestFullScreen",
    "mozRequestPointerLock",

    "itemId",
    "itemRef",
    "itemScope",
    "itemProp",
    "itemType",
    "itemValue",

    "onload",
    "hidden",
    "setCapture",
    "releaseCapture"
]);

domMemberMap.SVGElement = Arr.extendArray(domMemberMap.Element,
[
    "x",
    "y",
    "width",
    "height",
    "rx",
    "ry",
    "transform",
    "href",

    "ownerSVGElement",
    "viewportElement",
    "farthestViewportElement",
    "nearestViewportElement",

    "getBBox",
    "getCTM",
    "getScreenCTM",
    "getTransformToElement",
    "getPresentationAttribute",
    "preserveAspectRatio"
]);

domMemberMap.SVGSVGElement = Arr.extendArray(domMemberMap.Element,
[
    "x",
    "y",
    "width",
    "height",
    "rx",
    "ry",
    "transform",

    "viewBox",
    "viewport",
    "currentView",
    "useCurrentView",
    "pixelUnitToMillimeterX",
    "pixelUnitToMillimeterY",
    "screenPixelToMillimeterX",
    "screenPixelToMillimeterY",
    "currentScale",
    "currentTranslate",
    "zoomAndPan",

    "ownerSVGElement",
    "viewportElement",
    "farthestViewportElement",
    "nearestViewportElement",
    "contentScriptType",
    "contentStyleType",

    "getBBox",
    "getCTM",
    "getScreenCTM",
    "getTransformToElement",
    "getEnclosureList",
    "getIntersectionList",
    "getViewboxToViewportTransform",
    "getPresentationAttribute",
    "getElementById",
    "checkEnclosure",
    "checkIntersection",
    "createSVGAngle",
    "createSVGLength",
    "createSVGMatrix",
    "createSVGNumber",
    "createSVGPoint",
    "createSVGRect",
    "createSVGString",
    "createSVGTransform",
    "createSVGTransformFromMatrix",
    "deSelectAll",
    "preserveAspectRatio",
    "forceRedraw",
    "suspendRedraw",
    "unsuspendRedraw",
    "unsuspendRedrawAll",
    "getCurrentTime",
    "setCurrentTime",
    "animationsPaused",
    "pauseAnimations",
    "unpauseAnimations"
]);

domMemberMap.HTMLImageElement = Arr.extendArray(domMemberMap.Element,
[
    "src",
    "naturalWidth",
    "naturalHeight",
    "width",
    "height",
    "x",
    "y",
    "name",
    "alt",
    "longDesc",
    "lowsrc",
    "border",
    "complete",
    "hspace",
    "vspace",
    "isMap",
    "useMap",
]);

domMemberMap.HTMLAnchorElement = Arr.extendArray(domMemberMap.Element,
[
    "name",
    "target",
    "accessKey",
    "href",
    "protocol",
    "host",
    "hostname",
    "port",
    "pathname",
    "search",
    "hash",
    "hreflang",
    "coords",
    "shape",
    "text",
    "type",
    "rel",
    "rev",
    "ping",
    "download",
    "charset"
]);

domMemberMap.HTMLIFrameElement = Arr.extendArray(domMemberMap.Element,
[
    "contentDocument",
    "contentWindow",
    "frameBorder",
    "height",
    "longDesc",
    "marginHeight",
    "marginWidth",
    "name",
    "scrolling",
    "src",
    "width"
]);

domMemberMap.HTMLTableElement = Arr.extendArray(domMemberMap.Element,
[
    "bgColor",
    "border",
    "caption",
    "cellPadding",
    "cellSpacing",
    "frame",
    "rows",
    "rules",
    "summary",
    "tBodies",
    "tFoot",
    "tHead",
    "width",

    "createCaption",
    "createTFoot",
    "createTHead",
    "deleteCaption",
    "deleteRow",
    "deleteTFoot",
    "deleteTHead",
    "insertRow"
]);

domMemberMap.HTMLTableRowElement = Arr.extendArray(domMemberMap.Element,
[
    "bgColor",
    "cells",
    "ch",
    "chOff",
    "rowIndex",
    "sectionRowIndex",
    "vAlign",

    "deleteCell",
    "insertCell"
]);

domMemberMap.HTMLTableCellElement = Arr.extendArray(domMemberMap.Element,
[
    "abbr",
    "axis",
    "bgColor",
    "cellIndex",
    "ch",
    "chOff",
    "colSpan",
    "headers",
    "height",
    "noWrap",
    "rowSpan",
    "scope",
    "vAlign",
    "width"

]);

domMemberMap.HTMLScriptElement = Arr.extendArray(domMemberMap.Element,
[
    "src",
    "type",
    "async",
    "charset",
    "crossOrigin",
    "defer",
    "event",
    "htmlFor",
    "text"
]);

domMemberMap.HTMLButtonElement = Arr.extendArray(domMemberMap.Element,
[
    "accessKey",
    "disabled",
    "form",
    "name",
    "type",
    "value",

    "autofocus",
    "formAction",
    "formEnctype",
    "formMethod",
    "formNoValidate",
    "formTarget",

    "validity",
    "validationMessage",
    "willValidate",
    "checkValidity",
    "setCustomValidity",

    "click"
]);

domMemberMap.HTMLInputElement = Arr.extendArray(domMemberMap.Element,
[
    "type",
    "value",
    "checked",
    "accept",
    "accessKey",
    "alt",
    "autocomplete",
    "autofocus",
    "controllers",
    "defaultChecked",
    "defaultValue",
    "disabled",
    "form",
    "formAction",
    "formEnctype",
    "formMethod",
    "formNoValidate",
    "formTarget",
    "maxLength",
    "name",
    "readOnly",
    "selectionEnd",
    "selectionStart",
    "size",
    "src",
    "textLength",
    "useMap",

    "files",
    "indeterminate",
    "multiple",
    "list",
    "mozGetFileNameArray",
    "mozSetFileNameArray",

    "pattern",
    "placeholder",
    "required",

    "height",
    "width",
    "inputmode",
    "max",
    "min",
    "step",
    "selectionDirection",
    "validity",
    "validationMessage",
    "willValidate",
    "checkValidity",
    "setCustomValidity",
    "valueAsDate",
    "valueAsNumber",
    "mozIsTextField",
    "stepUp",
    "stepDown",

    "click",
    "select",
    "setSelectionRange"
]);

domMemberMap.HTMLFormElement = Arr.extendArray(domMemberMap.Element,
[
    "acceptCharset",
    "action",
    "author",
    "elements",
    "encoding",
    "enctype",
    "entry_id",
    "length",
    "method",
    "name",
    "post",
    "target",
    "text",
    "url",

    "checkValidity",
    "noValidate",
    "autocomplete",

    "reset",
    "submit"
]);

domMemberMap.HTMLBodyElement = Arr.extendArray(domMemberMap.Element,
[
    "aLink",
    "background",
    "bgColor",
    "link",
    "text",
    "vLink"
]);

domMemberMap.HTMLHtmlElement = Arr.extendArray(domMemberMap.Element,
[
    "version"
]);

domMemberMap.Text = Arr.extendArray(domMemberMap.Node,
[
    "data",
    "length",

    "appendData",
    "deleteData",
    "insertData",
    "replaceData",
    "splitText",
    "wholeText",
    "substringData"
]);

domMemberMap.Attr = Arr.extendArray(domMemberMap.Node,
[
    "name",
    "value",
    "specified",
    "ownerElement"
]);

domMemberMap.Event =
[
    "type",
    "target",
    "currentTarget",
    "originalTarget",
    "explicitOriginalTarget",
    "relatedTarget",
    "rangeParent",
    "rangeOffset",
    "view",

    "keyCode",
    "charCode",
    "screenX",
    "screenY",
    "clientX",
    "clientY",
    "layerX",
    "layerY",
    "pageX",
    "pageY",

    "detail",
    "button",
    "which",
    "ctrlKey",
    "shiftKey",
    "altKey",
    "metaKey",

    "eventPhase",
    "timeStamp",
    "bubbles",
    "cancelable",
    "cancelBubble",

    "isTrusted",
    "isChar",

    "getPreventDefault",
    "initEvent",
    "initMouseEvent",
    "initKeyEvent",
    "initUIEvent",
    "preventBubble",
    "preventCapture",
    "preventDefault",
    "stopPropagation"
];

domMemberMap.Array = Object.getOwnPropertyNames(Array.prototype).filter(function(name)
{
    return name !== "length";
});

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

Dom.domConstantMap =
{
    "ELEMENT_NODE": 1,
    "ATTRIBUTE_NODE": 1,
    "TEXT_NODE": 1,
    "CDATA_SECTION_NODE": 1,
    "ENTITY_REFERENCE_NODE": 1,
    "ENTITY_NODE": 1,
    "PROCESSING_INSTRUCTION_NODE": 1,
    "COMMENT_NODE": 1,
    "DOCUMENT_NODE": 1,
    "DOCUMENT_TYPE_NODE": 1,
    "DOCUMENT_FRAGMENT_NODE": 1,
    "NOTATION_NODE": 1,

    "DOCUMENT_POSITION_DISCONNECTED": 1,
    "DOCUMENT_POSITION_PRECEDING": 1,
    "DOCUMENT_POSITION_FOLLOWING": 1,
    "DOCUMENT_POSITION_CONTAINS": 1,
    "DOCUMENT_POSITION_CONTAINED_BY": 1,
    "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC": 1,

    "UNKNOWN_RULE": 1,
    "STYLE_RULE": 1,
    "CHARSET_RULE": 1,
    "IMPORT_RULE": 1,
    "MEDIA_RULE": 1,
    "FONT_FACE_RULE": 1,
    "PAGE_RULE": 1,
    "KEYFRAMES_RULE": 1,
    "KEYFRAME_RULE": 1,
    "MOZ_KEYFRAMES_RULE": 1,
    "MOZ_KEYFRAME_RULE": 1,
    "NAMESPACE_RULE": 1,
    "SUPPORTS_RULE": 1,

    "CAPTURING_PHASE": 1,
    "AT_TARGET": 1,
    "BUBBLING_PHASE": 1,

    "SCROLL_PAGE_UP": 1,
    "SCROLL_PAGE_DOWN": 1,

    "MOUSEUP": 1,
    "MOUSEDOWN": 1,
    "MOUSEOVER": 1,
    "MOUSEOUT": 1,
    "MOUSEMOVE": 1,
    "MOUSEDRAG": 1,
    "CLICK": 1,
    "DBLCLICK": 1,
    "KEYDOWN": 1,
    "KEYUP": 1,
    "KEYPRESS": 1,
    "DRAGDROP": 1,
    "FOCUS": 1,
    "BLUR": 1,
    "SELECT": 1,
    "CHANGE": 1,
    "RESET": 1,
    "SUBMIT": 1,
    "SCROLL": 1,
    "LOAD": 1,
    "UNLOAD": 1,
    "XFER_DONE": 1,
    "ABORT": 1,
    "ERROR": 1,
    "LOCATE": 1,
    "MOVE": 1,
    "RESIZE": 1,
    "FORWARD": 1,
    "HELP": 1,
    "BACK": 1,
    "TEXT": 1,

    "ALT_MASK": 1,
    "CONTROL_MASK": 1,
    "SHIFT_MASK": 1,
    "META_MASK": 1,

    "DOM_VK_TAB": 1,
    "DOM_VK_PAGE_UP": 1,
    "DOM_VK_PAGE_DOWN": 1,
    "DOM_VK_UP": 1,
    "DOM_VK_DOWN": 1,
    "DOM_VK_LEFT": 1,
    "DOM_VK_RIGHT": 1,
    "DOM_VK_CANCEL": 1,
    "DOM_VK_HELP": 1,
    "DOM_VK_BACK_SPACE": 1,
    "DOM_VK_CLEAR": 1,
    "DOM_VK_RETURN": 1,
    "DOM_VK_ENTER": 1,
    "DOM_VK_SHIFT": 1,
    "DOM_VK_CONTROL": 1,
    "DOM_VK_ALT": 1,
    "DOM_VK_PAUSE": 1,
    "DOM_VK_CAPS_LOCK": 1,
    "DOM_VK_ESCAPE": 1,
    "DOM_VK_SPACE": 1,
    "DOM_VK_END": 1,
    "DOM_VK_HOME": 1,
    "DOM_VK_PRINTSCREEN": 1,
    "DOM_VK_INSERT": 1,
    "DOM_VK_DELETE": 1,
    "DOM_VK_0": 1,
    "DOM_VK_1": 1,
    "DOM_VK_2": 1,
    "DOM_VK_3": 1,
    "DOM_VK_4": 1,
    "DOM_VK_5": 1,
    "DOM_VK_6": 1,
    "DOM_VK_7": 1,
    "DOM_VK_8": 1,
    "DOM_VK_9": 1,
    "DOM_VK_SEMICOLON": 1,
    "DOM_VK_EQUALS": 1,
    "DOM_VK_A": 1,
    "DOM_VK_B": 1,
    "DOM_VK_C": 1,
    "DOM_VK_D": 1,
    "DOM_VK_E": 1,
    "DOM_VK_F": 1,
    "DOM_VK_G": 1,
    "DOM_VK_H": 1,
    "DOM_VK_I": 1,
    "DOM_VK_J": 1,
    "DOM_VK_K": 1,
    "DOM_VK_L": 1,
    "DOM_VK_M": 1,
    "DOM_VK_N": 1,
    "DOM_VK_O": 1,
    "DOM_VK_P": 1,
    "DOM_VK_Q": 1,
    "DOM_VK_R": 1,
    "DOM_VK_S": 1,
    "DOM_VK_T": 1,
    "DOM_VK_U": 1,
    "DOM_VK_V": 1,
    "DOM_VK_W": 1,
    "DOM_VK_X": 1,
    "DOM_VK_Y": 1,
    "DOM_VK_Z": 1,
    "DOM_VK_CONTEXT_MENU": 1,
    "DOM_VK_NUMPAD0": 1,
    "DOM_VK_NUMPAD1": 1,
    "DOM_VK_NUMPAD2": 1,
    "DOM_VK_NUMPAD3": 1,
    "DOM_VK_NUMPAD4": 1,
    "DOM_VK_NUMPAD5": 1,
    "DOM_VK_NUMPAD6": 1,
    "DOM_VK_NUMPAD7": 1,
    "DOM_VK_NUMPAD8": 1,
    "DOM_VK_NUMPAD9": 1,
    "DOM_VK_MULTIPLY": 1,
    "DOM_VK_ADD": 1,
    "DOM_VK_SEPARATOR": 1,
    "DOM_VK_SUBTRACT": 1,
    "DOM_VK_DECIMAL": 1,
    "DOM_VK_DIVIDE": 1,
    "DOM_VK_F1": 1,
    "DOM_VK_F2": 1,
    "DOM_VK_F3": 1,
    "DOM_VK_F4": 1,
    "DOM_VK_F5": 1,
    "DOM_VK_F6": 1,
    "DOM_VK_F7": 1,
    "DOM_VK_F8": 1,
    "DOM_VK_F9": 1,
    "DOM_VK_F10": 1,
    "DOM_VK_F11": 1,
    "DOM_VK_F12": 1,
    "DOM_VK_F13": 1,
    "DOM_VK_F14": 1,
    "DOM_VK_F15": 1,
    "DOM_VK_F16": 1,
    "DOM_VK_F17": 1,
    "DOM_VK_F18": 1,
    "DOM_VK_F19": 1,
    "DOM_VK_F20": 1,
    "DOM_VK_F21": 1,
    "DOM_VK_F22": 1,
    "DOM_VK_F23": 1,
    "DOM_VK_F24": 1,
    "DOM_VK_NUM_LOCK": 1,
    "DOM_VK_SCROLL_LOCK": 1,
    "DOM_VK_COMMA": 1,
    "DOM_VK_PERIOD": 1,
    "DOM_VK_SLASH": 1,
    "DOM_VK_BACK_QUOTE": 1,
    "DOM_VK_OPEN_BRACKET": 1,
    "DOM_VK_BACK_SLASH": 1,
    "DOM_VK_CLOSE_BRACKET": 1,
    "DOM_VK_QUOTE": 1,
    "DOM_VK_META": 1,

    "UNCACHED": 1,
    "IDLE": 1,
    "CHECKING": 1,
    "DOWNLOADING": 1,
    "UPDATEREADY": 1,
    "OBSOLETE": 1,

    "SVG_ZOOMANDPAN_DISABLE": 1,
    "SVG_ZOOMANDPAN_MAGNIFY": 1,
    "SVG_ZOOMANDPAN_UNKNOWN": 1
};

// ********************************************************************************************* //
// Inline Event Handlers (introduced in Firefox 9)

/**
 * List of event handlers that are settable via on* DOM properties.
 */
Dom.domInlineEventHandlersMap =
{
    "onabort": 1,
    "onafterprint": 1,
    "onafterscriptexecute": 1,
    "onbeforeprint": 1,
    "onbeforescriptexecute": 1,
    "onbeforeunload": 1,
    "onblur": 1,
    "oncanplay": 1,
    "oncanplaythrough": 1,
    "onchange": 1,
    "onclick": 1,
    "oncontextmenu": 1,
    "oncopy": 1,
    "oncut": 1,
    "ondblclick": 1,
    "ondevicemotion": 1,
    "ondeviceorientation": 1,
    "ondrag": 1,
    "ondragend": 1,
    "ondragenter": 1,
    "ondragleave": 1,
    "ondragover": 1,
    "ondragstart": 1,
    "ondrop": 1,
    "ondurationchange": 1,
    "onemptied": 1,
    "onended": 1,
    "onerror": 1,
    "onfocus": 1,
    "onhashchange": 1,
    "oninput": 1,
    "oninvalid": 1,
    "onkeydown": 1,
    "onkeypress": 1,
    "onkeyup": 1,
    "onload": 1,
    "onloadeddata": 1,
    "onloadedmetadata": 1,
    "onloadstart": 1,
    "onmessage": 1,
    "onmousedown": 1,
    "onmousemove": 1,
    "onmouseout": 1,
    "onmouseover": 1,
    "onmouseup": 1,
    "onoffline": 1,
    "ononline": 1,
    "onpagehide": 1,
    "onpageshow": 1,
    "onpaste": 1,
    "onpause": 1,
    "onplay": 1,
    "onplaying": 1,
    "onpopstate": 1,
    "onprogress": 1,
    "onratechange": 1,
    "onreadystatechange": 1,
    "onreset": 1,
    "onresize": 1,
    "onscroll": 1,
    "onseeked": 1,
    "onseeking": 1,
    "onselect": 1,
    "onshow": 1,
    "onstalled": 1,
    "onsubmit": 1,
    "onsuspend": 1,
    "ontimeupdate": 1,
    "onunload": 1,
    "onvolumechange": 1,
    "onwaiting": 1,
    "onmozfullscreenchange": 1,
    "ondevicelight": 1,
    "ondeviceproximity": 1,
    "onmouseenter": 1,
    "onmouseleave": 1,
    "onmozfullscreenerror": 1,
    "onmozpointerlockchange": 1,
    "onmozpointerlockerror": 1,
    "onuserproximity": 1,
    "onwheel": 1
};

// ********************************************************************************************* //
// Registration

return Dom;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

// xxxHonza: remove deps on FBL.
define("firebug/lib/domplate",
[
    "firebug/lib/lib",
    "firebug/lib/string"
],
function(FBL, Str) {

// ********************************************************************************************* //

var Domplate = {};

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

function DomplateTag(tagName)
{
    this.tagName = tagName;
}

Domplate.DomplateTag = DomplateTag;

function DomplateEmbed()
{
}

function DomplateLoop()
{
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

var womb = null;
var uid = 0;

// xxxHonza: the only global should be Firebug object.
var domplate = function()
{
    var lastSubject = null;
    for (var i = 0; i < arguments.length; ++i)
        lastSubject = lastSubject ? copyObject(lastSubject, arguments[i]) : arguments[i];

    for (var name in lastSubject)
    {
        var val = lastSubject[name];
        if (isTag(val))
        {
            if (val.tag.subject)
            {
                // Clone the entire domplate tag, e.g. DIV(), that is derived from
                // an existing template. This allows to hold correct 'subject'
                // reference that is used when executing callbacks implemented by
                // templates. Note that 'subject' points to the current template object.
                // See issue: http://code.google.com/p/fbug/issues/detail?id=4425
                lastSubject[name] = val = copyObject({}, val);
                val.tag = copyObject({}, val.tag);
            }
            val.tag.subject = lastSubject;
        }
    }

    return lastSubject;
};

domplate.context = function(context, fn)
{
    var lastContext = domplate.lastContext;
    domplate.topContext = context;
    fn.apply(context);
    domplate.topContext = lastContext;
};

// xxxHonza: the only global should be Firebug object.
Domplate.domplate = FBL.domplate = window.domplate = domplate;

Domplate.TAG = function()
{
    var embed = new DomplateEmbed();
    return embed.merge(arguments);
};

Domplate.FOR = function()
{
    var loop = new DomplateLoop();
    return loop.merge(arguments);
};

DomplateTag.prototype =
{
    /**
     * Initializer for DOM templates. Called to create new Functions objects like TR, TD,
     * OBJLINK, etc. See defineTag
     *
     * @param args keyword argments for the template, the {} brace stuff after the tag name,
     *      eg TR({...}, TD(...
     * @param oldTag a nested tag, eg the TD tag in TR({...}, TD(...
     */
    merge: function(args, oldTag)
    {
        if (oldTag)
            this.tagName = oldTag.tagName;

        this.context = oldTag ? oldTag.context : null;  // normally null on construction
        this.subject = oldTag ? oldTag.subject : null;
        this.attrs = oldTag ? copyObject(oldTag.attrs) : {};
        this.classes = oldTag ? copyObject(oldTag.classes) : {};
        this.props = oldTag ? copyObject(oldTag.props) : null;
        this.listeners = oldTag ? copyArray(oldTag.listeners) : null;
        this.children = oldTag ? copyArray(oldTag.children) : [];
        this.vars = oldTag ? copyArray(oldTag.vars) : [];

        var attrs = args.length ? args[0] : null;
        var hasAttrs = typeof(attrs) == "object" && !isTag(attrs);

        // Do not clear children, they can be copied from the oldTag.
        //this.children = [];

        if (domplate.topContext)
            this.context = domplate.topContext;

        if (args.length)
            parseChildren(args, hasAttrs ? 1 : 0, this.vars, this.children);

        if (hasAttrs)
            this.parseAttrs(attrs);

        return creator(this, DomplateTag);
    },

    parseAttrs: function(args)
    {
        for (var name in args)
        {
            var val = parseValue(args[name]);
            readPartNames(val, this.vars);

            if (name.lastIndexOf("on", 0) == 0)
            {
                var eventName = name.substr(2);
                if (!this.listeners)
                    this.listeners = [];
                this.listeners.push(eventName, val);
            }
            else if (name[0] == "_")
            {
                var propName = name.substr(1);
                if (!this.props)
                    this.props = {};
                this.props[propName] = val;
            }
            else if (name[0] == "$")
            {
                var className = name.substr(1);
                if (!this.classes)
                    this.classes = {};
                this.classes[className] = val;
            }
            else
            {
                if (name == "class" && this.attrs.hasOwnProperty(name))
                    this.attrs[name] += " " + val;
                else
                    this.attrs[name] = val;
            }
        }
    },

    compile: function()
    {
        if (this.renderMarkup)
            return;

        this.compileMarkup();
        this.compileDOM();
    },

    compileMarkup: function()
    {
        this.markupArgs = [];
        var topBlock = [], topOuts = [], blocks = [], info = {args: this.markupArgs, argIndex: 0};

        this.generateMarkup(topBlock, topOuts, blocks, info);
        this.addCode(topBlock, topOuts, blocks);

        var fnBlock = ['(function (__code__, __context__, __in__, __out__'];
        for (var i = 0; i < info.argIndex; ++i)
            fnBlock.push(', s', i);
        fnBlock.push(') {\n');

        if (this.subject)
            fnBlock.push('with (this) {\n');
        if (this.context)
            fnBlock.push('with (__context__) {\n');
        fnBlock.push('with (__in__) {\n');

        fnBlock.push.apply(fnBlock, blocks);

        if (this.subject)
            fnBlock.push('}\n');
        if (this.context)
            fnBlock.push('}\n');

        fnBlock.push('}})\n');

        function __link__(tag, code, outputs, args)
        {
            if (!tag || !tag.tag)
            {
                if (FBTrace.DBG_DOMPLATE)
                {
                    FBTrace.sysout("domplate.Empty tag object passed to __link__ " +
                        "(compileMarkup). Ignoring element.");
                }
                return;
            }

            tag.tag.compile();

            var tagOutputs = [];
            var markupArgs = [code, tag.tag.context, args, tagOutputs];
            markupArgs.push.apply(markupArgs, tag.tag.markupArgs);
            tag.tag.renderMarkup.apply(tag.tag.subject, markupArgs);

            outputs.push(tag);
            outputs.push(tagOutputs);
        }

        function __escape__(value)
        {
            return Str.escapeForElementAttribute(value);
        }

        function __attr__(name, valueParts)
        {
            // Will be called with valueParts = [,arg,arg,...], but we don't
            // care that the first element is undefined.
            if (valueParts.length === 2 && valueParts[1] === undefined)
                return "";
            var value = valueParts.join("");
            return ' ' + name + '="' + __escape__(value) + '"';
        }

        var isArray = Array.isArray;

        function __loop__(iter, outputs, fn)
        {
            var iterOuts = [];
            outputs.push(iterOuts);

            if (!iter)
                return;

            if (isArray(iter) || iter instanceof NodeList)
                iter = new ArrayIterator(iter);

            var value = null;
            try
            {
                while (1)
                {
                    value = iter.next();
                    var itemOuts = [0,0];
                    iterOuts.push(itemOuts);
                    fn.apply(this, [value, itemOuts]);
                }
            }
            catch (exc)
            {
                if (exc != StopIteration && FBTrace.DBG_ERRORS)
                    FBTrace.sysout("domplate; __loop__ EXCEPTION " +
                        (value ? value.name : "no value") + ", " + exc, exc);

                // Don't throw the exception, many built in objects in Firefox throws exceptions
                // these days and it breaks the UI. We can remove as soon as:
                // 389002 and 455013 are fixed.
                //if (exc != StopIteration)
                //    throw exc;
            }
        }

        if (FBTrace.DBG_DOMPLATE)
        {
            fnBlock.push("//@ sourceURL=chrome://firebug/compileMarkup_" +
                (this.tagName?this.tagName:'')+"_"+(uid++)+".js\n");
        }

        var js = fnBlock.join("");
        this.renderMarkup = eval(js);
    },

    getVarNames: function(args)
    {
        if (this.vars)
            args.push.apply(args, this.vars);

        for (var i = 0; i < this.children.length; ++i)
        {
            var child = this.children[i];
            if (isTag(child))
                child.tag.getVarNames(args);
            else if (child instanceof Parts)
            {
                for (var i = 0; i < child.parts.length; ++i)
                {
                    if (child.parts[i] instanceof Variables)
                    {
                        var name = child.parts[i].names[0];
                        var names = name.split(".");
                        args.push(names[0]);
                    }
                }
            }
        }
    },

    generateMarkup: function(topBlock, topOuts, blocks, info)
    {
        if (FBTrace.DBG_DOMPLATE)
            var beginBlock = topBlock.length;

        topBlock.push(',"<', this.tagName, '"');

        for (var name in this.attrs)
        {
            if (name != "class")
            {
                var val = this.attrs[name];
                topBlock.push(',__attr__("', name, '",[');
                addParts(val, ',', topBlock, info, false);
                topBlock.push('])');
            }
        }
        if (this.listeners)
        {
            for (var i = 0; i < this.listeners.length; i += 2)
                readPartNames(this.listeners[i+1], topOuts);
        }

        if (this.props)
        {
            for (var name in this.props)
                readPartNames(this.props[name], topOuts);
        }

        if (this.attrs.hasOwnProperty("class") || this.classes)
        {
            topBlock.push(', " class=\\""');
            if (this.attrs.hasOwnProperty("class"))
                addParts(this.attrs["class"], ',', topBlock, info, true);
            topBlock.push(', " "');
            for (var name in this.classes)
            {
                topBlock.push(', (');
                addParts(this.classes[name], '', topBlock, info);
                topBlock.push(' ? "', name, '" + " " : "")');
            }
            topBlock.push(', "\\""');
        }
        topBlock.push(',">"');

        this.generateChildMarkup(topBlock, topOuts, blocks, info);

        // <br> element doesn't use end tag.
        if (this.tagName != "br")
            topBlock.push(',"</', this.tagName, '>"');

        if (FBTrace.DBG_DOMPLATE)
            FBTrace.sysout("DomplateTag.generateMarkup " + this.tagName + ": " +
                topBlock.slice( - topBlock.length + beginBlock).join("").replace("\n"," "),
                {listeners: this.listeners, props: this.props, attrs: this.attrs});

    },

    generateChildMarkup: function(topBlock, topOuts, blocks, info)
    {
        for (var i = 0; i < this.children.length; ++i)
        {
            var child = this.children[i];
            if (isTag(child))
                child.tag.generateMarkup(topBlock, topOuts, blocks, info);
            else
                addParts(child, ',', topBlock, info, true);
        }
    },

    addCode: function(topBlock, topOuts, blocks)
    {
        if (topBlock.length)
        {
            blocks.push('__code__.push(""', topBlock.join(""), ');\n');
            if (FBTrace.DBG_DOMPLATE)
                blocks.push('FBTrace.sysout("addCode "+__code__.join(""));\n');
        }

        if (topOuts.length)
            blocks.push('__out__.push(', topOuts.join(","), ');\n');
        topBlock.splice(0, topBlock.length);
        topOuts.splice(0, topOuts.length);
    },

    addLocals: function(blocks)
    {
        var varNames = [];
        this.getVarNames(varNames);

        var map = {};
        for (var i = 0; i < varNames.length; ++i)
        {
            var name = varNames[i];
            if ( map.hasOwnProperty(name) )
                continue;

            map[name] = 1;
            var names = name.split(".");
            blocks.push('var ', names[0] + ' = ' + '__in__.' + names[0] + ';\n');
        }
    },

    compileDOM: function()
    {
        var path = [];
        var blocks = [];
        this.domArgs = [];
        path.embedIndex = 0;
        path.loopIndex = 0;
        path.staticIndex = 0;
        path.renderIndex = 0;
        var nodeCount = this.generateDOM(path, blocks, this.domArgs);

        var fnBlock = ['(function (root, context, o'];
        for (var i = 0; i < path.staticIndex; ++i)
            fnBlock.push(', ', 's'+i);
        for (var i = 0; i < path.renderIndex; ++i)
            fnBlock.push(', ', 'd'+i);

        fnBlock.push(') {\n');
        for (var i = 0; i < path.loopIndex; ++i)
            fnBlock.push('var l', i, ' = 0;\n');
        for (var i = 0; i < path.embedIndex; ++i)
            fnBlock.push('var e', i, ' = 0;\n');

        if (this.subject)
            fnBlock.push('with (this) {\n');
        if (this.context)
            fnBlock.push('with (context) {\n');

        fnBlock.push(blocks.join(""));

        if (this.context)
            fnBlock.push('}\n');
        if (this.subject)
            fnBlock.push('}\n');

        fnBlock.push('return ', nodeCount, ';\n');
        fnBlock.push('})\n');

        function __bind__(object, fn)
        {
            return function(event) { return fn.apply(object, [event]); };
        }

        function __link__(node, tag, args)
        {
            if (!tag || !tag.tag)
            {
                if (FBTrace.DBG_DOMPLATE)
                {
                    FBTrace.sysout("domplate.Empty tag object passed to __link__ " +
                        "(compileDOM). Ignoring element.");
                }
                return;
            }

            tag.tag.compile();

            var domArgs = [node, tag.tag.context, 0];
            domArgs.push.apply(domArgs, tag.tag.domArgs);
            domArgs.push.apply(domArgs, args);

            return tag.tag.renderDOM.apply(tag.tag.subject, domArgs);
        }

        function __loop__(iter, fn)
        {
            if (!iter)
                return 0;

            var nodeCount = 0;
            for (var i = 0; i < iter.length; ++i)
            {
                iter[i][0] = i;
                iter[i][1] = nodeCount;
                nodeCount += fn.apply(this, iter[i]);
            }
            return nodeCount;
        }

        // start at a given node |parent|, then index recursively into its children using
        // arguments 2, 3, ... The primary purpose of the 'path' is to name variables in the
        // generated code
        function __path__(parent, offset)
        {
            var root = parent;

            for (var i = 2; i < arguments.length; ++i)
            {
                var index = arguments[i];

                if (i == 3)
                    index += offset;

                if (index == -1)  // then walk up the tree
                    parent = parent.parentNode;
                else
                    parent = parent.childNodes[index];

                if (FBTrace.DBG_DOMPLATE && !parent)
                    FBTrace.sysout("domplate.__path__ will return null for root "+root+
                        " and offset "+offset+" arguments["+i+"]="+arguments[i]+' index: '+
                        index, {root: root});
            }

            return parent;
        }

        if (FBTrace.DBG_DOMPLATE)
            fnBlock.push("//@ sourceURL=chrome://firebug/compileDOM_"+
                (this.tagName?this.tagName:'')+"_"+(uid++)+".js\n");

        var js = fnBlock.join("");
        // Exceptions on this line are often in the eval
        try
        {
            this.renderDOM = eval(js);
        }
        catch(exc)
        {
            if (FBTrace.DBG_DOMPLATE)
                FBTrace.sysout("renderDOM FAILS "+exc, {exc:exc, js: js});
            var chained =  new Error("Domplate.renderDom FAILS");
            chained.cause = {exc:exc, js: js};
            throw chained;
        }
    },

    generateDOM: function(path, blocks, args)
    {
        if (this.listeners || this.props)
            this.generateNodePath(path, blocks);

        if (this.listeners)
        {
            for (var i = 0; i < this.listeners.length; i += 2)
            {
                var val = this.listeners[i+1];
                var arg = generateArg(val, path, args);

                blocks.push('node.addEventListener("', this.listeners[i],
                    '", __bind__(this, ', arg, '), false);\n');
            }
        }

        if (this.props)
        {
            for (var name in this.props)
            {
                var val = this.props[name];
                var arg = generateArg(val, path, args);
                blocks.push('node.', name, ' = ', arg, ';\n');
            }
        }

        this.generateChildDOM(path, blocks, args);
        return 1;
    },

    generateNodePath: function(path, blocks)
    {
        blocks.push("var node = __path__(root, o");

        // this will be a sum of integers as a string which will be summed in the eval,
        // then passed to __path__
        for (var i = 0; i < path.length; ++i)
            blocks.push(",", path[i]);

        blocks.push(");\n");

        if (FBTrace.DBG_DOMPLATE)
        {
            var nBlocks = 2*path.length + 2;
            var genTrace = "FBTrace.sysout(\'"+blocks.slice(-nBlocks).join("").replace("\n","")+
                "\'+'->'+(node?FBL.getElementHTML(node):'null'), node);\n";
            blocks.push(genTrace);
        }
    },

    generateChildDOM: function(path, blocks, args)
    {
        path.push(0);
        for (var i = 0; i < this.children.length; ++i)
        {
            var child = this.children[i];
            if (isTag(child))
                path[path.length-1] += '+' + child.tag.generateDOM(path, blocks, args);
            else
                path[path.length-1] += '+1';
        }
        path.pop();
    },

    /**
     * We are just hiding from javascript.options.strict. For some reasons it's ok if
     * we return undefined here.
     *
     * @return null or undefined or possibly a context.
     */
    getContext: function()
    {
        return this.context;
    }
};

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

DomplateEmbed.prototype = copyObject(DomplateTag.prototype,
{
    merge: function(args, oldTag)
    {
        this.value = oldTag ? oldTag.value : parseValue(args[0]);
        this.attrs = oldTag ? oldTag.attrs : {};
        this.vars = oldTag ? copyArray(oldTag.vars) : [];

        var attrs = args[1];
        for (var name in attrs)
        {
            var val = parseValue(attrs[name]);
            this.attrs[name] = val;
            readPartNames(val, this.vars);
        }

        return creator(this, DomplateEmbed);
    },

    getVarNames: function(names)
    {
        if (this.value instanceof Parts)
            names.push(this.value.parts[0].name);

        if (this.vars)
            names.push.apply(names, this.vars);
    },

    generateMarkup: function(topBlock, topOuts, blocks, info)
    {
        this.addCode(topBlock, topOuts, blocks);

        if (FBTrace.DBG_DOMPLATE)
            var beginBlock = blocks.length;

        blocks.push('__link__(');
        addParts(this.value, '', blocks, info);
        blocks.push(', __code__, __out__, {\n');

        var lastName = null;
        for (var name in this.attrs)
        {
            if (lastName)
                blocks.push(',');
            lastName = name;

            var val = this.attrs[name];
            blocks.push('"', name, '":');
            addParts(val, '', blocks, info);
        }

        blocks.push('});\n');

        if (FBTrace.DBG_DOMPLATE)
        {
            FBTrace.sysout("DomplateEmbed.generateMarkup "+blocks.slice( - blocks.length +
                beginBlock).join("").replace("\n"," "), {value: this.value, attrs: this.attrs});
        }

        //this.generateChildMarkup(topBlock, topOuts, blocks, info);
    },

    generateDOM: function(path, blocks, args)  // XXXjjb args not used?
    {
        if (FBTrace.DBG_DOMPLATE)
            var beginBlock = blocks.length;

        var embedName = 'e'+path.embedIndex++;

        this.generateNodePath(path, blocks);

        var valueName = 'd' + path.renderIndex++;
        var argsName = 'd' + path.renderIndex++;
        blocks.push(embedName + ' = __link__(node, ', valueName, ', ', argsName, ');\n');

        if (FBTrace.DBG_DOMPLATE)
        {
            FBTrace.sysout("DomplateEmbed.generateDOM "+blocks.slice( - blocks.length +
                beginBlock).join("").replace("\n"," "), {path: path});

            blocks.push("FBTrace.sysout('__link__ called with node:'+" +
                "FBL.getElementHTML(node), node);\n");
        }

        return embedName;
    }
});

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

DomplateLoop.prototype = copyObject(DomplateTag.prototype,
{
    merge: function(args, oldTag)
    {
        this.isLoop = true;
        this.varName = oldTag ? oldTag.varName : args[0];
        this.iter = oldTag ? oldTag.iter : parseValue(args[1]);
        this.vars = [];

        this.children = oldTag ? copyArray(oldTag.children) : [];

        var offset = Math.min(args.length, 2);
        parseChildren(args, offset, this.vars, this.children);

        return creator(this, DomplateLoop);
    },

    getVarNames: function(names)
    {
        if (this.iter instanceof Parts)
            names.push(this.iter.parts[0].name);

        DomplateTag.prototype.getVarNames.apply(this, [names]);
    },

    generateMarkup: function(topBlock, topOuts, blocks, info)
    {
        this.addCode(topBlock, topOuts, blocks);

        // We are in a FOR loop and our this.iter property contains
        // either a simple function name as a string or a Parts object
        // with only ONE Variables object. There is only one variables object
        // as the FOR argument can contain only ONE valid function callback
        // with optional arguments or just one variable. Allowed arguments are
        // func or $var or $var.sub or $var|func or $var1,$var2|func or $var|func1|func2 or $var1,$var2|func1|func2
        var iterName;
        if (this.iter instanceof Parts)
        {
            // We have a function with optional aruments or just one variable
            var part = this.iter.parts[0];
            
            // Join our function arguments or variables
            // If the user has supplied multiple variables without a function
            // this will create an invalid result and we should probably add an
            // error message here or just take the first variable
            iterName = part.names.join(",");

            // Nest our functions
            if (part.format)
            {
                for (var i = 0; i < part.format.length; ++i)
                    iterName = part.format[i] + "(" + iterName + ")";
            }
        }
        else
        {
            // We have just a simple function name without any arguments
            iterName = this.iter;
        }

        blocks.push('__loop__.apply(this, [', iterName, ', __out__, function(',
            this.varName, ', __out__) {\n');
        this.generateChildMarkup(topBlock, topOuts, blocks, info);
        this.addCode(topBlock, topOuts, blocks);

        blocks.push('}]);\n');
    },

    generateDOM: function(path, blocks, args)
    {
        var iterName = 'd'+path.renderIndex++;
        var counterName = 'i'+path.loopIndex;
        var loopName = 'l'+path.loopIndex++;

        if (!path.length)
            path.push(-1, 0);

        var preIndex = path.renderIndex;
        path.renderIndex = 0;

        var nodeCount = 0;

        var subBlocks = [];
        var basePath = path[path.length-1];
        for (var i = 0; i < this.children.length; ++i)
        {
            path[path.length-1] = basePath+'+'+loopName+'+'+nodeCount;

            var child = this.children[i];
            if (isTag(child))
                nodeCount += '+' + child.tag.generateDOM(path, subBlocks, args);
            else
                nodeCount += '+1';
        }

        path[path.length-1] = basePath+'+'+loopName;

        blocks.push(loopName,' = __loop__.apply(this, [', iterName, ', function(',
            counterName,',',loopName);

        for (var i = 0; i < path.renderIndex; ++i)
            blocks.push(',d'+i);

        blocks.push(') {\n');
        blocks.push(subBlocks.join(""));
        blocks.push('return ', nodeCount, ';\n');
        blocks.push('}]);\n');

        path.renderIndex = preIndex;

        return loopName;
    }
});

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

function Variables(names, format)
{
    this.names = names;
    this.format = format;
}

function Parts(parts)
{
    this.parts = parts;
}

// ********************************************************************************************* //

function parseParts(str)
{
    // Match $var or $var.sub or $var|func or $var1,$var2|func or $var|func1|func2 or $var1,$var2|func1|func2
    var re = /\$([_A-Za-z][_A-Za-z0-9.]*(,\$[_A-Za-z][_A-Za-z0-9.]*)*([_A-Za-z0-9.|]*))/g;
    var index = 0;
    var parts = [];

    var m;
    while (m = re.exec(str))
    {
        var pre = str.substr(index, (re.lastIndex-m[0].length)-index);
        if (pre)
            parts.push(pre);

        var segs = m[1].split("|");
        var vars = segs[0].split(",$");

        // Assemble the variables object and append to buffer
        parts.push(new Variables(vars, segs.slice(1)));

        index = re.lastIndex;
    }

    // No matches found at all so we return the whole string
    if (!index)
        return str;

    // If we have data after our last matched index we append it here as the final step
    var post = str.substr(index);
    if (post)
        parts.push(post);

    return new Parts(parts);
}

function parseValue(val)
{
    return typeof(val) == 'string' ? parseParts(val) : val;
}

function parseChildren(args, offset, vars, children)
{
    for (var i = offset; i < args.length; ++i)
    {
        var val = parseValue(args[i]);
        children.push(val);
        readPartNames(val, vars);
    }
}

function readPartNames(val, vars)
{
    if (val instanceof Parts)
    {
        for (var i = 0; i < val.parts.length; ++i)
        {
            var part = val.parts[i];
            if (part instanceof Variables)
                vars.push(part.names[0]);
        }
    }
}

function generateArg(val, path, args)
{
    if (val instanceof Parts)
    {
        var vals = [];
        for (var i = 0; i < val.parts.length; ++i)
        {
            var part = val.parts[i];
            if (part instanceof Variables)
            {
                var varName = 'd'+path.renderIndex++;
                if (part.format)
                {
                    for (var j = 0; j < part.format.length; ++j)
                        varName = part.format[j] + '(' + varName + ')';
                }

                vals.push(varName);
            }
            else
                vals.push('"'+part.replace(/"/g, '\\"')+'"');
        }

        return vals.join('+');
    }
    else
    {
        args.push(val);
        return 's' + path.staticIndex++;
    }
}

function addParts(val, delim, block, info, escapeIt)
{
    var vals = [];
    if (val instanceof Parts)
    {
        for (var i = 0; i < val.parts.length; ++i)
        {
            var part = val.parts[i];
            if (part instanceof Variables)
            {
                var partName = part.names.join(",");
                if (part.format)
                {
                    for (var j = 0; j < part.format.length; ++j)
                        partName = part.format[j] + "(" + partName + ")";
                }

                if (escapeIt)
                    vals.push("__escape__(" + partName + ")");
                else
                    vals.push(partName);
            }
            else
                vals.push('"'+ part + '"');
        }
    }
    else if (isTag(val))
    {
        info.args.push(val);
        vals.push('s'+info.argIndex++);
    }
    else
        vals.push('"'+ val + '"');

    var parts = vals.join(delim);
    if (parts)
        block.push(delim, parts);
}

function isTag(obj)
{
    return (typeof(obj) == "function" || obj instanceof Function) && !!obj.tag;
}

function creator(tag, cons)
{
    var fn = function()
    {
        var tag = fn.tag;
        var cons = fn.cons;
        var newTag = new cons();
        return newTag.merge(arguments, tag);
    };

    fn.tag = tag;
    fn.cons = cons;
    extend(fn, Renderer);

    return fn;
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

function copyArray(oldArray)
{
    var ary = [];
    if (oldArray)
        for (var i = 0; i < oldArray.length; ++i)
            ary.push(oldArray[i]);
   return ary;
}

function copyObject(l, r)
{
    var m = {};
    extend(m, l);
    extend(m, r);
    return m;
}

function extend(l, r)
{
    for (var n in r)
        l[n] = r[n];
}

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

function ArrayIterator(array)
{
    var index = -1;

    this.next = function()
    {
        if (++index >= array.length)
            throw StopIteration;

        return array[index];
    };
}

function StopIteration() {}

FBL.$break = function()
{
    throw StopIteration;
};

// ********************************************************************************************* //

/**
 * @object Domplate Renderer object implements API for template rendering.
 * Every Domplate template inherits this APIs (through extend API) and should use
 * them every time it's rendered into DOM.
 */
var Renderer =
/** @lends Renderer */
{
    renderHTML: function(args, outputs, self)
    {
        try
        {
            var code = [];
            var markupArgs = [code, this.tag.getContext(), args, outputs];
            markupArgs.push.apply(markupArgs, this.tag.markupArgs);
            this.tag.renderMarkup.apply(self ? self : this.tag.subject, markupArgs);
            return code.join("");
        }
        catch (e)
        {
            if (FBTrace.DBG_DOMPLATE || FBTrace.DBG_ERRORS)
                FBTrace.sysout("domplate.renderHTML; EXCEPTION " + e,
                    {exc: e, render: this.tag.renderMarkup.toSource()});
        }
    },

    /**
     * This method is used when rendering (inserting) table rows into an existing
     * table (i.e. tbody) element.
     *
     * @param {Object} args Template input object (can be null).
     * @param {Node} after The row after which the new row will be inserted.
     *      If <tbody> element is passed the new row will be inserted at the end.
     * @param {Template} self Reference to the template object (can be null).
     */
    insertRows: function(args, after, self)
    {
        if (!args)
            args = {};

        this.tag.compile();

        var outputs = [];
        var html = this.renderHTML(args, outputs, self);

        var doc = after.ownerDocument;
        var table = doc.createElement("table");
        table.innerHTML = html;

        var tbody = table.firstChild;
        var localName = after.localName.toLowerCase();
        var parent = (localName == "tr") ? after.parentNode : after;
        var referenceElement = (localName == "tr") ? after.nextSibling : null;

        var firstRow = tbody.firstChild;
        var lastRow = null;
        while (tbody.firstChild)
        {
            lastRow = tbody.firstChild;
            if (referenceElement)
                parent.insertBefore(lastRow, referenceElement);
            else
                parent.appendChild(lastRow);
        }

        // To save the next poor soul:
        // In order to properly apply properties and event handlers on elements
        // constructed by a FOR tag, the tag needs to be able to iterate up and
        // down the tree. If FOR is the root element, as is the case with
        // many 'insertRows' calls, it will need to iterator over portions of the
        // new parent.
        //
        // To achieve this end, __path__ defines the -1 operator which allows
        // parent traversal. When combined with the offset that we calculate
        // below we are able to iterate over the elements.
        //
        // This fails when applied to a non-loop element as non-loop elements
        // do not generate to proper path to bounce up and down the tree.
        var offset = 0;
        if (this.tag.isLoop)
        {
            var node = firstRow.parentNode.firstChild;
            for (; node && node != firstRow; node = node.nextSibling)
                ++offset;
        }

        // strict warning: this.tag.context undefined
        var domArgs = [firstRow, this.tag.getContext(), offset];
        domArgs.push.apply(domArgs, this.tag.domArgs);
        domArgs.push.apply(domArgs, outputs);

        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);
        return [firstRow, lastRow];
    },

    insertBefore: function(args, before, self)
    {
        return this.insertNode(
                args, before.ownerDocument,
                function beforeInserter(frag) {
                    before.parentNode.insertBefore(frag, before);
                },
                self);
    },

    insertAfter: function(args, after, self)
    {
        return this.insertNode(
                args, after.ownerDocument,
                function(frag) {
                    after.parentNode.insertBefore(frag, after.nextSibling);
                },
                self);
    },

    insertNode: function(args, doc, inserter, self)
    {
        if (!args)
            args = {};

        this.tag.compile();

        var outputs = [];
        var html = this.renderHTML(args, outputs, self);
        if (FBTrace.DBG_DOMPLATE)
            FBTrace.sysout("domplate.insertNode html: "+html+"\n");

        var range = doc.createRange();

        // if doc starts with a Text node, domplate fails because the fragment starts
        // with a text node. That must be a gecko bug, but let's just workaround it since
        // we want to switch to innerHTML anyway
        var aDiv = doc.getElementsByTagName("div").item(0);
        range.setStartBefore(aDiv);

        // TODO replace with standard innerHTML
        var frag = range.createContextualFragment(html);

        var root = frag.firstChild;
        root = inserter(frag) || root;

        var domArgs = [root, this.tag.context, 0];
        domArgs.push.apply(domArgs, this.tag.domArgs);
        domArgs.push.apply(domArgs, outputs);

        if (FBTrace.DBG_DOMPLATE)
            FBTrace.sysout("domplate.insertNode domArgs:", domArgs);
        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);

        return root;
    },

    replace: function(args, parent, self)
    {
        if (!args)
            args = {};

        this.tag.compile();

        var outputs = [];
        var html = this.renderHTML(args, outputs, self);

        var root;
        if (parent.nodeType == Node.ELEMENT_NODE)
        {
            parent.innerHTML = html;
            root = parent.firstChild;
        }
        else
        {
            if (!parent || parent.nodeType != Node.DOCUMENT_NODE)
                parent = document;

            if (!womb || womb.ownerDocument != parent)
                womb = parent.createElement("div");
            womb.innerHTML = html;

            root = womb.firstChild;
            //womb.removeChild(root);
        }

        var domArgs = [root, this.tag.context, 0];
        domArgs.push.apply(domArgs, this.tag.domArgs);
        domArgs.push.apply(domArgs, outputs);

        try
        {
            this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);
        }
        catch(exc)
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("domplate renderDom FAILS " + exc, {exc: exc, renderDOM:
                    this.tag.renderDOM.toSource(), domplate: this, domArgs: domArgs, self: self});
            }

            var chained =  new Error("Domplate.renderDom FAILS: "+exc);
            chained.cause = {exc: exc, renderDOM: this.tag.renderDOM.toSource(),
                domplate: this, domArgs: domArgs, self: self};

            throw chained;
        }

        return root;
    },

    append: function(args, parent, self)
    {
        if (!args)
            args = {};

        this.tag.compile();

        var outputs = [];
        var html = this.renderHTML(args, outputs, self);
        if (FBTrace.DBG_DOMPLATE)
            FBTrace.sysout("domplate.append html: "+html+"\n");

        if (!womb || womb.ownerDocument != parent.ownerDocument)
            womb = parent.ownerDocument.createElement("div");
        womb.innerHTML = html;

        var root = womb.firstChild;
        while (womb.firstChild)
            parent.appendChild(womb.firstChild);

        var domArgs = [root, this.tag.context, 0];
        domArgs.push.apply(domArgs, this.tag.domArgs);
        domArgs.push.apply(domArgs, outputs);

        if (FBTrace.DBG_DOMPLATE)
            FBTrace.sysout("domplate.append domArgs:", domArgs);

        this.tag.renderDOM.apply(self ? self : this.tag.subject, domArgs);

        return root;
    }
};

// ********************************************************************************************* //

function defineTags()
{
    for (var i = 0; i < arguments.length; ++i)
    {
        var tagName = arguments[i];
        var fn = createTagHandler(tagName);
        var fnName = tagName.toUpperCase();

        // xxxHonza: Domplate is injected into FBL namespace only for backward
        // compatibility with extensions.
        Domplate[fnName] = FBL[fnName]= fn;
    }

    function createTagHandler(tagName)
    {
        return function() {
            var newTag = new Domplate.DomplateTag(tagName);
            return newTag.merge(arguments);
        };
    }
}

// xxxHonza: Domplate is injected into FBL namespace only for backward
// compatibility with extensions.
// We need to mark this as deprecated.
FBL.TAG = Domplate.TAG;
FBL.FOR = Domplate.FOR;
FBL.DomplateTag = Domplate.DomplateTag;

defineTags(
    "a", "button", "br", "canvas", "col", "colgroup", "div", "fieldset", "form", "h1", "h2",
    "h3", "hr", "img", "input", "label", "legend", "li", "ol", "optgroup", "option", "p",
    "pre", "select", "b", "span", "strong", "table", "tbody", "td", "textarea", "tfoot", "th",
    "thead", "tr", "tt", "ul", "iframe", "code", "style",

    // HTML5
    "article", "aside", "audio", "bb", "command", "datagrid", "datalist", "details",
    "dialog", "embed", "eventsource", "figure", "footer", "keygen", "mark", "meter", "nav",
    "output", "progress", "ruby", "rp", "rt", "section", "source", "time", "video"
);

// ********************************************************************************************* //
// Registration

return Domplate;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/dragdrop",
[
    "firebug/lib/object",
    "firebug/lib/events",
],
function(Obj, Events) {

"use strict";

// ********************************************************************************************* //

/**
 *
 * @param {Object} element
 * @param {Object} handle
 * @param {Object} callbacks: onDragStart, onDragOver, onDragLeave, onDrop
 */
function Tracker(handle, callbacks)
{
    this.element = handle;
    this.handle = handle;
    this.callbacks = callbacks;

    this.cursorStartPos = null;
    this.cursorLastPos = null;
    //this.elementStartPos = null;
    this.dragging = false;

    // Start listening
    this.onDragStart = Obj.bind(this.onDragStart, this);
    this.onDragOver = Obj.bind(this.onDragOver, this);
    this.onDrop = Obj.bind(this.onDrop, this);

    Events.addEventListener(this.element, "mousedown", this.onDragStart, false);
    this.active = true;
}

Tracker.prototype =
{
    onDragStart: function(event)
    {
        if (this.dragging)
            return;

        if (this.callbacks.onDragStart)
            this.callbacks.onDragStart(this);

        this.dragging = true;
        this.cursorStartPos = absoluteCursorPostion(event);
        this.cursorLastPos = this.cursorStartPos;
        //this.elementStartPos = new Position(
        //    parseInt(this.element.style.left),
        //    parseInt(this.element.style.top));

        Events.addEventListener(this.element.ownerDocument, "mousemove", this.onDragOver, false);
        Events.addEventListener(this.element.ownerDocument, "mouseup", this.onDrop, false);

        Events.cancelEvent(event);
    },

    onDragOver: function(event)
    {
        if (!this.dragging)
            return;

        Events.cancelEvent(event);

        var newPos = absoluteCursorPostion(event);
        //newPos = newPos.Add(this.elementStartPos);
        newPos = newPos.Subtract(this.cursorStartPos);
        //newPos = newPos.Bound(lowerBound, upperBound);
        //newPos.Apply(this.element);

        // Only fire event if the position has beeb changed.
        if (this.cursorLastPos.x == newPos.x && this.cursorLastPos.y == newPos.y)
            return;

        this.cursorLastPos = newPos;

        if (this.callbacks.onDragOver != null)
            this.callbacks.onDragOver(newPos, this);
    },

    onDrop: function(event)
    {
        if (!this.dragging)
            return;

        Events.cancelEvent(event);

        this.dragStop();
    },

    dragStop: function()
    {
        if (!this.dragging)
            return;

        Events.removeEventListener(this.element.ownerDocument, "mousemove", this.onDragOver, false);
        Events.removeEventListener(this.element.ownerDocument, "mouseup", this.onDrop, false);

        this.cursorStartPos = null;
        this.cursorLastPos = null;
        //this.elementStartPos = null;

        if (this.callbacks.onDrop != null)
            this.callbacks.onDrop(this);

        this.dragging = false;
    },

    destroy: function()
    {
        Events.removeEventListener(this.element, "mousedown", this.onDragStart, false);
        this.active = false;

        if (this.dragging)
            this.dragStop();
    }
};

// ********************************************************************************************* //

function Position(x, y)
{
    this.x = x;
    this.y = y;

    this.Add = function(val)
    {
        var newPos = new Position(this.x, this.y);
        if (val != null)
        {
            if(!isNaN(val.x))
                newPos.x += val.x;
            if(!isNaN(val.y))
                newPos.y += val.y;
        }
        return newPos;
    };

    this.Subtract = function(val)
    {
        var newPos = new Position(this.x, this.y);
        if (val != null)
        {
            if(!isNaN(val.x))
                newPos.x -= val.x;
            if(!isNaN(val.y))
                newPos.y -= val.y;
        }
        return newPos;
    };

    this.Bound = function(lower, upper)
    {
        var newPos = this.Max(lower);
        return newPos.Min(upper);
    };

    this.Check = function()
    {
        var newPos = new Position(this.x, this.y);
        if (isNaN(newPos.x))
            newPos.x = 0;

        if (isNaN(newPos.y))
            newPos.y = 0;

        return newPos;
    };

    this.Apply = function(element)
    {
        if (typeof(element) == "string")
            element = document.getElementById(element);

        if (!element)
            return;

        if(!isNaN(this.x))
            element.style.left = this.x + "px";

        if(!isNaN(this.y))
            element.style.top = this.y + "px";
    };
}

// ********************************************************************************************* //

function absoluteCursorPostion(e)
{
    if (isNaN(window.scrollX))
    {
        return new Position(e.clientX + document.documentElement.scrollLeft
            + document.body.scrollLeft, e.clientY + document.documentElement.scrollTop
            + document.body.scrollTop);
    }
    else
    {
        return new Position(e.clientX + window.scrollX, e.clientY + window.scrollY);
    }
}

// ********************************************************************************************* //

var DragDrop = {};
DragDrop.Tracker = Tracker;

// ********************************************************************************************* //
// Registration

return DragDrop;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*global define:1, Components:1, MouseEvent:1, Window: 1, Firebug:1*/

define("firebug/lib/events",
[
    "firebug/lib/trace",
    "firebug/lib/xpcom"
],
function(FBTrace, Xpcom) {

"use strict";

// ********************************************************************************************* //
// Constants

var Cu = Components.utils;

var elService = Xpcom.CCSV("@mozilla.org/eventlistenerservice;1", "nsIEventListenerService");

// ********************************************************************************************* //
// Implementation

var Events = {};

Events.dispatch = function(listeners, name, args)
{
    if (!listeners)
    {
        if (FBTrace.DBG_DISPATCH)
            FBTrace.sysout("Events.dispatch " + name + " without listeners");

        return;
    }

    try
    {
        var noMethods;
        if (FBTrace.DBG_DISPATCH)
            noMethods = [];

        for (var i = 0; i < listeners.length; ++i)
        {
            var listener = listeners[i];
            if (!listener)
            {
                if (FBTrace.DBG_DISPATCH || FBTrace.DBG_ERRORS)
                    FBTrace.sysout("Events.dispatch ERROR " + i + " " + name + " to null listener.");
                continue;
            }

            if (listener[name])
            {
                try
                {
                    listener[name].apply(listener, args);
                }
                catch(exc)
                {
                    if (FBTrace.DBG_ERRORS)
                    {
                        if (exc.stack)
                        {
                            var stack = exc.stack;
                            exc.stack = stack.split('\n');
                        }

                        var culprit = listeners[i] ? listeners[i].dispatchName : null;
                        var loc = (exc.fileName ? exc.fileName + ":" + exc.lineNumber : "<unknown>");
                        FBTrace.sysout("EXCEPTION in Events.dispatch " +
                            (culprit ? culprit + "." : "") + name + ": " + exc + " in " + loc, exc);
                    }
                }
            }
            else
            {
                if (FBTrace.DBG_DISPATCH)
                    noMethods.push(listener);
            }
        }

        if (FBTrace.DBG_DISPATCH)
            FBTrace.sysout("Events.dispatch " + name + " to " + listeners.length + " listeners, " +
                noMethods.length + " had no such method", noMethods);
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
        {
            if (exc.stack)
            {
                var stack = exc.stack;
                exc.stack = stack.split('\n');
            }

            var culprit = listeners[i] ? listeners[i].dispatchName : null;
            FBTrace.sysout("Exception in Events.dispatch " + (culprit ? culprit + "." : "") +
                name + ": " + exc, exc);
        }
    }
};

Events.dispatch2 = function(listeners, name, args)
{
    try
    {
        var noMethods;
        if (FBTrace.DBG_DISPATCH)
            noMethods = [];

        if (!listeners)
        {
            if (FBTrace.DBG_DISPATCH)
                FBTrace.sysout("dispatch2, no listeners for " + name);
            return;
        }

        for (var i = 0; i < listeners.length; ++i)
        {
            var listener = listeners[i];
            if (listener[name])
            {
                var result = listener[name].apply(listener, args);

                if (FBTrace.DBG_DISPATCH)
                    FBTrace.sysout("dispatch2 " + name + " to #" + i + " of " + listeners.length +
                        " listeners, result " + result, {result: result, listener: listeners[i],
                        fn: listener[name].toSource()});

                if (result)
                    return result;
            }
            else
            {
                if (FBTrace.DBG_DISPATCH)
                    noMethods.push(listener);
            }
        }

        if (FBTrace.DBG_DISPATCH && noMethods.length === listeners.length)
            FBTrace.sysout("Events.dispatch2 " + name + " to " + listeners.length + " listeners, " +
                noMethods.length + " had no such method:", noMethods);
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
        {
            if (exc.stack)
                exc.stack = exc.stack.split('/n');

            FBTrace.sysout("Exception in Events.dispatch2 " + name + " exc: " + exc, exc);
        }
    }
};

// ********************************************************************************************* //
// Events

Events.cancelEvent = function(event)
{
    event.stopPropagation();
    event.preventDefault();
};

Events.isLeftClick = function(event, allowKeyModifiers)
{
    return event.button === 0 && (allowKeyModifiers || this.noKeyModifiers(event));
};

Events.isMiddleClick = function(event, allowKeyModifiers)
{
    return event.button === 1 && (allowKeyModifiers || this.noKeyModifiers(event));
};

Events.isRightClick = function(event, allowKeyModifiers)
{
    return event.button === 2 && (allowKeyModifiers || this.noKeyModifiers(event));
};

Events.isSingleClick = function(event)
{
    return event instanceof MouseEvent && event.detail === 1;
};

Events.isDoubleClick = function(event)
{
    return event instanceof MouseEvent && event.detail === 2;
};

Events.noKeyModifiers = function(event)
{
    return !event.ctrlKey && !event.shiftKey && !event.altKey && !event.metaKey;
};

Events.isControlClick = function(event)
{
    return event.button === 0 && this.isControl(event);
};

Events.isShiftClick = function(event)
{
    return event.button === 0 && this.isShift(event);
};

Events.isControl = function(event)
{
    return (event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey;
};

Events.isAlt = function(event)
{
    return event.altKey && !event.ctrlKey && !event.shiftKey && !event.metaKey;
};

Events.isAltClick = function(event)
{
    return event.button === 0 && this.isAlt(event);
};

Events.isControlShift = function(event)
{
    return (event.metaKey || event.ctrlKey) && event.shiftKey && !event.altKey;
};

Events.isControlAlt = function(event)
{
    return (event.metaKey || event.ctrlKey) && !event.shiftKey && event.altKey;
};

Events.isShift = function(event)
{
    return event.shiftKey && !event.metaKey && !event.ctrlKey && !event.altKey;
};

// ********************************************************************************************* //
// DOM Events

const eventTypes =
{
    composition: [
        "composition",
        "compositionstart",
        "compositionend"
    ],

    contextmenu: [
        "contextmenu"
    ],

    drag: [
        "dragenter",
        "dragover",
        "dragexit",
        "dragdrop",
        "draggesture"
    ],

    focus: [
        "focus",
        "blur"
    ],

    form: [
        "submit",
        "reset",
        "change",
        "select",
        "input"
    ],

    key: [
        "keydown",
        "keyup",
        "keypress"
    ],

    load: [
        "load",
        "beforeunload",
        "unload",
        "abort",
        "error"
    ],

    mouse: [
        "mousedown",
        "mouseup",
        "click",
        "dblclick",
        "mouseover",
        "mouseout",
        "mousemove"
    ],

    mutation: [
        "DOMSubtreeModified",
        "DOMNodeInserted",
        "DOMNodeRemoved",
        "DOMNodeRemovedFromDocument",
        "DOMNodeInsertedIntoDocument",
        "DOMAttrModified",
        "DOMCharacterDataModified"
    ],

    paint: [
        "paint",
        "resize",
        "scroll"
    ],

    scroll: [
        "overflow",
        "underflow",
        "overflowchanged"
    ],

    text: [
        "text"
    ],

    ui: [
        "DOMActivate",
        "DOMFocusIn",
        "DOMFocusOut"
    ],

    clipboard: [
        "cut",
        "copy",
        "paste"
    ],

    touch: [
        "touchstart",
        "touchend",
        "touchmove",
        "touchenter",
        "touchleave",
        "touchcancel"
    ]
};

Events.getEventFamilies = function()
{
    var families = [];
    for (var eventFamily in eventTypes)
        families.push(eventFamily);
    return families;
};

Events.getEventTypes = function(family)
{
    var types = [];
    for (var eventFamily in eventTypes)
    {
        if (!family || family === eventFamily)
        {
            for (var type in eventTypes[eventFamily])
                types.push(eventTypes[eventFamily][type]);
        }
    }

    return types;
};

Events.isEventFamily = function(eventType)
{
    return eventTypes.hasOwnProperty(eventType);
};

Events.getEventFamily = function(eventType)
{
    if (!this.families)
    {
        this.families = {};

        for (var family in eventTypes)
        {
            var types = eventTypes[family];
            for (var i = 0; i < types.length; ++i)
                this.families[types[i]] = family;
        }
    }

    return this.families[eventType];
};

Events.attachAllListeners = function(object, listener)
{
    for (var family in eventTypes)
    {
        if (family !== "mutation" || Firebug.attachMutationEvents)
            this.attachFamilyListeners(family, object, listener);
    }
};

Events.detachAllListeners = function(object, listener)
{
    for (var family in eventTypes)
    {
        if (family !== "mutation" || Firebug.attachMutationEvents)
            this.detachFamilyListeners(family, object, listener);
    }
};

Events.attachFamilyListeners = function(family, object, listener)
{
    var types = eventTypes[family];
    for (var i = 0; i < types.length; ++i)
        object.addEventListener(types[i], listener, false);
};

Events.detachFamilyListeners = function(family, object, listener)
{
    var types = eventTypes[family];
    for (var i = 0; i < types.length; ++i)
        object.removeEventListener(types[i], listener, false);
};

// Table of non-bubbling event types. It's mostly okay if this gets slightly out
// of date - most event types that don't bubble are only listened to on child
// nodes, and therefore won't incorrectly appear in any UI.
var nonBubbling = {
    abort: 1,
    begin: 1,
    beginEvent: 1,
    blur: 1,
    canplay: 1,
    canplaythrough: 1,
    durationchange: 1,
    emptied: 1,
    end: 1,
    ended: 1,
    endEvent: 1,
    error: 1,
    focus: 1,
    invalid: 1,
    load: 1,
    loadeddata: 1,
    loadedmetadata: 1,
    loadend: 1,
    loadstart: 1,
    mouseenter: 1,
    mouseleave: 1,
    pagehide: 1,
    pageshow: 1,
    pause: 1,
    play: 1,
    playing: 1,
    progress: 1,
    ratechange: 1,
    readystatechange: 1,
    repeat: 1,
    repeatEvent: 1,
    scroll: 1,
    seeked: 1,
    seeking: 1,
    select: 1,
    show: 1,
    stalled: 1,
    suspend: 1,
    SVGLoad: 1,
    SVGUnload: 1,
    timeupdate: 1,
    volumechange: 1,
    waiting: 1,
};

// Return true if a type of DOM event bubbles.
Events.eventTypeBubbles = function(type)
{
    // N.B.: Technically "scroll" is a special case here, since it only bubbles
    // from document to window. But since we are only interested in elements we
    // can ignore that.
    return !nonBubbling.hasOwnProperty(type);
};

// Regex for event types that bubble from elements to document and window.
// It's okay if this gets slightly out of date - it would only imply that some
// event types in the event panel aren't listed on the nodes but as part of
// "document" or "window" instead.
var reBubblesToDocument = new RegExp("^(" +
    "animation(start|end|iteration)|" +
    "transitionend|" +
    "click|dblclick|wheel|mouse(down|up|move)|" +
    "composition(start|end|update)|" +
    "keydown|keypress|keyup|input|contextmenu|" +
    "DOM(AttrModified|NodeRemoved|NodeRemovedFromDocument|SubtreeModified|" +
        "CharacterDataModified|NodeInserted|NodeInsertedIntoDocument)|" +
    "drag(|end|enter|leave|over|start)|" +
    "drop|copy|cut|paste|" +
    "touch(cancel|enter|leave|move|start)" +
")$");

// Return true iff a type of event can bubble up from nodes to document and window.
Events.eventTypeBubblesToDocument = function(type)
{
    return reBubblesToDocument.test(type);
};

// ********************************************************************************************* //
// Event Listeners (+ support for tracking)

var listeners = [];

Events.addEventListener = function(parent, eventId, listener, capturing)
{
    if (FBTrace.DBG_EVENTLISTENERS)
    {
        for (var i = 0; i < listeners.length; i++)
        {
            var l = listeners[i];
            if (l.parent === parent && l.eventId === eventId && l.listener === listener &&
                l.capturing === capturing)
            {
                FBTrace.sysout("Events.addEventListener; ERROR already registered!", l);
                return;
            }
        }
    }

    parent.addEventListener(eventId, listener, capturing);

    if (FBTrace.DBG_EVENTLISTENERS)
    {
        var frames = [];
        for (var frame = Components.stack; frame; frame = frame.caller)
            frames.push(frame.filename + " (" + frame.lineNumber + ")");

        frames.shift();

        var pid = (parent.location ? parent.location + "" : typeof parent);

        listeners.push({
            parentId: pid,
            eventId: eventId,
            capturing: capturing,
            listener: listener,
            stack: frames,
            parent: parent,
        });
    }
};

Events.removeEventListener = function(parent, eventId, listener, capturing)
{
    try
    {
        parent.removeEventListener(eventId, listener, capturing);
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("events.removeEventListener; (" + eventId + ") " + e, e);
    }

    if (FBTrace.DBG_EVENTLISTENERS)
    {
        for (var i = 0; i < listeners.length; i++)
        {
            var l = listeners[i];
            if (l.parent === parent && l.eventId === eventId && l.listener === listener &&
                l.capturing === capturing)
            {
                listeners.splice(i, 1);
                return;
            }
        }

        // xxxHonza: it's not necessary to pollute the tracing console with this message.
        /*
        var frames = [];
        for (var frame = Components.stack; frame; frame = frame.caller)
            frames.push(frame.filename + " (" + frame.lineNumber + ")");

        frames.shift();

        var info = {
            eventId: eventId,
            capturing: capturing,
            listener: listener,
            stack: frames,
        };

        FBTrace.sysout("Events.removeEventListener; ERROR not registered!", info);
        */
    }
};

Events.getEventListenersForTarget = function(target)
{
    var listeners = elService.getListenerInfoFor(target, {});
    var ret = [];
    for (var i = 0; i < listeners.length; i++)
    {
        var rawListener = listeners[i];
        var listener = {
            type: rawListener.type,
            func: rawListener.listenerObject,
            capturing: rawListener.capturing,
            allowsUntrusted: rawListener.allowsUntrusted,
            target: target,
        };

        // Skip chrome event listeners.
        if (!listener.func || rawListener.inSystemEventGroup)
            continue;

        var funcGlobal = Cu.getGlobalForObject(listener.func);
        if (!(funcGlobal instanceof Window))
            continue;

        if (funcGlobal.document.nodePrincipal.subsumes(document.nodePrincipal))
            continue;

        ret.push(listener);
    }

    return ret;
};

if (FBTrace.DBG_EVENTLISTENERS && typeof Firebug !== "undefined")
{
    Firebug.Events = {};
    Firebug.Events.getRegisteredListeners = function()
    {
        return listeners;
    };
}

// ********************************************************************************************* //

return Events;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/fonts",
[
    "firebug/lib/trace",
    "firebug/lib/dom",
    "firebug/lib/url"
],
function(FBTrace, Dom, Url) {

"use strict";

// ********************************************************************************************* //
// Constants

var Fonts = {};

// ********************************************************************************************* //
// Fonts

/**
 * Retrieves all fonts used inside a node
 * @node: Node to return the fonts for
 * @return Array of fonts
 */
Fonts.getFonts = function(node)
{
    if (!Dom.domUtils)
        return [];

    var range = node.ownerDocument.createRange();
    try
    {
        range.selectNode(node);
    }
    catch(err)
    {
        if (FBTrace.DBG_FONTS || FBTrace.DBG_ERRORS)
            FBTrace.sysout("Fonts.getFonts; node couldn't be selected", err);
    }

    var fontFaces = Dom.domUtils.getUsedFontFaces(range);
    var fonts = [];
    for (var i=0; i<fontFaces.length; i++)
        fonts.push(fontFaces.item(i));

    if (FBTrace.DBG_FONTS)
        FBTrace.sysout("Fonts.getFonts; used fonts", fonts);

    return fonts;
};

/**
 * Retrieves all fonts used in a context, cached so that the first use is
 * potentially slow (several seconds on the HTML5 spec), and later ones are
 * instant but not up-to-date.
 * @context: Context to return the fonts for
 * @return Array of fonts
 */
Fonts.getFontsUsedInContext = function(context)
{
    if (context.fontCache)
        return context.fontCache;

    var fonts = [];
    if (context.window)
    {
        var doc = context.window.document;
        if (doc)
            fonts = Fonts.getFonts(doc.documentElement);
    }
    context.fontCache = fonts;
    return fonts;
};

/**
 * Retrieves the information about a font
 * @context: Context of the font
 * @win: Window the font is used in
 * @identifier: Either a URL in case of a web font or the font name
 * @return Object with information about the font
 */
Fonts.getFontInfo = function(context, win, identifier)
{
    if (!context)
        context = Firebug.currentContext;

    var doc = win ? win.document : context.window.document;
    if (!doc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("lib.getFontInfo; NO DOCUMENT", {win:win, context:context});
        return false;
    }

    var fonts = Fonts.getFonts(doc.documentElement);

    if (FBTrace.DBG_FONTS)
        FBTrace.sysout("Fonts.getFontInfo;", {fonts:fonts, identifier: identifier});

    for (var i=0; i<fonts.length; i++)
    {
        if (identifier == fonts[i].URI ||
            identifier.toLowerCase() == fonts[i].CSSFamilyName.toLowerCase() ||
            identifier.toLowerCase() == fonts[i].name.toLowerCase())
        {
            return fonts[i];
        }
    }

    return false;
};

// ********************************************************************************************* //

return Fonts;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/http",
[
    "firebug/lib/xpcom",
    "firebug/lib/trace",
    "firebug/lib/deprecated",
    "firebug/js/stackFrame",
    "firebug/lib/string"
],
function(Xpcom, FBTrace, Deprecated, StackFrame, Str) {

"use strict";

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;

const NS_SEEK_SET = Ci.nsISeekableStream.NS_SEEK_SET;
const ioService = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);

var Http = {};

// ********************************************************************************************* //
// Module Implementation

Http.readFromStream = function(stream, charset, noClose)
{
    // Causes a memory leak (see https://bugzilla.mozilla.org/show_bug.cgi?id=699801)
    //var sis = Cc["@mozilla.org/binaryinputstream;1"].createInstance(Ci.nsIBinaryInputStream);
    //sis.setInputStream(stream);

    var sis = Cc["@mozilla.org/scriptableinputstream;1"].
        createInstance(Ci.nsIScriptableInputStream);
    sis.init(stream);

    var segments = [];
    for (var count = stream.available(); count; count = stream.available())
        segments.push(sis.readBytes(count));

    if (!noClose)
        sis.close();

    var text = segments.join("");

    try
    {
        return Str.convertToUnicode(text, charset);
    }
    catch (err)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("http.readFromStream EXCEPTION charset: " + charset, err);
    }

    return text;
};

Http.readPostTextFromPage = function(url, context)
{
    if (url == context.browser.contentWindow.location.href)
    {
        try
        {
            var webNav = context.browser.webNavigation;
            var descriptor = (webNav instanceof Ci.nsIWebPageDescriptor) ?
                webNav.currentDescriptor : null;

            if (!(descriptor instanceof Ci.nsISHEntry))
                return;

            var entry = descriptor;
            if (entry && entry.postData)
            {
                if (!(entry.postData instanceof Ci.nsISeekableStream))
                    return;

                var postStream = entry.postData;
                postStream.seek(NS_SEEK_SET, 0);

                var charset = context.window.document.characterSet;
                return Http.readFromStream(postStream, charset, true);
            }
         }
         catch (exc)
         {
             if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("http.readPostText FAILS, url:"+url, exc);
         }
     }
};

Http.getResource = function(aURL)
{
    try
    {
        var channel = ioService.newChannel(aURL, null, null);
        var input = channel.open();

        return Http.readFromStream(input);
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("lib.getResource FAILS for \'"+aURL+"\'", e);
    }
};

/**
 * Returns a posted data for specified request object. The return value might contain
 * headers (if request.uploadStreamHasHeaders is set to true). You can remove these
 * headers using {@link Http.removeHeadersFromPostText}
 * 
 * @param {Object} request The request object
 * @param {Object} context Current Firebug context (to get charset of the current document)
 */
Http.readPostTextFromRequest = function(request, context)
{
    try
    {
        var is = (request instanceof Ci.nsIUploadChannel) ? request.uploadStream : null;
        if (is)
        {
            if (!(is instanceof Ci.nsISeekableStream))
                return;

            var ss = is;
            var prevOffset;
            if (ss)
            {
                prevOffset = ss.tell();
                ss.seek(NS_SEEK_SET, 0);
            }

            // Read data from the stream..
            var charset = (context && context.window) ? context.window.document.characterSet : null;
            var text = Http.readFromStream(is, charset, true);

            // Seek locks the file, so seek to the beginning only if necko hasn't read it yet,
            // since necko doesn't seek to 0 before reading (at least not till 459384 is fixed).
            if (ss && prevOffset == 0)
                ss.seek(NS_SEEK_SET, 0);

            return text;
        }
    }
    catch(exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("http.readPostTextFromRequest FAILS ", exc);
    }

    return null;
};

/**
 * Remove headers from post body, https://bugzilla.mozilla.org/show_bug.cgi?id=649338
 * 
 * @param {Object} request Channel implementing nsIUploadChannel2
 * @param {Object} text Extracted text (can include headers at the beginning).
 */
Http.removeHeadersFromPostText = function(request, text)
{
    if (!text)
        return text;

    if (typeof(Ci.nsIUploadChannel2) == "undefined")
        return text;

    if (!(request instanceof Ci.nsIUploadChannel2))
        return text;

    if (!request.uploadStreamHasHeaders)
        return text;

    var headerSeparator = "\r\n\r\n";
    var index = text.indexOf(headerSeparator);
    if (index == -1)
        return text;

    return text.substring(index + headerSeparator.length);
};

/**
 * Returns an array of headers from posted data (appended by Firefox)
 * 
 * @param {Object} request Channel implementing nsIUploadChannel2
 * @param {Object} text Posted data from the channel object.
 */
Http.getHeadersFromPostText = function(request, text)
{
    var headers = [];
    if (!text)
        return headers;

    if (typeof(Ci.nsIUploadChannel2) == "undefined")
        return headers;

    if (!(request instanceof Ci.nsIUploadChannel2))
        return headers;

    if (!request.uploadStreamHasHeaders)
        return headers;

    var headerSeparator = "\r\n\r\n";
    var index = text.indexOf(headerSeparator);
    if (index == -1)
        return headers;

    var text = text.substring(0, index);
    var lines = Str.splitLines(text);

    for (var i=0; i<lines.length; i++)
    {
        var header = lines[i].split(":");
        if (header.length != 2)
            continue;

        headers.push({
            name: Str.trim(header[0]),
            value: Str.trim(header[1]),
        });
    }

    return headers;
};

Http.getInputStreamFromString = function(dataString)
{
    var stringStream = Cc["@mozilla.org/io/string-input-stream;1"].
        createInstance(Ci.nsIStringInputStream);

    if ("data" in stringStream) // Gecko 1.9 or newer
        stringStream.data = dataString;
    else // 1.8 or older
        stringStream.setData(dataString, dataString.length);

    return stringStream;
};

Http.getWindowForRequest = function(request)
{
    var loadContext = Http.getRequestLoadContext(request);
    try
    {
        if (loadContext)
            return loadContext.associatedWindow;
    }
    catch (ex)
    {
    }

    return null;
};

Http.getRequestLoadContext = function(request)
{
    try
    {
        if (request && request.notificationCallbacks)
        {
            StackFrame.suspendShowStackTrace();
            return request.notificationCallbacks.getInterface(Ci.nsILoadContext);
        }
    }
    catch (exc)
    {
    }
    finally
    {
        StackFrame.resumeShowStackTrace();
    }

    try
    {
        if (request && request.loadGroup && request.loadGroup.notificationCallbacks)
        {
            StackFrame.suspendShowStackTrace();
            return request.loadGroup.notificationCallbacks.getInterface(Ci.nsILoadContext);
        }
    }
    catch (exc)
    {
    }
    finally
    {
        StackFrame.resumeShowStackTrace();
    }

    return null;
};

Http.getRequestWebProgress = Deprecated.deprecated("Use getRequestLoadContext function",
    Http.getRequestLoadContext);

// ********************************************************************************************* //
// HTTP Channel Fields

Http.safeGetRequestName = function(request)
{
    try
    {
        return request.name;
    }
    catch (exc)
    {
    }

    return null;
};

Http.safeGetURI = function(browser)
{
    try
    {
        return browser.currentURI;
    }
    catch (exc)
    {
    }

    return null;
};

Http.safeGetContentType = function(request)
{
    try
    {
        return new String(request.contentType).toLowerCase();
    }
    catch (err)
    {
    }

    return null;
};

Http.safeGetXHRResponseText = function(xhr)
{
    try
    {
        return xhr.responseText;
    }
    catch (err)
    {
    }

    return null;
};

// ********************************************************************************************* //
// IP Adress and port number (Requires Gecko 5).

Http.safeGetLocalAddress = function(request)
{
    try
    {
        if (request instanceof Ci.nsIHttpChannelInternal)
            return request.localAddress;
    }
    catch (err)
    {
    }
    return null;
};

Http.safeGetLocalPort = function(request)
{
    try
    {
        if (request instanceof Ci.nsIHttpChannelInternal)
            return request.localPort;
    }
    catch (err)
    {
    }
    return null;
};

Http.safeGetRemoteAddress = function(request)
{
    try
    {
        if (request instanceof Ci.nsIHttpChannelInternal)
            return request.remoteAddress;
    }
    catch (err)
    {
    }
    return null;
};

Http.safeGetRemotePort = function(request)
{
    try
    {
        if (request instanceof Ci.nsIHttpChannelInternal)
            return request.remotePort;
    }
    catch (err)
    {
    }
    return null;
};

// ********************************************************************************************* //
// XHR

Http.isXHR = function(request)
{
    try
    {
        var callbacks = request.notificationCallbacks;
        StackFrame.suspendShowStackTrace();
        var xhrRequest = callbacks ? callbacks.getInterface(Ci.nsIXMLHttpRequest) : null;
        return (xhrRequest != null);
    }
    catch (exc)
    {
    }
    finally
    {
        StackFrame.resumeShowStackTrace();
    }

    return false;
};

// ********************************************************************************************* //
// Conversions

Http.convertToUnicode = Deprecated.deprecated("Function moved to 'firebug/lib/string' module",
    Str.convertToUnicode);

Http.convertFromUnicode = Deprecated.deprecated("Function moved to 'firebug/lib/string' module",
    Str.convertFromUnicode);

// ********************************************************************************************* //
// Network Tracing

Http.getStateDescription = function(flag)
{
    var state = [];
    var nsIWebProgressListener = Ci.nsIWebProgressListener;
    if (flag & nsIWebProgressListener.STATE_START) state.push("STATE_START");
    else if (flag & nsIWebProgressListener.STATE_REDIRECTING) state.push("STATE_REDIRECTING");
    else if (flag & nsIWebProgressListener.STATE_TRANSFERRING) state.push("STATE_TRANSFERRING");
    else if (flag & nsIWebProgressListener.STATE_NEGOTIATING) state.push("STATE_NEGOTIATING");
    else if (flag & nsIWebProgressListener.STATE_STOP) state.push("STATE_STOP");

    if (flag & nsIWebProgressListener.STATE_IS_REQUEST) state.push("STATE_IS_REQUEST");
    if (flag & nsIWebProgressListener.STATE_IS_DOCUMENT) state.push("STATE_IS_DOCUMENT");
    if (flag & nsIWebProgressListener.STATE_IS_NETWORK) state.push("STATE_IS_NETWORK");
    if (flag & nsIWebProgressListener.STATE_IS_WINDOW) state.push("STATE_IS_WINDOW");
    if (flag & nsIWebProgressListener.STATE_RESTORING) state.push("STATE_RESTORING");
    if (flag & nsIWebProgressListener.STATE_IS_INSECURE) state.push("STATE_IS_INSECURE");
    if (flag & nsIWebProgressListener.STATE_IS_BROKEN) state.push("STATE_IS_BROKEN");
    if (flag & nsIWebProgressListener.STATE_IS_SECURE) state.push("STATE_IS_SECURE");
    if (flag & nsIWebProgressListener.STATE_SECURE_HIGH) state.push("STATE_SECURE_HIGH");
    if (flag & nsIWebProgressListener.STATE_SECURE_MED) state.push("STATE_SECURE_MED");
    if (flag & nsIWebProgressListener.STATE_SECURE_LOW) state.push("STATE_SECURE_LOW");

    return state.join(", ");
};

Http.getStatusDescription = function(status)
{
    var nsISocketTransport = Ci.nsISocketTransport;
    var nsITransport = Ci.nsITransport;

    if (status == nsISocketTransport.STATUS_RESOLVING) return "STATUS_RESOLVING";
    if (status == nsISocketTransport.STATUS_CONNECTING_TO) return "STATUS_CONNECTING_TO";
    if (status == nsISocketTransport.STATUS_CONNECTED_TO) return "STATUS_CONNECTED_TO";
    if (status == nsISocketTransport.STATUS_SENDING_TO) return "STATUS_SENDING_TO";
    if (status == nsISocketTransport.STATUS_WAITING_FOR) return "STATUS_WAITING_FOR";
    if (status == nsISocketTransport.STATUS_RECEIVING_FROM) return "STATUS_RECEIVING_FROM";
    if (status == nsITransport.STATUS_READING) return "STATUS_READING";
    if (status == nsITransport.STATUS_WRITING) return "STATUS_WRITING";
};

Http.getLoadFlagsDescription = function(loadFlags)
{
    var flags = [];
    var nsIChannel = Ci.nsIChannel;
    var nsICachingChannel = Ci.nsICachingChannel;

    if (loadFlags & nsIChannel.LOAD_DOCUMENT_URI) flags.push("LOAD_DOCUMENT_URI");
    if (loadFlags & nsIChannel.LOAD_RETARGETED_DOCUMENT_URI) flags.push("LOAD_RETARGETED_DOCUMENT_URI");
    if (loadFlags & nsIChannel.LOAD_REPLACE) flags.push("LOAD_REPLACE");
    if (loadFlags & nsIChannel.LOAD_INITIAL_DOCUMENT_URI) flags.push("LOAD_INITIAL_DOCUMENT_URI");
    if (loadFlags & nsIChannel.LOAD_TARGETED) flags.push("LOAD_TARGETED");
    if (loadFlags & nsIChannel.LOAD_CALL_CONTENT_SNIFFERS) flags.push("LOAD_CALL_CONTENT_SNIFFERS");
    if (loadFlags & nsICachingChannel.LOAD_NO_NETWORK_IO) flags.push("LOAD_NO_NETWORK_IO");
    if (loadFlags & nsICachingChannel.LOAD_CHECK_OFFLINE_CACHE) flags.push("LOAD_CHECK_OFFLINE_CACHE");
    if (loadFlags & nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE) flags.push("LOAD_BYPASS_LOCAL_CACHE");
    if (loadFlags & nsICachingChannel.LOAD_BYPASS_LOCAL_CACHE_IF_BUSY) flags.push("LOAD_BYPASS_LOCAL_CACHE_IF_BUSY");
    if (loadFlags & nsICachingChannel.LOAD_ONLY_FROM_CACHE) flags.push("LOAD_ONLY_FROM_CACHE");
    if (loadFlags & nsICachingChannel.LOAD_ONLY_IF_MODIFIED) flags.push("LOAD_ONLY_IF_MODIFIED");

    return flags.join(", ");
};

// ********************************************************************************************* //

Http.BaseProgressListener =
{
    QueryInterface : function(iid)
    {
        if (iid.equals(Ci.nsIWebProgressListener) ||
            iid.equals(Ci.nsISupportsWeakReference) ||
            iid.equals(Ci.nsISupports))
        {
            return this;
        }

        throw Components.results.NS_NOINTERFACE;
    },

    stateIsRequest: false,
    onLocationChange: function() {},
    onStateChange : function() {},
    onProgressChange : function() {},
    onStatusChange : function() {},
    onSecurityChange : function() {},
    onLinkIconAvailable : function() {}
};

// ********************************************************************************************* //
// Registration

return Http;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */
/*global define:1*/

define("firebug/lib/json",
[
    "firebug/lib/trace"
],
function(FBTrace) {

"use strict";

// ********************************************************************************************* //
// Constants

var Json = {};

// ********************************************************************************************* //
// JSON

Json.parseJSONString = function(jsonString, originURL)
{
    var regex, matches;
    if (FBTrace.DBG_JSONVIEWER)
        FBTrace.sysout("jsonviewer.parseJSON; " + jsonString);

    var first = firstNonWs(jsonString);
    if (first !== "[" && first !== "{")
    {
        // This (probably) isn't pure JSON. Let's try to strip various sorts
        // of XSSI protection/wrapping and see if that works better.

        // Prototype-style secure requests
        regex = /^\s*\/\*-secure-([\s\S]*)\*\/\s*$/;
        matches = regex.exec(jsonString);
        if (matches)
        {
            jsonString = matches[1];

            if (jsonString[0] === "\\" && jsonString[1] === "n")
                jsonString = jsonString.substr(2);

            if (jsonString[jsonString.length-2] === "\\" && jsonString[jsonString.length-1] === "n")
                jsonString = jsonString.substr(0, jsonString.length-2);
        }

        // Google-style (?) delimiters
        if (jsonString.indexOf("&&&START&&&") !== -1)
        {
            regex = /&&&START&&&([\s\S]*)&&&END&&&/;
            matches = regex.exec(jsonString);
            if (matches)
                jsonString = matches[1];
        }

        // while(1);, for(;;);, and )]}'
        regex = /^\s*(\)\]\}[^\n]*\n|while\s*\(1\);|for\s*\(;;\);)([\s\S]*)/;
        matches = regex.exec(jsonString);
        if (matches)
            jsonString = matches[2];

        // JSONP
        regex = /^\s*([A-Za-z0-9_$.]+\s*(?:\[.*\]|))\s*\(([\s\S]*)\)/;
        matches = regex.exec(jsonString);
        if (matches)
            jsonString = matches[2];
    }

    try
    {
        return JSON.parse(jsonString);
    }
    catch (exc) {}

    // Give up if we don't have valid start, to avoid some unnecessary overhead.
    first = firstNonWs(jsonString);
    if (first !== "[" && first !== "{" && isNaN(first) && first !== '"')
        return null;

    // Remove JavaScript comments, quote non-quoted identifiers, and merge
    // multi-line structures like |{"a": 1} \n {"b": 2}| into a single JSON
    // object [{"a": 1}, {"b": 2}].
    jsonString = pseudoJsonToJson(jsonString);

    try
    {
        return JSON.parse(jsonString);
    }
    catch (exc)
    {
        if (FBTrace.DBG_JSONVIEWER)
        {
            FBTrace.sysout("jsonviewer.parseJSON FAILS on "+originURL+" with EXCEPTION " + exc,
                {e: exc, json: jsonString});
        }
    }

    return null;
};

function firstNonWs(str)
{
    for (var i = 0, len = str.length; i < len; i++)
    {
        var ch = str[i];
        if (ch !== " " && ch !== "\n" && ch !== "\t" && ch !== "\r")
            return ch;
    }
    return "";
}

function pseudoJsonToJson(json)
{
    var ret = "";
    var at = 0, lasti = 0, lastch = "", hasMultipleParts = false;
    for (var i = 0, len = json.length; i < len; ++i)
    {
        var ch = json[i];
        if (/\s/.test(ch))
            continue;

        if (ch === '"')
        {
            // Consume a string.
            ++i;
            while (i < len)
            {
                if (json[i] === "\\")
                    ++i;
                else if (json[i] === '"')
                    break;
                ++i;
            }
        }
        else if (ch === "'")
        {
            // Convert an invalid string into a valid one.
            ret += json.slice(at, i) + "\"";
            at = i + 1;
            ++i;
            while (i < len)
            {
                if (json[i] === "\\")
                    ++i;
                else if (json[i] === "'")
                    break;
                ++i;
            }
            if (i < len)
            {
                ret += json.slice(at, i) + "\"";
                at = i + 1;
            }
        }
        else if ((ch === "[" || ch === "{") && (lastch === "]" || lastch === "}"))
        {
            // Multiple JSON messages in one... Make it into a single array by
            // inserting a comma and setting the "multiple parts" flag.
            ret += json.slice(at, i) + ",";
            hasMultipleParts = true;
            at = i;
        }
        else if (lastch === "," && (ch === "]" || ch === "}"))
        {
            // Trailing commas in arrays/objects.
            ret += json.slice(at, lasti);
            at = i;
        }
        else if (lastch === "/" && lasti === i-1)
        {
            // Some kind of comment; remove it.
            if (ch === "/")
            {

                ret += json.slice(at, i-1);
                at = i + json.slice(i).search(/\n|\r|$/);
                i = at - 1;
            }
            else if (ch === "*")
            {
                ret += json.slice(at, i-1);
                at = json.indexOf("*/", i+1) + 2;
                if (at === 1)
                    at = len;
                i = at - 1;
            }
            ch = "\0";
        }
        else if (/[a-zA-Z$_]/.test(ch) && lastch !== ":")
        {
            // Non-quoted identifier. Quote it.
            ret += json.slice(at, i) + "\"";
            at = i;
            i = i + json.slice(i).search(/[^a-zA-Z0-9$_]|$/);
            ret += json.slice(at, i) + "\"";
            at = i;
        }

        lastch = ch;
        lasti = i;
    }

    ret += json.slice(at);
    if (hasMultipleParts)
        ret = "[" + ret + "]";
    return ret;
}

// ********************************************************************************************* //

return Json;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/keywords",
[
    "firebug/lib/trace"
],
function(FBTrace) {

"use strict";

// ********************************************************************************************* //
// Debug APIs

var Keywords = {};

// ********************************************************************************************* //
// JavaScript Parsing

Keywords.jsKeywords =
{
    "var": 1,
    "const": 1,
    "class": 1,
    "extends": 1,
    "import": 1,
    "namespace": 1,
    "function": 1,
    "debugger": 1,
    "new": 1,
    "delete": 1,
    "null": 1,
    "undefined": 1,
    "true": 1,
    "false": 1,
    "void": 1,
    "typeof": 1,
    "instanceof": 1,
    "break": 1,
    "continue": 1,
    "return": 1,
    "throw": 1,
    "try": 1,
    "catch": 1,
    "finally": 1,
    "if": 1,
    "else": 1,
    "for": 1,
    "while": 1,
    "do": 1,
    "with": 1,
    "switch": 1,
    "case": 1,
    "default": 1
};

Keywords.isJavaScriptKeyword = function(name)
{
    return name in Keywords.jsKeywords;
};

// ********************************************************************************************* //

return Keywords;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/lib",
[
    "firebug/lib/object",
    "firebug/lib/xpcom",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/options",
    "firebug/lib/deprecated",
    "firebug/lib/wrapper",
    "firebug/lib/url",
    "firebug/js/sourceLink",
    "firebug/js/stackFrame",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/http",
    "firebug/chrome/window",
    "firebug/lib/search",
    "firebug/lib/xpath",
    "firebug/lib/string",
    "firebug/lib/xml",
    "firebug/lib/persist",
    "firebug/lib/array",
    "firebug/lib/system",
    "firebug/lib/json",
    "firebug/lib/fonts",
    "firebug/chrome/menu",
    "firebug/dom/toggleBranch",
    "firebug/trace/debug",
    "firebug/lib/keywords",
    "firebug/chrome/firefox"
],
function(Obj, Xpcom, Locale, Events, Options, Deprecated, Wrapper, Url, SourceLink,
    StackFrame, Css, Dom, Http, Win, Search, Xpath, Str, Xml, Persist, Arr, System, Json,
    Fonts, Menu, ToggleBranch, Debug, Keywords, Firefox) {

// ********************************************************************************************* //

var FBL = window.FBL || {};  // legacy.js adds top.FBL, FIXME, remove after iframe version

// ********************************************************************************************* //
// xxxHonza: all deprecated API should be removed from 1.9+
// All properties and methods of FBL namespace are deprecated.

// Backward compatibility with extensions
// deprecated
for (var p in Obj)
    FBL[p] = Obj[p];

for (var p in Xpcom)
    FBL[p] = Xpcom[p];

for (var p in Locale)
    FBL[p] = Locale[p];

for (var p in Events)
    FBL[p] = Events[p];

for (var p in Wrapper)
    FBL[p] = Wrapper[p];

for (var p in Url)
    FBL[p] = Url[p];

for (var p in StackFrame)
    FBL[p] = StackFrame[p];

for (var p in Css)
    FBL[p] = Css[p];

for (var p in Dom)
    FBL[p] = Dom[p];

for (var p in Http)
    FBL[p] = Http[p];

for (var p in Win)
    FBL[p] = Win[p];

for (var p in Search)
    FBL[p] = Search[p];

for (var p in Xpath)
    FBL[p] = Xpath[p];

for (var p in Str)
    FBL[p] = Str[p];

for (var p in Xml)
    FBL[p] = Xml[p];

for (var p in Persist)
    FBL[p] = Persist[p];

for (var p in Arr)
    FBL[p] = Arr[p];

for (var p in System)
    FBL[p] = System[p];

for (var p in Json)
    FBL[p] = Json[p];

for (var p in Fonts)
    FBL[p] = Fonts[p];

for (var p in Menu)
    FBL[p] = Menu[p];

for (var p in ToggleBranch)
    FBL[p] = ToggleBranch[p];

for (var p in Debug)
    FBL[p] = Debug[p];

for (var p in Keywords)
    FBL[p] = Keywords[p];

for (var p in Firefox)
    FBL[p] = Firefox[p];

FBL.deprecated = Deprecated.deprecated;
FBL.SourceLink = SourceLink.SourceLink;

// deprecated
FBL.$ = function(id, doc)
{
    if (doc)
        return doc.getElementById(id);
    else
        return document.getElementById(id);
};

// deprecated
FBL.jsd = Components.classes["@mozilla.org/js/jsd/debugger-service;1"].
    getService(Components.interfaces.jsdIDebuggerService);

// ********************************************************************************************* //
// Constants

try
{
    Components.utils["import"]("resource://gre/modules/PluralForm.jsm");
    Components.utils["import"]("resource://firebug/firebug-service.js");

    // deprecated
    FBL.fbs = fbs; // left over from component.
}
catch (err)
{
}

// deprecated
FBL.reUpperCase = /[A-Z]/;

// ********************************************************************************************* //
// Registration

return FBL;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/locale",
[
],
function() {

"use strict";

// ********************************************************************************************* //
// Module

// The entire localization support is implemented as a Mozilla Module so that it can be
// used before Firebug is fully loaded.
return Components.utils["import"]("resource://firebug/locale.js").Locale;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/object",
[
    "firebug/lib/trace",
    "firebug/lib/xpcom",
    "firebug/lib/array",
    "firebug/lib/string"
],
function(FBTrace, Xpcom, Arr, Str) {

"use strict";

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;

// ********************************************************************************************* //

var Obj = {};

// ********************************************************************************************* //

Obj.bind = function()  // fn, thisObject, args => thisObject.fn(arguments, args);
{
   var args = Arr.cloneArray(arguments), fn = args.shift(), object = args.shift();
   return function bind() { return fn.apply(object, Arr.arrayInsert(Arr.cloneArray(args), 0, arguments)); };
};

Obj.bindFixed = function() // fn, thisObject, args => thisObject.fn(args);
{
    var args = Arr.cloneArray(arguments), fn = args.shift(), object = args.shift();
    return function() { return fn.apply(object, args); };
};

Obj.extend = function()
{
    if (arguments.length < 2)
    {
        FBTrace.sysout("object.extend; ERROR", arguments);
        throw new Error("Obj.extend on undefined object");
    }

    var newOb = {};
    for (var i = 0, len = arguments.length; i < len; ++i)
    {
        var ob = arguments[i];
        for (var prop in ob)
        {
            // Use property descriptor to clone also getters and setters.
            var pd = Object.getOwnPropertyDescriptor(ob, prop);
            if (pd)
                Object.defineProperty(newOb, prop, pd);
            else
                newOb[prop] = ob[prop];
        }
    }

    return newOb;
};

Obj.descend = function(prototypeParent, childProperties)
{
    function protoSetter() {};
    protoSetter.prototype = prototypeParent;
    var newOb = new protoSetter();
    for (var n in childProperties)
        newOb[n] = childProperties[n];
    return newOb;
};

// ********************************************************************************************* //

Obj.isFunction = function(ob)
{
    return typeof(ob) == "function";
}

// ********************************************************************************************* //

/**
 * Returns true if the passed object has any properties, otherwise returns false.
 *
 * @param {Object} ob Inspected object
 * @param {Object} nonEnumProps If set to true, check also non-enumerable properties (optional)
 * @param {Object} ownPropsOnly If set to true, only check own properties not inherited (optional)
 */
Obj.hasProperties = function(ob, nonEnumProps, ownPropsOnly)
{
    try
    {
        if (!ob)
            return false;

        var type = typeof(ob);
        if (type == "string" && ob.length)
            return true;

        if (type === "number" || type === "boolean" || type === "undefined" || ob === null)
            return false;

        try
        {
            // This is probably unnecessary in Firefox 19 or so.
            if ("toString" in ob && ob.toString() === "[xpconnect wrapped native prototype]")
                return true;
        }
        catch (exc) {}

        // The default case (both options false) is relatively simple.
        // Just use for..in loop.
        if (!nonEnumProps && !ownPropsOnly)
        {
            for (var name in ob)
                return true;
            return false;
        }

        var props;
        if (nonEnumProps)
            props = Object.getOwnPropertyNames(ob);
        else
            props = Object.keys(ob);

        if (props.length)
            return true;

        // Not interested in inherited properties, bail out.
        if (ownPropsOnly)
            return false;

        // Climb prototype chain.
        var parent = Object.getPrototypeOf(ob);
        if (parent)
            return this.hasProperties(parent, nonEnumProps, ownPropsOnly);
    }
    catch (exc)
    {
        // Primitive (non string) objects will throw an exception when passed into
        // Object.keys or Object.getOwnPropertyNames APIs.
        // There are also many "security error" exceptions I guess none of which are really
        // necessary to display in the FBTrace console, so, remove the tracing for now.
        // if (FBTrace.DBG_ERRORS)
        //     FBTrace.sysout("lib.hasProperties(" + Str.safeToString(ob) + ") ERROR " + exc, exc);

        // workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=648560
        if (ob.wrappedJSObject)
            return true;
    }

    return false;
};

Obj.getPrototype = function(ob)
{
    try
    {
        return ob.prototype;
    } catch (exc) {}
    return null;
};

var uidCounter = 1;
Obj.getUniqueId = function()
{
    return uidCounter++;
};

Obj.getRandomInt = function(min, max)
{
    return Math.floor(Math.random() * (max - min + 1) + min);
};

// Cross Window instanceof; type is local to this window
Obj.XW_instanceof = function(obj, type)
{
    if (obj instanceof type)
        return true;  // within-window test

    if (!type)
        return false;

    if (!obj)
        return (type == "undefined");

    // compare strings: obj constructor.name to type.name.
    // This is not perfect, we should compare type.prototype to object.__proto__,
    // but mostly code does not change the constructor object.
    do
    {
        // then the function that constructed us is the argument
        if (obj.constructor && obj.constructor.name == type.name)
            return true;
    }
    while(obj = obj.__proto__);  // walk the prototype chain.

    return false;

    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Property_Inheritance_Revisited
    // /Determining_Instance_Relationships
};

/**
 * Tells if the given property of the provided object is a non-native getter or not.
 * This method depends on PropertyPanel.jsm module available in Firefox 5+
 * isNonNativeGetter has been introduced in Firefox 7
 * The method has been moved to WebConsoleUtils.jsm in Fx 18
 *
 * @param object aObject The object that contains the property.
 * @param string aProp The property you want to check if it is a getter or not.
 * @return boolean True if the given property is a getter, false otherwise.
 */
Obj.isNonNativeGetter = function(obj, propName)
{
    try
    {
        var scope = {};
        Cu.import("resource://gre/modules/devtools/WebConsoleUtils.jsm", scope);

        if (scope.WebConsoleUtils.isNonNativeGetter)
        {
            Obj.isNonNativeGetter = function(obj, propName)
            {
                return scope.WebConsoleUtils.isNonNativeGetter(obj, propName);
            };

            return Obj.isNonNativeGetter(obj, propName);
        }
    }
    catch (err)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("Obj.isNonNativeGetter; EXCEPTION " + err, err);
    }

    // OK, the method isn't available let's use an empty implementation
    Obj.isNonNativeGetter = function()
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("Obj.isNonNativeGetter; ERROR built-in method not found!");
        return true;
    };

    return true;
};

// xxxFlorent: [ES6-getPropertyNames]
// http://wiki.ecmascript.org/doku.php?id=harmony:extended_object_api&s=getownpropertynames
/**
 * Gets property names from an object.
 *
 * @param {*} subject The object
 * @return {Array} The property names
 *
 */
Obj.getPropertyNames = Object.getPropertyNames || function(subject)
{
    var props = Object.getOwnPropertyNames(subject);
    var proto = Object.getPrototypeOf(subject);
    while (proto !== null)
    {
        props = props.concat(Object.getOwnPropertyNames(proto));
        proto = Object.getPrototypeOf(proto);
    }
    // only keep unique elements from props (not optimised):
    //    props = [...new Set(props)];
    return Arr.unique(props);
};

// ********************************************************************************************* //

return Obj;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/options",
[
    "firebug/lib/events",
    "firebug/lib/trace"
],
function (Events, FBTrace) {

"use strict";

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const nsIPrefBranch = Ci.nsIPrefBranch;
const PrefService = Cc["@mozilla.org/preferences-service;1"];

const nsIPrefService = Ci.nsIPrefService;
const prefService = PrefService.getService(nsIPrefService);
const prefs = PrefService.getService(nsIPrefBranch);

const prefNames =  // XXXjjb TODO distribute to modules
[
    // Global
    "defaultPanelName", "throttleMessages", "textSize", "showInfoTips",
    "commandEditor", "textWrapWidth", "framePosition", "showErrorCount",
    "activateSameOrigin", "allPagesActivation", "hiddenPanels",
    "panelTabMinWidth", "sourceLinkLabelWidth", "currentVersion",
    "useDefaultLocale", "toolbarCustomizationDone",
    "showBreakNotification", "stringCropLength", "showFirstRunPage",

    // Search
    "searchCaseSensitive", "searchGlobal", "searchUseRegularExpression",
    "netSearchHeaders", "netSearchParameters", "netSearchResponseBody",

    // Console
    "showJSErrors", "showJSWarnings", "showCSSErrors", "showXMLErrors",
    "showChromeErrors", "showChromeMessages",
    "showXMLHttpRequests", "showNetworkErrors", "tabularLogMaxHeight",
    "consoleFilterTypes", "alwaysShowCommandLine",
    "commandLineShowCompleterPopup",

    // HTML
    "showFullTextNodes", "showCommentNodes",
    "showTextNodesWithWhitespace", "entityDisplay",
    "highlightMutations", "expandMutations", "scrollToMutations", "shadeBoxModel",
    "showQuickInfoBox", "displayedAttributeValueLimit", "multiHighlightLimit",

    // CSS
    "onlyShowAppliedStyles",
    "showUserAgentCSS",
    "expandShorthandProps",
    "cssEditMode",
    "colorDisplay",

    // Computed
    "computedStylesDisplay",
    "showMozillaSpecificStyles",

    // Script
    "decompileEvals", "replaceTabs", "maxScriptLineLength",

    // DOM
    "showUserProps", "showUserFuncs", "showDOMProps", "showDOMFuncs", "showDOMConstants",
    "ObjectShortIteratorMax", "showEnumerableProperties", "showOwnProperties",
    "showInlineEventHandlers", "showClosures",

    // Layout
    "showRulers",

    // Net
    "netFilterCategories", "netDisplayedResponseLimit",
    "netDisplayedPostBodyLimit", "netPhaseInterval", "sizePrecision",
    "netParamNameLimit", "netShowPaintEvents", "netShowBFCacheResponses",
    "netHtmlPreviewHeight",

    // JSON Preview
    "sortJsonPreview",

    // Stack
    "omitObjectPathStack",

    "showStackTrace", // Console
    "filterSystemURLs", // Stack
    "breakOnErrors",  "trackThrowCatch" // Script
];

var optionUpdateMap = {};

// ********************************************************************************************* //

/**
 * Interface to preference storage.
 * Panels send commands to request option change.
 * Backend responds with events when the change is accepted.
 */
var Options =
/** @lends Options */
{
    prefDomain: "extensions.firebug",

    getPrefDomain: function()
    {
        return this.prefDomain;
    },

    initialize: function(prefDomain)
    {
        this.prefDomain = prefDomain;

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("options.initialize with prefDomain " + this.prefDomain);

        this.initializePrefs();
    },

    shutdown: function()
    {
        prefs.removeObserver(this.prefDomain, this, false);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Custom Listeners

    listeners: [],

    addListener: function(listener)
    {
        this.listeners.push(listener);
    },

    removeListener: function(listener)
    {
        for (var i=0; i<this.listeners.length; ++i)
            if (this.listeners[i] == listener)
                return this.listeners.splice(i, 1);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // nsIPrefObserver

    observe: function(subject, topic, data)
    {
        if (data.indexOf(Options.prefDomain) === -1)
            return;

        var name = data.substr(Options.prefDomain.length+1);  // +1 for .
        var value = this.get(name);

        if (FBTrace.DBG_OPTIONS)
            FBTrace.sysout("options.observe name = value: "+name+"= "+value+"\n");

        this.updatePref(name, value);
    },

    updatePref: function(name, value)
    {
        // Prevent infinite recursion due to pref observer
        if (optionUpdateMap.hasOwnProperty(name))
            return;

        try
        {
            optionUpdateMap[name] = 1;
            Firebug[name] = value;

            Events.dispatch(this.listeners, "updateOption", [name, value]);
        }
        catch (err)
        {
            if (FBTrace.DBG_OPTIONS || FBTrace.DBG_ERRORS)
                FBTrace.sysout("options.updatePref EXCEPTION:" + err, err);
        }
        finally
        {
            delete optionUpdateMap[name];
        }

        if (FBTrace.DBG_OPTIONS)
            FBTrace.sysout("options.updatePref EXIT: "+name+"="+value+"\n");
    },

    register: function(name, value)
    {
        var currentValue = this.getPref(this.prefDomain, name);

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("registerPreference "+name+" -> "+value+" type "+typeof(value)+
                " with currentValue "+currentValue);

        if (currentValue === undefined)
        {
            // https://developer.mozilla.org/en/Code_snippets/Preferences
            // This is the reason why you should usually pass strings ending with a dot to
            // getBranch(), like prefs.getBranch("accessibility.").
            var defaultBranch = prefService.getDefaultBranch(this.prefDomain+"."); //

            var type = this.getPreferenceTypeByExample(typeof(value));
            if (this.setPreference(name, value, type, defaultBranch))
                return true;
        }

        return false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Options
    // TODO support per context options eg break on error

    initializePrefs: function()
    {
        for (var i = 0; i < prefNames.length; ++i)
            Firebug[prefNames[i]] = this.getPref(this.prefDomain, prefNames[i]);

        prefs.addObserver(this.prefDomain, this, false);

        var basePrefNames = prefNames.length;

        for (var i = basePrefNames; i < prefNames.length; ++i)
            Firebug[prefNames[i]] = this.getPref(this.prefDomain, prefNames[i]);

        if (FBTrace.DBG_OPTIONS)
        {
             for (var i = 0; i < prefNames.length; ++i)
             {
                FBTrace.sysout("options.initialize option "+this.prefDomain+"."+prefNames[i]+"="+
                    Firebug[prefNames[i]]+"\n");
             }
        }
    },

    togglePref: function(name)
    {
        this.set(name, !this.get(name));
    },

    get: function(name)
    {
        return Options.getPref(this.prefDomain, name);
    },

    getPref: function(prefDomain, name)
    {
        var prefName = prefDomain + "." + name;

        var type = prefs.getPrefType(prefName);

        var value = null;
        if (type == nsIPrefBranch.PREF_STRING)
            value = prefs.getCharPref(prefName);
        else if (type == nsIPrefBranch.PREF_INT)
            value = prefs.getIntPref(prefName);
        else if (type == nsIPrefBranch.PREF_BOOL)
            value = prefs.getBoolPref(prefName);

        if (FBTrace.DBG_OPTIONS)
            FBTrace.sysout("options.getPref "+prefName+" has type "+
                this.getPreferenceTypeName(type)+" and value "+value);

        return value;
    },

    getDefault: function(name)
    {
        return Options.getDefaultPref(this.prefDomain, name);
    },

    getDefaultPref: function(prefDomain, name)
    {
        var defaultPrefs = prefService.getDefaultBranch(prefDomain + ".");
        var type = defaultPrefs.getPrefType(name);

        var value = null;
        if (type == nsIPrefBranch.PREF_STRING)
            value = defaultPrefs.getCharPref(name);
        else if (type == nsIPrefBranch.PREF_INT)
            value = defaultPrefs.getIntPref(name);
        else if (type == nsIPrefBranch.PREF_BOOL)
            value = defaultPrefs.getBoolPref(name);

        if (FBTrace.DBG_OPTIONS)
        {
            FBTrace.sysout("options.getDefaultPref "+prefName+" has type "+
                this.getPreferenceTypeName(type)+" and value "+value);
        }

        return value;
    },

    set: function(name, value)
    {
        Options.setPref(Options.prefDomain, name, value);
    },

    /**
     * Set a preference value.
     *
     * @param prefDomain, e.g. "extensions.firebug"
     * @param name Name of the preference (the part after prfDomain without dot)
     * @param value New value for the preference.
     * @param prefType optional pref type useful when adding a new preference.
     */
    setPref: function(prefDomain, name, value, prefType)
    {
        var prefName = prefDomain + "." + name;

        var type = this.getPreferenceTypeByExample((prefType ? prefType : typeof(value)));
        if (!this.setPreference(prefName, value, type, prefs))
            return;

        if (FBTrace.DBG_OPTIONS)
            FBTrace.sysout("options.setPref type="+type+" name="+prefName+" value="+value);
    },

    setPreference: function(prefName, value, type, prefBranch)
    {
        if (FBTrace.DBG_OPTIONS)
            FBTrace.sysout("setPreference "+prefName, {prefName: prefName, value: value});

        if (type == nsIPrefBranch.PREF_STRING)
            prefBranch.setCharPref(prefName, value);
        else if (type == nsIPrefBranch.PREF_INT)
            prefBranch.setIntPref(prefName, value);
        else if (type == nsIPrefBranch.PREF_BOOL)
            prefBranch.setBoolPref(prefName, value);
        else if (type == nsIPrefBranch.PREF_INVALID)
        {
            FBTrace.sysout("options.setPref FAILS: Invalid preference "+prefName+" with type "+
                type+", check that it is listed in defaults/prefs.js");

            return false;
        }

        return true;
    },

    getPreferenceTypeByExample: function(prefType)
    {
        var type = nsIPrefBranch.PREF_INVALID;
        if (prefType)
        {
            if (prefType === typeof("s"))
                type = nsIPrefBranch.PREF_STRING;
            else if (prefType === typeof(1))
                type = nsIPrefBranch.PREF_INT;
            else if (prefType === typeof(true))
                type = nsIPrefBranch.PREF_BOOL;
        }
        else
        {
            type = prefs.getPrefType(prefName);
        }

        return type;
    },

    getPreferenceTypeName: function(prefType)
    {
        if (prefType == Ci.nsIPrefBranch.PREF_STRING)
            return "string";
        else if (prefType == Ci.nsIPrefBranch.PREF_INT)
            return "int";
        else if (prefType == Ci.nsIPrefBranch.PREF_BOOL)
            return "boolean";
    },

    clear: function(name)
    {
        Options.clearPref(Options.prefDomain, name);
    },

    clearPref: function(prefDomain, name)
    {
        var prefName = prefDomain + "." + name;
        if (prefs.prefHasUserValue(prefName))
            prefs.clearUserPref(prefName);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Firebug UI text zoom

    changeTextSize: function(amt)
    {
        var textSize = Options.get("textSize");
        var newTextSize = textSize + amt;
        if ((newTextSize < 0 && Math.abs(newTextSize) < this.negativeZoomFactors.length) ||
            (newTextSize >= 0 && textSize+amt < this.positiveZoomFactors.length))
        {
            this.setTextSize(textSize+amt);
        }
    },

    setTextSize: function(value)
    {
        var setValue = value;
        if (value >= this.positiveZoomFactors.length)
            setValue = this.positiveZoomFactors[this.positiveZoomFactors.length-1];
        else if (value < 0 && Math.abs(value) >= this.negativeZoomFactors.length)
            setValue = this.negativeZoomFactors[this.negativeZoomFactors.length-1];
        this.set("textSize", setValue);
    },

    positiveZoomFactors: [1, 1.1, 1.2, 1.3, 1.5, 2, 3],
    negativeZoomFactors: [1, 0.95, 0.8, 0.7, 0.5],

    getZoomByTextSize: function(value)
    {
        var zoom = value >= 0 ? (this.positiveZoomFactors[value] || 1) :
            (this.negativeZoomFactors[Math.abs(value)] || 1);

        return zoom;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Resets all Firebug options to default state. Note that every option
     * starting with "extensions.firebug" is considered as a Firebug option.
     *
     * Options starting with DBG_ are intended for Firebug Tracing Console (FBTrace)
     * and ignored (their state is not changed).
     */
    resetAllOptions: function()
    {
        var preferences = prefs.getChildList("extensions.firebug", {});
        for (var i = 0; i < preferences.length; i++)
        {
            if (preferences[i].indexOf("DBG_") == -1)
            {
                if (FBTrace.DBG_OPTIONS)
                    FBTrace.sysout("Clearing option: " + i + ") " + preferences[i]);

                if (prefs.prefHasUserValue(preferences[i]))  // avoid exception
                    prefs.clearUserPref(preferences[i]);
            }
            else
            {
                if (FBTrace.DBG_OPTIONS)
                    FBTrace.sysout("Skipped clearing option: " + i + ") " + preferences[i]);
            }
        }
    },

    forceSave: function()
    {
        prefs.savePrefFile(null);
    }
};

// ********************************************************************************************* //
// Registration

return Options;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/persist",
[
    "firebug/lib/trace",
],
function(FBTrace) {

"use strict";

// ********************************************************************************************* //
// Constants

var Persist = {};

const overrideDefaultsWithPersistedValuesTimeout = 500;

// ********************************************************************************************* //
// Persistence (cross page refresh)

Persist.persistObjects = function(panel, panelState)
{
    // Persist the location and selection so we can restore them in case of a reload
    if (panel.location)
        panelState.persistedLocation = Persist.persistObject(panel.location, panel.context); // fn(context)->location

    if (panel.selection)
        panelState.persistedSelection = Persist.persistObject(panel.selection, panel.context);

    if (FBTrace.DBG_INITIALIZE)
        FBTrace.sysout("lib.persistObjects "+panel.name+" panel.location:"+panel.location+
            " panel.selection:"+panel.selection+" panelState:", panelState);
};

Persist.persistObject = function(object, context)
{
    var rep = Firebug.getRep(object, context);
    return rep ? rep.persistObject(object, context) : null;
};

Persist.restoreLocation =  function(panel, panelState)
{
    var restored = false;

    if (!panel.location && panelState && panelState.persistedLocation)
    {
        var location = panelState.persistedLocation(panel.context);

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("lib.restoreObjects "+panel.name+" persistedLocation: "+location+
                " panelState:", panelState);

        if (location)
        {
            panel.navigate(location);
            restored = true;
        }
    }

    if (!panel.location)
        panel.navigate(null);

    if (FBTrace.DBG_INITIALIZE)
        FBTrace.sysout("lib.restoreLocation panel.location: "+panel.location+" restored: "+
            restored+" panelState:", panelState);

    return restored;
};

Persist.restoreSelection = function(panel, panelState)
{
    var needRetry = false;

    if (!panel.selection && panelState && panelState.persistedSelection)
    {
        var selection = panelState.persistedSelection(panel.context);
        if (selection)
            panel.select(selection);
        else
            needRetry = true;
    }

    if (!panel.selection)  // Couldn't restore the selection, so select the default object
        panel.select(null);

    function overrideDefaultWithPersistedSelection()
    {
        if (panel.selection == panel.getDefaultSelection() && panelState.persistedSelection)
        {
            var selection = panelState.persistedSelection(panel.context);
            if (selection)
                panel.select(selection);
        }

        if (FBTrace.DBG_INITIALIZE)
            FBTrace.sysout("lib.overrideDefaultsWithPersistedValues "+panel.name+
                " panel.location: "+panel.location+" panel.selection: "+panel.selection+
                " panelState:", panelState);
    }

    if (needRetry)
    {
        // If we couldn't restore the selection, wait a bit and try again
        panel.context.setTimeout(overrideDefaultWithPersistedSelection,
            overrideDefaultsWithPersistedValuesTimeout);
    }

    if (FBTrace.DBG_INITIALIZE)
        FBTrace.sysout("lib.restore "+panel.name+" needRetry "+needRetry+" panel.selection: "+
            panel.selection+" panelState:", panelState);
};

Persist.restoreObjects = function(panel, panelState)
{
    Persist.restoreLocation(panel, panelState);
    Persist.restoreSelection(panel, panelState);
};

Persist.getPersistedState = function(context, panelName)
{
    if (!context)
        return null;

    var persistedState = context.persistedState;
    if (!persistedState)
        persistedState = context.persistedState = {};

    if (!persistedState.panelState)
        persistedState.panelState = {};

    var panelState = persistedState.panelState[panelName];
    if (!panelState)
        panelState = persistedState.panelState[panelName] = {};

    return panelState;
};

// ********************************************************************************************* //

return Persist;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/search",
[
    "firebug/lib/trace",
    "firebug/lib/options",
],
function(FBTrace, Options) {

"use strict";

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;
var Cc = Components.classes;

var Search = {};

var finder = Search.finder = Cc["@mozilla.org/embedcomp/rangefind;1"].createInstance(Ci.nsIFind);

// ********************************************************************************************* //

/**
 * @class Searches for text in a given node.
 *
 * @constructor
 * @param {Node} rootNode Node to search
 * @param {Function} rowFinder results filter. On find this method will be called
 *      with the node containing the matched text as the first parameter. This may
 *      be undefined to return the node as is.
 */
Search.TextSearch = function(rootNode, rowFinder)
{
    var doc = rootNode.ownerDocument;
    var searchRange = null;
    var startPt = null;

    /**
     * Find the first result in the node.
     *
     * @param {String} text Text to search for
     * @param {boolean} reverse true to perform a reverse search
     * @param {boolean} caseSensitive true to perform a case sensitive search
     */
    this.find = function(text, reverse, caseSensitive)
    {
        this.text = text;

        finder.findBackwards = !!reverse;
        finder.caseSensitive = !!caseSensitive;

        var range = this.range = finder.Find(
            text, searchRange,
            startPt || searchRange,
            searchRange);

        var match = range ?  range.startContainer : null;
        return this.currentNode = (rowFinder && match ? rowFinder(match) : match);
    };

    /**
     * Find the next search result
     *
     * @param {boolean} wrapAround true to wrap the search if the end of range is reached
     * @param {boolean} sameNode true to return multiple results from the same text node
     * @param {boolean} reverse true to search in reverse
     * @param {boolean} caseSensitive true to perform a case sensitive search
     */
    this.findNext = function(wrapAround, sameNode, reverse, caseSensitive)
    {
        this.wrapped = false;
        startPt = undefined;

        if (sameNode && this.range)
        {
            startPt = this.range.cloneRange();
            if (reverse)
                startPt.setEnd(startPt.startContainer, startPt.startOffset);
            else
                startPt.setStart(startPt.startContainer, startPt.startOffset+1);
        }

        if (!startPt)
        {
            var curNode = this.currentNode ? this.currentNode : rootNode;
            startPt = doc.createRange();
            try
            {
                if (reverse)
                {
                    startPt.setStartBefore(curNode);
                }
                else
                {
                    startPt.setStartAfter(curNode);
                }
            }
            catch (e)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("lib.TextSearch.findNext setStartAfter fails for nodeType:"+
                        (this.currentNode?this.currentNode.nodeType:rootNode.nodeType),e);

                try
                {
                    FBTrace.sysout("setStart try\n");
                    startPt.setStart(curNode);
                    FBTrace.sysout("setStart success\n");
                }
                catch (exc)
                {
                    return;
                }
            }
        }

        var match = startPt && this.find(this.text, reverse, caseSensitive);
        if (!match && wrapAround)
        {
            this.wrapped = true;
            this.reset();
            return this.find(this.text, reverse, caseSensitive);
        }

        return match;
    };

    /**
     * Resets the instance state to the initial state.
     */
    this.reset = function()
    {
        searchRange = doc.createRange();
        searchRange.selectNode(rootNode);

        startPt = searchRange;
    };

    this.reset();
};

Search.SourceBoxTextSearch = function(sourceBox)
{
    this.tryToContinueSearch = function(sBox, text)
    {
        if (sBox != sourceBox)
            return false;

        var isSubstring = text.indexOf(this.text) !=-1 || this.text.indexOf(text) !=-1;

        if (isSubstring && this.mark && Math.abs(sourceBox.centralLine - this.mark) < 10)
            this.mark--;
        else
            this.reset();

        return true;
    };
    this.find = function(text, reverse, caseSensitive)
    {
        this.text = text;

        this.re = new Search.ReversibleRegExp(text);

        return this.findNext(false, reverse, caseSensitive);
    };

    this.findNext = function(wrapAround, reverse, caseSensitive)
    {
        this.wrapped = false;
        var lines = sourceBox.lines;
        var match = null;
        for (var iter = new Search.ReversibleIterator(lines.length, this.mark, reverse); iter.next();)
        {
            match = this.re.exec(lines[iter.index], false, caseSensitive);
            if (match)
            {
                this.mark = iter.index;
                return iter.index;
            }
        }

        if (!match && wrapAround)
        {
            this.reset();
            this.wrapped = true;
            return this.findNext(false, reverse, caseSensitive);
        }

        return match;
    };

    this.reset = function()
    {
        delete this.mark;
    };

    this.reset();
};

Search.ReversibleIterator = function(length, start, reverse)
{
    this.length = length;
    this.index = start;
    this.reversed = !!reverse;

    this.next = function()
    {
        if (this.index === undefined || this.index === null)
        {
            this.index = this.reversed ? length : -1;
        }
        this.index += this.reversed ? -1 : 1;

        return 0 <= this.index && this.index < length;
    };

    this.reverse = function()
    {
        this.reversed = !this.reversed;
    };
};


/**
 * @class Implements a RegExp-like object that will search for the literal value
 * of a given string, rather than the regular expression. This allows for
 * iterative literal searches without having to escape user input strings
 * to prevent invalid regular expressions from being used.
 *
 * @constructor
 * @param {String} literal Text to search for
 * @param {Boolean} reverse Truthy to preform a reverse search, falsy to perform a forward seach
 * @param {Boolean} caseSensitive Truthy to perform a case sensitive search, falsy to perform a case insensitive search.
 */
Search.LiteralRegExp = function(literal, reverse, caseSensitive)
{
    var searchToken = (!caseSensitive) ? literal.toLowerCase() : literal;

    this.__defineGetter__("global", function() { return true; });
    this.__defineGetter__("multiline", function() { return true; });
    this.__defineGetter__("reverse", function() { return reverse; });
    this.__defineGetter__("ignoreCase", function() { return !caseSensitive; });
    this.lastIndex = 0;

    this.exec = function(text)
    {
        if (!text)
            return null;

        var searchText = (!caseSensitive) ? text.toLowerCase() : text,
            startIndex = (reverse ? text.length-1 : 0) + this.lastIndex,
            index;

        if (0 <= startIndex && startIndex < text.length)
            index = searchText[reverse ? "lastIndexOf" : "indexOf"](searchToken, startIndex);
        else
            index = -1;

        if (index >= 0)
        {
            var ret = [ text.substr(index, searchToken.length) ];
            ret.index = index;
            ret.input = text;
            this.lastIndex = index + (reverse ? -1*text.length : searchToken.length);
            return ret;
        }
        else
            this.lastIndex = 0;

        return null;
    };

    this.test = function(text)
    {
        if (!text)
            return false;

        var searchText = (!caseSensitive) ? text.toLowerCase() : text;
        return searchText.indexOf(searchToken) >= 0;
    };
};

Search.ReversibleRegExp = function(regex, flags)
{
    var re = {};

    function expression(text, reverse)
    {
        return text + (reverse ? "(?![\\s\\S]*" + text + ")" : "");
    }

    function flag(flags, caseSensitive)
    {
        return (flags || "") + (caseSensitive ? "" : "i");
    }

    this.exec = function(text, reverse, caseSensitive, lastMatch)
    {
        // Ensure we have a regex
        var key = (reverse ? "r" : "n") + (caseSensitive ? "n" : "i") 
                                + (Firebug.searchUseRegularExpression ? "r" : "n");
        if (!re[key])
        {
            try
            {
                if (Firebug.searchUseRegularExpression)
                    re[key] = new RegExp(expression(regex, reverse), flag(flags, caseSensitive));
                else
                    re[key] = new Search.LiteralRegExp(regex, reverse, caseSensitive);
            }
            catch (ex)
            {
                // The user likely entered an invalid regular expression or is in the
                // process of entering a valid one. Treat this as a plain text search
                re[key] = new Search.LiteralRegExp(regex, reverse, caseSensitive);
            }
        }

        // Modify as needed to all for iterative searches
        var indexOffset = 0;
        var searchText = text;
        if (lastMatch)
        {
            if (reverse)
            {
                searchText = text.substr(0, lastMatch.index);
            }
            else
            {
                indexOffset = lastMatch.index+lastMatch[0].length;
                searchText = text.substr(indexOffset);
            }
        }

        var curRe = re[key];
        curRe.lastIndex = 0;
        var ret = curRe.exec(searchText);
        if (ret)
        {
            ret.input = text;
            ret.index = ret.index + indexOffset;
            ret.reverse = reverse;
            ret.caseSensitive = caseSensitive;
        }
        return ret;
    };

    this.fakeMatch = function(text, reverse, caseSensitive)
    {
        var ret = [text];
        ret.index = 0;
        ret.input = text;
        ret.reverse = reverse;
        ret.caseSensitive = caseSensitive;
        return ret;
    };
};

return Search;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/string",
[
    "firebug/lib/trace",
    "firebug/lib/options",
    "firebug/lib/deprecated",
    "firebug/lib/xpcom",
    "firebug/lib/system",
],
function(FBTrace, Options, Deprecated, Xpcom, System) {

"use strict";

// ********************************************************************************************* //
// Constants

const Ci = Components.interfaces;
const Cc = Components.classes;
const Cu = Components.utils;

const entityConverter = Xpcom.CCSV("@mozilla.org/intl/entityconverter;1", "nsIEntityConverter");

const reNotWhitespace = /[^\s]/;

var Str = {};

// ********************************************************************************************* //
// Whitespace and Entity conversions

var entityConversionLists = Str.entityConversionLists =
{
    normal : {
        whitespace : {
            "\t" : "\u200c\u2192",
            "\n" : "\u200c\u00b6",
            "\r" : "\u200c\u00ac",
            " "  : "\u200c\u00b7"
        }
    },
    reverse : {
        whitespace : {
            "&Tab;" : "\t",
            "&NewLine;" : "\n",
            "\u200c\u2192" : "\t",
            "\u200c\u00b6" : "\n",
            "\u200c\u00ac" : "\r",
            "\u200c\u00b7" : " "
        }
    }
};

var normal = entityConversionLists.normal,
    reverse = entityConversionLists.reverse;

function addEntityMapToList(ccode, entity)
{
    var lists = Array.slice(arguments, 2),
        len = lists.length,
        ch = String.fromCharCode(ccode);

    for (var i = 0; i < len; i++)
    {
        var list = lists[i];
        normal[list]=normal[list] || {};
        normal[list][ch] = "&" + entity + ";";
        reverse[list]=reverse[list] || {};
        reverse[list]["&" + entity + ";"] = ch;
    }
}

var e = addEntityMapToList,
    white = "whitespace",
    text = "text",
    attr = "attributes",
    css = "css",
    editor = "editor";

e(0x0000, "#0", text, attr, css, editor);
e(0x0022, "quot", attr, css);
e(0x0026, "amp", attr, text, css);
e(0x0027, "apos", css);
e(0x003c, "lt", attr, text, css);
e(0x003e, "gt", attr, text, css);
e(0xa9, "copy", text, editor);
e(0xae, "reg", text, editor);
e(0x2122, "trade", text, editor);

// See http://en.wikipedia.org/wiki/Dash
e(0x2012, "#8210", attr, text, editor); // figure dash
e(0x2013, "ndash", attr, text, editor); // en dash
e(0x2014, "mdash", attr, text, editor); // em dash
e(0x2015, "#8213", attr, text, editor); // horizontal bar

// See http://www.cs.tut.fi/~jkorpela/chars/spaces.html
e(0x00a0, "nbsp", attr, text, white, editor);
e(0x2002, "ensp", attr, text, white, editor);
e(0x2003, "emsp", attr, text, white, editor);
e(0x2004, "emsp13", attr, text, white, editor);
e(0x2005, "emsp14", attr, text, white, editor);
e(0x2007, "numsp", attr, text, white, editor);
e(0x2008, "puncsp", attr, text, white, editor);
e(0x2009, "thinsp", attr, text, white, editor);
e(0x200a, "hairsp", attr, text, white, editor);
e(0x200b, "#8203", attr, text, white, editor); // zero-width space (ZWSP)
e(0x200c, "zwnj", attr, text, white, editor);

e(0x202f, "#8239", attr, text, white, editor); // NARROW NO-BREAK SPACE
e(0x205f, "#8287", attr, text, white, editor); // MEDIUM MATHEMATICAL SPACE
e(0x3000, "#12288", attr, text, white, editor); // IDEOGRAPHIC SPACE
e(0xfeff, "#65279", attr, text, white, editor); // ZERO WIDTH NO-BREAK SPACE

e(0x200d, "zwj", attr, text, white, editor);
e(0x200e, "lrm", attr, text, white, editor);
e(0x200f, "rlm", attr, text, white, editor);
e(0x202d, "#8237", attr, text, white, editor); // left-to-right override
e(0x202e, "#8238", attr, text, white, editor); // right-to-left override

// ********************************************************************************************* //
// Entity escaping

var entityConversionRegexes =
{
    normal : {},
    reverse : {}
};

var escapeEntitiesRegEx =
{
    normal : function(list)
    {
        var chars = [];
        for (var ch in list)
            chars.push(ch);
        return new RegExp("([" + chars.join("") + "])", "gm");
    },
    reverse : function(list)
    {
        var chars = [];
        for (var ch in list)
            chars.push(ch);
        return new RegExp("(" + chars.join("|") + ")", "gm");
    }
};

function getEscapeRegexp(direction, lists)
{
    var name = "";
    var re;
    var groups = [].concat(lists);
    for (i = 0; i < groups.length; i++)
        name += groups[i].group;
    re = entityConversionRegexes[direction][name];
    if (!re)
    {
        var list = {};
        if (groups.length > 1)
        {
            for ( var i = 0; i < groups.length; i++)
            {
                var aList = entityConversionLists[direction][groups[i].group];
                for ( var item in aList)
                    list[item] = aList[item];
            }
        }
        else if (groups.length==1)
        {
            list = entityConversionLists[direction][groups[0].group]; // faster for special case
        }
        else
        {
            list = {}; // perhaps should print out an error here?
        }
        re = entityConversionRegexes[direction][name] = escapeEntitiesRegEx[direction](list);
    }
    return re;
}

function createSimpleEscape(name, direction)
{
    return function(value)
    {
        var list = entityConversionLists[direction][name];
        return String(value).replace(
                getEscapeRegexp(direction, {
                    group : name,
                    list : list
                }),
                function(ch)
                {
                    return list[ch];
                }
            );
    };
}

function escapeEntityAsName(char)
{
    try
    {
        return entityConverter.ConvertToEntity(char, entityConverter.entityW3C);
    }
    catch(e)
    {
        return char;
    }
}

function escapeEntityAsUnicode(char)
{
    var charCode = char.charCodeAt(0);

    if (charCode == 34)
        return "&quot;";
    else if (charCode == 38)
        return "&amp;";
    else if (charCode < 32 || charCode >= 127)
        return "&#" + charCode + ";";

    return char;
}

function escapeGroupsForEntities(str, lists, type)
{
    var results = [];
    var noEntityString = "";
    var textListIndex = -1;

    if (!type)
        type = "names";

    for (var i = 0, listsLen = lists.length; i < listsLen; i++)
    {
        if (lists[i].group == "text")
        {
            textListIndex = i;
            break;
        }
    }

    for (var i = 0, strLen = str.length; i < strLen; i++)
    {
        var result = str.charAt(i);

        // If there's "text" in the list groups, use a different
        // method for converting the characters
        if (textListIndex != -1)
        {
            if (type == "unicode")
                result = escapeEntityAsUnicode(str.charAt(i));
            else if (type == "names")
                result = escapeEntityAsName(str.charAt(i));
        }

        if (result != str.charAt(i))
        {
            if (noEntityString != "")
            {
                results.push({
                    "str": noEntityString,
                    "class": "",
                    "extra": ""
                });
                noEntityString = "";
            }

            results.push({
                "str": result,
                "class": lists[textListIndex].class,
                "extra": lists[textListIndex].extra[result] ? lists[textListIndex].class
                        + lists[textListIndex].extra[result] : ""
            });
        }
        else
        {
            var listEntity;
            for (var j = 0, listsLen = lists.length; j < listsLen; j++)
            {
                var list = lists[j];
                if (list.group != "text")
                {
                    listEntity = entityConversionLists.normal[list.group][result];
                    if (listEntity)
                    {
                        result = listEntity;

                        if (noEntityString != "")
                        {
                            results.push({
                                "str": noEntityString,
                                "class": "",
                                "extra": ""
                            });
                            noEntityString = "";
                        }

                        results.push({
                            "str": result,
                            "class": list.class,
                            "extra": list.extra[result] ? list.class + list.extra[result] : ""
                        });
                        break;
                    }
                }
            }

            if (result == str.charAt(i))
            {
                noEntityString += result;
            }
        }
    }

    if (noEntityString != "")
    {
        results.push({
            "str": noEntityString,
            "class": "",
            "extra": ""
        });
    }

    return results;
}

Str.escapeGroupsForEntities = escapeGroupsForEntities;

function unescapeEntities(str, lists)
{
    var re = getEscapeRegexp("reverse", lists),
        split = String(str).split(re),
        len = split.length,
        results = [],
        cur, r, i, ri = 0, l, list;

    if (!len)
        return str;

    lists = [].concat(lists);
    for (i = 0; i < len; i++)
    {
        cur = split[i];
        if (cur == '')
            continue;

        for (l = 0; l < lists.length; l++)
        {
            list = lists[l];
            r = entityConversionLists.reverse[list.group][cur];
            if (r)
            {
                results[ri] = r;
                break;
            }
        }

        if (!r)
            results[ri] = cur;
        ri++;
    }
    return results.join('') || '';
}

// ********************************************************************************************* //
// String escaping

var escapeForTextNode = Str.escapeForTextNode = createSimpleEscape("text", "normal");
var escapeForElementAttribute = Str.escapeForElementAttribute = createSimpleEscape("attributes", "normal");
Str.escapeForHtmlEditor = createSimpleEscape("editor", "normal");
Str.escapeForCss = createSimpleEscape("css", "normal");

// deprecated compatibility functions
Str.deprecateEscapeHTML = createSimpleEscape("text", "normal");
Str.deprecatedUnescapeHTML = createSimpleEscape("text", "reverse");

Str.escapeHTML = Deprecated.deprecated("use appropriate escapeFor... function",
    Str.deprecateEscapeHTML);
Str.unescapeHTML = Deprecated.deprecated("use appropriate unescapeFor... function",
    Str.deprecatedUnescapeHTML);

var escapeForSourceLine = Str.escapeForSourceLine = createSimpleEscape("text", "normal");

var unescapeWhitespace = createSimpleEscape("whitespace", "reverse");

Str.unescapeForTextNode = function(str)
{
    if (Options.get("showTextNodesWithWhitespace"))
        str = unescapeWhitespace(str);

    if (Options.get("entityDisplay") == "names")
        str = escapeForElementAttribute(str);

    return str;
};

Str.unescapeForURL = createSimpleEscape('text', 'reverse');

Str.escapeNewLines = function(value)
{
    return value.replace(/\r/gm, "\\r").replace(/\n/gm, "\\n");
};

Str.stripNewLines = function(value)
{
    return typeof(value) == "string" ? value.replace(/[\r\n]/gm, " ") : value;
};

Str.escapeSingleQuoteJS = function(value)
{
    return value.replace("\\", "\\\\", "g").replace(/\r/gm, "\\r")
                .replace(/\n/gm, "\\n").replace("'", "\\'", "g");
};

Str.reverseString = function(value)
{
    return value.split("").reverse().join("");
};

Str.escapeJS = function(value)
{
    return value.replace("\\", "\\\\", "g").replace(/\r/gm, "\\r")
        .replace(/\n/gm, "\\n").replace('"', '\\"', "g");
};

Str.cropString = function(text, limit, alterText)
{
    if (!alterText)
        alterText = "...";

    // Make sure it's a string.
    text = text + "";

    // Use default limit if necessary.
    if (!limit)
        limit = Options.get("stringCropLength");

    // Crop the string only if a limit is actually specified.
    if (limit <= 0)
        return text;

    var halfLimit = (limit / 2);
    halfLimit -= 2; // adjustment for alterText's increase in size

    if (text.length > limit)
        return text.substr(0, halfLimit) + alterText + text.substr(text.length-halfLimit);

    return text;
};

Str.cropStringEx = function(text, limit, alterText, pivot)
{
    if (!alterText)
        alterText = "...";

    // Make sure it's a string.
    text = text + "";

    // Use default limit if necessary.
    if (!limit)
        limit = Options.get("stringCropLength");

    // Crop the string only if a limit is actually specified.
    if (limit <= 0)
        return text;

    if (text.length < limit)
        return text;

    if (typeof(pivot) == "undefined")
        pivot = text.length / 2;

    var halfLimit = (limit / 2);

    // Adjust the pivot to the real center in case it's at an edge.
    if (pivot < halfLimit)
        pivot = halfLimit;

    if (pivot > text.length - halfLimit)
        pivot = text.length - halfLimit;

    // Get substring around the pivot
    var begin = Math.max(0, pivot - halfLimit);
    var end = Math.min(text.length - 1, pivot + halfLimit);
    var result = text.substring(begin, end);

    // Add alterText to the beginning or end of the result as necessary.
    if (begin > 0)
        result = alterText + result;

    if (end < text.length - 1)
        result += alterText;

    return result;
};

Str.lineBreak = function()
{
    if (System.isWin(window))
        return "\r\n";

    if (System.isMac(window))
        return "\r";

    return "\n";
};

Str.cropMultipleLines = function(text, limit)
{
    return this.escapeNewLines(this.cropString(text, limit));
};

Str.isWhitespace = function(text)
{
    return !reNotWhitespace.exec(text);
};

Str.splitLines = function(text)
{
    if (!text)
        return [];

    const reSplitLines2 = /.*(:?\r\n|\n|\r)?/mg;
    var lines;
    if (text.match)
    {
        lines = text.match(reSplitLines2);
    }
    else
    {
        var str = text+"";
        lines = str.match(reSplitLines2);
    }
    lines.pop();
    return lines;
};

Str.trim = function(text)
{
    return text.replace(/^\s*|\s*$/g, "");
};

Str.trimLeft = function(text)
{
    return text.replace(/^\s+/, "");
};

Str.trimRight = function(text)
{
    return text.replace(/\s+$/, "");
};

Str.hasPrefix = function(hay, needle)
{
    // Passing empty string is ok, but null or undefined is not.
    if (hay == null)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("Str.hasPrefix; string must not be null", {hay: hay, needle: needle});

        return false;
    }

    // This is the fastest way of testing for prefixes - (hay.indexOf(needle) === 0)
    // can be O(|hay|) in the worst case, and (hay.substr(0, needle.length) === needle)
    // unnecessarily creates a new string and might be O(|needle|) in some JavaScript
    // implementations. See the discussion in issue 3071.
    return hay.lastIndexOf(needle, 0) === 0;
};

Str.endsWith = function(str, suffix)
{
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
};

// ********************************************************************************************* //
// HTML Wrap

Str.wrapText = function(text, noEscapeHTML)
{
    var reNonAlphaNumeric = /[^A-Za-z_$0-9'"-]/;

    var html = [];
    var wrapWidth = Options.get("textWrapWidth");

    // Split long text into lines and put every line into a <code> element (only in case
    // if noEscapeHTML is false). This is useful for automatic scrolling when searching
    // within response body (in order to scroll we need an element).
    // Don't use <pre> elements since this adds additional new line endings when copying
    // selected source code using Firefox->Edit->Copy (Ctrl+C) (issue 2093).
    var lines = Str.splitLines(text);
    for (var i = 0; i < lines.length; ++i)
    {
        var line = lines[i];

        if (wrapWidth > 0)
        {
            while (line.length > wrapWidth)
            {
                var m = reNonAlphaNumeric.exec(line.substr(wrapWidth, 100));
                var wrapIndex = wrapWidth + (m ? m.index : 0);
                var subLine = line.substr(0, wrapIndex);
                line = line.substr(wrapIndex);

                if (!noEscapeHTML) html.push("<code class=\"wrappedText focusRow\" role=\"listitem\">");
                html.push(noEscapeHTML ? subLine : escapeForTextNode(subLine));
                if (!noEscapeHTML) html.push("</code>");
            }
        }

        if (!noEscapeHTML) html.push("<code class=\"wrappedText focusRow\" role=\"listitem\">");
        html.push(noEscapeHTML ? line : escapeForTextNode(line));
        if (!noEscapeHTML) html.push("</code>");
    }

    return html;
};

Str.insertWrappedText = function(text, textBox, noEscapeHTML)
{
    var html = Str.wrapText(text, noEscapeHTML);
    textBox.innerHTML = "<pre role=\"list\">" + html.join("") + "</pre>";
};

// ********************************************************************************************* //
// Indent

const reIndent = /^(\s+)/;

function getIndent(line)
{
    var m = reIndent.exec(line);
    return m ? m[0].length : 0;
}

Str.cleanIndentation = function(text)
{
    var lines = Str.splitLines(text);

    var minIndent = -1;
    for (var i = 0; i < lines.length; ++i)
    {
        var line = lines[i];
        var indent = getIndent(line);
        if (minIndent == -1 && line && !Str.isWhitespace(line))
            minIndent = indent;
        if (indent >= minIndent)
            lines[i] = line.substr(minIndent);
    }
    return lines.join("");
};

// ********************************************************************************************* //
// Formatting

//deprecated compatibility functions
Str.deprecateEscapeHTML = createSimpleEscape("text", "normal");

/**
 * Formats a number with a fixed number of decimal places considering the locale settings
 * @param {Integer} number Number to format
 * @param {Integer} decimals Number of decimal places
 * @returns {String} Formatted number
 */
Str.toFixedLocaleString = function(number, decimals)
{
    // Check whether 'number' is a valid number
    if (isNaN(parseFloat(number)))
        throw new Error("Value '" + number + "' of the 'number' parameter is not a number");

    // Check whether 'decimals' is a valid number
    if (isNaN(parseFloat(decimals)))
        throw new Error("Value '" + decimals + "' of the 'decimals' parameter is not a number");

    var precision = Math.pow(10, decimals);
    var formattedNumber = (Math.round(number * precision) / precision).toLocaleString();
    var decimalMark = (0.1).toLocaleString().match(/\D/);
    var decimalsCount = (formattedNumber.lastIndexOf(decimalMark) == -1) ?
        0 : formattedNumber.length - formattedNumber.lastIndexOf(decimalMark) - 1;

    // Append decimals if needed
    if (decimalsCount < decimals)
    {
        // If the number doesn't have any decimals, add the decimal mark
        if (decimalsCount == 0)
            formattedNumber += decimalMark;

        // Append additional decimals
        for (var i=0, count = decimals - decimalsCount; i<count; ++i)
            formattedNumber += "0";
    }

    return formattedNumber;
};

// xxxsz: May be refactored when Firefox implements the ECMAScript Internationalization API
// See https://bugzil.la/853301
Str.formatNumber = Deprecated.deprecated("use <number>.toLocaleString() instead",
    function(number) { return number.toLocaleString(); });

Str.formatSize = function(bytes)
{
    var negative = (bytes < 0);
    bytes = Math.abs(bytes);

    var sizePrecision = Options.get("sizePrecision");
    if (typeof(sizePrecision) == "undefined")
    {
        Options.set("sizePrecision", 2);
        sizePrecision = 2;
    }

    // Get size precision (number of decimal places from the preferences)
    // and make sure it's within limits.
    sizePrecision = (sizePrecision > 2) ? 2 : sizePrecision;
    sizePrecision = (sizePrecision < -1) ? -1 : sizePrecision;

    var result;

    if (sizePrecision == -1)
        result = bytes + " B";

    var precision = Math.pow(10, sizePrecision);

    if (bytes == -1 || bytes == undefined)
        return "?";
    else if (bytes == 0)
        return "0 B";
    else if (bytes < 1024)
        result = bytes.toLocaleString() + " B";
    else if (Math.round(bytes / 1024 * precision) / precision < 1024)
        result = this.toFixedLocaleString(bytes / 1024, sizePrecision) + " KB";
    else
        result = this.toFixedLocaleString(bytes / (1024 * 1024), sizePrecision) + " MB";

    return negative ? "-" + result : result;
};

/**
 * Returns a formatted time string
 *
 * Examples:
 * Str.formatTime(12345678) => default formatting options => "3h 25m 45.678s"
 * Str.formatTime(12345678, "ms") => use milliseconds as min. time unit => "3h 25m 45s 678ms"
 * Str.formatTime(12345678, null, "m") => use minutes as max. time unit => "205m 45.678s"
 * Str.formatTime(12345678, "m", "h") => use minutes as min. and hours as max. time unit
 *     => "3h 25.7613m"
 *
 * @param {Integer} time Time to format in milliseconds
 * @param {Integer} [minTimeUnit=1] Minimal time unit to use in the formatted string
 *     (default is seconds)
 * @param {Integer} [maxTimeUnit=4] Maximal time unit to use in the formatted string
 *     (default is days)
 * @returns {String} Formatted time string
 */
Str.formatTime = function(time, minTimeUnit, maxTimeUnit, decimalPlaces)
{
    var time = parseInt(time);

    if (isNaN(time))
        return "";

    var timeUnits = [
        {
            unit: "ms",
            interval: 1000
        },
        {
            unit: "s",
            interval: 60
        },
        {
            unit: "m",
            interval: 60
        },
        {
            unit: "h",
            interval: 24
        },
        {
            unit: "d",
            interval: 1
        },
    ];

    if (time == -1)
    {
        return "";
    }
    else
    {
        // Get the index of the min. and max. time unit and the decimal places
        var minTimeUnitIndex = (Math.abs(time) < 1000) ? 0 : 1;
        var maxTimeUnitIndex = timeUnits.length - 1;

        for (var i=0, len=timeUnits.length; i<len; ++i)
        {
            if (timeUnits[i].unit == minTimeUnit)
                minTimeUnitIndex = i;
            if (timeUnits[i].unit == maxTimeUnit)
                maxTimeUnitIndex = i;
        }

        if (!decimalPlaces)
            decimalPlaces = (Math.abs(time) >= 60000 && minTimeUnitIndex == 1 ? 0 : 2);

        // Calculate the maximal time interval
        var timeUnitInterval = 1;
        for (var i=0; i<maxTimeUnitIndex; ++i)
            timeUnitInterval *= timeUnits[i].interval;

        var formattedString = (time < 0 ? "-" : "");
        time = Math.abs(time);
        for (var i=maxTimeUnitIndex; i>=minTimeUnitIndex; --i)
        {
            var value = time / timeUnitInterval;
            if (i != minTimeUnitIndex)
            {
                if (value < 0)
                    value = Math.ceil(value);
                else
                    value = Math.floor(value);
            }
            else
            {
                var decimalFactor = Math.pow(10, decimalPlaces);
                value = Math.round(value * decimalFactor) / decimalFactor;
            }

            if (value != 0 || (i == minTimeUnitIndex && formattedString == ""))
                formattedString += value.toLocaleString() + timeUnits[i].unit + " ";
            time %= timeUnitInterval;
            if (i != 0)
                timeUnitInterval /= timeUnits[i - 1].interval;
        }

        return formattedString.trim();
    }
};

/**
 * Formats an IPv4 or IPv6 address incl. port
 * @param {String} address IP address to format
 * @param {String} [port] IP port to format
 * @returns {String} Formatted IP address
 */
Str.formatIP = function(address, port)
{
    if (!address || address == "")
        return "";

    var result = address;
    var isIPv6Address = address.indexOf(":") != -1;
    if (isIPv6Address)
        result = "["+result+"]";

    if (port && port != "")
        result += ":"+port;

    return result;
};

/**
 * Capitalizes the first letter of a string or each word in it
 *
 * @param {String} string String to format
 * @param {Boolean} [capitalizeEachWord=false] If true, the first character of each word will be
 *     transformed to uppercase, otherwise only the very first character of the string
 * @param {Boolean} [restToLowerCase=true] If true, the rest of the string will be transformed
 *     to lower case, otherwise it will stay untouched
 * @returns {String} Converted string
 */
Str.capitalize = function(string, capitalizeEachWord, restToLowerCase)
{
    function capitalizeFirstLetter(string)
    {
        var rest = string.slice(1);

        if (restToLowerCase !== false)
            rest = rest.toLowerCase();

        return string.charAt(0).toUpperCase() + rest;
    }

    if (!capitalizeEachWord)
        return capitalizeFirstLetter(string, restToLowerCase);

    return string.split(" ").map(capitalizeFirstLetter).join(" ");
};

// ********************************************************************************************* //
// Conversions

Str.convertToUnicode = function(text, charset)
{
    if (!text)
        return "";

    try
    {
        var conv = Cc["@mozilla.org/intl/scriptableunicodeconverter"].getService(
            Ci.nsIScriptableUnicodeConverter);
        conv.charset = charset ? charset : "UTF-8";
        return conv.ConvertToUnicode(text);
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("Str.convertToUnicode: fails: for charset "+charset+" conv.charset:"+
                conv.charset+" exc: "+exc, exc);
        }

        // the exception is worthless, make up a new one
        throw new Error("Firebug failed to convert to unicode using charset: "+conv.charset+
            " in @mozilla.org/intl/scriptableunicodeconverter");
    }
};

Str.convertFromUnicode = function(text, charset)
{
    if (!text)
        return "";

    try
    {
        var conv = Cc["@mozilla.org/intl/scriptableunicodeconverter"].createInstance(
            Ci.nsIScriptableUnicodeConverter);
        conv.charset = charset ? charset : "UTF-8";
        return conv.ConvertFromUnicode(text);
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("Str.convertFromUnicode: fails: for charset "+charset+" conv.charset:"+
                conv.charset+" exc: "+exc, exc);
        }
    }
};

// ********************************************************************************************* //

Str.safeToString = function(ob)
{
    try
    {
        if (!ob)
            return ""+ob;
        if (ob && (typeof (ob["toString"]) == "function") )
            return ob.toString();
        if (ob && typeof (ob["toSource"]) == "function")
            return ob.toSource();
       /* https://bugzilla.mozilla.org/show_bug.cgi?id=522590 */
        var str = "[";
        for (var p in ob)
            str += p + ",";
        return str + "]";

    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("Str.safeToString FAILS "+exc, exc);
    }
    return "[unsupported: no toString() function in type "+typeof(ob)+"]";
};

// ********************************************************************************************* //

return Str;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/system",
[
    "firebug/lib/trace",
    "firebug/lib/array",
    "firebug/trace/debug",
    "firebug/lib/xpcom"
],
function(FBTrace, Arr, Debug, Xpcom) {

"use strict";

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;
var Cc = Components.classes;
var Cu = Components.utils;

var ioService = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);

var System = {};

// ********************************************************************************************* //

System.getPlatformName = function()
{
    return Cc["@mozilla.org/xre/app-info;1"].getService(Ci.nsIXULRuntime).OS;
};

System.beep = function()
{
    var sounder = Cc["@mozilla.org/sound;1"].getService(Ci.nsISound);
    sounder.beep();
};

// ********************************************************************************************* //
// Programs

System.launchProgram = function(exePath, args)
{
    try
    {
        var file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsIFile);
        file.initWithPath(exePath);

        if (System.getPlatformName() == "Darwin" && file.isDirectory())
        {
            args = Arr.extendArray(["-a", exePath], args);
            file.initWithPath("/usr/bin/open");
        }

        if (!file.exists())
            return false;

        var process = Cc["@mozilla.org/process/util;1"].createInstance(Ci.nsIProcess);
        process.init(file);
        process.run(false, args, args.length, {});
        return true;
    }
    catch (exc)
    {
        Debug.ERROR(exc);
    }

    return false;
};

System.getIconURLForFile = function(path)
{
    var fileHandler = ioService.getProtocolHandler("file")
        .QueryInterface(Ci.nsIFileProtocolHandler);

    try
    {
        var file = Cc["@mozilla.org/file/local;1"].createInstance(Ci.nsIFile);
        file.initWithPath(path);

        if ((System.getPlatformName() == "Darwin") && !file.isDirectory() &&
            (path.indexOf(".app/") != -1))
        {
            path = path.substr(0,path.lastIndexOf(".app/")+4);
            file.initWithPath(path);
        }

        return "moz-icon://" + fileHandler.getURLSpecFromFile(file) + "?size=16";
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("getIconURLForFile ERROR " + exc + " for " + path, exc);
    }

    return null;
};

System.copyToClipboard = function(string)
{
    var clipboard = Cc["@mozilla.org/widget/clipboardhelper;1"].getService(Ci.nsIClipboardHelper);
    clipboard.copyString(string);

    if (FBTrace.DBG_ERRORS && !string)
        FBTrace.sysout("system.copyToClipboard; " + string, string);
};

System.getStringDataFromClipboard = function()
{
    // https://developer.mozilla.org/en-US/docs/Using_the_Clipboard#Pasting_Clipboard_Contents
    var clip = Cc["@mozilla.org/widget/clipboard;1"].getService(Ci.nsIClipboard);
    if (!clip)
        return false;

    var trans = Cc["@mozilla.org/widget/transferable;1"].createInstance(Ci.nsITransferable);
    if (!trans)
        return false;

    if ("init" in trans)
        trans.init(null);

    trans.addDataFlavor("text/unicode");

    clip.getData(trans, clip.kGlobalClipboard);

    var str = {};
    var strLength = {};

    try
    {
        trans.getTransferData("text/unicode", str, strLength);

        if (str)
        {
            str = str.value.QueryInterface(Ci.nsISupportsString);
            return str.data.substring(0, strLength.value / 2);
        }
    }
    catch (ex)
    {
    }

    return false;
};

// ********************************************************************************************* //
// OS Checkers

System.isMac = function(win)
{
    return win.navigator.platform.search("Mac") != -1;
}

System.isWin = function(win)
{
    return win.navigator.platform.search("Win") != -1;
}

// ********************************************************************************************* //
// Firebug Version Comparator

/**
 * Compare expected Firebug version with the current Firebug installed.
 * @param {Object} expectedVersion Expected version of Firebug.
 * @returns
 * -1 the current version is smaller
 *  0 the current version is the same
 *  1 the current version is bigger
 *
 * @example:
 * if (compareFirebugVersion("1.9") >= 0)
 * {
 *     // The current version is Firebug 1.9+
 * }
 */
System.checkFirebugVersion = function(expectedVersion)
{
    if (!expectedVersion)
        return 1;

    var version = Firebug.getVersion();

    // Use Firefox comparator service.
    var versionChecker = Xpcom.CCSV("@mozilla.org/xpcom/version-comparator;1",
        "nsIVersionComparator");
    return versionChecker.compare(version, expectedVersion);
};

// ********************************************************************************************* //
// JS Modules

/**
 * Allows importing a JS module (Firefox platform) and specify alternative locations
 * to keep backward compatibility in case when the module location changes.
 * It helps Firebug to support multiple Firefox versions.
 *
 * @param {Array} locations List of URLs to try when importing the module.
 * @returns Scope of the imported module or an empty scope if module wasn't successfully loaded.
 */
System.importModule = function(locations)
{
    for (var i=0; i<locations.length; i++)
    {
        try
        {
            var moduleUrl = locations[i];
            var scope = {};
            Cu["import"](moduleUrl, scope);
            return scope;
        }
        catch (err)
        {
        }
    }

    // Module wasn't loaded return an empty scope.
    return {};
};

// ********************************************************************************************* //

return System;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/tool",
[
],
function() {

"use strict";

// ********************************************************************************************* //
// Implementation

var FirebugTool = function(name)
{
    this.toolName = name;
    this.active = false;
};

FirebugTool.prototype =
{
    getName: function()
    {
        return this.toolName;
    },
    getActive: function()
    {
        return this.active;
    },
    setActive: function(active)
    {
        this.active = !!active;
    }
};

// ********************************************************************************************* //
// Registration

return FirebugTool;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/trace",
[
],
function() {

"use strict";

// ********************************************************************************************* //
// Constants

const Cu = Components.utils;

var fbTraceScope = {};
Cu["import"]("resource://firebug/fbtrace.js", fbTraceScope);

var prefLoaderScope = {};
Cu["import"]("resource://firebug/prefLoader.js", prefLoaderScope);

//xxxHonza: duplicated from modules/firebug-trace-service.js
var TraceAPI = ["dump", "sysout", "setScope", "matchesNode", "time", "timeEnd"];

// ********************************************************************************************* //
// Wrapper

/**
 * Wraps tracer for given option. Logs made through the wrapper will automatically
 * be checked against the option and only displayed if the option is true.
 * If FBTrace console isn't installed all options are false and there is no
 * additional performance penalty.
 */
function TraceWrapper(tracer, option)
{
    function createMethodWrapper(method)
    {
        return function()
        {
            // Check the option before the log is passed to the tracing console.
            if (tracer[option])
                tracer[method].apply(tracer, arguments);
        };
    }

    for (var i=0; i<TraceAPI.length; i++)
    {
        var method = TraceAPI[i];
        this[method] = createMethodWrapper(method);
    }

    /**
     * Use to check whether scoped tracer is on/off.
     */
    this.__defineGetter__("active", function()
    {
        return tracer[option];
    });
}

// ********************************************************************************************* //
// Scoped Logging

var tracer = fbTraceScope.FBTrace;

/**
 * Support for scoped logging.
 * 
 * // The log will be displayed only if DBG_MYMODULE option is on. 'DBG_MYMODULE' preference
 * // will be automatically created and appear in the FBTrace console (after restart).
 * FBTrace = FBTrace.to("DBG_MYMODULE");
 * FBTrace.sysout("mymodule.initialiaze");
 */
tracer.to = function(option)
{
    // Automatically create corresponding DBG_ + <option> preference so, it appears
    // in the FBTrace Console window and can be checked on/off
    // Note that FBTrace Console is already initialized and do not refresh if a new
    // pref is created. So, the option appears after restart.
    // xxxHonza: FIX ME
    var value = prefLoaderScope.PrefLoader.getPref(option);
    if (typeof(value) != "boolean")
        prefLoaderScope.PrefLoader.setPref(option, false);

    return new TraceWrapper(this, option);
};

// ********************************************************************************************* //
// Registration

return tracer;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/url",
[
    "firebug/lib/trace",
    "firebug/lib/string",
],
function (FBTrace, Str) {

"use strict";

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;

const ioService = Cc["@mozilla.org/network/io-service;1"].getService(Ci.nsIIOService);

// ********************************************************************************************* //
// Implementation

var Url = {};

// ************************************************************************************************
// Regular expressions

Url.reCSS = /\.css$/;
Url.reJavascript = /\s*javascript:\s*(.*)/;
Url.reFile = /file:\/\/([^\/]*)\//;
Url.reChrome = /chrome:\/\/([^\/]*)\//;
Url.reDataURL = /data:text\/javascript;fileName=([^;]*);baseLineNumber=(\d*?),((?:.*?%0A)|(?:.*))/g;

// ************************************************************************************************
// URLs

Url.getFileName = function(url)
{
    var split = Url.splitURLBase(url);
    return split.name;
};

Url.getProtocol = function(url)
{
    var split = Url.splitURLBase(url);
    return split.protocol;
};

Url.splitURLBase = function(url)
{
    if (Url.isDataURL(url))
        return Url.splitDataURL(url);
    return Url.splitURLTrue(url);
};

Url.splitDataURL = function(url)
{
    if (!Str.hasPrefix(url, "data:"))
        return false; //  the first 5 chars must be 'data:'

    var point = url.indexOf(",", 5);
    if (point < 5)
        return false; // syntax error

    var props = { protocol: "data", encodedContent: url.substr(point+1) };

    var metadataBuffer = url.substring(5, point);
    var metadata = metadataBuffer.split(";");
    for (var i = 0; i < metadata.length; i++)
    {
        var nv = metadata[i].split("=");
        if (nv.length == 2)
            props[nv[0]] = nv[1];
    }

    // Additional Firebug-specific properties
    if (props.hasOwnProperty("fileName"))
    {
         var caller_URL = decodeURIComponent(props["fileName"]);
         var caller_split = Url.splitURLTrue(caller_URL);

         props["fileName"] = caller_URL;

        if (props.hasOwnProperty("baseLineNumber"))  // this means it's probably an eval()
        {
            props["path"] = caller_split.path;
            props["line"] = props["baseLineNumber"];
            var hint = decodeURIComponent(props["encodedContent"]).substr(0,200).replace(/\s*$/, "");
            props["name"] =  "eval->"+hint;
        }
        else
        {
            props["name"] = caller_split.name;
            props["path"] = caller_split.path;
        }
    }
    else
    {
        if (!props.hasOwnProperty("path"))
            props["path"] = "data:";
        if (!props.hasOwnProperty("name"))
            props["name"] =  decodeURIComponent(props["encodedContent"]).substr(0,200).replace(/\s*$/, "");
    }

    return props;
};

const reSplitFile = /(.*?):\/{2,3}([^\/]*)(.*?)([^\/]*?)($|\?.*)/;
Url.splitURLTrue = function(url)
{
    var m = reSplitFile.exec(url);
    if (!m)
        return {name: url, path: url};
    else if (m[4] == "" && m[5] == "")
        return {protocol: m[1], domain: m[2], path: m[3], name: m[3] != "/" ? m[3] : m[2]};
    else
        return {protocol: m[1], domain: m[2], path: m[2]+m[3], name: m[4]+m[5]};
};

Url.getFileExtension = function(url)
{
    if (!url)
        return null;

    // Remove query string from the URL if any.
    var queryString = url.indexOf("?");
    if (queryString != -1)
        url = url.substr(0, queryString);

    // Now get the file extension.
    var lastDot = url.lastIndexOf(".");
    return url.substr(lastDot+1);
};

Url.isSystemURL = function(url)
{
    if (!url) return true;
    if (url.length == 0) return true;
    if (url[0] == "h") return false;
    if (url.substr(0, 9) == "resource:")
        return true;
    else if (url.substr(0, 16) == "chrome://firebug")
        return true;
    else if (url  == "XPCSafeJSObjectWrapper.cpp")
        return true;
    else if (url.substr(0, 6) == "about:")
        return true;
    else if (url.indexOf("firebug-service.js") != -1)
        return true;
    else if (url.indexOf("/modules/debuggerHalter.js") != -1)
        return true;
    else
        return false;
};

Url.isSystemPage = function(win)
{
    try
    {
        var doc = win.document;
        if (!doc)
            return false;

        // Detect pages for pretty printed XML
        if ((doc.styleSheets.length && doc.styleSheets[0].href
                == "chrome://global/content/xml/XMLPrettyPrint.css")
            || (doc.styleSheets.length > 1 && doc.styleSheets[1].href
                == "chrome://browser/skin/feeds/subscribe.css"))
            return true;

        return Url.isSystemURL(win.location.href);
    }
    catch (exc)
    {
        // Sometimes documents just aren't ready to be manipulated here, but don't let that
        // gum up the works
        FBTrace.sysout("Url.isSystemPage; EXCEPTION document not ready?: " + exc);
        return false;
    }
};

Url.isSystemStyleSheet = function(sheet)
{
    var href = sheet && sheet.href;
    return href && Url.isSystemURL(href);
};

Url.getURIHost = function(uri)
{
    try
    {
        if (uri)
            return uri.host;
        else
            return "";
    }
    catch (exc)
    {
        return "";
    }
};

Url.isLocalURL = function(url)
{
    if (url.substr(0, 5) == "file:")
        return true;
    else if (url.substr(0, 8) == "wyciwyg:")
        return true;
    else
        return false;
};

Url.isDataURL = function(url)
{
    return (url && url.substr(0,5) == "data:");
};

Url.getLocalPath = function(url)
{
    if (this.isLocalURL(url))
    {
        var fileHandler = ioService.getProtocolHandler("file")
            .QueryInterface(Ci.nsIFileProtocolHandler);
        var file = fileHandler.getFileFromURLSpec(url);
        return file.path;
    }
};

/**
 * Mozilla URI from non-web URL
 * @param URL 
 * @returns undefined or nsIURI
 */
Url.getLocalSystemURI = function(url)
{
    try
    {
        var uri = ioService.newURI(url, null, null);
        if (uri.schemeIs("resource"))
        {
            var ph = ioService.getProtocolHandler("resource")
                .QueryInterface(Ci.nsIResProtocolHandler);
            var abspath = ph.getSubstitution(uri.host);
            uri = ioService.newURI(uri.path.substr(1), null, abspath);
        }
        while (uri.schemeIs("chrome"))
        {
            var chromeRegistry = Cc["@mozilla.org/chrome/chrome-registry;1"]
                .getService(Ci.nsIChromeRegistry);
            uri = chromeRegistry.convertChromeURL(uri);
        }
        return uri;
    }
    catch(exc)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("getLocalSystemURI failed for "+url);
    }
};

/*
 * Mozilla native path for local URL
 */
Url.getLocalOrSystemPath = function(url, allowDirectories)
{
    var uri = Url.getLocalSystemURI(url);
    if (uri instanceof Ci.nsIFileURL)
    {
        var file = uri.file;
        if (allowDirectories)
            return file && file.path;
        else
            return file && !file.isDirectory() && file.path;
    }
};

Url.getLocalOrSystemFile = function(url)
{
    var uri = Url.getLocalSystemURI(url);
    if (uri instanceof Ci.nsIFileURL)
        return uri.file;
};

Url.getURLFromLocalFile = function(file)
{
    var fileHandler = ioService.getProtocolHandler("file")
        .QueryInterface(Ci.nsIFileProtocolHandler);
    var URL = fileHandler.getURLSpecFromFile(file);
    return URL;
};

Url.getDataURLForContent = function(content, url)
{
    // data:text/javascript;fileName=x%2Cy.js;baseLineNumber=10,<the-url-encoded-data>
    var uri = "data:text/html;";
    uri += "fileName="+encodeURIComponent(url)+ ",";
    uri += encodeURIComponent(content);
    return uri;
};

Url.getDomain = function(url)
{
    var m = /[^:]+:\/{1,3}([^\/]+)/.exec(url);
    return m ? m[1] : "";
};

Url.getURLPath = function(url)
{
    var m = /[^:]+:\/{1,3}[^\/]+(\/.*?)$/.exec(url);
    return m ? m[1] : "";
};

Url.getPrettyDomain = function(url)
{
    var m = /[^:]+:\/{1,3}(www\.)?([^\/]+)/.exec(url);
    return m ? m[2] : "";
};

/**
 * Returns the base URL for a given window
 * @param {Object} win DOM window
 * @returns {String} Base URL
 */
Url.getBaseURL = function(win)
{
    if (!win)
        return;

    var base = win.document.getElementsByTagName("base").item(0);
    return base ? base.href : win.location.href;
};

Url.absoluteURL = function(url, baseURL)
{
    // Replace "/./" with "/" using regular expressions (don't use string since /./
    // can be treated as regular expressoin too, see 3551).
    return Url.absoluteURLWithDots(url, baseURL).replace(/\/\.\//, "/", "g");
};

Url.absoluteURLWithDots = function(url, baseURL)
{
    // Should implement http://www.apps.ietf.org/rfc/rfc3986.html#sec-5
    // or use the newURI approach described in issue 3110.
    // See tests/content/lib/absoluteURLs.js

    if (url.length === 0)
        return baseURL;

    var R_query_index = url.indexOf("?");
    var R_head = url;
    if (R_query_index !== -1)
        R_head = url.substr(0, R_query_index);

    if (url.indexOf(":") !== -1)
        return url;

    var reURL = /(([^:]+:)\/{1,2}[^\/]*)(.*?)$/;
    var m_url = reURL.exec(R_head);
    if (m_url)
        return url;

    var B_query_index = baseURL.indexOf("?");
    var B_head = baseURL;
    if (B_query_index !== -1)
        B_head = baseURL.substr(0, B_query_index);

    if (url[0] === "?")   // cases where R.path is empty.
        return B_head + url;
    if  (url[0] === "#")
        return baseURL.split("#")[0]+url;

    var m = reURL.exec(B_head);
    if (!m)
        return "";

    var head = m[1];
    var tail = m[3];
    if (url.substr(0, 2) == "//")
        return m[2] + url;
    else if (url[0] == "/")
    {
        return head + url;
    }
    else if (tail[tail.length-1] == "/")
        return B_head + url;
    else
    {
        var parts = tail.split("/");
        return head + parts.slice(0, parts.length-1).join("/") + "/" + url;
    }
};

var reChromeCase = /chrome:\/\/([^\/]*)\/(.*?)$/;
Url.normalizeURL = function(url)  // this gets called a lot, any performance improvement welcome
{
    if (!url)
        return "";
    // Replace one or more characters that are not forward-slash followed by /.., by space.
    if (url.length < 255) // guard against monsters.
    {
        // Replace one or more characters that are not forward-slash followed by /.., by space.
        url = url.replace(/[^\/]+\/\.\.\//, "", "g");
        // Issue 1496, avoid #
        url = url.replace(/#.*/,"");
        // For some reason, JSDS reports file URLs like "file:/" instead of "file:///", so they
        // don't match up with the URLs we get back from the DOM
        url = url.replace(/file:\/([^\/])/g, "file:///$1");
        // For script tags inserted dynamically sometimes the script.fileName is bogus
        url = url.replace(/[^\s]*\s->\s/, "");

        if (Str.hasPrefix(url, "chrome:"))
        {
            var m = reChromeCase.exec(url);  // 1 is package name, 2 is path
            if (m)
            {
                url = "chrome://"+m[1].toLowerCase()+"/"+m[2];
            }
        }
    }
    return url;
};

Url.denormalizeURL = function(url)
{
    return url.replace(/file:\/\/\//g, "file:/");
};

// ********************************************************************************************* //

Url.parseURLParams = function(url)
{
    var q = url ? url.indexOf("?") : -1;
    if (q == -1)
        return [];

    var search = url.substr(q+1);
    var h = search.lastIndexOf("#");
    if (h != -1)
        search = search.substr(0, h);

    if (!search)
        return [];

    return Url.parseURLEncodedText(search);
};

Url.parseURLEncodedText = function(text, noLimit)
{
    const maxValueLength = 25000;

    var params = [];

    // In case the text is empty just return the empty parameters
    if (text == "")
        return params;

    // Unescape '+' characters that are used to encode a space.
    // See section 2.2.in RFC 3986: http://www.ietf.org/rfc/rfc3986.txt
    text = text.replace(/\+/g, " ");

    // Unescape '&amp;' character
    text = Str.unescapeForURL(text);

    function decodeText(text)
    {
        try
        {
            return decodeURIComponent(text);
        }
        catch (e)
        {
            return decodeURIComponent(unescape(text));
        }
    }

    var args = text.split("&");
    for (var i = 0; i < args.length; ++i)
    {
        try
        {
            var index = args[i].indexOf("=");
            if (index != -1)
            {
                var paramName = args[i].substring(0, index);
                var paramValue = args[i].substring(index + 1);

                if (paramValue.length > maxValueLength && !noLimit)
                    paramValue = Locale.$STR("LargeData");

                params.push({name: decodeText(paramName), value: decodeText(paramValue)});
            }
            else
            {
                var paramName = args[i];
                params.push({name: decodeText(paramName), value: ""});
            }
        }
        catch (e)
        {
            if (FBTrace.DBG_ERRORS)
            {
                FBTrace.sysout("parseURLEncodedText EXCEPTION ", e);
                FBTrace.sysout("parseURLEncodedText EXCEPTION URI", args[i]);
            }
        }
    }

    params.sort(function(a, b) { return a.name <= b.name ? -1 : 1; });

    return params;
};

Url.reEncodeURL = function(file, text, noLimit)
{
    var lines = text.split("\n");
    var params = Url.parseURLEncodedText(lines[lines.length-1], noLimit);

    var args = [];
    for (var i = 0; i < params.length; ++i)
        args.push(encodeURIComponent(params[i].name)+"="+encodeURIComponent(params[i].value));

    var url = file.href;
    url += (url.indexOf("?") == -1 ? "?" : "&") + args.join("&");

    return url;
};

/**
 * Extracts the URL from a CSS URL definition.
 * Example: url(../path/to/file) => ../path/to/file
 * @param {String} url CSS URL definition
 * @returns {String} Extracted URL
 */
Url.extractFromCSS = function(url)
{
    return url.replace(/^url\(["']?(.*?)["']?\)$/, "$1");
};

Url.makeURI = function(urlString)
{
    try
    {
        if (urlString)
            return ioService.newURI(urlString, null, null);
    }
    catch (exc)
    {
        //var explain = {message: "Firebug.lib.makeURI FAILS", url: urlString, exception: exc};
        // todo convert explain to json and then to data url
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("makeURI FAILS for \""+urlString+"\" ", exc);

        return false;
    }
};

/**
 * Converts resource: to file: Url.
 * @param {String} resourceURL
 */
Url.resourceToFile = function(resourceURL)
{
    var resHandler = ioService.getProtocolHandler("resource")
        .QueryInterface(Ci.nsIResProtocolHandler);

    var justURL = resourceURL.split("resource://")[1];
    var split = justURL.split("/");
    var sub = split.shift();

    var path = resHandler.getSubstitution(sub).spec;
    return path + split.join("/");
};

// ********************************************************************************************* //
// Registration

return Url;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/wrapper",
[
],
function() {

"use strict";

// ********************************************************************************************* //
// Constants

var Cu = Components.utils;
var Wrapper = {};

// ********************************************************************************************* //
// Wrappers

Wrapper.getContentView = function(object)
{
    if (isPrimitive(object))
        return object;

    return object.wrappedJSObject;
};

Wrapper.unwrapObject = function(object)
{
    if (isPrimitive(object))
        return object;

    return XPCNativeWrapper.unwrap(object);
};

Wrapper.wrapObject = function(object)
{
    if (isPrimitive(object))
        return object;

    return XPCNativeWrapper(object);
};

Wrapper.isDeadWrapper = function(wrapper)
{
    return Cu.isDeadWrapper(wrapper);
};

Wrapper.unwrapIValue = function(object, viewChrome)
{
    var unwrapped = object.getWrappedValue();
    if (viewChrome)
        return unwrapped;

    try
    {
        // XPCSafeJSObjectWrapper is not defined in Firefox 4.0
        // this should be the only call to getWrappedValue in firebug
        if (typeof(XPCSafeJSObjectWrapper) != "undefined")
        {
            return XPCSafeJSObjectWrapper(unwrapped);
        }
        else if (typeof(unwrapped) == "object")
        {
            var result = XPCNativeWrapper.unwrap(unwrapped);
            if (result)
                return result;
        }
    }
    catch (exc)
    {
        if (FBTrace.DBG_ERRORS)
        {
            FBTrace.sysout("unwrapIValue FAILS for " + object + " cause: " + exc,
                {exc: exc, object: object, unwrapped: unwrapped});
        }
    }

    return unwrapped;
};

Wrapper.unwrapIValueObject = function(scope, viewChrome)
{
    var scopeVars = {};
    var listValue = {value: null}, lengthValue = {value: 0};
    scope.getProperties(listValue, lengthValue);

    for (var i = 0; i < lengthValue.value; ++i)
    {
        var prop = listValue.value[i];
        var name = Wrapper.unwrapIValue(prop.name);

        if (prop.value.jsType === prop.value.TYPE_NULL) // null is an object (!)
        {
            scopeVars[name] = null;
        }
        else
        {
            if (!Wrapper.shouldIgnore(name))
                scopeVars[name] = Wrapper.unwrapIValue(prop.value, viewChrome);
        }
    }

    return scopeVars;
};

/**
 * Create a content-accessible view of a simple chrome object. All properties
 * are marked as non-writable, except if they have explicit getters/setters.
 */
Wrapper.cloneIntoContentScope = function(global, obj)
{
    if (!obj || typeof obj !== "object")
        return obj;
    var newObj = (Array.isArray(obj) ? Cu.createArrayIn(global) : Cu.createObjectIn(global));
    for (var prop in obj)
    {
        var desc = Object.getOwnPropertyDescriptor(obj, prop);
        if (!desc)
            continue;
        if ("writable" in desc)
            desc.writable = false;
        desc.configurable = false;
        Object.defineProperty(newObj, prop, desc);
    }
    Cu.makeObjectPropsNormal(newObj);
    return newObj;
};

// ********************************************************************************************* //

Wrapper.ignoreVars =
{
    // internal firebug things XXXjjb todo we should privatize these
    "_firebug": 1,
    "__fb_scopedVars": 1,
};

Wrapper.shouldIgnore = function(name)
{
    return (Wrapper.ignoreVars[name] === 1);
};

function isPrimitive(obj)
{
    return !(obj && (typeof obj === "object" || typeof obj === "function"));
}

// ********************************************************************************************* //
// Registration

return Wrapper;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/xml",
[
    "firebug/lib/trace",
    "firebug/lib/string"
],
function(FBTrace, Str) {

"use strict";

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;
var Cc = Components.classes;

var Xml = {};

// ********************************************************************************************* //
// HTML and XML Serialization

Xml.getElementType = function(node)
{
    if (isElementXUL(node))
        return 'xul';
    else if (isElementSVG(node))
        return 'svg';
    else if (isElementMathML(node))
        return 'mathml';
    else if (isElementXHTML(node))
        return 'xhtml';
    else if (isElementHTML(node))
        return 'html';
};

Xml.getElementSimpleType = function(node)
{
    if (isElementSVG(node))
        return 'svg';
    else if (isElementMathML(node))
        return 'mathml';
    else
        return 'html';
};

var isElementHTML = Xml.isElementHTML = function(node)
{
    return node.nodeName == node.nodeName.toUpperCase() && node.namespaceURI == 'http://www.w3.org/1999/xhtml';
};

var isElementXHTML = Xml.isElementXHTML = function(node)
{
    return node.nodeName != node.nodeName.toUpperCase() && node.namespaceURI == 'http://www.w3.org/1999/xhtml';
};

var isElementHTMLOrXHTML = Xml.isElementHTMLOrXHTML = function(node)
{
    return node.namespaceURI == "http://www.w3.org/1999/xhtml";
};

var isElementMathML = Xml.isElementMathML = function(node)
{
    return node.namespaceURI == 'http://www.w3.org/1998/Math/MathML';
};

var isElementSVG = Xml.isElementSVG = function(node)
{
    return node.namespaceURI == 'http://www.w3.org/2000/svg';
};

var isElementXUL = Xml.isElementXUL = function(node)
{
    return node instanceof XULElement;
};

var getNodeName = Xml.getNodeName = function(node)
{
    var name = node.nodeName;
    return isElementHTML(node) ? name.toLowerCase() : name;
};

Xml.getLocalName = function(node)
{
    var name = node.localName;
    return isElementHTML(node) ? name.toLowerCase() : name;
};

// End tags for void elements are forbidden http://wiki.whatwg.org/wiki/HTML_vs._XHTML
var selfClosingTags = Xml.selfClosingTags =
{
    "meta": 1,
    "link": 1,
    "area": 1,
    "base": 1,
    "col": 1,
    "input": 1,
    "img": 1,
    "br": 1,
    "hr": 1,
    "param": 1,
    "embed": 1
};

var isSelfClosing = Xml.isSelfClosing = function(element)
{
    if (isElementSVG(element) || isElementMathML(element))
        return true;
    var tag = element.localName.toLowerCase();
    return (selfClosingTags.hasOwnProperty(tag));
};

Xml.getElementHTML = function(element)
{
    function toHTML(elt, html)
    {
        if (elt.nodeType == Node.ELEMENT_NODE)
        {
            if (Firebug.shouldIgnore(elt))
                return;

            var nodeName = getNodeName(elt);
            html.push('<', nodeName);

            for (var i = 0; i < elt.attributes.length; ++i)
            {
                var attr = elt.attributes[i];

                // Hide attributes set by Firebug
                // XXX Do we even have any?
                if (Str.hasPrefix(attr.localName, "firebug-"))
                    continue;

                // MathML
                if (Str.hasPrefix(attr.localName, "-moz-math"))
                {
                    // just hide for now
                    continue;
                }

                html.push(' ', attr.name, '="', Str.escapeForElementAttribute(attr.value), '"');
            }

            if (elt.firstChild)
            {
                html.push('>');

                for (var child = elt.firstChild; child; child = child.nextSibling)
                    toHTML(child, html);

                html.push('</', nodeName, '>');
            }
            else if (isElementSVG(elt) || isElementMathML(elt))
            {
                html.push('/>');
            }
            else if (isSelfClosing(elt))
            {
                html.push((isElementXHTML(elt))?'/>':'>');
            }
            else
            {
                html.push('></', nodeName, '>');
            }
        }
        else if (elt.nodeType == Node.TEXT_NODE)
        {
            html.push(Str.escapeForTextNode(elt.textContent));
        }
        else if (elt.nodeType == Node.CDATA_SECTION_NODE)
        {
            html.push('<![CDATA[', elt.nodeValue, ']]>');
        }
        else if (elt.nodeType == Node.COMMENT_NODE)
        {
            html.push('<!--', elt.nodeValue, '-->');
        }
    }

    var html = [];
    toHTML(element, html);
    return html.join("");
};

Xml.getElementXML = function(element)
{
    function toXML(elt, xml)
    {
        if (elt.nodeType == Node.ELEMENT_NODE)
        {
            if (Firebug.shouldIgnore(elt))
                return;

            var nodeName = getNodeName(elt);
            xml.push('<', nodeName);

            for (var i = 0; i < elt.attributes.length; ++i)
            {
                var attr = elt.attributes[i];

                // Hide attributes set by Firebug
                if (Str.hasPrefix(attr.localName, "firebug-"))
                    continue;

                // MathML
                if (Str.hasPrefix(attr.localName, "-moz-math"))
                {
                    // just hide for now
                    continue;
                }

                xml.push(' ', attr.nodeName, '="', Str.escapeForElementAttribute(attr.value),'"');
            }

            if (elt.firstChild)
            {
                xml.push('>');

                for (var child = elt.firstChild; child; child = child.nextSibling)
                    toXML(child, xml);

                xml.push('</', nodeName, '>');
            }
            else
                xml.push('/>');
        }
        else if (elt.nodeType == Node.TEXT_NODE)
            xml.push(elt.nodeValue);
        else if (elt.nodeType == Node.CDATA_SECTION_NODE)
            xml.push('<![CDATA[', elt.nodeValue, ']]>');
        else if (elt.nodeType == Node.COMMENT_NODE)
            xml.push('<!--', elt.nodeValue, '-->');
    }

    var xml = [];
    toXML(element, xml);
    return xml.join("");
};

// ************************************************************************************************
// Whitespace and Entity conversions

var domUtils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);

/**
 * Returns true if given document is based on a XML and so displaying pretty printed XML elements.
 */
Xml.isXMLPrettyPrint = function(context, win)
{
    if (!context)
        return;

    if (context.isXMLPrettyPrintDetected)
        return context.isXMLPrettyPrint;

    try
    {
        var doc = win ? win.document : context.window.document;
        if (!doc)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("lib.isXMLPrettyPrint; NO DOCUMENT", {win:win, context:context});
            return false;
        }
        if (!doc.documentElement)
            return false;

        var bindings = domUtils.getBindingURLs(doc.documentElement);
        for (var i = 0; i < bindings.length; i++)
        {
            var bindingURI = bindings.queryElementAt(i, Ci.nsIURI);
            if (FBTrace.DBG_CSS)
                FBTrace.sysout("bindingURL: " + i + " " + bindingURI.resolve(""));

            context.isXMLPrettyPrintDetected = true;
            return context.isXMLPrettyPrint = (bindingURI.resolve("") ===
                "chrome://global/content/xml/XMLPrettyPrint.xml");
        }
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("xml.isXMLPrettyPrint; EXCEPTION "+e, e);
    }
};

// ************************************************************************************************

Xml.isVisible = function(elt)
{
    if (isElementXUL(elt))
    {
        //FBTrace.sysout("isVisible elt.offsetWidth: "+elt.offsetWidth+" offsetHeight:"+
        // elt.offsetHeight+" localName:"+ elt.localName+" nameSpace:"+elt.nameSpaceURI+"\n");
        return (!elt.hidden && !elt.collapsed);
    }

    try
    {
        return !isElementHTMLOrXHTML(elt) ||
            elt.offsetWidth > 0 ||
            elt.offsetHeight > 0 ||
            elt.localName in invisibleTags;
    }
    catch (err)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("lib.isVisible; EXCEPTION " + err, err);
    }

    return false;
};

var invisibleTags = Xml.invisibleTags =
{
    "HTML": 1,
    "HEAD": 1,
    "TITLE": 1,
    "META": 1,
    "LINK": 1,
    "STYLE": 1,
    "SCRIPT": 1,
    "NOSCRIPT": 1,
    "BR": 1,
    "PARAM": 1,
    "COL": 1,

    "html": 1,
    "head": 1,
    "title": 1,
    "meta": 1,
    "link": 1,
    "style": 1,
    "script": 1,
    "noscript": 1,
    "br": 1,
    "param": 1,
    "col": 1,
    /*
    "window": 1,
    "browser": 1,
    "frame": 1,
    "tabbrowser": 1,
    "WINDOW": 1,
    "BROWSER": 1,
    "FRAME": 1,
    "TABBROWSER": 1,
    */
};

// ********************************************************************************************* //
// Registration

return Xml;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/xpath",
[
    "firebug/lib/string"
],
function(Str) {

"use strict";

// ********************************************************************************************* //
// Constants

var Xpath = {};

// ********************************************************************************************* //
// XPATH

/**
 * Gets an XPath for an element which describes its hierarchical location.
 */
Xpath.getElementXPath = function(element)
{
    if (element && element.id)
        return '//*[@id="' + element.id + '"]';
    else
        return Xpath.getElementTreeXPath(element);
};

Xpath.getElementTreeXPath = function(element)
{
    var paths = [];

    // Use nodeName (instead of localName) so namespace prefix is included (if any).
    for (; element && element.nodeType == Node.ELEMENT_NODE; element = element.parentNode)
    {
        var index = 0;
        for (var sibling = element.previousSibling; sibling; sibling = sibling.previousSibling)
        {
            // Ignore document type declaration.
            if (sibling.nodeType == Node.DOCUMENT_TYPE_NODE)
                continue;

            if (sibling.nodeName == element.nodeName)
                ++index;
        }

        var tagName = (element.prefix ? element.prefix + ":" : "") + element.localName;
        var pathIndex = (index ? "[" + (index+1) + "]" : "");
        paths.splice(0, 0, tagName + pathIndex);
    }

    return paths.length ? "/" + paths.join("/") : null;
};

Xpath.cssToXPath = function(rule)
{
    var regElement = /^([#.]?)([a-z0-9\\*_-]*)((\|)([a-z0-9\\*_-]*))?/i;
    var regAttr1 = /^\[([^\]]*)\]/i;
    var regAttr2 = /^\[\s*([^~=\s]+)\s*(~?=)\s*"([^"]+)"\s*\]/i;
    var regPseudo = /^:([a-z_-])+/i;
    var regCombinator = /^(\s*[>+\s])?/i;
    var regComma = /^\s*,/i;

    var index = 1;
    var parts = ["//", "*"];
    var lastRule = null;

    while (rule.length && rule != lastRule)
    {
        lastRule = rule;

        // Trim leading whitespace
        rule = Str.trim(rule);
        if (!rule.length)
            break;

        // Match the element identifier
        var m = regElement.exec(rule);
        if (m)
        {
            if (!m[1])
            {
                // XXXjoe Namespace ignored for now
                if (m[5])
                    parts[index] = m[5];
                else
                    parts[index] = m[2];
            }
            else if (m[1] == '#')
                parts.push("[@id='" + m[2] + "']");
            else if (m[1] == '.')
                parts.push("[contains(concat(' ',normalize-space(@class),' '), ' " + m[2] + " ')]");

            rule = rule.substr(m[0].length);
        }

        // Match attribute selectors
        m = regAttr2.exec(rule);
        if (m)
        {
            if (m[2] == "~=")
                parts.push("[contains(@" + m[1] + ", '" + m[3] + "')]");
            else
                parts.push("[@" + m[1] + "='" + m[3] + "']");

            rule = rule.substr(m[0].length);
        }
        else
        {
            m = regAttr1.exec(rule);
            if (m)
            {
                parts.push("[@" + m[1] + "]");
                rule = rule.substr(m[0].length);
            }
        }

        // Skip over pseudo-classes and pseudo-elements, which are of no use to us
        m = regPseudo.exec(rule);
        while (m)
        {
            rule = rule.substr(m[0].length);
            m = regPseudo.exec(rule);
        }

        // Match combinators
        m = regCombinator.exec(rule);
        if (m && m[0].length)
        {
            if (m[0].indexOf(">") != -1)
                parts.push("/");
            else if (m[0].indexOf("+") != -1)
                parts.push("/following-sibling::");
            else
                parts.push("//");

            index = parts.length;
            parts.push("*");
            rule = rule.substr(m[0].length);
        }

        m = regComma.exec(rule);
        if (m)
        {
            parts.push(" | ", "//", "*");
            index = parts.length-1;
            rule = rule.substr(m[0].length);
        }
    }

    var xpath = parts.join("");
    return xpath;
};

Xpath.getElementsBySelector = function(doc, css)
{
    var xpath = Xpath.cssToXPath(css);
    return Xpath.getElementsByXPath(doc, xpath);
};

Xpath.getElementsByXPath = function(doc, xpath)
{
    try
    {
        return Xpath.evaluateXPath(doc, xpath);
    }
    catch(ex)
    {
        return [];
    }
};

/**
 * Evaluates an XPath expression.
 *
 * @param {Document} doc
 * @param {String} xpath The XPath expression.
 * @param {Node} contextNode The context node.
 * @param {int} resultType
 *
 * @returns {*} The result of the XPath expression, depending on resultType :<br> <ul>
 *          <li>if it is XPathResult.NUMBER_TYPE, then it returns a Number</li>
 *          <li>if it is XPathResult.STRING_TYPE, then it returns a String</li>
 *          <li>if it is XPathResult.BOOLEAN_TYPE, then it returns a boolean</li>
 *          <li>if it is XPathResult.UNORDERED_NODE_ITERATOR_TYPE
 *              or XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, then it returns an array of nodes</li>
 *          <li>if it is XPathResult.ORDERED_NODE_SNAPSHOT_TYPE
 *              or XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE, then it returns an array of nodes</li>
 *          <li>if it is XPathResult.ANY_UNORDERED_NODE_TYPE
 *              or XPathResult.FIRST_ORDERED_NODE_TYPE, then it returns a single node</li>
 *          </ul>
 */
Xpath.evaluateXPath = function(doc, xpath, contextNode, resultType)
{
    if (contextNode === undefined)
        contextNode = doc;

    if (resultType === undefined)
        resultType = XPathResult.ANY_TYPE;

    var result = doc.evaluate(xpath, contextNode, null, resultType, null);

    switch (result.resultType)
    {
        case XPathResult.NUMBER_TYPE:
            return result.numberValue;

        case XPathResult.STRING_TYPE:
            return result.stringValue;

        case XPathResult.BOOLEAN_TYPE:
            return result.booleanValue;

        case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
        case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
            var nodes = [];
            for (var item = result.iterateNext(); item; item = result.iterateNext())
                nodes.push(item);
            return nodes;

        case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
        case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
            var nodes = [];
            for (var i = 0; i < result.snapshotLength; ++i)
                nodes.push(result.snapshotItem(i));
            return nodes;

        case XPathResult.ANY_UNORDERED_NODE_TYPE:
        case XPathResult.FIRST_ORDERED_NODE_TYPE:
            return result.singleNodeValue;
    }
};

Xpath.getRuleMatchingElements = function(rule, doc)
{
    var css = rule.selectorText;
    var xpath = Xpath.cssToXPath(css);
    return Xpath.getElementsByXPath(doc, xpath);
};

// ********************************************************************************************* //
// Registration

return Xpath;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/lib/xpcom",
[
],
function() {

"use strict";

// ********************************************************************************************* //
// Constants

var Ci = Components.interfaces;
var Cc = Components.classes;
var Cu = Components.utils;

var Xpcom = {};

// ********************************************************************************************* //
// XPCOM Utilities

/**
 * Returns required XPCOM service
 * @param {Object} cName Name of the service.
 * @param {Object} ifaceName Name of the required interface 
 */
Xpcom.CCSV = function(cName, ifaceName)
{
    try
    {
        // if fbs fails to load, the error can be Cc[cName] has no properties
        return Cc[cName].getService(Ci[ifaceName]);
    }
    catch (exc)
    {
        Cu.reportError(cName + "@" + ifaceName + " FAILED " + exc + " " +
            (exc.stack ? exc.stack : ""));

        if (!Cc[cName])
            Cu.reportError("Xpcom.CCSV; No Components.classes entry for " + cName);
        else if (!Ci[ifaceName])
            Cu.reportError("Xpcom.CCSV; No Components.interfaces entry for " + ifaceName);
    }
};

/**
 * Returns a new instance of required XPCOM component
 * @param {Object} cName Name of the component.
 * @param {Object} ifaceName Name of required interface.
 */
Xpcom.CCIN = function(cName, ifaceName)
{
    try
    {
        return Cc[cName].createInstance(Ci[ifaceName]);
    }
    catch (exc)
    {
        Cu.reportError(cName + "@" + ifaceName + " FAILED " + exc);

        if (!Cc[cName])
            Cu.reportError("Xpcom.CCIN; No Components.classes entry for " + cName);
        else if (!Ci[ifaceName])
            Cu.reportError("Xpcom.CCIN; No Components.interfaces entry for " + ifaceName);
    }
};

/**
 * Queries passed object for required interface.
 * @param {Object} obj Object to query an interface for.
 * @param {Object} iface Required interface.
 */
Xpcom.QI = function(obj, iface)
{
    try
    {
        return obj.QueryInterface(iface);
    }
    catch (exc)
    {
        Cu.reportError(cName + "@" + ifaceName + " FAILED " + exc);
    }
};

// ********************************************************************************************* //
// Registration

return Xpcom;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/fontViewer",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/xpcom",
    "firebug/lib/events",
    "firebug/chrome/window",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/string",
    "firebug/lib/fonts",
    "firebug/lib/url",
    "firebug/lib/http",
    "firebug/net/netUtils",
    "firebug/lib/options"
],
function(Module, Obj, Firebug, Domplate, Locale, Xpcom, Events, Win, Css, Dom, Str, Fonts, Url,
    Http, NetUtils, Options) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, TAG, DIV, SPAN, TD, TR, TABLE, TBODY, P, UL, LI, PRE, A, STYLE} = Domplate;

// List of font content types
var contentTypes =
[
    "application/x-woff",
    "application/x-font-woff",
    "application/x-ttf",
    "application/x-font-ttf",
    "font/ttf",
    "font/woff",
    "application/x-otf",
    "application/x-font-otf",
    "application/font-woff"
];

// ********************************************************************************************* //
// Model implementation

Firebug.FontViewerModel = Obj.extend(Module,
{
    dispatchName: "fontViewer",
    contentTypes: contentTypes,

    initialize: function()
    {
        Firebug.TabCacheModel.addListener(this);
        Firebug.NetMonitor.NetInfoBody.addListener(this);
        Firebug.registerUIListener(this);
    },

    shutdown: function()
    {
        Firebug.TabCacheModel.removeListener(this);
        Firebug.NetMonitor.NetInfoBody.removeListener(this);
        Firebug.unregisterUIListener(this);
    },

    /**
     * Checks whether the given file name and content are a valid font file
     * 
     * @param contentType: MIME type of the file
     * @param url: URL of the file
     * @param data: File contents
     * @return True, if the given data outlines a font file, otherwise false
     */
    isFont: function(contentType, url, data)
    {
        if (!contentType)
            return false;

        if (NetUtils.matchesContentType(contentType, contentTypes))
        {
            if (FBTrace.DBG_FONTS)
            {
                FBTrace.sysout("fontviewer.isFont; content type: "+contentType,
                    {url: url, data: data});
            }

            return true;
        }

        // Workaround for font responses without proper content type
        // Let's consider all responses starting with "wOFF" as font. In the worst
        // case there will be an exception when parsing. This means that no-font
        // responses (and post data) (with "wOFF") can be parsed unnecessarily,
        // which represents a little overhead, but this happens only if the request
        // is actually expanded by the user in the UI (Net & Console panel).
        var extension = Url.getFileExtension(url);
        var validExtension = /woff|otf|ttf/.exec(extension);
        if (validExtension && (!data || Str.hasPrefix(data, "wOFF") || Str.hasPrefix(data, "OTTO")))
        {
            if (FBTrace.DBG_FONTS)
            {
                FBTrace.sysout("fontviewer.isFont; Font without proper content type",
                    {url: url, data: data});
            }

            return true;
        }

        contentType = contentType.split(";")[0];
        contentType = Str.trim(contentType);
        return contentTypes[contentType];
    },

    /**
     * Parses the file and returns information about the font
     * 
     * @param file: File to parse
     * @return Font related information
     */
    parseFont: function(file)
    {
        return Fonts.getFontInfo(Firebug.currentContext, null, file.href);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // TabCacheModel listener

    shouldCacheRequest: function(request)
    {
        if (this.isFont(request.contentType, request.name))
            return true;

        return false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // NetInfoBody listener

    updateResponse: function(netInfoBox, file, context)
    {
        // Let listeners parse the font
        Events.dispatch(this.fbListeners, "onParseFont", [file]);

        // The font is still not there, try to parse most common cases
        if (!file.fontObject)
        {
            if (this.isFont(Http.safeGetContentType(file.request), file.href, file.responseText))
                file.fontObject = this.parseFont(file);
        }

        if (file.fontObject)
        {
            var responseTextBox = netInfoBox.getElementsByClassName("netInfoResponseText").item(0);
            this.Preview.render(responseTextBox, file, context);
            netInfoBox.responsePresented = true;

            if (FBTrace.DBG_FONTS)
                FBTrace.sysout("fontviewer.updateResponse", file);
        }
    }
});

// ********************************************************************************************* //

Firebug.FontViewerModel.Preview = domplate(
{
    bodyTag:
        DIV({"class": "fontInfo", _repObject: "$fontObject"},
            DIV({"class": "fontInfoGroup fontInfoGeneralInfoTitle"},
                SPAN(Locale.$STR("fontviewer.General Info"))
            ),
            TABLE({cellpadding: 0, cellspacing: 0},
                TBODY({"class": "fontInfoGeneralInfoBody", "role": "list",
                    "aria-label": Locale.$STR("fontviewer.General Info")})
            ),
            DIV({"class": "fontInfoGroup fontInfoMetaDataTitle",
                $collapsed: "$fontObject|noMetaData"},
                SPAN(Locale.$STR("fontviewer.Meta Data")),
                SPAN({"class": "fontInfoToggleView", onclick: "$onToggleView",
                    _sourceDisplayed: false, _rowName: "MetaData"},
                    Locale.$STR("fontviewer.view source")
                )
            ),
            TABLE({cellpadding: 0, cellspacing: 0},
                TBODY({"class": "fontInfoMetaDataBody", "role": "list",
                    "aria-label": Locale.$STR("fontviewer.Meta Data")})
            ),
            DIV({"class": "fontInfoGroup fontInfoPreviewTitle"},
                SPAN(Locale.$STR("fontviewer.Preview")),
                SPAN({"class": "fontInfoToggleView", onclick: "$onToggleView",
                  _lettersDisplayed: false, _rowName: "Preview"},
                  Locale.$STR("fontviewer.view characters")
                )
            ),
            DIV({"class": "fontInfoPreview"},
                STYLE({"class": "fontInfoPreviewStyle"}),
                DIV({"class": "fontInfoPreviewSample"},
                    FOR("style", "$styles",
                        P({"class": "$fontObject.CSSFamilyName|getFontFaceClass",
                            "style": "font-size: $style|getFontSize"},
                            SPAN({"class": "fontViewerFontSize"}, "$style"),
                            SPAN(Locale.$STR("fontviewer.pangram"))
                        )
                    )
                ),
                DIV({"class": "fontInfoPreviewCharacters"},
                    FOR("charType", "$charTypes",
                        P({"class": "$fontObject.CSSFamilyName|getFontFaceClass"},
                            "$charType|getCharacters"
                        )
                    )
                )
            )
        ),

    propDataTag:
        FOR("prop", "$props",
            TR({"role": "listitem", _repObject: "$prop.node"},
                TD({"class": "fontInfoPropName", "role": "presentation"},
                    SPAN("$prop|getPropName")
                ),
                TD({"class": "fontInfoPropValue", "role": "list", "aria-label": "$prop.name"},
                    TAG("$prop|getTag", {node: "$prop.node"})
                )
            )
        ),

    sourceTag:
        TR({"role": "presentation"},
            TD({colspan: 2, "role": "presentation"},
                PRE({"class": "source"})
            )
        ),

    translatedInfoTag:
        DIV({"class": "fontInfoTranslatedInfo"},
            DIV({"class": "fontInfoLangInfo"},
                FOR("lang", "$node|getLanguages",
                    A({"class": "fontInfoLangTab", $selected: "$lang.selected", role: "tab",
                        onclick: "$onTranslatedLangChange"}, "$lang.name")
                )
            ),
            DIV({"class": "fontInfoTranslatedContent"},
                "$node|getTranslatedText"
            )
        ),

    vendorTag:
        TAG("$node|getLinkedTextTag", {node: "$node"}),

    licenseTag:
        DIV({"class": "fontInfoLicense"},
            TAG("$node|getLinkedTextTag", {node: "$node"}),
            TAG("$translatedInfoTag", {node: "$node"})
        ),

    creditsTag:
        UL({"class": "fontInfoCredits"},
            FOR("credit", "$node|getCredits",
                LI(
                    TAG("$credit|getLinkedTextTag", {node: "$credit"}),
                    " ",
                    SPAN({"class": "fontInfoCreditsRole"}, "$credit|getRole")
                )
            )
        ),

    linkTag:
        A({"class": "fontInfoLink", href: "$node|getUrl", onclick: "$onOpenUrl"},
            "$node|getLinkName"),

    textTag:
        SPAN("$node|getText"),

    /**
     * Handles toggling of the font information display
     * 
     * @param event: Click event
     */
    onToggleView: function(event)
    {
        var target = event.target;
        var fontInfo = Dom.getAncestorByClass(target, "fontInfo");
        var fontObject = fontInfo.repObject;

        switch (target.rowName)
        {
            case "MetaData":
                if (target.sourceDisplayed)
                {
                    this.insertMetaDataFormatted(fontInfo, fontObject.metadata);
                    target.textContent = Locale.$STR("fontviewer.view source");
                }
                else
                {
                    this.insertMetaDataSource(fontInfo, fontObject.metadata);
                    target.textContent = Locale.$STR("fontviewer.pretty print");
                }
                target.sourceDisplayed = !target.sourceDisplayed;
                break;

            case "Preview":
                var sample = fontInfo.getElementsByClassName("fontInfoPreviewSample").item(0);
                var chars = fontInfo.getElementsByClassName("fontInfoPreviewCharacters").item(0);
                if (target.lettersDisplayed)
                {
                    sample.style.display = "block";
                    chars.style.display = "none";
                    target.textContent = Locale.$STR("fontviewer.view characters");
                }
                else
                {
                    sample.style.display = "none";
                    chars.style.display = "block";
                    target.textContent = Locale.$STR("fontviewer.view sample");
                }
                target.lettersDisplayed = !target.lettersDisplayed;
                break;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Meta data

    /**
     * Checks, whether the font contains meta data
     * 
     * @param fontObject: Font related information
     * @return True, if font contains meta data, otherwise false
     */
    noMetaData: function(fontObject)
    {
        return fontObject.metadata == "";
    },

    /**
     * Selects the corresponding Domplate template related to a given meta data property
     * 
     * @param prop: Meta data property
     * @return Domplate template related to the property
     */
    getTag: function(prop)
    {
        return prop.tag ? prop.tag : Firebug.FontViewerModel.Preview.textTag;
    },

    /**
     * Returns the translated property name
     * 
     * @param prop: Meta data property
     * @return Translated name of the property
     */
    getPropName: function(prop)
    {
        return prop.name ? prop.name : Locale.$STR("fontviewer."+prop.node.nodeName);
    },

    /**
     * Returns the text of a meta data property or a string
     * 
     * @param value: Meta data property or string
     * @return String representing the text related to the property
     */
    getText: function(value)
    {
        if (typeof(value) == "string")
            return value;

        var name = value.getAttribute("id") || value.getAttribute("name");
        if (name)
            return name;

        return value.textContent;
    },

    /**
     * Opens a URL in a new browser tab
     * 
     * @param event: Click event
     */
    onOpenUrl: function(event)
    {
        Win.openNewTab(event.target.getAttribute("href"));
        Events.cancelEvent(event);
    },

    /**
     * Returns either text or a linked text depending on a URL to be present of a
     * meta data property
     * 
     * @param node: Meta data property node
     * @return Text or linked text
     */
    getLinkedTextTag: function(node)
    {
        if (this.getUrl(node))
            return Firebug.FontViewerModel.Preview.linkTag;
        else
            return Firebug.FontViewerModel.Preview.textTag;
    },

    /**
     * Returns the URL of a meta data property
     * 
     * @param node: Meta data property node
     * @return URL of the meta data property
     */
    getUrl: function(node)
    {
        return node.getAttribute("url");
    },

    /**
     * Returns the name of a link related to a meta data property
     * 
     * @param node: Meta data property node
     * @return Link name of the meta data property
     */
    getLinkName: function(node)
    {
        return node.getAttribute("id") || node.getAttribute("name") || node.getAttribute("url");
    },

    /**
     * Returns an array of font credits
     * 
     * @param node: Meta data property node
     * @return Credits
     */
    getCredits: function(node)
    {
        return Array.prototype.slice.call(node.children);
    },

    /**
     * Returns the role of a contributor of the font
     * 
     * @param node: Meta data property node
     * @return Contributor role
     */
    getRole: function(node)
    {
        var role = node.getAttribute("role");
        return role ? "("+role+")" : "";
    },

    /**
     * Returns the available languages of a translated meta data property text
     * 
     * @param node: Meta data property node
     * @return Array of languages
     */
    getLanguages: function(node)
    {
        var texts = Array.prototype.slice.call(node.getElementsByTagName("text"));
        var langs = [];
        var defaultLang = this.getDefaultLang(node);
        texts.forEach(function(e, i, a) {
            var lang = e.getAttribute("lang");
            langs.push({name: lang, selected: lang == defaultLang});
        });

        return langs;
    },

    /**
     * Returns the default language of a meta data property
     * 
     * @param node: Meta data property node
     * @return Language
     */
    getDefaultLang: function(node)
    {
        var localeDomain = "general.useragent";
        var localeName = "locale";
        var localeValue = Options.getPref(localeDomain, localeName);

        if (node.querySelector("text[lang="+localeValue+"]"))
            return localeValue;

        if (node.querySelector("text[lang=en]"))
            return "en";

        if (node.firstElementChild)
            return node.firstElementChild.getAttribute("lang");

        return null;
    },

    /**
     * Returns the translated text of meta data property
     * 
     * @param node: Meta data property node
     * @param lang: Language of the text
     * @return Translated text
     */
    getTranslatedText: function(node, lang)
    {
        if (!lang)
            lang = this.getDefaultLang(node);

        if (lang)
        {
            var element = node.querySelector("text[lang="+lang+"]");
            if (element)
                return element.textContent;
        }

        return "";
    },

    /**
     * Displays the XML source of the meta data
     * 
     * @param fontInfo: Font related information
     * @param source: XML source of the meta data
     */
    insertMetaDataSource: function(fontInfo, source)
    {
        var tbody = fontInfo.getElementsByClassName("fontInfoMetaDataBody").item(0);
        var node = this.sourceTag.replace({}, tbody);
        var sourceNode = node.getElementsByClassName("source").item(0);
        Str.insertWrappedText(source, sourceNode);
    },

    /**
     * Displays the meta data information formatted
     * 
     * @param fontInfo: Font related information
     * @param source: XML source of the meta data
     */
    insertMetaDataFormatted: function(fontInfo, source)
    {
        var tbody = fontInfo.getElementsByClassName("fontInfoMetaDataBody").item(0);
        var parser = Xpcom.CCIN("@mozilla.org/xmlextras/domparser;1", "nsIDOMParser");
        var doc = parser.parseFromString(source, "text/xml");
        var root = doc.documentElement;

        if (FBTrace.DBG_FONTS)
            FBTrace.sysout("fontviewer.insertMetaDataFormatted; XML", doc);

        Dom.clearNode(tbody);

        var props = [];
        var propValueTemplates = {
            vendor: Firebug.FontViewerModel.Preview.vendorTag,
            credits: Firebug.FontViewerModel.Preview.creditsTag,
            description: Firebug.FontViewerModel.Preview.translatedInfoTag,
            copyright: Firebug.FontViewerModel.Preview.translatedInfoTag,
            trademark: Firebug.FontViewerModel.Preview.translatedInfoTag,
            license: Firebug.FontViewerModel.Preview.licenseTag
        };

        for (var i=0; i<root.children.length; i++)
        {
            var child = root.children[i];
            props.push({tag: propValueTemplates[child.nodeName], node: child});
        }

        if (FBTrace.DBG_FONTS)
            FBTrace.sysout("fontviewer.insertMetaDataFormatted; props", props);

        tbody.repObject = root;
        Firebug.FontViewerModel.Preview.propDataTag.insertRows({props: props}, tbody);
    },

    /**
     * Handles text language changes
     * 
     * @param event: Click event
     */
    onTranslatedLangChange: function(event)
    {
        var target = event.target;
        var translatedInfo = Dom.getAncestorByClass(target, "fontInfoTranslatedInfo");
        var selected = translatedInfo.getElementsByClassName("selected").item(0);
        Css.removeClass(selected, "selected");
        Css.setClass(target, "selected");

        var content = translatedInfo.getElementsByClassName("fontInfoTranslatedContent").item(0);
        content.textContent = this.getTranslatedText(Firebug.getRepObject(target),
            target.textContent);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Preview

    /**
     * Returns the CSS font-face class name
     * 
     * @param cssFamilyName: CSS name of the font family
     * @return Name of the font-face class
     */
    getFontFaceClass: function(cssFamilyName)
    {
        return "fontFacePreview"+cssFamilyName.replace(/[^a-z0-9_]/ig, "");
    },

    /**
     * Returns the font size CSS
     * 
     * @param size: Font size
     * @return Font size CSS
     */
    getFontSize: function(size)
    {
        return size+"pt";
    },

    /**
     * Returns the characters used for the font preview
     * 
     * @param charType: Type of characters to return
     * @return Preview characters
     */
    getCharacters: function(charType)
    {
        switch (charType)
        {
            case "lowercase":
                return "abcdefghijklmnopqrstuvwxyz";

            case "uppercase":
                return "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

            case "numbersAndSpecialChars":
                return "0123456789.:,;(\"*!?')";
        }
    },

    /**
     * Returns the CSS for the @font-face CSS
     * 
     * @param fontObject: Font related information
     * @return @font-face CSS
     */
    getFontFaceCss: function(fontObject)
    {
        var fontFaceClass = this.getFontFaceClass(fontObject.CSSFamilyName);
        return fontObject.rule.cssText.replace(/url\(.*?\)/g, "url("+fontObject.URI+")")+
            " ."+fontFaceClass+" {font-family: \""+fontObject.CSSFamilyName+"\";}";
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    /**
     * Displays general information about the font
     * 
     * @param body: Node containing the font information display
     * @param fontObject: Font related information
     */
    insertGeneralInfo: function(body, fontObject)
    {

        var fontInfo = body.getElementsByClassName("fontInfo").item(0);
        var tbody = fontInfo.getElementsByClassName("fontInfoGeneralInfoBody").item(0);

        Dom.clearNode(tbody);

        if (fontObject)
        {
            var props =
            [
                {name: Locale.$STR("fontviewer.Name"), node: fontObject.name}, 
                {name: Locale.$STR("fontviewer.CSS Family Name"), node: fontObject.CSSFamilyName},
                {name: Locale.$STR("fontviewer.Format"), node: fontObject.format}
            ];
            Firebug.FontViewerModel.Preview.propDataTag.insertRows({props: props}, tbody);
        }
    },

    /**
     * Renders the font display
     * 
     * @param body: Node containing the font information display
     * @param file: Font file to be displayed
     * @param context: Related context
     */
    render: function(body, file, context)
    {
        var fontObject = file.fontObject;
        if (!fontObject)
            return;

        var styles = [10, 14, 18];
        var charTypes = ["lowercase", "uppercase", "numbersAndSpecialChars"];

        var node = this.bodyTag.replace({fontObject: fontObject, styles: styles,
            charTypes: charTypes}, body, this);

        var styleNode = node.getElementsByClassName("fontInfoPreviewStyle").item(0);
        styleNode.textContent = this.getFontFaceCss(fontObject);

        this.insertGeneralInfo(body, file.fontObject);

        if (fontObject.metadata != "")
            this.insertMetaDataFormatted(body, fontObject.metadata);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.FontViewerModel);

return Firebug.FontViewerModel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/httpActivityObserver",
[
    "firebug/chrome/module",
    "firebug/lib/xpcom",
    "firebug/lib/object",
    "firebug/lib/trace",
    "firebug/lib/http",
    "firebug/chrome/window",
    "firebug/net/netProgress",
    "firebug/net/netUtils"
],
function(Module, Xpcom, Obj, FBTrace, Http, Win, NetProgress, NetUtils) {

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;
var Cr = Components.results;

var nsIHttpActivityObserver = Ci.nsIHttpActivityObserver;
var nsISocketTransport = Ci.nsISocketTransport;

var activeRequests = [];

// ********************************************************************************************* //
// Callbacks

var startFile = NetProgress.prototype.startFile;
var requestedHeaderFile = NetProgress.prototype.requestedHeaderFile;
var respondedHeaderFile = NetProgress.prototype.respondedHeaderFile;
var requestedFile = NetProgress.prototype.requestedFile;
var respondedFile = NetProgress.prototype.respondedFile;
var bodySentFile = NetProgress.prototype.bodySentFile;
var responseStartedFile = NetProgress.prototype.responseStartedFile;
var respondedCacheFile = NetProgress.prototype.respondedCacheFile;
var connectingFile = NetProgress.prototype.connectingFile;
var connectedFile = NetProgress.prototype.connectedFile;
var waitingForFile = NetProgress.prototype.waitingForFile;
var sendingFile = NetProgress.prototype.sendingFile;
var receivingFile = NetProgress.prototype.receivingFile;
var responseCompletedFile = NetProgress.prototype.responseCompletedFile;
var closedFile = NetProgress.prototype.closedFile;
var resolvingFile = NetProgress.prototype.resolvingFile;
var resolvedFile = NetProgress.prototype.resolvedFile;
var windowPaint = NetProgress.prototype.windowPaint;
var timeStamp = NetProgress.prototype.timeStamp;
var windowLoad = NetProgress.prototype.windowLoad;
var contentLoad = NetProgress.prototype.contentLoad;

// ********************************************************************************************* //
// Activity Observer

var NetHttpActivityObserver =
{
    registered: false,

    registerObserver: function()
    {
        if (!Ci.nsIHttpActivityDistributor)
            return;

        if (this.registered)
            return;

        var distributor = this.getActivityDistributor();
        if (!distributor)
            return;

        distributor.addObserver(this);
        this.registered = true;

        if (FBTrace.DBG_ACTIVITYOBSERVER || FBTrace.DBG_OBSERVERS)
        {
            // import fbObserverService
            Components.utils.import("resource://firebug/observer-service.js");
            this.trackId = fbObserverService.track(Components.stack);
            FBTrace.sysout("activityObserver.registerObserver;"+this.trackId+" this.registered: "+this.registered);
        }

    },

    unregisterObserver: function()
    {
        if (!Ci.nsIHttpActivityDistributor)
            return;

        if (!this.registered)
            return;

        var distributor = this.getActivityDistributor();
        if (!distributor)
            return;

        distributor.removeObserver(this);
        this.registered = false;

        if (FBTrace.DBG_ACTIVITYOBSERVER || FBTrace.DBG_OBSERVERS)
        {
            // import fbObserverService
            Components.utils.import("resource://firebug/observer-service.js");
            fbObserverService.untrack(this.trackId);
            FBTrace.sysout("activityObserver.unregisterObserver;"+this.trackId+" this.registered: "+this.registered);
        }

    },

    getActivityDistributor: function()
    {
        if (!this.activityDistributor)
        {
            try
            {
                var hadClass = Cc["@mozilla.org/network/http-activity-distributor;1"];
                if (!hadClass)
                    return null;

                this.activityDistributor = hadClass.getService(Ci.nsIHttpActivityDistributor);

                if (FBTrace.DBG_NET)
                    FBTrace.sysout("net.NetHttpActivityObserver; Activity Observer Registered");
            }
            catch (err)
            {
                if (FBTrace.DBG_NET || FBTrace.DBG_ERRORS)
                    FBTrace.sysout("net.NetHttpActivityObserver; Activity Observer EXCEPTION", err);
            }
        }
        return this.activityDistributor;
    },

    /* nsIActivityObserver */
    observeActivity: function(httpChannel, activityType, activitySubtype, timestamp,
        extraSizeData, extraStringData)
    {
        try
        {
            if (httpChannel instanceof Ci.nsIHttpChannel)
                this.observeRequest(httpChannel, activityType, activitySubtype, timestamp,
                    extraSizeData, extraStringData);
        }
        catch (exc)
        {
            if ( (typeof(FBTrace) !== undefined) && FBTrace && FBTrace.DBG_ERRORS)  // then we are in some sane scope
                FBTrace.sysout("net.observeActivity: EXCEPTION "+exc, exc);
        }
    },

    observeRequest: function(httpChannel, activityType, activitySubtype, timestamp,
        extraSizeData, extraStringData)
    {
        var win = Http.getWindowForRequest(httpChannel);
        if (!win)
        {
            var index = activeRequests.indexOf(httpChannel);
            if (index == -1)
                return;

            if (!(win = activeRequests[index+1]))
                return;
        }

        var context = Firebug.connection.getContextByWindow(win);
        var tabId = Win.getWindowProxyIdForWindow(win);
        if (!(tabId && win))
            return;

        var networkContext = Firebug.NetMonitor.contexts[tabId];
        if (!networkContext)
            networkContext = context ? context.netProgress : null;

        if (!networkContext)
            return;

        var time = new Date();
        time.setTime(timestamp/1000);

        if (FBTrace.DBG_ACTIVITYOBSERVER)
        {
            FBTrace.sysout("activityObserver.observeActivity; " +
                NetUtils.getTimeLabel(time) + ", " +
                Http.safeGetRequestName(httpChannel) + ", " +
                getActivityTypeDescription(activityType) + ", " +
                getActivitySubtypeDescription(activitySubtype) + ", " +
                extraSizeData,
                extraStringData);
        }

        time = time.getTime();

        if (activityType == nsIHttpActivityObserver.ACTIVITY_TYPE_HTTP_TRANSACTION)
        {
            if (activitySubtype == nsIHttpActivityObserver.ACTIVITY_SUBTYPE_REQUEST_HEADER)
            {
                activeRequests.push(httpChannel);
                activeRequests.push(win);

                var isXHR = Http.isXHR(httpChannel);
                networkContext.post(requestedHeaderFile, [httpChannel, time, win, isXHR, extraStringData]);
            }
            else if (activitySubtype == nsIHttpActivityObserver.ACTIVITY_SUBTYPE_TRANSACTION_CLOSE)
            {
                var index = activeRequests.indexOf(httpChannel);
                activeRequests.splice(index, 2);

                networkContext.post(closedFile, [httpChannel, time]);
            }
            else if (activitySubtype == nsIHttpActivityObserver.ACTIVITY_SUBTYPE_RESPONSE_HEADER)
                networkContext.post(respondedHeaderFile, [httpChannel, time, extraStringData]);
            else if (activitySubtype == nsIHttpActivityObserver.ACTIVITY_SUBTYPE_REQUEST_BODY_SENT)
                networkContext.post(bodySentFile, [httpChannel, time]);
            else if (activitySubtype == nsIHttpActivityObserver.ACTIVITY_SUBTYPE_RESPONSE_START)
                networkContext.post(responseStartedFile, [httpChannel, time]);
            else if (activitySubtype == nsIHttpActivityObserver.ACTIVITY_SUBTYPE_RESPONSE_COMPLETE)
                networkContext.post(responseCompletedFile, [httpChannel, time, extraSizeData]);
        }
        else if (activityType == nsIHttpActivityObserver.ACTIVITY_TYPE_SOCKET_TRANSPORT)
        {
            if (activitySubtype == nsISocketTransport.STATUS_RESOLVING)
                networkContext.post(resolvingFile, [httpChannel, time]);
            //else if (activitySubtype == nsISocketTransport.STATUS_RESOLVED)
            //    networkContext.post(resolvedFile, [httpChannel, time]);
            else if (activitySubtype == nsISocketTransport.STATUS_CONNECTING_TO)
                networkContext.post(connectingFile, [httpChannel, time]);
            else if (activitySubtype == nsISocketTransport.STATUS_CONNECTED_TO)
                networkContext.post(connectedFile, [httpChannel, time]);
            else if (activitySubtype == nsISocketTransport.STATUS_SENDING_TO)
                networkContext.post(sendingFile, [httpChannel, time, extraSizeData]);
            else if (activitySubtype == nsISocketTransport.STATUS_WAITING_FOR)
                networkContext.post(waitingForFile, [httpChannel, time]);
            else if (activitySubtype == nsISocketTransport.STATUS_RECEIVING_FROM)
                networkContext.post(receivingFile, [httpChannel, time, extraSizeData]);
        }
    },

    /* nsISupports */
    QueryInterface: function(iid)
    {
        if (iid.equals(Ci.nsISupports) ||
            iid.equals(Ci.nsIActivityObserver)) {
            return this;
         }

        throw Cr.NS_ERROR_NO_INTERFACE;
    }
};

// ********************************************************************************************* //
// Activity Observer Tracing Support

function getActivityTypeDescription(a)
{
    switch (a)
    {
    case nsIHttpActivityObserver.ACTIVITY_TYPE_SOCKET_TRANSPORT:
        return "ACTIVITY_TYPE_SOCKET_TRANSPORT";
    case nsIHttpActivityObserver.ACTIVITY_TYPE_HTTP_TRANSACTION:
        return "ACTIVITY_TYPE_HTTP_TRANSACTION";
    default:
        return a;
    }
}

function getActivitySubtypeDescription(a)
{
    switch (a)
    {
    case nsIHttpActivityObserver.ACTIVITY_SUBTYPE_REQUEST_HEADER:
        return "ACTIVITY_SUBTYPE_REQUEST_HEADER";
    case nsIHttpActivityObserver.ACTIVITY_SUBTYPE_REQUEST_BODY_SENT:
          return "ACTIVITY_SUBTYPE_REQUEST_BODY_SENT";
    case nsIHttpActivityObserver.ACTIVITY_SUBTYPE_RESPONSE_START:
        return "ACTIVITY_SUBTYPE_RESPONSE_START";
    case nsIHttpActivityObserver.ACTIVITY_SUBTYPE_RESPONSE_HEADER:
        return "ACTIVITY_SUBTYPE_RESPONSE_HEADER";
    case nsIHttpActivityObserver.ACTIVITY_SUBTYPE_RESPONSE_COMPLETE:
        return "ACTIVITY_SUBTYPE_RESPONSE_COMPLETE";
    case nsIHttpActivityObserver.ACTIVITY_SUBTYPE_TRANSACTION_CLOSE:
        return "ACTIVITY_SUBTYPE_TRANSACTION_CLOSE";

    case nsISocketTransport.STATUS_RESOLVING:
        return "STATUS_RESOLVING";
    case nsISocketTransport.STATUS_RESOLVED:
        return "STATUS_RESOLVED";
    case nsISocketTransport.STATUS_CONNECTING_TO:
        return "STATUS_CONNECTING_TO";
    case nsISocketTransport.STATUS_CONNECTED_TO:
        return "STATUS_CONNECTED_TO";
    case nsISocketTransport.STATUS_SENDING_TO:
        return "STATUS_SENDING_TO";
    case nsISocketTransport.STATUS_WAITING_FOR:
        return "STATUS_WAITING_FOR";
    case nsISocketTransport.STATUS_RECEIVING_FROM:
        return "STATUS_RECEIVING_FROM";

    default:
        return a;
    }
}

// ********************************************************************************************* //

// https://bugzilla.mozilla.org/show_bug.cgi?id=669730
var HttpActivityObserverModule = Obj.extend(Module,
{
    dispatchName: "HttpActivityObserverModule",

    destroyContext: function(context)
    {
        this.cleanUp(context.window);
    },

    unwatchWindow: function(context, win)
    {
        this.cleanUp(win);
    },

    cleanUp: function(win)
    {
        for (var i=0; i<activeRequests.length; i+=2)
        {
            if (activeRequests[i+1] == win)
            {
                activeRequests.splice(i, 2);
                i -= 2;
            }
        }
    },

    shutdown: function()
    {
        // destroy NetHttpActivityObserver
        NetHttpActivityObserver.unregisterObserver();
        NetHttpActivityObserver.registerObserver = function() {};
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(HttpActivityObserverModule);

return NetHttpActivityObserver;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/jsonViewer",
[
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/http",
    "firebug/lib/string",
    "firebug/lib/json",
    "firebug/dom/toggleBranch",
    "firebug/lib/system",
    "firebug/dom/domPanel",
    "firebug/chrome/reps"
],
function(Module, Obj, Firebug, Domplate, Locale, Events, Css, Dom, Http, Str, Json,
    ToggleBranch, System) {

"use strict";

// ********************************************************************************************* //
// Constants

var {domplate, SPAN, DIV} = Domplate;

// List of JSON content types.
var contentTypes =
{
    "text/plain": 1,
    "text/javascript": 1,
    "text/x-javascript": 1,
    "text/json": 1,
    "text/x-json": 1,
    "application/json": 1,
    "application/x-json": 1,
    "application/javascript": 1,
    "application/x-javascript": 1,
    "application/json-rpc": 1
};

// ********************************************************************************************* //
// Model implementation

Firebug.JSONViewerModel = Obj.extend(Module,
{
    dispatchName: "jsonViewer",
    contentTypes: contentTypes,

    initialize: function()
    {
        Firebug.NetMonitor.NetInfoBody.addListener(this);
        Firebug.registerUIListener(this);
    },

    shutdown: function()
    {
        Firebug.NetMonitor.NetInfoBody.removeListener(this);
        Firebug.unregisterUIListener(this);
    },

    onContextMenu: function(items, object, target, context, panel, popup)
    {
        if (panel.name != "net" && panel.name != "console")
            return;

        var memberLabel = Dom.getAncestorByClass(target, "memberLabel");

        if (!memberLabel)
            return;

        var row = Dom.getAncestorByClass(target, "memberRow");
        if (!row || !row.domObject.value)
            return;

        items.push({
           id: "fbNetCopyJSON",
           nol10n: true,
           label: Locale.$STRF("net.jsonviewer.Copy_JSON", [row.domObject.name]),
           command: Obj.bindFixed(this.copyJsonResponse, this, row)
        });
    },

    copyJsonResponse:function(row)
    {
        var value = JSON.stringify(row.domObject.value);
        if (value)
            System.copyToClipboard(value);
    },

    initTabBody: function(infoBox, file)
    {
        if (FBTrace.DBG_JSONVIEWER)
            FBTrace.sysout("jsonviewer.initTabBody", {infoBox: infoBox, file: file});

        // Let listeners to parse the JSON.
        Events.dispatch(this.fbListeners, "onParseJSON", [file]);

        // The JSON is still no there, try to parse most common cases.
        if (!file.jsonObject)
        {
            if (this.isJSON(Http.safeGetContentType(file.request), file.responseText))
                file.jsonObject = this.parseJSON(file);
        }

        // The jsonObject is created so, the JSON tab can be displayed.
        if (file.jsonObject)
        {
            Firebug.NetMonitor.NetInfoBody.appendTab(infoBox, "JSON",
                Locale.$STR("jsonviewer.tab.JSON"));

            if (FBTrace.DBG_JSONVIEWER)
                FBTrace.sysout("jsonviewer.initTabBody; JSON object available " +
                    (typeof(file.jsonObject) != "undefined"), file.jsonObject);
        }
    },

    isJSON: function(contentType, data)
    {
        // Workaround for JSON responses without proper content type
        // Let's consider all responses starting with "{" as JSON. In the worst
        // case there will be an exception when parsing. This means that no-JSON
        // responses (and post data) (with "{") can be parsed unnecessarily,
        // which represents a little overhead, but this happens only if the request
        // is actually expanded by the user in the UI (Net & Console panels).
        // Do a manual string search instead of checking (data.strip()[0] === "{")
        // to improve performance/memory usage.
        var len = data ? data.length : 0;
        for (var i = 0; i < len; i++)
        {
            var ch = data.charAt(i);
            if (ch === "{")
                return true;
            if (ch === " " || ch === "\t" || ch === "\n" || ch === "\r")
                continue;
            break;
        }

        if (!contentType)
            return false;

        contentType = contentType.split(";")[0];
        contentType = Str.trim(contentType);
        return contentTypes[contentType];
    },

    // Update listener for TabView
    updateTabBody: function(infoBox, file, context)
    {
        var tab = infoBox.selectedTab;
        var tabBody = infoBox.getElementsByClassName("netInfoJSONText").item(0);
        if (!Css.hasClass(tab, "netInfoJSONTab") || tabBody.updated)
            return;

        if (FBTrace.DBG_JSONVIEWER)
            FBTrace.sysout("jsonviewer.updateTabBody", infoBox);

        tabBody.updated = true;
        tabBody.context = context;

        this.Preview.render(tabBody, file, context);
    },

    parseJSON: function(file)
    {
        var jsonString = new String(file.responseText);
        return Json.parseJSONString(jsonString, "http://" + file.request.originalURI.host);
    },
});

// ********************************************************************************************* //

Firebug.JSONViewerModel.Preview = domplate(
{
    bodyTag:
        DIV({"class": "jsonPreview", _repObject: "$file"},
            DIV({"class": "title"},
                DIV({"class": "sortLink", onclick: "$onSort", $sorted: "$sorted"},
                    SPAN({"class": "doSort"}, Locale.$STR("jsonviewer.sort")),
                    SPAN({"class": "doNotSort"}, Locale.$STR("jsonviewer.do not sort"))
                )
            ),
            DIV({"class": "jsonPreviewBody"})
        ),

    onSort: function(event)
    {
        var target = event.target;
        var sortLink = Dom.getAncestorByClass(target, "sortLink");
        if (!sortLink)
            return;

        Events.cancelEvent(event);

        Css.toggleClass(sortLink, "sorted");
        Firebug.Options.set("sortJsonPreview", !Firebug.sortJsonPreview);

        var preview = Dom.getAncestorByClass(sortLink, "jsonPreview");
        var body = Dom.getAncestorByClass(sortLink, "netInfoJSONText");
        if (!body)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("jsonViewer.onSort; ERROR body is null");
            return;
        }

        this.render(body, preview.repObject, body.context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    render: function(body, file, context)
    {
        if (!file.jsonObject)
            return;

        if (!body.jsonTree)
            body.jsonTree = new JSONTreePlate();

        var input = {file: file, sorted: Firebug.sortJsonPreview};
        var parentNode = this.bodyTag.replace(input, body, this);
        parentNode = parentNode.getElementsByClassName("jsonPreviewBody").item(0);

        body.jsonTree.render(file.jsonObject, parentNode, context);
    }
});

// ********************************************************************************************* //

function JSONTreePlate()
{
    // Used by Firebug.DOMPanel.DirTable domplate.
    this.toggles = new ToggleBranch.ToggleBranch();
}

// xxxHonza: this object is *not* a panel (using Firebug terminology), but
// there is no other way how to subclass the DOM Tree than to derive from the DOMBasePanel.
// Better solution would be to have a middle object between DirTablePlate and DOMBasePanel.
JSONTreePlate.prototype = Obj.extend(Firebug.DOMBasePanel.prototype,
{
    dispatchName: "JSONTreePlate",

    render: function(jsonObject, parentNode, context)
    {
        try
        {
            this.panelNode = parentNode;
            this.context = context;

            var members = this.getMembers(jsonObject, 0);
            this.expandMembers(members, this.toggles, 0, 0);
            this.showMembers(members, false, false);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS || FBTrace.DBG_JSONVIEWER)
                FBTrace.sysout("jsonviewer.render; EXCEPTION", err);
        }
    },

    getMembers: function(object, level)
    {
        if (!level)
            level = 0;

        var members = [];

        for (var name in object)
        {
            var val = object[name];
            this.addMember(object, "user", members, name, val, level);
        }

        function sortName(a, b) { return a.name > b.name ? 1 : -1; }

        // Sort only if it isn't an array (issue 4382).
        if (Firebug.sortJsonPreview && !Array.isArray(object, this.context.window))
            members.sort(sortName);

        return members;
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.JSONViewerModel);

return Firebug.JSONViewerModel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/netCacheReader",
[
    "firebug/firebug",
    "firebug/chrome/module",
    "firebug/lib/object",
    "firebug/lib/locale",
    "firebug/lib/trace",
    "firebug/lib/dom",
    "firebug/lib/css",
    "firebug/net/netMonitor",
    "firebug/net/netUtils",
    "firebug/lib/domplate",
],
function(Firebug, Module, Obj, Locale, FBTrace, Dom, Css, NetMonitor, NetUtils, Domplate) {

"use strict"

// ********************************************************************************************* //
// Constants

var Cc = Components.classes;
var Ci = Components.interfaces;
var Cr = Components.results;

var CacheService = Cc["@mozilla.org/network/cache-service;1"];

var cacheSession = null;
var autoFetchDelay = 1000;

// ********************************************************************************************* //
// Domplate Templates

var {TABLE, TBODY} = Domplate;

// Used to generate basic structure of the 'Cache' tab that is available within request
// info body (visible when a request is expanded in the Net panel).
var cacheBodyTag =
    TABLE({"class": "netInfoCacheTable", cellpadding: 0, cellspacing: 0, "role": "presentation"},
        TBODY({"role": "list", "aria-label": Locale.$STR("Cache")})
    );

// ********************************************************************************************* //
// Model implementation

/**
 * @module Responsible for fetching given URL entry from the browser cache. The Net panel
 * displays such info for requests that are stored in the cache.
 *
 * The cache descriptor is fetched asynchronously when the user expands a requests row
 * within the Net panel. Note that opening the cache descriptor during the page load can
 * influence the caching logic (see issue 6385).
 */
var NetCacheReader = Obj.extend(Module,
/** @lends NetCacheReader */
{
    dispatchName: "netCacheReader",

    // Set to true if cache-data should be fetched automatically.
    autoFetch: false,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function()
    {
        Module.initialize.apply(this, arguments);

        // Register a listener so, we can create a custom info tab within request info body.
        NetMonitor.NetInfoBody.addListener(this);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        NetMonitor.NetInfoBody.removeListener(this);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // TabView Listener

    initTabBody: function(infoBox, file)
    {
        if (!file.cacheEntryRequested)
            return;

        // This is the way how templates can access the current context.
        var panel = Firebug.getElementPanel(infoBox);
        var context = panel.context;

        // Create a custom 'Cache' tab.
        NetMonitor.NetInfoBody.appendTab(infoBox, "Cache", Locale.$STR("Cache"));

        // Fetch data from the cache.
        this.getCacheEntry(file, context.netProgress);
    },

    updateTabBody: function(infoBox, file, context)
    {
        // If the file is not loaded yet or the cache-entry is not available, bail out.
        if (!file.loaded || !file.cacheEntry)
            return;

        var tab = infoBox.selectedTab;
        var tabBody = infoBox.getElementsByClassName("netInfoCacheText").item(0);
        if (!Css.hasClass(tab, "netInfoCacheTab") || tabBody.updated)
            return;

        // The UI update should happen only once so, set this flag.
        tabBody.updated = true;

        // Render basic body structure (table).
        cacheBodyTag.replace({}, tabBody);

        // Render cache information in the UI.
        NetMonitor.NetInfoBody.insertHeaderRows(tabBody, file.cacheEntry, "Cache");
    },

    updateRequestTabBody: function(context, file)
    {
        var panel = context.getPanel("net");
        var row = file.row;
        if (!row)
            return;

        // If the row is already closed, bail out.
        if (!Css.hasClass(row, "opened"))
            return;

        // Update the cache info body.
        var infoRow = row.nextSibling;
        var netInfoBox = infoRow.getElementsByClassName("netInfoBody").item(0);
        if (!netInfoBox)
            return;

        this.updateTabBody(netInfoBox, file, context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    requestCacheEntry: function(file, netProgress)
    {
        // Bail out if the cache is disabled.
        if (!NetMonitor.BrowserCache.isEnabled())
            return;

        // Don't request the cache entry twice.
        if (file.cacheEntryRequested)
            return;

        // The actual request to the cache will be done as soon as the net panel entry
        // is expanded by the user. Reading cache during the page load can influence
        // the caching. See issue 6385.
        file.cacheEntryRequested = true;

        // In case of auto-exporters (such as NetExport) we need to fetch the
        // cache entry automatically and not wait till the user touches the UI.
        if (this.autoFetch)
        {
            var listener = this.getCacheEntry.bind(this, file, netProgress);
            netProgress.context.setTimeout(listener, autoFetchDelay);
        }
    },

    getCacheEntry: function(file, netProgress)
    {
        try
        {
            // Fetch data from the browser cache.
            fetchCacheEntry(file, netProgress);
        }
        catch (exc)
        {
            if (exc.name != "NS_ERROR_CACHE_KEY_NOT_FOUND")
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("net.getCacheEntry; FAILS " + file.href, exc);
            }
        }
    }
});

// ********************************************************************************************* //
// Local Helpers

function fetchCacheEntry(file, netProgress)
{
    if (file.cacheEntry)
        return;

    if (FBTrace.DBG_NET_EVENTS)
        FBTrace.sysout("net.getCacheEntry; file.href: " + file.href);

    // Initialize cache session.
    if (!cacheSession)
    {
        var cacheService = CacheService.getService(Ci.nsICacheService);
        cacheSession = cacheService.createSession("HTTP", Ci.nsICache.STORE_ANYWHERE, true);
        cacheSession.doomEntriesIfExpired = false;
    }

    cacheSession.asyncOpenCacheEntry(file.href, Ci.nsICache.ACCESS_READ,
    {
        onCacheEntryAvailable: function(descriptor, accessGranted, status)
        {
            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.onCacheEntryAvailable; file.href: " + file.href);

            if (descriptor)
                onDescriptorAvailable(netProgress, file, descriptor);

            getCachedHeaders(file);
        }
    });
}

function onDescriptorAvailable(netProgress, file, descriptor)
{
    if (file.size <= 0)
        file.size = descriptor.dataSize;

    if (descriptor.lastModified && descriptor.lastFetched &&
        descriptor.lastModified < Math.floor(file.startTime/1000))
    {
        file.fromCache = true;
    }

    file.cacheEntry =
    [
        {
            name: "Last Modified",
            value: NetUtils.getDateFromSeconds(descriptor.lastModified)
        },
        {
            name: "Last Fetched",
            value: NetUtils.getDateFromSeconds(descriptor.lastFetched)
        },
        {
            name: "Expires",
            value: NetUtils.getDateFromSeconds(descriptor.expirationTime)
        },
        {
            name: "Data Size",
            value: descriptor.dataSize
        },
        {
            name: "Fetch Count",
            value: descriptor.fetchCount
        },
        {
            name: "Device",
            value: descriptor.deviceID
        }
    ];

    try
    {
        // Get contentType from the cache.
        var value = descriptor.getMetaDataElement("response-head");
        var contentType = getContentTypeFromResponseHead(value);
        file.mimeType = NetUtils.getMimeType(contentType, file.href);
    }
    catch (e)
    {
        if (FBTrace.DBG_ERRORS)
            FBTrace.sysout("net.onCacheEntryAvailable; EXCEPTION " + e, e);
    }

    descriptor.close();
    netProgress.update(file);

    // Update UI (in case the request/file is currently expanded)
    NetCacheReader.updateRequestTabBody(netProgress.context, file);
}

function getCachedHeaders(file)
{
    // Cached headers are important only if the request comes from the cache.
    if (!file.fromCache)
        return;

    // The request is containing cached headers now. These will be also displayed
    // within the Net panel.
    var cache = {};
    NetUtils.getHttpHeaders(file.request, cache);
    file.cachedResponseHeaders = cache.responseHeaders;
}

function getContentTypeFromResponseHead(value)
{
    var values = value.split("\r\n");
    for (var i=0; i<values.length; i++)
    {
        var option = values[i].split(": ");
        var headerName = option[0];
        if (headerName && headerName.toLowerCase() == "content-type")
            return option[1];
    }
}

// ********************************************************************************************* //
// Registration

// xxxHonza: expose the module through NetMonitor namespace to avoid cycle dependency problem.
// NetCacheReader module is used within NetProgress module, but can't be included there.
NetMonitor.NetCacheReader = NetCacheReader;

Firebug.registerModule(NetCacheReader);

return NetCacheReader;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/netDebugger",
[
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/lib/array",
    "firebug/net/netUtils",
],
function(Rep, Obj, Firebug, Domplate, Locale, Events, Url, Css, Dom, Arr, NetUtils) {

// ********************************************************************************************* //
// Constants

var {domplate, DIV, SPAN, TR, P, A, INPUT} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;

var panelName = "net";

// ********************************************************************************************* //
// Breakpoints

function NetBreakpointGroup()
{
    this.breakpoints = [];
}

NetBreakpointGroup.prototype = Obj.extend(new Firebug.Breakpoint.BreakpointGroup(),
{
    name: "netBreakpoints",
    title: Locale.$STR("net.label.XHR Breakpoints"),

    addBreakpoint: function(href)
    {
        this.breakpoints.push(new Breakpoint(href));
    },

    removeBreakpoint: function(href)
    {
        var bp = this.findBreakpoint(href);
        Arr.remove(this.breakpoints, bp);
    },

    matchBreakpoint: function(bp, args)
    {
        var href = args[0];
        return bp.href == href;
    }
});

// ********************************************************************************************* //

function Breakpoint(href)
{
    this.href = href;
    this.checked = true;
    this.condition = "";
    this.onEvaluateFails = Obj.bind(this.onEvaluateFails, this);
    this.onEvaluateSucceeds =  Obj.bind(this.onEvaluateSucceeds, this);
}

Breakpoint.prototype =
{
    evaluateCondition: function(context, file)
    {
        try
        {
            var scope = {};

            var params = file.urlParams;
            for (var i=0; params && i<params.length; i++)
            {
                var param = params[i];
                scope[param.name] = param.value;
            }

            scope["$postBody"] = NetUtils.getPostText(file, context);

            // The properties of scope are all strings; we pass them in then
            // unpack them using 'with'. The function is called immediately.
            var expr = "(function (){var scope = " + JSON.stringify(scope) +
                "; with (scope) { return  " + this.condition + ";}})();";

            // The callbacks will set this if the condition is true or if the eval faults.
            delete context.breakingCause;

            Firebug.CommandLine.evaluate(expr, context, null, context.window,
                this.onEvaluateSucceeds, this.onEvaluateFails );

            if (FBTrace.DBG_NET)
            {
                FBTrace.sysout("net.evaluateCondition", {expr: expr, scope: scope,
                    json: JSON.stringify(scope)});
            }

            return !!context.breakingCause;
        }
        catch (err)
        {
            if (FBTrace.DBG_NET)
                FBTrace.sysout("net.evaluateCondition; EXCEPTION "+err, err);
        }

        return false;
    },

    onEvaluateSucceeds: function(result, context)
    {
        // Don't break if the result is false.
        if (!result)
            return;

        context.breakingCause = {
            title: Locale.$STR("net.Break On XHR"),
            message: this.condition
        };
    },

    onEvaluateFails: function(result, context)
    {
        // Break if there is an error when evaluating the condition (to display the error).
        context.breakingCause = {
            title: Locale.$STR("net.Break On XHR"),
            message: "Breakpoint condition evaluation fails ",
            prevValue: this.condition,
            newValue:result
        };
    }
};

// ********************************************************************************************* //
// Breakpoint UI

var BreakpointRep = domplate(Rep,
{
    inspectable: false,

    tag:
        DIV({"class": "breakpointRow focusRow", $disabled: "$bp|isDisabled", _repObject: "$bp",
            role: "option", "aria-checked": "$bp.checked"},
            DIV({"class": "breakpointBlockHead"},
                INPUT({"class": "breakpointCheckbox", type: "checkbox",
                    _checked: "$bp.checked", tabindex: "-1", onclick: "$onEnable"}),
                SPAN({"class": "breakpointName", title: "$bp|getTitle"}, "$bp|getName"),
                SPAN({"class": "closeButton", onclick: "$onRemove"})
            ),
            DIV({"class": "breakpointCondition"},
                SPAN("$bp.condition")
            )
        ),

    getTitle: function(bp)
    {
        return bp.href;
    },

    getName: function(bp)
    {
        return Url.getFileName(bp.href);
    },

    isDisabled: function(bp)
    {
        return !bp.checked;
    },

    onRemove: function(event)
    {
        Events.cancelEvent(event);

        if (!Css.hasClass(event.target, "closeButton"))
            return;

        var bpPanel = Firebug.getElementPanel(event.target);
        var context = bpPanel.context;

        // Remove from list of breakpoints.
        var row = Dom.getAncestorByClass(event.target, "breakpointRow");
        var bp = row.repObject;
        context.netProgress.breakpoints.removeBreakpoint(bp.href);

        bpPanel.refresh();

        var panel = context.getPanel(panelName, true);
        if (!panel)
            return;

        panel.enumerateRequests(function(file)
        {
            if (file.getFileURL() == bp.href)
            {
                file.row.removeAttribute("breakpoint");
                file.row.removeAttribute("disabledBreakpoint");
            }
        });
    },

    onEnable: function(event)
    {
        var checkBox = event.target;
        var bpRow = Dom.getAncestorByClass(checkBox, "breakpointRow");

        if (checkBox.checked)
        {
            Css.removeClass(bpRow, "disabled");
            bpRow.setAttribute("aria-checked", "true");
        }
        else
        {
            Css.setClass(bpRow, "disabled");
            bpRow.setAttribute("aria-checked", "false");
        }

        var bp = bpRow.repObject;
        bp.checked = checkBox.checked;

        var bpPanel = Firebug.getElementPanel(event.target);
        var context = bpPanel.context;

        var panel = context.getPanel(panelName, true);
        if (!panel)
            return;

        panel.enumerateRequests(function(file)
        {
            if (file.getFileURL() == bp.href)
                file.row.setAttribute("disabledBreakpoint", bp.checked ? "false" : "true");
        });
    },

    supportsObject: function(object, type)
    {
        return object instanceof Breakpoint;
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerRep(BreakpointRep);

return {
    NetBreakpointGroup: NetBreakpointGroup
};

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/netMonitor",
[
    "firebug/chrome/activableModule",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/lib/options",
    "firebug/chrome/window",
    "firebug/lib/string",
    "firebug/lib/persist",
    "firebug/net/httpActivityObserver",
    "firebug/net/requestObserver",
    "firebug/net/netProgress",
    "firebug/lib/http",
    "firebug/net/netUtils",
    "firebug/net/netDebugger",
    "firebug/lib/events",
    "firebug/lib/locale",
    "firebug/trace/traceListener",
    "firebug/trace/traceModule"
],
function(ActivableModule, Obj, Firebug, Firefox, Options, Win, Str, Persist,
    NetHttpActivityObserver, HttpRequestObserver, NetProgress, Http, NetUtils, NetDebugger,
    Events, Locale, TraceListener, TraceModule) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;

var panelName = "net";

var startFile = NetProgress.prototype.startFile;
var openingFile = NetProgress.prototype.openingFile;
var requestedFile = NetProgress.prototype.requestedFile;
var respondedFile = NetProgress.prototype.respondedFile;
var respondedCacheFile = NetProgress.prototype.respondedCacheFile;
var windowPaint = NetProgress.prototype.windowPaint;
var timeStamp = NetProgress.prototype.timeStamp;
var windowLoad = NetProgress.prototype.windowLoad;
var contentLoad = NetProgress.prototype.contentLoad;

// ********************************************************************************************* //

/**
 * @module Represents a module object for the Net panel. This object is derived
 * from {@link ActivableModule} in order to support activation (enable/disable).
 * This allows to avoid (performance) expensive features if the functionality is not necessary
 * for the user.
 */
Firebug.NetMonitor = Obj.extend(ActivableModule,
/** @lends Firebug.NetMonitor */
{
    dispatchName: "netMonitor",
    maxQueueRequests: 500,
    contexts: new Array(),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Module

    initialize: function()
    {
        ActivableModule.initialize.apply(this, arguments);

        this.traceNetListener = new TraceListener("net.", "DBG_NET", true);
        this.traceActivityListener = new TraceListener("activityObserver.",
            "DBG_ACTIVITYOBSERVER", true);

        TraceModule.addListener(this.traceNetListener);
        TraceModule.addListener(this.traceActivityListener);

        Firebug.connection.addListener(this.DebuggerListener);

        NetHttpObserver.registerObserver();
    },

    initializeUI: function()
    {
        ActivableModule.initializeUI.apply(this, arguments);

        // Initialize max limit for logged requests.
        Firebug.NetMonitor.updateMaxLimit();

        // Synchronize UI buttons with the current filter.
        this.syncFilterButtons(Firebug.chrome);

        // Initialize filter button tooltips
        var doc = Firebug.chrome.window.document;
        var filterButtons = doc.getElementsByClassName("fbNetFilter");
        for (var i=0, len=filterButtons.length; i<len; ++i)
        {
            if (filterButtons[i].id != "fbNetFilter-all")
            {
                filterButtons[i].tooltipText = Locale.$STRF("firebug.labelWithShortcut",
                    [filterButtons[i].tooltipText, Locale.$STR("tooltip.multipleFiltersHint")]);
            }
        }

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.NetMonitor.initializeUI; enabled: " + this.isAlwaysEnabled());
    },

    shutdown: function()
    {
        ActivableModule.shutdown.apply(this, arguments);

        TraceModule.removeListener(this.traceNetListener);
        TraceModule.removeListener(this.traceActivityListener);

        Firebug.connection.removeListener(this.DebuggerListener);

        NetHttpObserver.unregisterObserver();
    },

    initContext: function(context, persistedState)
    {
        ActivableModule.initContext.apply(this, arguments);

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.initContext for: " + context.getName());

        // XXXjjb changed test to instanceof because jetpack uses fake window objects
        if (context.window && context.window instanceof Window)
        {
            var win = context.window;

            var onWindowPaintHandler = function()
            {
                if (context.netProgress)
                    context.netProgress.post(windowPaint, [win, NetUtils.now()]);
            };

            if (Options.get("netShowPaintEvents"))
            {
                context.addEventListener(win, "MozAfterPaint", onWindowPaintHandler, false);
            }

            // Register "load" listener in order to track window load time.
            var onWindowLoadHandler = function()
            {
                if (context.netProgress)
                    context.netProgress.post(windowLoad, [win, NetUtils.now()]);
                context.removeEventListener(win, "load", onWindowLoadHandler, true);

                context.setTimeout(function()
                {
                    if (win && !win.closed)
                    {
                        context.removeEventListener(win, "MozAfterPaint", onWindowPaintHandler, false);
                    }
                }, 2000); //xxxHonza: this should be customizable using preferences.
            };
            context.addEventListener(win, "load", onWindowLoadHandler, true);

            // Register "DOMContentLoaded" listener to track timing.
            var onContentLoadHandler = function()
            {
                if (context.netProgress)
                    context.netProgress.post(contentLoad, [win, NetUtils.now()]);
                context.removeEventListener(win, "DOMContentLoaded", onContentLoadHandler, true);
            };

            context.addEventListener(win, "DOMContentLoaded", onContentLoadHandler, true);
        }

        if (Firebug.NetMonitor.isAlwaysEnabled())
            monitorContext(context);

        if (context.netProgress)
        {
            // Load existing breakpoints
            var persistedPanelState = Persist.getPersistedState(context, panelName);
            if (persistedPanelState.breakpoints)
                context.netProgress.breakpoints = persistedPanelState.breakpoints;
        }
    },

    showContext: function(browser, context)
    {
        ActivableModule.showContext.apply(this, arguments);

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.showContext; " + (context ? context.getName() : "NULL") +
                ", temp contexts: " + getTempContextCount());
    },

    loadedContext: function(context)
    {
        var tabId = Win.getWindowProxyIdForWindow(context.browser.contentWindow);
        delete this.contexts[tabId];

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.loadedContext; temp contexts (" + getTempContextCount() + ")");

        var netProgress = context.netProgress;
        if (netProgress)
        {
            netProgress.loaded = true;

            // Set Page title and id into all document objects.
            for (var i=0; i<netProgress.documents.length; i++)
            {
                var doc = netProgress.documents[i];
                doc.id = context.uid;
                doc.title = NetUtils.getPageTitle(context);
            }
        }
    },

    destroyContext: function(context, persistedState)
    {
        ActivableModule.destroyContext.apply(this, arguments);

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.destroyContext for: " +
                (context ? context.getName() : "No context"));

        if (context.netProgress)
        {
            // Remember existing breakpoints.
            var persistedPanelState = Persist.getPersistedState(context, panelName);
            persistedPanelState.breakpoints = context.netProgress.breakpoints;
        }

        if (Firebug.NetMonitor.isAlwaysEnabled())
            unmonitorContext(context);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Activable Module

    onObserverChange: function(observer)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.onObserverChange; hasObservers: " + this.hasObservers() +
                ", Firebug suspended: " + Firebug.getSuspended());

        if (!Firebug.getSuspended())  // then Firebug is in action
            this.onResumeFirebug();   // and we need to test to see if we need to addObserver
    },

    onResumeFirebug: function()
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.onResumeFirebug; enabled: " + Firebug.NetMonitor.isAlwaysEnabled());

        // Resume only if NetPanel is enabled and so, observing NetMonitor module.
        if (Firebug.NetMonitor.isAlwaysEnabled())
        {
            NetHttpActivityObserver.registerObserver();
            Firebug.connection.eachContext(monitorContext);
        }
        else
        {
            // If the Net panel is not enabled, we need to make sure the unmonitorContext
            // is executed and so, the start button (aka Firebug status bar icons) is
            // properly updated.
            NetHttpActivityObserver.unregisterObserver();
            Firebug.connection.eachContext(unmonitorContext);
        }
    },

    onSuspendFirebug: function()
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.onSuspendFirebug; enabled: " + Firebug.NetMonitor.isAlwaysEnabled());

        NetHttpActivityObserver.unregisterObserver();
        Firebug.connection.eachContext(unmonitorContext);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // User Actions

    clear: function(context)
    {
        // The user pressed a Clear button so, remove content of the panel...
        var panel = context.getPanel(panelName, true);
        if (panel)
            panel.clear();
    },

    onToggleFilter: function(event, context, filterCategory)
    {
        if (!context.netProgress)
            return;

        var filterCategories = [];
        if (Events.isControl(event) && filterCategory != "all")
        {
            filterCategories = Options.get("netFilterCategories").split(" ");
            var filterCategoryIndex = filterCategories.indexOf(filterCategory);
            if (filterCategoryIndex == -1)
                filterCategories.push(filterCategory);
            else
                filterCategories.splice(filterCategoryIndex, 1);
        }
        else
        {
            filterCategories.push(filterCategory);
        }

        // Remove "all" filter in case several filters are selected
        if (filterCategories.length > 1)
        {
            var allIndex = filterCategories.indexOf("all");
            if (allIndex != -1)
                filterCategories.splice(allIndex, 1);
        }

        // If no filter categories are selected, use the default
        if (filterCategories.length == 0)
            filterCategories = Options.getDefault("netFilterCategories").split(" ");

        Options.set("netFilterCategories", filterCategories.join(" "));

        this.syncFilterButtons(Firebug.chrome);

        Events.dispatch(Firebug.NetMonitor.fbListeners, "onFiltersSet", [filterCategories]);
    },

    syncFilterButtons: function(chrome)
    {
        var filterCategories = new Set();
        Options.get("netFilterCategories").split(" ").forEach(function(element)
        {
            filterCategories.add(element);
        });
        var doc = chrome.window.document;
        var buttons = doc.getElementsByClassName("fbNetFilter");

        for (var i=0, len=buttons.length; i<len; ++i)
        {
            var filterCategory = buttons[i].id.substr(buttons[i].id.search("-") + 1);
            buttons[i].checked = filterCategories.has(filterCategory);
        }
    },

    togglePersist: function(context)
    {
        var panel = context.getPanel(panelName);
        panel.persistContent = panel.persistContent ? false : true;

        Firebug.chrome.setGlobalAttribute("cmd_firebug_togglePersistNet", "checked",
            panel.persistContent);
    },

    updateOption: function(name, value)
    {
        if (name == "net.logLimit")
            this.updateMaxLimit();
    },

    updateMaxLimit: function()
    {
        var value = Options.get("net.logLimit");
        this.maxQueueRequests = value ? value : this.maxQueueRequests;
    },

    addTimeStamp: function(context, time, label, color)
    {
        if (context.netProgress)
            context.netProgress.post(timeStamp, [context.window, time, label, color]);
    }
});

// ********************************************************************************************* //

// HTTP Observer

// HTTP listener - based on HttpRequestObserver module
// This observer is used for observing the first document http-on-modify-request
// and http-on-examine-response events, which are fired before the context
// is initialized (initContext method call). Without this observer this events
// would be lost and the time measuring would be wrong.
//
// This observer stores these early requests in helper array (contexts) and maps
// them to appropriate tab - initContext then uses the array in order to access it.

var NetHttpObserver =
{
    dispatchName: "NetHttpObserver",
    registered: false,

    registerObserver: function()
    {
        if (this.registered)
            return;

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.NetHttpObserver.register;");

        HttpRequestObserver.addObserver(this, "firebug-http-event", false);
        this.registered = true;
    },

    unregisterObserver: function()
    {
        if (!this.registered)
            return;

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.NetHttpObserver.unregister;");

        HttpRequestObserver.removeObserver(this, "firebug-http-event");
        this.registered = false;
    },

    /* nsIObserve */
    observe: function(subject, topic, data)
    {
        if (!Firebug.NetMonitor.isAlwaysEnabled())
            return;

        try
        {
            if (FBTrace.DBG_NET_EVENTS)
            {
                FBTrace.sysout("net.events.observe " + (topic ? topic.toUpperCase() : topic) +
                    ", " + ((subject instanceof Ci.nsIRequest) ? Http.safeGetRequestName(subject) : "") +
                    ", Browser: " + Firebug.chrome.window.document.title);
            }

            if (!(subject instanceof Ci.nsIHttpChannel))
                return;

            var win = Http.getWindowForRequest(subject);
            var context = Firebug.connection.getContextByWindow(win);

            // The context doesn't have to exist yet. In such cases a temp Net context is
            // created within onModifyRequest.

            // Some requests are not associated with any page (e.g. favicon).
            // These are ignored as Net panel shows only page requests.
            var tabId = win ? Win.getWindowProxyIdForWindow(win) : null;
            if (!tabId)
            {
                if (FBTrace.DBG_NET)
                    FBTrace.sysout("net.observe NO TAB " + Http.safeGetRequestName(subject) +
                        ", " + tabId + ", " + win);
                return;
            }

            if (topic == "http-on-modify-request")
                this.onModifyRequest(subject, win, tabId, context);
            else if (topic == "http-on-examine-response")
                this.onExamineResponse(subject, win, tabId, context);
            else if (topic == "http-on-examine-cached-response")
                this.onExamineCachedResponse(subject, win, tabId, context);
            else if (topic == "http-on-opening-request")
                this.openingFile(subject, win, tabId, context);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("net.observe EXCEPTION", err);
        }
    },

    onModifyRequest: function(request, win, tabId, context)
    {
        var name = request.URI.asciiSpec;
        var origName = request.originalURI.asciiSpec;
        var isRedirect = (name != origName);

        // We only need to create a new context if this is a top document uri (not frames).
        if ((request.loadFlags & Ci.nsIChannel.LOAD_DOCUMENT_URI) &&
            request.loadGroup && request.loadGroup.groupObserver &&
            win == win.parent && !isRedirect)
        {
            var browser = Firefox.getBrowserForWindow(win);

            if (!Firebug.TabWatcher.shouldCreateContext(browser, name, null))
            {
                if (FBTrace.DBG_NET)
                    FBTrace.sysout("net.onModifyRequest; Activation logic says don't create " +
                        "temp context for: " + name);
                return;
            }

            // Create a new network context prematurely.
            if (!Firebug.NetMonitor.contexts[tabId])
            {
                Firebug.NetMonitor.contexts[tabId] = createNetProgress(null);

                // OK, we definitely want to watch this page load, temporary context is created
                // so, make sure the activity-observer is registered and we have detailed
                // timing info for this first document request.
                NetHttpActivityObserver.registerObserver();

                if (FBTrace.DBG_NET)
                    FBTrace.sysout("net.onModifyRequest; Temp Context created (" +
                        getTempContextCount() + "), " + tabId);
            }
        }

        var networkContext = Firebug.NetMonitor.contexts[tabId];
        if (!networkContext)
            networkContext = context ? context.netProgress : null;

        if (networkContext)
        {
            networkContext.post(startFile, [request, win]);

            // We need to track the request now since the activity observer is not used in case
            // the response comes from BF cache. If it's a regular HTTP request the timing
            // is properly overridden by the activity observer (ACTIVITY_SUBTYPE_REQUEST_HEADER).
            // Even if the Firebug.netShowBFCacheResponses is false now, the user could
            // switch it on later.
            var xhr = Http.isXHR(request);
            networkContext.post(requestedFile, [request, NetUtils.now(), win, xhr]);
        }
    },

    onExamineResponse: function(request, win, tabId, context)
    {
        var networkContext = Firebug.NetMonitor.contexts[tabId];
        if (!networkContext)
            networkContext = context ? context.netProgress : null;

        if (!networkContext)
            return;

        var info = new Object();
        info.responseStatus = request.responseStatus;
        info.responseStatusText = request.responseStatusText;

        // Initialize info.postText property.
        info.request = request;
        NetUtils.getPostText(info, context);

        // Get response headers now. They could be replaced by cached headers later
        // (if the response is coming from the cache).
        NetUtils.getHttpHeaders(request, info, context);

        if (FBTrace.DBG_NET && info.postText)
            FBTrace.sysout("net.onExamineResponse, POST data: " + info.postText, info);

        networkContext.post(respondedFile, [request, NetUtils.now(), info]);

        // Make sure to track the first document response.
        //Firebug.TabCacheModel.registerStreamListener(request, win, true);
    },

    onExamineCachedResponse: function(request, win, tabId, context)
    {
        var networkContext = Firebug.NetMonitor.contexts[tabId];
        if (!networkContext)
            networkContext = context ? context.netProgress : null;

        if (!networkContext)
        {
            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.onExamineCachedResponse; No CONTEXT for:" +
                    Http.safeGetRequestName(request));
            return;
        }

        var info = new Object();
        info.responseStatus = request.responseStatus;
        info.responseStatusText = request.responseStatusText;

        // Initialize info.postText property.
        info.request = request;
        NetUtils.getPostText(info, context);

        networkContext.post(respondedCacheFile, [request, NetUtils.now(), info]);
    },

    openingFile: function(request, win, tabId, context)
    {
        var networkContext = Firebug.NetMonitor.contexts[tabId];
        if (!networkContext)
            networkContext = context ? context.netProgress : null;

        if (!networkContext)
            return;

        networkContext.post(openingFile, [request, win]);
    },

    /* nsISupports */
    QueryInterface: function(iid)
    {
        if (iid.equals(Ci.nsISupports) ||
            iid.equals(Ci.nsIObserver)) {
             return this;
         }

        throw Cr.NS_ERROR_NO_INTERFACE;
    }
};

// ********************************************************************************************* //
// Monitoring start/stop

function monitorContext(context)
{
    if (context.netProgress)
        return;

    var networkContext = null;

    // Use an existing context associated with the browser tab if any
    // or create a pure new network context.
    if (context.window)
    {
        var tabId = Win.getWindowProxyIdForWindow(context.window);
        networkContext = Firebug.NetMonitor.contexts[tabId];
    }

    if (FBTrace.DBG_NET)
        FBTrace.sysout("net.monitorContext; (" + networkContext + ") " +
            tabId + ", " + context.getName());

    if (networkContext)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.monitorContext; Use temporary context: " + tabId);

        networkContext.context = context;
        delete Firebug.NetMonitor.contexts[tabId];
    }
    else
    {
        if (FBTrace.DBG_NET)
        {
            FBTrace.sysout("net.monitorContext; create network monitor context object for: " +
                tabId);
        }

        networkContext = createNetProgress(context);
    }

    // Register activity-distributor observer if available (#488270)
    //NetHttpActivityObserver.registerObserver();

    context.netProgress = networkContext;

    // Add cache listener so, net panel has always fresh responses.
    // Safe to call multiple times.
    networkContext.cacheListener.register(context.sourceCache);

    // Activate net panel sub-context.
    var panel = context.getPanel(panelName);
    context.netProgress.activate(panel);

    // Display info message, but only if the panel isn't just reloaded or Persist == true.
    if (!context.persistedState)
        panel.insertActivationMessage();

    updateStartButton(true);
}

function unmonitorContext(context)
{
    if (FBTrace.DBG_NET)
        FBTrace.sysout("net.unmonitorContext; (" +
            (context ? context.netProgress : "netProgress == NULL") + ") " +
            (context ? context.getName() : "no context"));

    var netProgress = context ? context.netProgress : null;
    if (!netProgress)
        return;

    // Since the print into the UI is done by timeout asynchronously,
    // make sure there are no requests left.
    var panel = context.getPanel(panelName, true);
    if (panel)
        panel.updateLayout();

    //NetHttpActivityObserver.unregisterObserver();

    // Remove cache listener. Safe to call multiple times.
    netProgress.cacheListener.unregister();

    // Deactivate net sub-context.
    context.netProgress.activate(null);

    updateStartButton(false);

    // And finaly destroy the net panel sub context.
    delete context.netProgress;
}

function updateStartButton(enabled)
{
    if (FBTrace.DBG_NET)
        FBTrace.sysout("net.updateStartButton; update start button, enabled: " + enabled);

    var firebugStatus = Firefox.getElementById("firebugStatus");

    // Update status
    if (enabled)
        firebugStatus.setAttribute("net", "on");
    else
        firebugStatus.removeAttribute("net");

    // Update start button tooltip
    if (Firebug.StartButton)
        Firebug.StartButton.resetTooltip();
    else
        FBTrace.sysout("net.updateStartButton; ERROR No Firebug.StartButton ?");
}

function createNetProgress(context)
{
    var netProgress = new NetProgress(context);
    netProgress.cacheListener = new NetCacheListener(netProgress);
    netProgress.breakpoints = new NetDebugger.NetBreakpointGroup();
    return netProgress;
}

// ********************************************************************************************* //
// TabCache Listener

/**
 * TabCache listner implementation. Net panel uses this listner to remember all
 * responses stored into the cache. There can be more requests to the same URL that
 * returns different responses. The Net panels must remember all of them (tab cache
 * remembers only the last one)
 */
function NetCacheListener(netProgress)
{
    this.netProgress = netProgress;
    this.cache = null;
}

NetCacheListener.prototype =
{
    dispatchName: "NetCacheListener",

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Registration

    register: function(cache)
    {
        if (this.cache)
            return;

        this.cache = cache;
        this.cache.addListener(this);
    },

    unregister: function()
    {
        if (!this.cache)
            return;

        this.cache.removeListener(this);
        this.cache = null;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Cache Listener

    onStartRequest: function(context, request)
    {
        // Keep in mind that the file object (representing the request) doesn't have to be
        // created at this moment (top document request).
    },

    onStopRequest: function(context, request, responseText)
    {
        // Remember the response for this request.
        var file = this.netProgress.getRequestFile(request, null, true);
        if (file && responseText)
            file.responseText = responseText;

        Events.dispatch(Firebug.NetMonitor.fbListeners, "onResponseBody", [context, file]);
    }
};

// ********************************************************************************************* //
// Debugger Listener

Firebug.NetMonitor.DebuggerListener =
{
    getBreakpoints: function(context, groups)
    {
        if (context.netProgress && !context.netProgress.breakpoints.isEmpty())
            groups.push(context.netProgress.breakpoints);
    },
};

// ********************************************************************************************* //
// Tracing support

function getTempContextCount()
{
    var counter = 0;
    for (var p in Firebug.NetMonitor.contexts)
        counter++;
    return counter;
}

// ********************************************************************************************* //
// Registration

// Keep compatibility with existing XUL based extensions
// deprecated
Firebug.NetMonitor.Utils = NetUtils;

Firebug.registerActivableModule(Firebug.NetMonitor);

return Firebug.NetMonitor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/netPanel",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/lib/domplate",
    "firebug/lib/xpcom",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/options",
    "firebug/lib/url",
    "firebug/js/sourceLink",
    "firebug/lib/http",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/chrome/window",
    "firebug/lib/search",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/lib/system",
    "firebug/chrome/menu",
    "firebug/net/netUtils",
    "firebug/net/netProgress",
    "firebug/css/cssReps",
    "firebug/net/timeInfoTip",
    "firebug/chrome/panelNotification",
    "firebug/chrome/activablePanel",
    "firebug/js/breakpoint",
    "firebug/net/xmlViewer",
    "firebug/net/svgViewer",
    "firebug/net/jsonViewer",
    "firebug/net/fontViewer",
    "firebug/chrome/infotip",
    "firebug/css/cssPanel",
    "firebug/chrome/searchBox",
    "firebug/console/errors",
    "firebug/net/netMonitor",
    "firebug/net/netReps",
    "firebug/net/netCacheReader",
],
function(Obj, Firebug, Firefox, Domplate, Xpcom, Locale,
    Events, Options, Url, SourceLink, Http, Css, Dom, Win, Search, Str,
    Arr, System, Menu, NetUtils, NetProgress, CSSInfoTip, TimeInfoTip,
    PanelNotification, ActivablePanel) {

// ********************************************************************************************* //
// Constants

var {domplate, DIV, TR, P, UL, A} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;

var layoutInterval = 300;
var panelName = "net";
var NetRequestEntry = Firebug.NetMonitor.NetRequestEntry;
var NetRequestTable = Firebug.NetMonitor.NetRequestTable;

// ********************************************************************************************* //

/**
 * @panel Represents a Firebug panel that displays info about HTTP activity associated with
 * the current page. This class is derived from {@ActivablePanel} in order
 * to support activation (enable/disable). This allows to avoid (performance) expensive
 * features if the functionality is not necessary for the user.
 */
function NetPanel() {}
NetPanel.prototype = Obj.extend(ActivablePanel,
/** @lends NetPanel */
{
    name: panelName,
    searchable: true,
    editable: true,
    breakable: true,
    enableA11y: true,
    order: 60,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Initialization

    initialize: function(context, doc)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.NetPanel.initialize; " + context.getName());

        this.queue = [];
        this.onContextMenu = Obj.bind(this.onContextMenu, this);

        ActivablePanel.initialize.apply(this, arguments);

        // Listen for set filters, so the panel is properly updated when needed
        Firebug.NetMonitor.addListener(this);
    },

    destroy: function(state)
    {
        Firebug.NetMonitor.removeListener(this);

        ActivablePanel.destroy.apply(this, arguments);
    },

    initializeNode : function()
    {
        Events.addEventListener(this.panelNode, "contextmenu", this.onContextMenu, false);

        this.onResizer = Obj.bind(this.onResize, this);
        this.resizeEventTarget = Firebug.chrome.$('fbContentBox');
        Events.addEventListener(this.resizeEventTarget, "resize", this.onResizer, true);

        ActivablePanel.initializeNode.apply(this, arguments);
    },

    destroyNode : function()
    {
        Events.removeEventListener(this.panelNode, "contextmenu", this.onContextMenu, false);
        Events.removeEventListener(this.resizeEventTarget, "resize", this.onResizer, true);

        ActivablePanel.destroyNode.apply(this, arguments);
    },

    loadPersistedContent: function(state)
    {
        this.initLayout();

        var tbody = this.table.querySelector(".netTableBody");

        // Move all net-rows from the persistedState to this panel.
        var prevTableBody = state.panelNode.getElementsByClassName("netTableBody").item(0);
        if (!prevTableBody)
            return;

        var files = [];

        // Iterate persisted content - table rows. These rows can represent various things
        // 1) netPageRow - already persisted group
        // 2) netRow - request entries from the previous session (page load)
        while (prevTableBody.firstChild)
        {
            var row = prevTableBody.firstChild;

            // Collect all entries that belongs to the current page load (not history)
            if (Css.hasClass(row, "netRow") &&
                Css.hasClass(row, "hasHeaders") &&
                !Css.hasClass(row, "history"))
            {
                row.repObject.history = true;
                files.push({
                    file: row.repObject,
                    offset: 0 + "%",
                    width: 0 + "%",
                    elapsed:  -1
                });
            }

            if (Css.hasClass(row, "netPageRow"))
            {
                Css.removeClass(row, "opened");

                // Insert the old page-load-history entry just before the summary-row,
                // but after the limit row.
                tbody.insertBefore(row, this.summaryRow);
            }
            else
            {
                prevTableBody.removeChild(row);
            }
        }

        // New page-load-history entry is inserted just before summary row
        // (at the end of page-load-history entry list)
        var lastRow = this.summaryRow.previousSibling;
        if (files.length)
        {
            var pageRow = Firebug.NetMonitor.NetPage.pageTag.insertRows({page: state}, lastRow)[0];
            pageRow.files = files;

            lastRow = this.summaryRow.previousSibling;
        }

        // Insert a separator tag at the end of page-load-history entry list.
        if (this.table.getElementsByClassName("netPageRow").item(0))
            Firebug.NetMonitor.NetPage.separatorTag.insertRows({}, lastRow);

        Dom.scrollToBottom(this.panelNode);
    },

    savePersistedContent: function(state)
    {
        ActivablePanel.savePersistedContent.apply(this, arguments);

        state.pageTitle = NetUtils.getPageTitle(this.context);
    },

    show: function(state)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.netPanel.show; " + this.context.getName(), state);

        var enabled = Firebug.NetMonitor.isAlwaysEnabled();
        this.showToolbarButtons("fbNetButtons", enabled);

        if (enabled)
            Firebug.chrome.setGlobalAttribute("cmd_firebug_togglePersistNet", "checked", this.persistContent);
        else
            this.table = null;

        if (!enabled)
            return;

        if (!this.filterCategories)
            this.setFilter(Options.get("netFilterCategories").split(" "));

        this.layout();

        if (!this.layoutInterval)
            this.layoutInterval = setInterval(Obj.bindFixed(this.updateLayout, this), layoutInterval);

        if (this.wasScrolledToBottom)
            Dom.scrollToBottom(this.panelNode);
    },

    hide: function()
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.netPanel.hide; " + this.context.getName());

        // clear the state that is tracking the infotip so it is reset after next show()
        delete this.infoTipURL;
        this.wasScrolledToBottom = Dom.isScrolledToBottom(this.panelNode);

        clearInterval(this.layoutInterval);
        delete this.layoutInterval;
    },

    updateOption: function(name, value)
    {
        if (name == "netShowBFCacheResponses")
            this.updateBFCacheResponses();
    },

    updateBFCacheResponses: function()
    {
        if (this.table)
        {
            if (Firebug.netShowBFCacheResponses)
                Css.setClass(this.table, "showBFCacheResponses");
            else
                Css.removeClass(this.table, "showBFCacheResponses");

            // Recalculate the summary information since some requests doesn't have to
            // be displayed now.
            this.updateSummaries(NetUtils.now(), true);
        }
    },

    updateSelection: function(object)
    {
        if (!object)
            return;

        var netProgress = this.context.netProgress;
        var file = netProgress.getRequestFile(object.request);
        if (!file)
        {
            for (var i=0; i<netProgress.requests.length; i++) {
                if (Http.safeGetRequestName(netProgress.requests[i]) == object.href) {
                   file = netProgress.files[i];
                   break;
                }
            }
        }

        if (file)
        {
            Dom.scrollIntoCenterView(file.row);
            if (!Css.hasClass(file.row, "opened"))
                NetRequestEntry.toggleHeadersRow(file.row);
        }
    },

    getPopupObject: function(target)
    {
        var header = Dom.getAncestorByClass(target, "netHeaderRow");
        if (header)
            return NetRequestTable;

        return ActivablePanel.getPopupObject.apply(this, arguments);
    },

    supportsObject: function(object, type)
    {
        return ((object instanceof SourceLink.SourceLink && object.type == "net") ? 2 : 0);
    },

    getOptionsMenuItems: function()
    {
        return [
            this.disableCacheOption(),
            "-",
            Menu.optionMenu("net.option.Show_Paint_Events", "netShowPaintEvents",
                "net.option.tip.Show_Paint_Events"),
            Menu.optionMenu("net.option.Show_BFCache_Responses", "netShowBFCacheResponses",
                "net.option.tip.Show_BFCache_Responses")
        ];
    },

    disableCacheOption: function()
    {
        var BrowserCache = Firebug.NetMonitor.BrowserCache;
        var disabled = !BrowserCache.isEnabled();
        return {
            label: "net.option.Disable_Browser_Cache",
            type: "checkbox",
            checked: disabled,
            tooltiptext: "net.option.tip.Disable_Browser_Cache",
            command: function()
            {
                BrowserCache.toggle(!this.hasAttribute("checked"));
            }
        };
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Context Menu

    getContextMenuItems: function(nada, target)
    {
        var items = [];

        var file = Firebug.getRepObject(target);
        if (!file || !(file instanceof Firebug.NetFile))
            return items;

        var object = Firebug.getObjectByURL(this.context, file.href);
        var isPost = NetUtils.isURLEncodedRequest(file, this.context);
        var params = Url.parseURLParams(file.href);

        items.push(
            {
                label: "CopyLocation",
                tooltiptext: "clipboard.tip.Copy_Location",
                command: Obj.bindFixed(System.copyToClipboard, System, file.href)
            }
        );

        if (params.length > 0)
        {
            items.push(
                {
                    id: "fbCopyUrlParameters",
                    label: "CopyURLParameters",
                    tooltiptext: "net.tip.Copy_URL_Parameters",
                    command: Obj.bindFixed(this.copyURLParams, this, file)
                }
            );
        }

        if (isPost)
        {
            items.push(
                {
                    label: "CopyLocationParameters",
                    tooltiptext: "net.tip.Copy_Location_Parameters",
                    command: Obj.bindFixed(this.copyParams, this, file)
                },
                {
                    id: "fbCopyPOSTParameters",
                    label: "CopyPOSTParameters",
                    tooltiptext: "net.tip.Copy_POST_Parameters",
                    command: Obj.bindFixed(this.copyPOSTParams, this, file)
                }
            );
        }

        items.push(
            {
                label: "CopyRequestHeaders",
                tooltiptext: "net.tip.Copy_Request_Headers",
                command: Obj.bindFixed(this.copyRequestHeaders, this, file)
            },
            {
                label: "CopyResponseHeaders",
                tooltiptext: "net.tip.Copy_Response_Headers",
                command: Obj.bindFixed(this.copyResponseHeaders, this, file)
            }
        );

        if (NetUtils.textFileCategories.hasOwnProperty(file.category))
        {
            items.push(
                {
                    label: "CopyResponse",
                    tooltiptext: "net.tip.Copy_Response",
                    command: Obj.bindFixed(this.copyResponse, this, file)
                }
            );
        }

        items.push(
            {
                id: "fbCopyAsCurl",
                label: "CopyAsCurl",
                tooltiptext: "net.tip.Copy_as_cURL",
                command: Obj.bindFixed(this.copyAsCurl, this, file)
            }
        );

        items.push(
            "-",
            {
                label: "OpenInTab",
                tooltiptext: "firebug.tip.Open_In_Tab",
                command: Obj.bindFixed(this.openRequestInTab, this, file)
            }
        );

        if (NetUtils.textFileCategories.hasOwnProperty(file.category))
        {
            items.push(
                {
                    label: "Open_Response_In_New_Tab",
                    tooltiptext: "net.tip.Open_Response_In_New_Tab",
                    command: Obj.bindFixed(NetUtils.openResponseInTab, this, file)
                }
            );
        }

        items.push("-");

        if (!file.loaded)
        {
            items.push(
                {
                    label: "StopLoading",
                    tooltiptext: "net.tip.Stop_Loading",
                    command: Obj.bindFixed(this.stopLoading, this, file)
                }
            );
        }

        items.push(
            {
                label: "net.label.Resend",
                tooltiptext: "net.tip.Resend",
                id: "fbNetResend",
                command: Obj.bindFixed(Firebug.Spy.XHR.resend, Firebug.Spy.XHR, file, this.context)
            }
        );

        if (object)
        {
            // xxxHonza: This is dangerous construct. Inspect menu-items are generated
            // automatically for every context menu in FirebugChrome.onContextShowing().
            // Also, FirebugChrome is using Rep.getRealObject() while this logic is based
            // on Firebug.getObjectByURL(), which can return different objects to be inspected.
            // This feature has been introduced to allow inspecting of specific network requests
            // like stylesheets and javascript files, but at that time the network request
            // template (FirebugReps.NetFile) returned null for getRealObject().
            // FirebugReps.NetFile.getRealObject() now returns an object representing the request
            // itself (used also by 'Use in Command Line' feature), which is different from what
            // Firebug.getObjectByURL() returns. See also issue 6647.
            var subItems = Firebug.chrome.getInspectMenuItems(object);
            if (subItems.length)
            {
                items.push("-");
                items.push.apply(items, subItems);
            }
        }

        if (file.isXHR)
        {
            var bp = this.context.netProgress.breakpoints.findBreakpoint(file.getFileURL());

            items.push(
                "-",
                {
                    label: "net.label.Break_On_XHR",
                    tooltiptext: "net.tip.Break_On_XHR",
                    type: "checkbox",
                    checked: !!bp,
                    command: Obj.bindFixed(this.breakOnRequest, this, file)
                }
            );

            if (bp)
            {
                items.push(
                    {
                        label: "EditBreakpointCondition",
                        tooltiptext: "breakpoints.tip.Edit_Breakpoint_Condition",
                        command: Obj.bindFixed(this.editBreakpointCondition, this, file)
                    }
                );
            }
        }

        return items;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Context Menu Commands

    copyURLParams: function(file)
    {
        var params = Url.parseURLParams(file.href);
        var result = params.map(function(o) { return o.name + "=" + o.value; });
        System.copyToClipboard(result.join(Str.lineBreak()));
    },

    copyPOSTParams: function(file)
    {
        if (!NetUtils.isURLEncodedRequest(file, this.context))
            return;

        var text = NetUtils.getPostText(file, this.context, true);
        if (text)
        {
            var lines = text.split("\n");
            var params = Url.parseURLEncodedText(lines[lines.length-1]);
            var result = params.map(function(o) { return o.name + "=" + o.value; });
            System.copyToClipboard(result.join(Str.lineBreak()));
        }
    },

    copyParams: function(file)
    {
        var text = NetUtils.getPostText(file, this.context, true);
        var url = Url.reEncodeURL(file, text, true);
        System.copyToClipboard(url);
    },

    copyRequestHeaders: function(file)
    {
        System.copyToClipboard(file.requestHeadersText);
    },

    copyResponseHeaders: function(file)
    {
        System.copyToClipboard(file.responseHeadersText);
    },

    copyResponse: function(file)
    {
        // Copy response to the clipboard
        System.copyToClipboard(NetUtils.getResponseText(file, this.context));
    },

    copyAsCurl: function(file)
    {
        System.copyToClipboard(NetUtils.generateCurlCommand(file,
            Options.get("net.curlAddCompressedArgument")));
    },

    openRequestInTab: function(file)
    {
        if (file.postText)
        {
            var lines = file.postText.split("\n");
            Win.openNewTab(file.href, lines[lines.length-1]);
        }
        else
        {
            Win.openNewTab(file.href, null);
        }
    },

    breakOnRequest: function(file)
    {
        if (!file.isXHR)
            return;

        // Create new or remove an existing breakpoint.
        var breakpoints = this.context.netProgress.breakpoints;
        var url = file.getFileURL();
        var bp = breakpoints.findBreakpoint(url);
        if (bp)
            breakpoints.removeBreakpoint(url);
        else
            breakpoints.addBreakpoint(url);

        this.enumerateRequests(function(currFile)
        {
            if (url != currFile.getFileURL())
                return;

            if (bp)
                currFile.row.removeAttribute("breakpoint");
            else
                currFile.row.setAttribute("breakpoint", "true");
        });
    },

    stopLoading: function(file)
    {
        const NS_BINDING_ABORTED = 0x804b0002;

        file.request.cancel(NS_BINDING_ABORTED);
    },

    // Support for xhr breakpoint conditions.
    onContextMenu: function(event)
    {
        if (!Css.hasClass(event.target, "sourceLine"))
            return;

        var row = Dom.getAncestorByClass(event.target, "netRow");
        if (!row)
            return;

        var file = row.repObject;
        var bp = this.context.netProgress.breakpoints.findBreakpoint(file.getFileURL());
        if (!bp)
            return;

        this.editBreakpointCondition(file);
        Events.cancelEvent(event);
    },

    editBreakpointCondition: function(file)
    {
        var bp = this.context.netProgress.breakpoints.findBreakpoint(file.getFileURL());
        if (!bp)
            return;

        var condition = bp ? bp.condition : "";

        this.selectedSourceBox = this.panelNode;
        Firebug.Editor.startEditing(file.row, condition);
    },

    getEditor: function(target, value)
    {
        if (!this.conditionEditor)
            this.conditionEditor = new Firebug.NetMonitor.ConditionEditor(this.document);

        return this.conditionEditor;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Activable Panel

    /**
     * Support for panel activation.
     */
    onActivationChanged: function(enable)
    {
        if (FBTrace.DBG_NET || FBTrace.DBG_ACTIVATION)
            FBTrace.sysout("net.NetPanel.onActivationChanged; enable: " + enable);

        if (enable)
        {
            Firebug.NetMonitor.addObserver(this);
            Firebug.TabCacheModel.addObserver(this);
        }
        else
        {
            Firebug.NetMonitor.removeObserver(this);
            Firebug.TabCacheModel.removeObserver(this);
        }
    },

    breakOnNext: function(breaking)
    {
        this.context.breakOnXHR = breaking;
    },

    shouldBreakOnNext: function()
    {
        return this.context.breakOnXHR;
    },

    getBreakOnNextTooltip: function(enabled)
    {
        return (enabled ? Locale.$STR("net.Disable Break On XHR") : Locale.$STR("net.Break On XHR"));
    },

    // Support for info tips.
    showInfoTip: function(infoTip, target, x, y)
    {
        var row = Dom.getAncestorByClass(target, "netRow");
        if (row && row.repObject)
        {
            if (Dom.getAncestorByClass(target, "netTotalSizeCol"))
            {
                var infoTipURL = "netTotalSize";
                if (infoTipURL == this.infoTipURL)
                    return true;

                this.infoTipURL = infoTipURL;
                return this.populateTotalSizeInfoTip(infoTip, row);
            }
            else if (Dom.getAncestorByClass(target, "netSizeCol"))
            {
                var infoTipURL = row.repObject.href + "-netsize";
                if (infoTipURL == this.infoTipURL && row.repObject == this.infoTipFile)
                    return true;

                this.infoTipURL = infoTipURL;
                this.infoTipFile = row.repObject;
                return this.populateSizeInfoTip(infoTip, row.repObject);
            }
            else if (Dom.getAncestorByClass(target, "netTimeCol"))
            {
                var infoTipURL = row.repObject.href + "-nettime";
                if (infoTipURL == this.infoTipURL && row.repObject == this.infoTipFile)
                    return true;

                this.infoTipURL = infoTipURL;
                this.infoTipFile = row.repObject;
                return this.populateTimeInfoTip(infoTip, row.repObject);
            }
            else if (Css.hasClass(row, "category-image") &&
                !Dom.getAncestorByClass(target, "netRowHeader"))
            {
                var infoTipURL = row.repObject.href + "-image";
                if (infoTipURL == this.infoTipURL)
                    return true;

                this.infoTipURL = infoTipURL;
                return CSSInfoTip.populateImageInfoTip(infoTip, row.repObject.href);
            }
        }

        delete this.infoTipURL;
        return false;
    },

    populateTimeInfoTip: function(infoTip, file)
    {
        return TimeInfoTip.render(this.context, file, infoTip);
    },

    populateSizeInfoTip: function(infoTip, file)
    {
        Firebug.NetMonitor.SizeInfoTip.render(file, infoTip);
        return true;
    },

    populateTotalSizeInfoTip: function(infoTip, row)
    {
        var totalSizeLabel = row.getElementsByClassName("netTotalSizeLabel").item(0);
        var file = {size: totalSizeLabel.getAttribute("totalSize")};
        Firebug.NetMonitor.SizeInfoTip.tag.replace({file: file}, infoTip);
        return true;
    },

    // Support for search within the panel.
    getSearchOptionsMenuItems: function()
    {
        return [
            Firebug.Search.searchOptionMenu("search.Case_Sensitive", "searchCaseSensitive",
                "search.tip.Case_Sensitive"),
            //Firebug.Search.searchOptionMenu("search.net.Headers", "netSearchHeaders"),
            //Firebug.Search.searchOptionMenu("search.net.Parameters", "netSearchParameters"),
            Firebug.Search.searchOptionMenu("search.Use_Regular_Expression",
                "searchUseRegularExpression", "search.tip.Use_Regular_Expression"),
            Firebug.Search.searchOptionMenu("search.net.Response_Bodies", "netSearchResponseBody",
                "search.net.tip.Response_Bodies")
        ];
    },

    search: function(text, reverse)
    {
        if (!text)
        {
            delete this.currentSearch;
            this.highlightNode(null);
            return false;
        }

        var row;
        if (this.currentSearch && text == this.currentSearch.text)
        {
            row = this.currentSearch.findNext(true, false, reverse, Firebug.Search.isCaseSensitive(text));
        }
        else
        {
            this.currentSearch = new NetPanelSearch(this);
            row = this.currentSearch.find(text, reverse, Firebug.Search.isCaseSensitive(text));
        }

        if (row)
        {
            var sel = this.document.defaultView.getSelection();
            sel.removeAllRanges();
            sel.addRange(this.currentSearch.range);

            Dom.scrollIntoCenterView(row, this.panelNode);
            if(this.currentSearch.shouldSearchResponses() &&
                Dom.getAncestorByClass(row, "netInfoResponseText"))
            {
                this.highlightNode(row);
            }
            else
            {
                this.highlightNode(Dom.getAncestorByClass(row, "netRow"));
            }
            Events.dispatch(this.fbListeners, 'onNetMatchFound', [this, text, row]);
            return true;
        }
        else
        {
            Events.dispatch(this.fbListeners, 'onNetMatchFound', [this, text, null]);
            return false;
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onFiltersSet: function(filterCategories)
    {
        this.setFilter(filterCategories);
        this.updateSummaries(NetUtils.now(), true);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    updateFile: function(file)
    {
        if (!file.invalid)
        {
            file.invalid = true;
            this.queue.push(file);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    updateLayout: function()
    {
        if (!this.queue.length)
            return;

        var rightNow = NetUtils.now();
        var length = this.queue.length;

        if (this.panelNode.offsetHeight)
            this.wasScrolledToBottom = Dom.isScrolledToBottom(this.panelNode);

        this.layout();

        if (this.wasScrolledToBottom)
            Dom.scrollToBottom(this.panelNode);

        this.updateHRefLabelWidth();

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.updateLayout; Layout done, time elapsed: " +
                Str.formatTime(NetUtils.now() - rightNow) + " (" + length + ")");
    },

    layout: function()
    {
        if (!this.queue.length || !this.context.netProgress ||
            !Firebug.NetMonitor.isAlwaysEnabled())
            return;

        this.initLayout();

        var rightNow = NetUtils.now();
        this.updateRowData(rightNow);
        this.updateLogLimit(Firebug.NetMonitor.maxQueueRequests);
        this.updateTimeline(rightNow);
        this.updateSummaries(rightNow);
    },

    initLayout: function()
    {
        if (!this.table)
        {
            var prefName = Options.prefDomain + ".net.logLimit";
            var config = {
                totalCount: 0,
                prefName: prefName,
                buttonTooltip: Locale.$STRF("LimitPrefsTitle", [prefName])
            };

            // Render notification box
            var limitBox = NetRequestTable.limitTag.append({}, this.panelNode);
            this.limitRow = PanelNotification.render(limitBox, config);

            // Render basic Net panel table (a row == one HTTP request)
            this.table = NetRequestTable.tableTag.append({}, this.panelNode);
            var tbody = this.table.querySelector(".netTableBody");

            // xxxHonza: Fake first row (shold be renamed, but it's a hack anyway).
            // There is no way to insert a row befor the current first row in a table.
            // See Domplate.insertRows() comment for more details.
            NetRequestEntry.footerTag.insertRows({}, tbody);

            // Render summary row
            this.summaryRow = NetRequestEntry.summaryTag.insertRows({}, tbody)[0];

            // Update visibility of columns according to the preferences
            var hiddenCols = Options.get("net.hiddenColumns");
            if (hiddenCols)
                this.table.setAttribute("hiddenCols", hiddenCols);

            this.updateBFCacheResponses();
        }
    },

    updateRowData: function(rightNow)
    {
        var queue = this.queue;
        this.queue = [];

        var phase;
        var newFileData = [];

        for (var i = 0; i < queue.length; ++i)
        {
            var file = queue[i];

            // xxxHonza: the entire phase management should ba part of NetPanel object
            if (!file.phase && this.context.netProgress)
                this.context.netProgress.extendPhase(file);

            if (!file.phase)
                continue;

            file.invalid = false;

            phase = this.calculateFileTimes(file, phase, rightNow);

            this.updateFileRow(file, newFileData);
            this.invalidatePhase(phase);
        }

        if (newFileData.length)
        {
            var tbody = this.table.querySelector(".netTableBody");
            var lastRow = this.summaryRow.previousSibling;
            this.insertRows(newFileData, lastRow);
        }
    },

    insertRows: function(files, lastRow)
    {
        var row = NetRequestEntry.fileTag.insertRows({files: files}, lastRow)[0];

        for (var i = 0; i < files.length; ++i)
        {
            var file = files[i].file;
            row.repObject = file;
            file.row = row;

            if (file.breakLayout)
                row.setAttribute("breakLayout", "true");

            // Make sure a breakpoint is displayed.
            var breakpoints = this.context.netProgress.breakpoints;
            if (breakpoints && breakpoints.findBreakpoint(file.getFileURL()))
                row.setAttribute("breakpoint", "true");

            // Allow customization of request entries in the list. A row is represented
            // by <TR> HTML element.
            Events.dispatch(NetRequestTable.fbListeners, "onCreateRequestEntry", [this, row]);

            row = row.nextSibling;
        }
    },

    invalidatePhase: function(phase)
    {
        if (phase && !phase.invalidPhase)
        {
            phase.invalidPhase = true;
            this.invalidPhases = true;
        }
    },

    updateFileRow: function(file, newFileData)
    {
        var row = file.row;
        if (!row)
        {
            newFileData.push({
                file: file,
                offset: this.barOffset + "%",
                width: this.barReceivingWidth + "%",
                elapsed: file.loaded ? this.elapsed : -1
            });
        }
        else
        {
            var sizeLabel = row.getElementsByClassName("netSizeLabel").item(0);

            var sizeText = NetRequestEntry.getSize(file);

            // Show also total downloaded size for requests in progress.
            if (file.totalReceived)
                sizeText += " (" + Str.formatSize(file.totalReceived) + ")";

            sizeLabel.firstChild.nodeValue = sizeText;

            var methodLabel = row.getElementsByClassName("netStatusLabel").item(0);
            methodLabel.firstChild.nodeValue = NetRequestEntry.getStatus(file);

            var hrefLabel = row.getElementsByClassName("netHrefLabel").item(0);
            hrefLabel.firstChild.nodeValue = NetRequestEntry.getHref(file);

            if (file.mimeType)
            {
                // Force update category.
                file.category = null;
                for (var category in NetUtils.fileCategories)
                    Css.removeClass(row, "category-" + category);
                Css.setClass(row, "category-" + NetUtils.getFileCategory(file));
            }

            var remoteIPLabel = row.querySelector(".netRemoteAddressCol .netAddressLabel");
            remoteIPLabel.textContent = NetRequestEntry.getRemoteAddress(file);

            var localIPLabel = row.querySelector(".netLocalAddressCol .netAddressLabel");
            localIPLabel.textContent = NetRequestEntry.getLocalAddress(file);

            if (file.requestHeaders)
                Css.setClass(row, "hasHeaders");

            if (file.fromCache)
                Css.setClass(row, "fromCache");
            else
                Css.removeClass(row, "fromCache");

            if (file.fromBFCache)
                Css.setClass(row, "fromBFCache");
            else
                Css.removeClass(row, "fromBFCache");

            if (NetRequestEntry.isError(file))
                Css.setClass(row, "responseError");
            else
                Css.removeClass(row, "responseError");

            var netBar = Dom.getChildByClass(row, "netTimeCol").childNodes[1];
            var timeLabel = Dom.getChildByClass(netBar, "netReceivingBar").firstChild;
            timeLabel.textContent = NetRequestEntry.getElapsedTime({elapsed: this.elapsed});

            if (file.loaded)
                Css.setClass(row, "loaded");
            else
                Css.removeClass(row, "loaded");

            if (Css.hasClass(row, "opened"))
            {
                var netInfoBox = row.nextSibling.getElementsByClassName("netInfoBody").item(0);
                Firebug.NetMonitor.NetInfoBody.updateInfo(netInfoBox, file, this.context);
            }
        }
    },

    updateTimeline: function(rightNow)
    {
        var tbody = this.table.querySelector(".netTableBody");

        // XXXjoe Don't update rows whose phase is done and layed out already
        var phase;
        for (var row = tbody.firstChild; row; row = row.nextSibling)
        {
            var file = row.repObject;

            // Some rows aren't associated with a file (e.g. header, sumarry).
            if (!file)
                continue;

            if (!file.loaded)
                continue;

            phase = this.calculateFileTimes(file, phase, rightNow);

            // Parent node for all timing bars.
            var netBar = row.querySelector(".netBar");

            // Get bar nodes
            var blockingBar = netBar.childNodes[1];
            var resolvingBar = blockingBar.nextSibling;
            var connectingBar = resolvingBar.nextSibling;
            var sendingBar = connectingBar.nextSibling;
            var waitingBar = sendingBar.nextSibling;
            var receivingBar = waitingBar.nextSibling;

            // All bars starts at the beginning
            resolvingBar.style.left = connectingBar.style.left = sendingBar.style.left =
                blockingBar.style.left =
                waitingBar.style.left = receivingBar.style.left = this.barOffset + "%";

            // Sets width of all bars (using style). The width is computed according to measured timing.
            blockingBar.style.width = this.barBlockingWidth + "%";
            resolvingBar.style.width = this.barResolvingWidth + "%";
            connectingBar.style.width = this.barConnectingWidth + "%";
            sendingBar.style.width = this.barSendingWidth + "%";
            waitingBar.style.width = this.barWaitingWidth + "%";
            receivingBar.style.width = this.barReceivingWidth + "%";

            // Remove existing bars
            var bars = netBar.querySelectorAll(".netPageTimingBar");
            for (var i=0; i<bars.length; i++)
                bars[i].parentNode.removeChild(bars[i]);

            // Generate UI for page timings (vertical lines displayed for the first phase)
            for (var i=0; i<phase.timeStamps.length; i++)
            {
                var timing = phase.timeStamps[i];
                if (!timing.offset)
                    continue;

                var bar = netBar.ownerDocument.createElement("DIV");
                netBar.appendChild(bar);

                if (timing.classes)
                    Css.setClass(bar, timing.classes);

                Css.setClass(bar, "netPageTimingBar");

                bar.style.left = timing.offset + "%";
                bar.style.display = "block";
            }
        }
    },

    calculateFileTimes: function(file, phase, rightNow)
    {
        var phases = this.context.netProgress.phases;

        if (phase != file.phase)
        {
            phase = file.phase;
            this.phaseStartTime = phase.startTime;
            this.phaseEndTime = phase.endTime ? phase.endTime : rightNow;

            // End of the first phase has to respect even the window "onload" event time, which
            // can occur after the last received file. This sets the extent of the timeline so,
            // the windowLoadBar is visible.
            if (phase.windowLoadTime && this.phaseEndTime < phase.windowLoadTime)
                this.phaseEndTime = phase.windowLoadTime;

            this.phaseElapsed = this.phaseEndTime - phase.startTime;
        }

        var elapsed = file.loaded ? file.endTime - file.startTime : 0; /*this.phaseEndTime - file.startTime*/
        this.barOffset = Math.floor(((file.startTime-this.phaseStartTime)/this.phaseElapsed) * 100);

        //Helper log for debugging timing problems.
        //NetUtils.traceRequestTiming("net.calculateFileTimes;", file);

        var blockingEnd = NetUtils.getBlockingEndTime(file);
        this.barBlockingWidth = Math.round(((blockingEnd - file.startTime) / this.phaseElapsed) * 100);
        this.barResolvingWidth = Math.round(((file.connectingTime - file.startTime) / this.phaseElapsed) * 100);
        this.barConnectingWidth = Math.round(((file.sendingTime - file.startTime) / this.phaseElapsed) * 100);
        this.barSendingWidth = Math.round(((file.waitingForTime - file.startTime) / this.phaseElapsed) * 100);
        this.barWaitingWidth = Math.round(((file.respondedTime - file.startTime) / this.phaseElapsed) * 100);
        this.barReceivingWidth = Math.round((elapsed / this.phaseElapsed) * 100);

        // Total request time doesn't include the time spent in queue.
        // xxxHonza: since all phases are now graphically distinguished it's easy to
        // see blocking requests. It's make sense to display the real total time now.
        this.elapsed = elapsed/* - (file.sendingTime - file.connectedTime)*/;

        // The nspr timer doesn't have 1ms precision, so it can happen that entire
        // request is executed in l ms (so the total is zero). Let's display at least
        // one bar in such a case so the timeline is visible.
        if (this.elapsed <= 0)
            this.barReceivingWidth = "1";

        // Compute also offset for page timings, e.g.: contentLoadBar and windowLoadBar,
        // which are displayed for the first phase. This is done only if a page exists.
        this.calculateTimeStamps(file, phase);

        return phase;
    },

    calculateTimeStamps: function(file, phase)
    {
        // Iterate all time stamps for the current phase and calculate offsets (from the
        // beginning of the waterfall graphs) for the vertical lines.
        for (var i=0; i<phase.timeStamps.length; i++)
        {
            var timeStamp = phase.timeStamps[i];
            var time = timeStamp.time;

            if (time > 0)
            {
                var offset = (((time - this.phaseStartTime)/this.phaseElapsed) * 100).toFixed(3);
                timeStamp.offset = offset;
            }
         }
    },

    updateSummaries: function(rightNow, updateAll)
    {
        if (!this.invalidPhases && !updateAll)
            return;

        this.invalidPhases = false;

        var phases = this.context.netProgress.phases;
        if (!phases.length)
            return;

        var fileCount = 0, totalSize = 0, cachedSize = 0, totalTime = 0;
        for (var i = 0; i < phases.length; ++i)
        {
            var phase = phases[i];
            phase.invalidPhase = false;

            var summary = this.summarizePhase(phase, rightNow);
            fileCount += summary.fileCount;
            totalSize += summary.totalSize;
            cachedSize += summary.cachedSize;
            totalTime += summary.totalTime;
        }

        var row = this.summaryRow;
        if (!row)
            return;

        var countLabel = row.getElementsByClassName("netCountLabel").item(0); //childNodes[1].firstChild;
        countLabel.textContent = Locale.$STRP("plural.Request_Count2", [fileCount]);

        var sizeLabel = row.getElementsByClassName("netTotalSizeLabel").item(0); //childNodes[4].firstChild;
        sizeLabel.setAttribute("totalSize", totalSize);
        sizeLabel.textContent = NetRequestEntry.formatSize(totalSize);

        var cacheSizeLabel = row.getElementsByClassName("netCacheSizeLabel").item(0);
        cacheSizeLabel.setAttribute("collapsed", cachedSize == 0);
        cacheSizeLabel.textContent = "(" + Locale.$STRF("net.summary.from_cache",
            [NetRequestEntry.formatSize(cachedSize)]) + ")";

        var timeLabel = row.getElementsByClassName("netTotalTimeLabel").item(0);
        var timeText = NetRequestEntry.formatTime(totalTime);
        var firstPhase = phases[0];
        if (firstPhase.windowLoadTime)
        {
            var loadTime = firstPhase.windowLoadTime - firstPhase.startTime;
            timeText += " (onload: " + NetRequestEntry.formatTime(loadTime) + ")";
        }

        timeLabel.textContent = timeText;
    },

    summarizePhase: function(phase, rightNow)
    {
        var cachedSize = 0, totalSize = 0;

        var categories = this.filterCategories;
        if (categories == "all")
            categories = null;

        var fileCount = 0;
        var minTime = 0, maxTime = 0;

        for (var i=0; i<phase.files.length; i++)
        {
            var file = phase.files[i];

            // Do not count BFCache responses if the user says so.
            if (!Firebug.netShowBFCacheResponses && file.fromBFCache)
                continue;

            if (!categories || categories.indexOf(file.category) != -1)
            {
                if (file.loaded)
                {
                    ++fileCount;

                    if (file.size > 0)
                    {
                        totalSize += file.size;
                        if (file.fromCache)
                            cachedSize += file.size;
                    }

                    if (!minTime || file.startTime < minTime)
                        minTime = file.startTime;
                    if (file.endTime > maxTime)
                        maxTime = file.endTime;
                }
            }
        }

        var totalTime = maxTime - minTime;
        return {cachedSize: cachedSize, totalSize: totalSize, totalTime: totalTime,
                fileCount: fileCount};
    },

    updateLogLimit: function(limit)
    {
        var netProgress = this.context.netProgress;

        if (!netProgress)  // XXXjjb Honza, please check, I guess we are getting here with the context not setup
        {
            if (FBTrace.DBG_NET)
                FBTrace.sysout("net.updateLogLimit; NO NET CONTEXT for: " + this.context.getName());
            return;
        }

        // Must be positive number;
        limit = Math.max(0, limit);

        var filesLength = netProgress.files.length;
        if (!filesLength || filesLength <= limit)
            return;

        // Remove old requests.
        var removeCount = Math.max(0, filesLength - limit);
        for (var i=0; i<removeCount; i++)
        {
            var file = netProgress.files[0];
            this.removeLogEntry(file);

            // Remove the file occurrence from the queue.
            for (var j=0; j<this.queue.length; j++)
            {
                if (this.queue[j] == file) {
                    this.queue.splice(j, 1);
                    j--;
                }
            }
        }
    },

    removeLogEntry: function(file, noInfo)
    {
        // Remove associated row-entry from the UI before the removeFile method
        // is called (and file.row erased).
        if (this.table)
        {
            var tbody = this.table.querySelector(".netTableBody");
            if (tbody && file.row)
                tbody.removeChild(file.row);
        }

        if (!this.removeFile(file))
            return;

        if (!this.table)
            return;

        var tbody = this.table.querySelector(".netTableBody");
        if (!tbody)
            return;

        if (noInfo || !this.limitRow)
            return;

        this.limitRow.config.totalCount++;

        PanelNotification.updateCounter(this.limitRow);

        //if (netProgress.currentPhase == file.phase)
        //  netProgress.currentPhase = null;
    },

    removeFile: function(file)
    {
        var netProgress = this.context.netProgress;
        var index = netProgress.files.indexOf(file);
        if (index == -1)
            return false;

        netProgress.files.splice(index, 1);
        netProgress.requests.splice(index, 1);

        // Don't forget to remove the phase whose last file has been removed.
        var phase = file.phase;

        // xxxHonza: This needs to be examined yet. Looks like the queue contains
        // requests from the previous page. When flushed the requestedFile isn't called
        // and the phase is not set.
        if (!phase)
            return true;

        phase.removeFile(file);
        if (!phase.files.length)
        {
            Arr.remove(netProgress.phases, phase);

            if (netProgress.currentPhase == phase)
                netProgress.currentPhase = null;
        }

        file.clear();

        return true;
    },

    insertActivationMessage: function()
    {
        if (!Firebug.NetMonitor.isAlwaysEnabled())
            return;

        // Make sure the basic structure of the table panel is there.
        this.initLayout();

        // Bail out if the activation message is already there.
        if (this.table.querySelector(".netActivationRow"))
            return;

        // Insert activation message
        var lastRow = this.summaryRow.previousSibling;
        NetRequestEntry.activationTag.insertRows({}, lastRow)[0];

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.insertActivationMessage; " + this.context.getName());
    },

    enumerateRequests: function(fn)
    {
        if (!this.table)
            return;

        var rows = this.table.getElementsByClassName("netRow");
        for (var i=0; i<rows.length; i++)
        {
            var row = rows[i];
            var pageRow = Css.hasClass(row, "netPageRow");

            if (Css.hasClass(row, "collapsed") && !pageRow)
                continue;

            if (Css.hasClass(row, "history"))
                continue;

            // Export also history. These requests can be collapsed and so not visible.
            if (row.files)
            {
                for (var j=0; j<row.files.length; j++)
                    fn(row.files[j].file);
            }

            var file = Firebug.getRepObject(row);
            if (file)
                fn(file);
        }
    },

    setFilter: function(filterCategories)
    {
        this.filterCategories = filterCategories;

        var panelNode = this.panelNode;
        for (var category in NetUtils.fileCategories)
        {
            if (filterCategories.join(" ") != "all" && filterCategories.indexOf(category) == -1)
                Css.setClass(panelNode, "hideCategory-" + category);
            else
                Css.removeClass(panelNode, "hideCategory-" + category);
        }
    },

    clear: function()
    {
        Dom.clearNode(this.panelNode);

        this.table = null;
        this.summaryRow = null;
        this.limitRow = null;

        this.queue = [];
        this.invalidPhases = false;

        if (this.context.netProgress)
            this.context.netProgress.clear();

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.panel.clear; " + this.context.getName());
    },

    onResize: function()
    {
        this.updateHRefLabelWidth();
    },

    updateHRefLabelWidth: function()
    {
        if (!this.table)
            return;

        // Update max-width of the netHrefLabel according to the width of the parent column.
        // I don't know if there is a way to do this in Css.
        // See Issue 3633: Truncated URLs in net panel
        var netHrefCol = this.table.querySelector("#netHrefCol");
        var hrefLabel = this.table.querySelector(".netHrefLabel");

        if (!hrefLabel)
            return;

        if (!Firebug.currentContext)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("net.updateHRefLabelWidth; Firebug.currentContext == NULL");
            return;
        }

        var maxWidth = netHrefCol.clientWidth;

        var rules = Dom.domUtils.getCSSStyleRules(hrefLabel);
        for (var i = 0; i < rules.Count(); ++i)
        {
            var rule = Xpcom.QI(rules.GetElementAt(i), Ci.nsIDOMCSSStyleRule);
            if (rule.selectorText == ".netHrefLabel")
            {
                var style = rule.style;
                var paddingLeft = parseInt(style.getPropertyValue("padding-left"));
                if (maxWidth == 0)
                    style.setProperty("max-width", "15%", "");
                else
                    style.setProperty("max-width", (maxWidth - paddingLeft) + "px", "");
                break;
            }
        }
    },
});

// ********************************************************************************************* //

/**
 * Use this object to automatically select Net panel and inspect a network request.
 * Firebug.chrome.select(new Firebug.NetMonitor.NetFileLink(url [, request]));
 */
Firebug.NetMonitor.NetFileLink = function(href, request)
{
    this.href = href;
    this.request = request;
};

Firebug.NetMonitor.NetFileLink.prototype =
{
    toString: function()
    {
        return this.message + this.href;
    }
};

// ********************************************************************************************* //

var NetPanelSearch = function(panel, rowFinder)
{
    var panelNode = panel.panelNode;
    var doc = panelNode.ownerDocument;
    var searchRange, startPt;

    // Common search object methods.
    this.find = function(text, reverse, caseSensitive)
    {
        this.text = text;

        Search.finder.findBackwards = !!reverse;
        Search.finder.caseSensitive = !!caseSensitive;

        this.currentRow = this.getFirstRow();
        this.resetRange();

        return this.findNext(false, false, reverse, caseSensitive);
    };

    this.findNext = function(wrapAround, sameNode, reverse, caseSensitive)
    {
        while (this.currentRow)
        {
            var match = this.findNextInRange(reverse, caseSensitive);
            if (match)
                return match;

            if (this.shouldSearchResponses())
                this.findNextInResponse(reverse, caseSensitive);

            this.currentRow = this.getNextRow(wrapAround, reverse);

            if (this.currentRow)
                this.resetRange();
        }
    };

    // Internal search helpers.
    this.findNextInRange = function(reverse, caseSensitive)
    {
        if (this.range)
        {
            startPt = doc.createRange();
            if (reverse)
                startPt.setStartBefore(this.currentNode);
            else
                startPt.setStart(this.currentNode, this.range.endOffset);

            this.range = Search.finder.Find(this.text, searchRange, startPt, searchRange);
            if (this.range)
            {
                this.currentNode = this.range ? this.range.startContainer : null;
                return this.currentNode ? this.currentNode.parentNode : null;
            }
        }

        if (this.currentNode)
        {
            startPt = doc.createRange();
            if (reverse)
                startPt.setStartBefore(this.currentNode);
            else
                startPt.setStartAfter(this.currentNode);
        }

        this.range = Search.finder.Find(this.text, searchRange, startPt, searchRange);
        this.currentNode = this.range ? this.range.startContainer : null;
        return this.currentNode ? this.currentNode.parentNode : null;
    },

    this.findNextInResponse = function(reverse, caseSensitive)
    {
        var file = Firebug.getRepObject(this.currentRow);
        if (!file)
            return;

        var scanRE = Firebug.Search.getTestingRegex(this.text);
        if (scanRE.test(file.responseText))
        {
            if (!Css.hasClass(this.currentRow, "opened"))
                NetRequestEntry.toggleHeadersRow(this.currentRow);

            var netInfoRow = this.currentRow.nextSibling;
            var netInfoBox = netInfoRow.getElementsByClassName("netInfoBody").item(0);
            Firebug.NetMonitor.NetInfoBody.selectTabByName(netInfoBox, "Response");

            // Before the search is started, the new content must be properly
            // re-layouted within the page. The layout is executed by reading
            // the following property.
            // xxxHonza: Force layout to be executed (workaround)
            // This workaround can be removed as soon as #488427 is fixed.
            doc.body.offsetWidth;
        }
    },

    // Helpers
    this.resetRange = function()
    {
        searchRange = doc.createRange();
        searchRange.setStart(this.currentRow, 0);
        searchRange.setEnd(this.currentRow, this.currentRow.childNodes.length);

        startPt = searchRange;
    };

    this.getFirstRow = function()
    {
        var table = panelNode.getElementsByClassName("netTable").item(0);
        return table.querySelector(".netTableBody").firstChild;
    };

    this.getNextRow = function(wrapAround, reverse)
    {
        // xxxHonza: reverse searching missing.
        for (var sib = this.currentRow.nextSibling; sib; sib = sib.nextSibling)
        {
            if (this.shouldSearchResponses())
                return sib;
            else if (Css.hasClass(sib, "netRow"))
                return sib;
        }

        return wrapAround ? this.getFirstRow() : null;
    };

    this.shouldSearchResponses = function()
    {
        return Firebug["netSearchResponseBody"];
    };
};

// ********************************************************************************************* //

Firebug.NetMonitor.ConditionEditor = function(doc)
{
    Firebug.Breakpoint.ConditionEditor.apply(this, arguments);
};

Firebug.NetMonitor.ConditionEditor.prototype = domplate(Firebug.Breakpoint.ConditionEditor.prototype,
{
    endEditing: function(target, value, cancel)
    {
        if (cancel)
            return;

        var file = target.repObject;
        var panel = Firebug.getElementPanel(target);
        var bp = panel.context.netProgress.breakpoints.findBreakpoint(file.getFileURL());
        if (bp)
            bp.condition = value;
    }
});

// ********************************************************************************************* //
// Browser Cache

Firebug.NetMonitor.BrowserCache =
{
    cacheDomain: "browser.cache",

    isEnabled: function()
    {
        var diskCache = Options.getPref(this.cacheDomain, "disk.enable");
        var memoryCache = Options.getPref(this.cacheDomain, "memory.enable");
        return diskCache && memoryCache;
    },

    toggle: function(state)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.BrowserCache.toggle; " + state);

        Options.setPref(this.cacheDomain, "disk.enable", state);
        Options.setPref(this.cacheDomain, "memory.enable", state);
    }
};

// ********************************************************************************************* //
// Registration

Firebug.registerPanel(NetPanel);

return Firebug.NetMonitor;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/netProgress",
[
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/js/sourceLink",
    "firebug/lib/http",
    "firebug/lib/css",
    "firebug/chrome/window",
    "firebug/lib/string",
    "firebug/lib/array",
    "firebug/lib/system",
    "firebug/net/netUtils"
],
function(Obj, Firebug, Locale, Events, Url, SourceLink, Http, Css, Win, Str,
    Arr, System, NetUtils) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

const reIgnore = /about:|javascript:|resource:|chrome:|jar:/;
const reResponseStatus = /HTTP\/1\.\d\s(\d+)\s(.*)/;

var panelName = "net";

// ********************************************************************************************* //
// Net Progress

function NetProgress(context)
{
    if (FBTrace.DBG_NET)
        FBTrace.sysout("net.NetProgress.constructor; " +
            (context ? context.getName() : "NULL Context"));

    this.context = context;

    var panel = null;
    var queue = [];

    this.post = function(handler, args)
    {
        if (panel)
        {
            var file = handler.apply(this, args);
            if (file)
            {
                panel.updateFile(file);

                // If the panel isn't currently visible, make sure the limit is up to date.
                if (!panel.layoutInterval)
                    panel.updateLogLimit(Firebug.NetMonitor.maxQueueRequests);

                return file;
            }
        }
        else
        {
            // The first page request is made before the initContext (known problem).
            queue.push(handler, args);
        }
    };

    this.flush = function()
    {
        for (var i=0; i<queue.length; i+=2)
            this.post(queue[i], queue[i+1]);

        queue = [];
    };

    this.activate = function(activePanel)
    {
        this.panel = panel = activePanel;
        if (panel)
            this.flush();
    };

    this.update = function(file)
    {
        if (panel)
            panel.updateFile(file);
    };

    this.clear = function()
    {
        for (var i=0; this.files && i<this.files.length; i++)
            this.files[i].clear();

        this.requests = [];
        this.files = [];
        this.phases = [];
        this.documents = [];
        this.windows = [];
        this.currentPhase = null;

        queue = [];
    };

    this.clear();
}

NetProgress.prototype =
{
    dispatchName: "netProgress",
    panel: null,

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    requestNumber: 1,

    openingFile: function openingFile(request, win)
    {
        var file = this.getRequestFile(request, win);
        if (file)
        {
            // Parse URL params so, they are available for conditional breakpoints.
            file.urlParams = Url.parseURLParams(file.href);
            this.breakOnXHR(file);
        }
    },

    startFile: function startFile(request, win)
    {
        // Called asynchronously since Fx17, so can't be used for Break on XHR,
        // since JS stack is not available at the moment.
        // See https://bugzilla.mozilla.org/show_bug.cgi?id=800799
    },

    requestedHeaderFile: function requestedHeaderFile(request, time, win, xhr, extraStringData)
    {
        var file = this.getRequestFile(request);
        if (file)
        {
            logTime(file, "requestedHeaderFile", time);

            file.requestHeadersText = extraStringData;

            this.requestedFile(request, time, win, xhr);

            Events.dispatch(Firebug.NetMonitor.fbListeners, "onRequest", [this.context, file]);
        }
    },

    // Can be called from onModifyRequest (to catch request start even in case of BF cache) and also
    // from requestHeaderFile (activity observer)
    requestedFile: function requestedFile(request, time, win, xhr)
    {
        var file = this.getRequestFile(request, win);
        if (file)
        {
            logTime(file, "requestedFile", time);

            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.events.requestedFile +0 " + getPrintableTime() + ", " +
                    request.URI.path, file);

            // For cached image files, we may never hear another peep from any observers
            // after this point, so we have to assume that the file is cached and loaded
            // until we get a respondedFile call later
            file.startTime = file.endTime = time;
            file.resolvingTime = time;
            file.connectingTime = time;
            file.connectedTime = time;
            file.sendingTime = time;
            file.waitingForTime = time;
            file.respondedTime = time;
            file.isXHR = xhr;
            file.isBackground = request.loadFlags & Ci.nsIRequest.LOAD_BACKGROUND;
            file.method = request.requestMethod;

            if (!Ci.nsIHttpActivityDistributor)
                NetUtils.getPostText(file, this.context);

            this.extendPhase(file);

            return file;
        }
        else
        {
            if (FBTrace.DBG_NET)
                FBTrace.sysout("net.requestedFile no file for request=");
        }
    },

    breakOnXHR: function breakOnXHR(file)
    {
        var halt = false;
        var conditionIsFalse = false;

        // If there is an enabled breakpoint with condition:
        // 1) break if the condition is evaluated to true.
        var breakpoints = this.context.netProgress.breakpoints;
        var bp = breakpoints ? breakpoints.findBreakpoint(file.getFileURL()) : null;
        if (bp && bp.checked)
        {
            halt = true;
            if (bp.condition)
            {
                halt = bp.evaluateCondition(this.context, file);
                conditionIsFalse = !halt;
            }
        }

        // 2) If break on XHR flag is set and there is no condition evaluated to false,
        // break with "break on next" breaking cause (this new breaking cause can override
        // an existing one that is set when evaluating a breakpoint condition).
        if (this.context.breakOnXHR && !conditionIsFalse)
        {
            this.context.breakingCause = {
                title: Locale.$STR("net.Break On XHR"),
                message: Str.cropString(file.href, 200),
                copyAction: Obj.bindFixed(System.copyToClipboard, System, file.href)
            };

            halt = true;
        }

        // Ignore if there is no reason to break.
        if (!halt)
            return;

        // Even if the execution was stopped at breakpoint reset the global
        // breakOnXHR flag.
        this.context.breakOnXHR = false;

        Firebug.Breakpoint.breakNow(this.context.getPanel(panelName, true));
    },

    respondedHeaderFile: function respondedHeaderFile(request, time, extraStringData)
    {
        var file = this.getRequestFile(request);
        if (file)
        {
            logTime(file, "respondedHeaderFile", time);

            file.responseHeadersText = extraStringData;
        }
    },

    bodySentFile: function bodySentFile(request, time)
    {
        var file = this.getRequestFile(request);
        if (file)
        {
            logTime(file, "bodySentFile", time);

            NetUtils.getPostText(file, this.context);
        }
    },

    responseStartedFile: function responseStartedFile(request, time)
    {
        var file = this.getRequestFile(request);
        if (file)
        {
            logTime(file, "responseStartedFile", time);

            if (!file.responseStarted)
            {
                file.respondedTime = time;
                file.responseStarted = true;
            }

            file.endTime = time;
            return file;
        }
    },

    respondedFile: function respondedFile(request, time, info)
    {
        Events.dispatch(Firebug.NetMonitor.fbListeners, "onExamineResponse", [this.context, request]);

        var file = this.getRequestFile(request);
        if (file)
        {
            logTime(file, "respondedFile", time);

            if (!Ci.nsIHttpActivityDistributor)
            {
                file.respondedTime = time;
                file.endTime = time;

                if (request.contentLength >= 0)
                    file.size = request.contentLength;
            }

            if (info)
            {
                if (info.responseStatus == 304)
                    file.fromCache = true;
                else if (!file.fromCache)
                    file.fromCache = false;
            }

            // respondedFile can be executed asynchronously and getting headers now
            // could be too late. They could be already replaced by cached headers.
            if (info.responseHeaders)
                file.responseHeaders = info.responseHeaders;

            // Get also request headers (and perhaps also responseHeaders, they won't be
            // replaced if already available).
            NetUtils.getHttpHeaders(request, file, this.context);

            if (info)
            {
                file.responseStatus = info.responseStatus;
                file.responseStatusText = info.responseStatusText;
                file.postText = info.postText;
            }

            file.aborted = false;

            // Use ACTIVITY_SUBTYPE_RESPONSE_COMPLETE to get the info if possible.
            if (!Ci.nsIHttpActivityDistributor)
            {
                if (file.fromCache)
                    getCacheEntry(file, this);
            }

            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.events.respondedFile +" + (NetUtils.now() - file.startTime) + " " +
                     getPrintableTime() + ", " + request.URI.path, file);

            // The ACTIVITY_SUBTYPE_TRANSACTION_CLOSE could come earlier.
            if (file.loaded)
                return;

            this.endLoad(file);

            // If there is a network error, log it into the Console panel.
            if (Firebug.showNetworkErrors && Firebug.NetMonitor.NetRequestEntry.isError(file))
            {
                Firebug.Errors.increaseCount(this.context);
                var message = "NetworkError: " + Firebug.NetMonitor.NetRequestEntry.getStatus(file) + " - "+file.href;
                Firebug.Console.log(message, this.context, "error", null, true, file.getFileLink(message));
            }

            Events.dispatch(Firebug.NetMonitor.fbListeners, "onResponse", [this.context, file]);
            return file;
        }
    },

    respondedCacheFile: function respondedCacheFile(request, time, info)
    {
        Events.dispatch(Firebug.NetMonitor.fbListeners, "onExamineCachedResponse",
            [this.context, request]);

        var file = this.getRequestFile(request, null, true);
        if (file)
        {
            logTime(file, "respondedCacheFile", time);

            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.events.respondedCacheFile +" + (NetUtils.now() - file.startTime) + " " +
                     getPrintableTime() + ", " + request.URI.path, file);

            // on-examine-cache-response is using different timer, do not track response
            // times from the cache and use the proper waiting time.
            if (file.waitingStarted)
                time = file.waitingForTime;

            if (!file.responseStarted)
            {
                file.respondedTime = time;
                file.responseStarted = true;
            }

            file.endTime = time;
            file.fromBFCache = true;
            file.fromCache = true;
            file.aborted = false;

            try
            {
                if (request instanceof Ci.nsIApplicationCacheChannel)
                {
                    if (request.loadedFromApplicationCache)
                        file.fromAppCache = true;
                }
            }
            catch (e)
            {
                if (FBTrace.DBG_ERRORS)
                    FBTrace.sysout("net.respondedCacheFile ERROR " + e, e);
            }

            if (request.contentLength >= 0)
                file.size = request.contentLength;

            NetUtils.getHttpHeaders(request, file, this.context);

            if (info)
            {
                file.responseStatus = info.responseStatus;
                file.responseStatusText = info.responseStatusText;
                file.postText = info.postText;
            }

            getCacheEntry(file, this);

            this.endLoad(file);

            Events.dispatch(Firebug.NetMonitor.fbListeners, "onCachedResponse",
                [this.context, file]);

            return file;
        }
        else
        {
            if (FBTrace.DBG_NET)
                FBTrace.sysout("net.respondedCacheFile; NO FILE FOR " +
                    Http.safeGetRequestName(request));
        }
    },

    waitingForFile: function waitingForFile(request, time)
    {
        var file = this.getRequestFile(request, null, true);
        if (file)
        {
            logTime(file, "waitingForFile", time);

            if (!file.waitingStarted)
            {
                file.waitingForTime = time;
                file.waitingStarted = true;
            }
        }

        // Don't update the UI now (optimization).
        return null;
    },

    sendingFile: function sendingFile(request, time, size)
    {
        var file = this.getRequestFile(request, null, true);
        if (file)
        {
            logTime(file, "sendingFile", time);

            // Remember when the send started.
            if (!file.sendStarted)
            {
                file.sendingTime = time;
                file.waitingForTime = time; // in case waiting-for would never came.
                file.sendStarted = true;
            }

            // Catch 2.
            // It can happen that "connected" event sometimes comes after sending,
            // which doesn't make much sense (Firefox bug?)
            if (!file.connected)
            {
                file.connected = true;
                file.connectedTime = time;
            }

            file.totalSent = size;

            // Catch 1.
            // Request is sending so reset following flags. There are cases where
            // RESPONSE_COMPLETE and TRANSACTION_CLOSE came in the middle of
            // connetion initialization (resolving, connecting, connected).
            file.loaded = false;
            file.responseStarted = false;

            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.events.sendingFile +" + (NetUtils.now() - file.startTime) + " " +
                     getPrintableTime() + ", " + request.URI.path, file);
        }

        // Don't update the UI now (optimization).
        return null;
    },

    connectingFile: function connectingFile(request, time)
    {
        var file = this.getRequestFile(request, null, true);

        logTime(file, "connectingFile", time);

        // Resolving, connecting and connected can come after the file is loaded
        // (closedFile received). This happens if the response is coming from the
        // cache. Just ignore it.
        if (file && file.loaded)
            return null;

        if (file && !file.connectStarted)
        {
            file.connectStarted = true;
            file.connectingTime = time;
            file.connectedTime = time; // in case connected-to would never came.
            file.sendingTime = time;  // in case sending-to would never came.
            file.waitingForTime = time; // in case waiting-for would never came.
        }

        // Don't update the UI now (optimization).
        return null;
    },

    connectedFile: function connectedFile(request, time)
    {
        var file = this.getRequestFile(request, null, true);

        logTime(file, "connectedFile", time);

        if (file && file.loaded)
            return null;

        if (file && !file.connected)
        {
            file.connected = true;
            file.connectedTime = time;
            file.sendingTime = time;  // in case sending-to would never came.
            file.waitingForTime = time; // in case waiting-for would never came.
        }

        // Don't update the UI now (optimization).
        return null;
    },

    receivingFile: function receivingFile(request, time, size)
    {
        var file = this.getRequestFile(request, null, true);
        if (file)
        {
            logTime(file, "receivingFile", time);

            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.events.receivingFile +" + time + " " +
                    getPrintableTime() + ", " +
                    Str.formatSize(size) + " (" + size + "B), " +
                    request.URI.path, file);

            file.endTime = time;
            file.totalReceived = size;

            // Update phase's lastFinishedFile in case of long time downloads.
            // This forces the timeline to have proper extent.
            if (file.phase && file.phase.endTime < time)
                file.phase.lastFinishedFile = file;

            // Force update UI.
            if (file.row && Css.hasClass(file.row, "opened"))
            {
                var netInfoBox = file.row.nextSibling.getElementsByClassName("netInfoBody").item(0);
                if (netInfoBox)
                {
                    netInfoBox.responsePresented = false;
                    netInfoBox.htmlPresented = false;
                }
            }
        }

        return file;
    },

    responseCompletedFile: function responseCompletedFile(request, time, responseSize)
    {
        var file = this.getRequestFile(request, null, true);
        if (file)
        {
            logTime(file, "responseCompletedFile", time);

            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.events.responseCompletedFile +" + time + " " +
                    getPrintableTime() + ", " + request.URI.path, file);

            if (responseSize >= 0)
                file.size = responseSize;

            // This was only a helper to show download progress.
            file.totalReceived = 0;

            // The request is completed, get cache entry.
            getCacheEntry(file, this);

            // Sometimes the HTTP-ON-EXAMINE-RESPONSE doesn't come.
            if (!file.loaded  && file.responseHeadersText)
            {
                var info = null;
                var m = file.responseHeadersText.match(reResponseStatus);
                if (m.length == 3)
                    info = {responseStatus: m[1], responseStatusText: m[2]};
                this.respondedFile(request, NetUtils.now(), info);
            }

            this.updateIPInfo(request, file);
        }

        return file;
    },

    closedFile: function closedFile(request, time)
    {
        var file = this.getRequestFile(request, null, true);
        if (file)
        {
            logTime(file, "closedFile", time);

            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.events.closedFile +" + time + " " +
                    getPrintableTime() + ", " + request.URI.path);

            // If the response never came, stop the loading and set time info.
            // In this case the request is marked with "Timeout" and the
            // respondedTime is set to the time when ACTIVITY_SUBTYPE_TRANSACTION_CLOSE
            // is received (after timeout).
            // If file.responseHeadersText is null the response didn't come.
            if (!file.loaded && !file.responseHeadersText)
            {
                if (FBTrace.DBG_NET_EVENTS)
                    FBTrace.sysout("net.events; TIMEOUT " + Http.safeGetRequestName(request));

                this.endLoad(file);

                file.aborted = true;
                if (!file.responseStatusText)
                    file.responseStatusText = "Aborted";

                if (!file.responseStarted)
                {
                    file.respondedTime = time;
                    file.responseStarted = true;
                }

                file.endTime = time;
            }
        }

        return file;
    },

    resolvingFile: function resolvingFile(request, time)
    {
        var file = this.getRequestFile(request, null, true);

        if (file)
            logTime(file, "resolvingFile", time);

        if (file && file.loaded)
            return null;

        if (file && !file.resolveStarted)
        {
            file.resolveStarted = true;
            file.resolvingTime = time;
            file.connectingTime = time; // in case connecting would never came.
            file.connectedTime = time; // in case connected-to would never came.
            file.sendingTime = time;  // in case sending-to would never came.
            file.waitingForTime = time; // in case waiting-for would never came.
        }

        return file;
    },

    resolvedFile: function resolvedFile(request, time)
    {
        return null;
    },

    stopFile: function stopFile(request, time, postText, responseText)
    {
        var file = this.getRequestFile(request, null, true);
        if (file)
        {

            logTime(file, "stopFile", time);

            if (FBTrace.DBG_NET_EVENTS)
                FBTrace.sysout("net.stopFile +" + (NetUtils.now() - file.startTime) + " " +
                    getPrintableTime() + ", " + request.URI.path, file);

            // xxxHonza: spy should measure time using the activity observer too.
            // Don't ruin the endTime if it was already set.
            if (file.endTime == file.startTime)
                file.endTime = time;

            file.postText = postText;
            file.responseText = responseText;

            NetUtils.getHttpHeaders(request, file, this.context);

            this.endLoad(file);

            getCacheEntry(file, this);
        }

        return file;
    },

    abortFile: function abortFile(request, time, postText, responseText)
    {
        var file = this.getRequestFile(request, null, true);
        if (file)
        {
            logTime(file, "abortFile", time);

            file.aborted = true;
            file.responseStatusText = "Aborted";
        }

        return this.stopFile(request, time, postText, responseText);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // IP Address and port number

    updateIPInfo: function(request, file)
    {
        file.localAddress = Http.safeGetLocalAddress(request);
        file.localPort = Http.safeGetLocalPort(request);
        file.remoteAddress = Http.safeGetRemoteAddress(request);
        file.remotePort = Http.safeGetRemotePort(request);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    windowPaint: function windowPaint(window, time)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.windowPaint +? " + getPrintableTime() + ", " +
                window.location.href, this.phases);

        if (!this.phases.length)
            return;

        var phase = this.context.netProgress.currentPhase;
        var timeStamp = phase.addTimeStamp("MozAfterPaint", "netPaintBar");
        timeStamp.time = time;

        // Return the first file, so the layout is updated. I can happen that the
        // onLoad event is the last one and the graph end-time must be recalculated.
        return phase.files[0];
    },

    timeStamp: function timeStamp(window, time, label)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.timeStamp +? " + getPrintableTime() + ", " +
                window.location.href, this.phases);

        if (!this.phases.length)
            return;

        var phase = this.context.netProgress.currentPhase;
        var timeStamp = phase.addTimeStamp(label, "netTimeStampBar");
        timeStamp.time = time;

        return phase.files[0];
    },

    windowLoad: function windowLoad(window, time)
    {
        if (FBTrace.DBG_NET_EVENTS)
            FBTrace.sysout("net.windowLoad +? " + getPrintableTime() + ", " +
                window.location.href, this.phases);

        if (!this.phases.length)
            return;

        // Update all requests that belong to the first phase.
        var firstPhase = this.phases[0];

        // Keep the information also in the phase for now, NetExport and other could need it.
        firstPhase.windowLoadTime = time;

        var timeStamp = firstPhase.addTimeStamp("load", "netWindowLoadBar");
        timeStamp.time = time;

        // Return the first file, so the layout is updated. I can happen that the
        // onLoad event is the last one and the graph end-time must be recalculated.
        return firstPhase.files[0];
    },

    contentLoad: function contentLoad(window, time)
    {
        if (FBTrace.DBG_NET_EVENTS)
            FBTrace.sysout("net.contentLoad +? " + getPrintableTime() + ", " +
                window.location.href);

        if (!this.phases.length)
            return;

        // Update all requests that belong to the first phase.
        var firstPhase = this.phases[0];

        // Keep the information also in the phase for now, NetExport and other could need it.
        firstPhase.contentLoadTime = time;

        var timeStamp = firstPhase.addTimeStamp("DOMContentLoaded", "netContentLoadBar");
        timeStamp.time = time;

        return null;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getRequestFile: function getRequestFile(request, win, noCreate)
    {
        var name = Http.safeGetRequestName(request);
        if (!name || reIgnore.exec(name))
            return null;

        for (var i=0; i<this.files.length; i++)
        {
            var file = this.files[i];
            if (file.request == request)
                return file;
        }

        if (noCreate)
            return null;

        if (!win || Win.getRootWindow(win) != this.context.window)
            return;

        var fileDoc = this.getRequestDocument(win);
        var isDocument = request.loadFlags & Ci.nsIChannel.LOAD_DOCUMENT_URI && fileDoc.parent;
        var doc = isDocument ? fileDoc.parent : fileDoc;

        var file = doc.createFile(request);
        if (isDocument)
        {
            fileDoc.documentFile = file;
            file.ownDocument = fileDoc;
        }

        file.request = request;
        file.requestNumber = this.requestNumber;
        this.requestNumber++;
        this.requests.push(request);
        this.files.push(file);

        if (FBTrace.DBG_NET_EVENTS)
            FBTrace.sysout("net.createFile; " + Http.safeGetRequestName(request) +
                "(" + this.files.length + ")");

        return file;
    },

    getRequestDocument: function(win)
    {
        if (win)
        {
            var index = this.windows.indexOf(win);
            if (index == -1)
            {
                var doc = new NetDocument();
                if (win.parent != win)
                    doc.parent = this.getRequestDocument(win.parent);

                //doc.level = NetUtils.getFrameLevel(win);

                this.documents.push(doc);
                this.windows.push(win);

                return doc;
            }
            else
                return this.documents[index];
        }
        else
            return this.documents[0];
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    endLoad: function(file)
    {
        if (FBTrace.DBG_NET_EVENTS)
            FBTrace.sysout("net.events.endLoad +" + (NetUtils.now() - file.startTime) + " " +
                getPrintableTime() + ", " + file.request.URI.path, file);

        // Set file as loaded.
        file.loaded = true;

        // Update last finished file of the associated phase.
        //xxxHonza: verify this.
        if (file.phase)
            file.phase.lastFinishedFile = file;
    },

    extendPhase: function(file)
    {
        // Phase start can be measured since HTTP-ON-MODIFIED-REQUEST as
        // ACTIVITY_SUBTYPE_REQUEST_HEADER won't fire if the response comes from the BF cache.
        // If it's real HTTP request we need to start again since ACTIVITY_SUBTYPE_REQUEST_HEADER
        // has the proper time.
        // Order of ACTIVITY_SUBTYPE_REQUEST_HEADER can be different than order of
        // HTTP-ON-MODIFIED-REQUEST events, see issue 4535
        if (file.phase)
        {
            if (file.phase.files[0] == file)
                file.phase.startTime = file.startTime;

            // Since the request order can be wrong (see above) we need to iterate all files
            // in this phase and find the one that actually executed first.
            // In some cases, the waterfall can display a request executed before another,
            // but started later.
            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=664781
            var phase = file.phase;
            for (var i=0; i<phase.files.length; i++)
            {
                var file = phase.files[i];
                if (file.startTime > 0 && phase.startTime > file.startTime)
                    phase.startTime = file.startTime;
            }
            return;
        }

        if (this.currentPhase)
        {
            // If the new request has been started within a "phaseInterval" after the
            // previous reqeust has been started, associate it with the current phase;
            // otherwise create a new phase.
            var phaseInterval = Firebug.netPhaseInterval;
            var lastStartTime = this.currentPhase.lastStartTime;
            if (phaseInterval > 0 && this.loaded && file.startTime - lastStartTime >= phaseInterval)
                this.startPhase(file);
            else
                this.currentPhase.addFile(file);
        }
        else
        {
            // If there is no phase yet, just create it.
            this.startPhase(file);
        }
    },

    startPhase: function(file)
    {
        var phase = new NetPhase(file);
        phase.initial = !this.currentPhase;

        file.breakLayout = true;

        this.currentPhase = phase;
        this.phases.push(phase);
    },
};

// ********************************************************************************************* //
// Time Logging

function logTime(file, title, time)
{
    // xxxHonza: just for debugging purposes.
    return;

    if (!file._timings)
        file._timings = {counter: 0};

    if (!file._timings.logs)
        file._timings.logs = [];

    file._timings.logs.push({
        title: title,
        index: ++file._timings.counter,
        time: time
    });
}

// ********************************************************************************************* //

/**
 * A Document is a helper object that represents a document (window) on the page.
 * This object is created for main page document and for every embedded document (iframe)
 * for which a request is made.
 */
function NetDocument()
{
    this.id = 0;
    this.title = "";
}

NetDocument.prototype =
{
    createFile: function(request)
    {
        return new NetFile(request.name, this);
    }
};

// ********************************************************************************************* //

/**
 * A File is a helper object that represents a file for which a request is made.
 * The document refers to it's parent document (NetDocument) through a member
 * variable.
 */
function NetFile(href, document)
{
    this.href = href;
    this.document = document;
}

NetFile.prototype =
{
    status: 0,
    files: 0,
    loaded: false,
    fromCache: false,
    size: -1,
    expectedSize: -1,
    endTime: null,
    waitingForTime: null,
    connectingTime: null,

    getFileLink: function(message)
    {
        // this.SourceLink = function(url, line, type, object, instance)
        var link = new SourceLink.SourceLink(this.href, null, "net", this.request);
        return link;
    },

    getFileURL: function()
    {
        var index = this.href.indexOf("?");
        if (index < 0)
            return this.href;

        return this.href.substring(0, index);
    },

    clear: function()
    {
        // Remove all members to avoid circular references and memleaks.
        for (var name in this)
            delete this[name];
    }
};

Firebug.NetFile = NetFile;

// ********************************************************************************************* //

/**
 * A Phase is a helper object that groups requests made in the same time frame.
 * In other words, if a new requests is started within a given time (specified
 * by phaseInterval [ms]) - after previous request has been started -
 * it automatically belongs to the same phase.
 * If a request is started after this period, a new phase is created
 * and this file becomes to be the first in that phase.
 * The first phase is ended when the page finishes it's loading. Other phases
 * might be started by additional XHR made by the page.
 *
 * All phases are stored within NetProgress.phases array.
 *
 * Phases are used to compute size of the graphical timeline. The timeline
 * for each phase starts from the beginning of the graph.
 */
function NetPhase(file)
{
    // Start time of the phase. Remains the same, even if the file
    // is removed from the log (due to a max limit of entries).
    // This ensures stability of the time line.
    this.startTime = file.startTime;

    // The last finished request (file) in the phase.
    this.lastFinishedFile = null;

    // Set to true if the phase needs to be updated in the UI.
    this.invalidPhase = null;

    // List of files associated with this phase.
    this.files = [];

    // List of paint events.
    this.windowPaints = [];

    this.timeStamps = [];

    this.addFile(file);
}

NetPhase.prototype =
{
    addFile: function(file)
    {
        this.files.push(file);
        file.phase = this;
    },

    removeFile: function removeFile(file)
    {
        Arr.remove(this.files, file);

        // The file don't have a parent phase now.
        file.phase = null;

        // If the last file has been removed, update the last file member.
        if (file == this.lastFinishedFile)
        {
            if (this.files.length == 0)
            {
                this.lastFinishedFile = null;
            }
            else
            {
                for (var i=0; i<this.files.length; i++)
                {
                    if (this.lastFinishedFile.endTime < this.files[i].endTime)
                        this.lastFinishedFile = this.files[i];
                }
            }
        }
    },

    get lastStartTime()
    {
        return this.files[this.files.length - 1].startTime;
    },

    get endTime()
    {
        var endTime = this.lastFinishedFile ? this.lastFinishedFile.endTime : null;
        if (this.timeStamps.length > 0)
        {
            var lastTimeStamp = this.timeStamps[this.timeStamps.length-1].time;
            endTime = (endTime > lastTimeStamp) ? endTime : lastTimeStamp;
        }
        return endTime;
    },

    addTimeStamp: function(label, classes)
    {
        var timeStamp = {
            label: label,
            classes: classes
        };

        this.timeStamps.push(timeStamp);
        return timeStamp;
    }
};

// ********************************************************************************************* //

function getCacheEntry(file, netProgress)
{
    // xxxHonza: dependency on NetCacheReader can't be used in this module
    // since it causes cycle dependency problem. So, use the module through
    // NetMonitor namespace.
    Firebug.NetMonitor.NetCacheReader.requestCacheEntry(file, netProgress);
}

// ********************************************************************************************* //
// Helper for tracing

function getPrintableTime()
{
    var date = new Date();
    return "(" + date.getSeconds() + ":" + date.getMilliseconds() + ")";
}

// ********************************************************************************************* //
// Registration

return NetProgress;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/netReps",
[
    "firebug/chrome/eventSource",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/chrome/firefox",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/options",
    "firebug/lib/url",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/chrome/window",
    "firebug/lib/search",
    "firebug/lib/string",
    "firebug/lib/json",
    "firebug/lib/array",
    "firebug/dom/toggleBranch",
    "firebug/lib/dragdrop",
    "firebug/net/netUtils",
    "firebug/net/netProgress",
    "firebug/lib/http",
    "firebug/chrome/rep",
    "firebug/js/breakpoint",
    "firebug/net/xmlViewer",
    "firebug/net/svgViewer",
    "firebug/net/jsonViewer",
    "firebug/net/fontViewer",
    "firebug/chrome/infotip",
    "firebug/css/cssPanel",
    "firebug/chrome/searchBox",
    "firebug/console/errors",
    "firebug/net/netMonitor"
],
function(EventSource, Obj, Firebug, Firefox, Domplate, Locale, Events, Options, Url, Css, Dom,
    Win, Search, Str, Json, Arr, ToggleBranch, DragDrop, NetUtils, NetProgress, Http, Rep) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, TAG, DIV, SPAN, TD, TR, TH, TABLE, THEAD, TBODY, P, CODE, PRE, A, IFRAME} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;

const hiddenColsPref = "net.hiddenColumns";

var panelName = "net";

// ********************************************************************************************* //

const reSplitIP = /^(\d+)\.(\d+)\.(\d+)\.(\d+):(\d+)$/;

/**
 * @domplate Represents a template that is used to render basic content of the net panel.
 */
Firebug.NetMonitor.NetRequestTable = domplate(Rep, new EventSource(),
{
    inspectable: false,

    tableTag:
        TABLE({"class": "netTable", cellpadding: 0, cellspacing: 0, hiddenCols: "",
            "role": "treegrid"},
            THEAD(
                TR({"class": "netHeaderRow netRow focusRow outerFocusRow",
                    onclick: "$onClickHeader", "role": "row"},
                    TD({id: "netBreakpointBar", width: "1%", "class": "netHeaderCell",
                        "role": "columnheader"},
                        "&nbsp;"
                    ),
                    TD({id: "netHrefCol", width: "18%", "class": "netHeaderCell alphaValue a11yFocus",
                        "role": "columnheader"},
                        DIV({"class": "netHeaderCellBox",
                            title: Locale.$STR("net.header.URL Tooltip")},
                            Locale.$STR("net.header.URL")
                        )
                    ),
                    TD({id: "netStatusCol", width: "12%", "class": "netHeaderCell alphaValue a11yFocus",
                        "role": "columnheader"},
                        DIV({"class": "netHeaderCellBox",
                            title: Locale.$STR("net.header.Status Tooltip")},
                            Locale.$STR("net.header.Status")
                        )
                    ),
                    TD({id: "netProtocolCol", width: "4%", "class": "netHeaderCell alphaValue a11yFocus",
                        "role": "columnheader"},
                        DIV({"class": "netHeaderCellBox",
                            title: Locale.$STR("net.header.Protocol Tooltip")},
                            Locale.$STR("net.header.Protocol")
                        )
                    ),
                    TD({id: "netDomainCol", width: "12%", "class": "netHeaderCell alphaValue a11yFocus",
                        "role": "columnheader"},
                        DIV({"class": "netHeaderCellBox",
                            title: Locale.$STR("net.header.Domain Tooltip")},
                            Locale.$STR("net.header.Domain")
                        )
                    ),
                    TD({id: "netSizeCol", width: "4%", "class": "netHeaderCell a11yFocus",
                        "role": "columnheader"},
                        DIV({"class": "netHeaderCellBox",
                            title: Locale.$STR("net.header.Size Tooltip")},
                            Locale.$STR("net.header.Size")
                        )
                    ),
                    TD({id: "netLocalAddressCol", width: "4%", "class": "netHeaderCell a11yFocus",
                        "role": "columnheader"},
                        DIV({"class": "netHeaderCellBox",
                            title: Locale.$STR("net.header.Local IP Tooltip")},
                            Locale.$STR("net.header.Local IP")
                        )
                    ),
                    TD({id: "netRemoteAddressCol", width: "4%", "class": "netHeaderCell a11yFocus",
                        "role": "columnheader"},
                        DIV({"class": "netHeaderCellBox",
                            title: Locale.$STR("net.header.Remote IP Tooltip")},
                            Locale.$STR("net.header.Remote IP")
                        )
                    ),
                    TD({id: "netTimeCol", width: "53%", "class": "netHeaderCell a11yFocus",
                        "role": "columnheader"},
                        DIV({"class": "netHeaderCellBox",
                            title: Locale.$STR("net.header.Timeline Tooltip")},
                            Locale.$STR("net.header.Timeline")
                        )
                    )
                )
            ),
            TBODY({"class": "netTableBody", "role" : "presentation"})
        ),

    limitTag:
        DIV({"class": "panelNotificationBox collapsed"}),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    onClickHeader: function(event)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.onClickHeader\n");

        // Also support enter key for sorting
        if (!Events.isLeftClick(event) && !(event.type == "keypress" && event.keyCode == 13))
            return;

        var table = Dom.getAncestorByClass(event.target, "netTable");
        var column = Dom.getAncestorByClass(event.target, "netHeaderCell");
        this.sortColumn(table, column);
    },

    sortColumn: function(table, col, direction)
    {
        if (!col)
            return;

        var numerical = !Css.hasClass(col, "alphaValue");

        var colIndex = 0;
        for (col = col.previousSibling; col; col = col.previousSibling)
            ++colIndex;

        // the first breakpoint bar column is not sortable.
        if (colIndex == 0)
            return;

        this.sort(table, colIndex, numerical, direction);
    },

    sort: function(table, colIndex, numerical, direction)
    {
        var headerRow = table.querySelector(".netHeaderRow");

        // Remove class from the currently sorted column
        var headerSorted = Dom.getChildByClass(headerRow, "netHeaderSorted");
        Css.removeClass(headerSorted, "netHeaderSorted");
        if (headerSorted)
            headerSorted.removeAttribute("aria-sort");

        // Mark new column as sorted.
        var header = headerRow.childNodes[colIndex];
        Css.setClass(header, "netHeaderSorted");

        // If the column is already using required sort direction, bubble out.
        if ((direction == "desc" && header.sorted == 1) ||
            (direction == "asc" && header.sorted == -1))
            return;

        var newDirection = ((header.sorted && header.sorted == 1) || (!header.sorted && direction == "asc")) ? "ascending" : "descending";
        if (header)
            header.setAttribute("aria-sort", newDirection);

        var tbody = table.lastChild;
        var colID = header.getAttribute("id");

        table.setAttribute("sortcolumn", colID);
        table.setAttribute("sortdirection", newDirection);

        var values = [];
        for (var row = tbody.childNodes[1]; row; row = row.nextSibling)
        {
            if (!row.repObject)
                continue;

            if (Css.hasClass(row, "history"))
                continue;

            var cell = row.childNodes[colIndex];
            var sortFunction = function sort(a, b) { return a.value < b.value ? -1 : 1; };
            var ipSortFunction = function sort(a, b)
            {
                var aParts = reSplitIP.exec(a.value);
                var bParts = reSplitIP.exec(b.value);

                if (!aParts)
                    return -1;
                if (!bParts)
                    return 1;

                for (var i=1; i<aParts.length; ++i)
                {
                    if (parseInt(aParts[i]) != parseInt(bParts[i]))
                        return parseInt(aParts[i]) < parseInt(bParts[i]) ? -1 : 1;
                }

                return 1;
            };
            var value;

            switch (colID)
            {
                case "netTimeCol":
                    value = row.repObject.requestNumber;
                    break;
                case "netSizeCol":
                    value = row.repObject.size;
                    break;
                case "netRemoteAddressCol":
                case "netLocalAddressCol":
                    value = cell.textContent;
                    sortFunction = ipSortFunction;
                    break;
                default:
                    value = numerical ? parseFloat(cell.textContent) : cell.textContent;
            }

            if (Css.hasClass(row, "opened"))
            {
                var netInfoRow = row.nextSibling;
                values.push({row: row, value: value, info: netInfoRow});
                row = netInfoRow;
            }
            else
            {
                values.push({row: row, value: value});
            }
        }

        values.sort(sortFunction);

        if (newDirection == "ascending")
        {
            Css.removeClass(header, "sortedDescending");
            Css.setClass(header, "sortedAscending");
            header.sorted = -1;

            for (var i = 0; i < values.length; ++i)
            {
                tbody.appendChild(values[i].row);
                if (values[i].info)
                    tbody.appendChild(values[i].info);
            }
        }
        else
        {
            Css.removeClass(header, "sortedAscending");
            Css.setClass(header, "sortedDescending");

            header.sorted = 1;

            for (var i = values.length-1; i >= 0; --i)
            {
                tbody.appendChild(values[i].row);
                if (values[i].info)
                    tbody.appendChild(values[i].info);
            }
        }

        // Make sure the summary row is again at the end.
        var summaryRow = tbody.getElementsByClassName("netSummaryRow").item(0);
        tbody.appendChild(summaryRow);
    },

    supportsObject: function(object, type)
    {
        return (object == this);
    },

    /**
     * Provides menu items for header context menu.
     */
    getContextMenuItems: function(object, target, context)
    {
        var popup = Firebug.chrome.$("fbContextMenu");
        if (popup.firstChild && popup.firstChild.getAttribute("command") == "cmd_copy")
            popup.removeChild(popup.firstChild);

        var items = [];

        // Iterate over all columns and create a menu item for each.
        var table = context.getPanel(panelName, true).table;
        var hiddenCols = table.getAttribute("hiddenCols");

        var lastVisibleIndex;
        var visibleColCount = 0;

        // Iterate all columns except of the first one for breakpoints.
        var header = Dom.getAncestorByClass(target, "netHeaderRow");
        var columns = Arr.cloneArray(header.childNodes);
        columns.shift();
        for (var i=0; i<columns.length; i++)
        {
            var column = columns[i];
            var columnContent = column.getElementsByClassName("netHeaderCellBox").item(0);
            var visible = (hiddenCols.indexOf(column.id) == -1);

            items.push({
                label: columnContent.textContent,
                tooltiptext: columnContent.title,
                type: "checkbox",
                checked: visible,
                nol10n: true,
                command: Obj.bindFixed(this.onShowColumn, this, context, column.id)
            });

            if (visible)
            {
                lastVisibleIndex = i;
                visibleColCount++;
            }
        }

        // If the last column is visible, disable its menu item.
        if (visibleColCount == 1)
            items[lastVisibleIndex].disabled = true;

        items.push("-");
        items.push({
            label: "net.header.Reset_Header",
            tooltiptext: "net.header.tip.Reset_Header",
            command: Obj.bindFixed(this.onResetColumns, this, context)
        });

        return items;
    },

    onShowColumn: function(context, colId)
    {
        var panel = context.getPanel(panelName, true);
        var table = panel.table;
        var hiddenCols = table.getAttribute("hiddenCols");

        // If the column is already present in the list of hidden columns,
        // remove it, otherwise append it.
        var index = hiddenCols.indexOf(colId);
        if (index >= 0)
        {
            table.setAttribute("hiddenCols", hiddenCols.substr(0,index-1) +
                hiddenCols.substr(index+colId.length));
        }
        else
        {
            table.setAttribute("hiddenCols", hiddenCols + " " + colId);
        }

        // Store current state into the preferences.
        Options.set(hiddenColsPref, table.getAttribute("hiddenCols"));

        panel.updateHRefLabelWidth();
    },

    onResetColumns: function(context)
    {
        var panel = context.getPanel(panelName, true);
        var header = panel.panelNode.getElementsByClassName("netHeaderRow").item(0);

        // Reset widths
        var columns = header.childNodes;
        for (var i=0; i<columns.length; i++)
        {
            var col = columns[i];
            if (col.style)
                col.style.width = "";
        }

        // Reset visibility. Only the Status column is hidden by default.
        Options.clear(hiddenColsPref);
        panel.table.setAttribute("hiddenCols", Options.get(hiddenColsPref));
    },
});

// ********************************************************************************************* //

/**
 * @domplate Represents a template that is used to render net panel entries.
 */
Firebug.NetMonitor.NetRequestEntry = domplate(Rep, new EventSource(),
{
    fileTag:
        FOR("file", "$files",
            TR({"class": "netRow $file.file|getCategory focusRow outerFocusRow",
                onclick: "$onClick", "role": "row", "aria-expanded": "false",
                $hasHeaders: "$file.file|hasRequestHeaders",
                $history: "$file.file.history",
                $loaded: "$file.file.loaded",
                $responseError: "$file.file|isError",
                $fromBFCache: "$file.file|isFromBFCache",
                $fromCache: "$file.file.fromCache",
                $inFrame: "$file.file|getInFrame"},
                TD({"class": "netDebugCol netCol"},
                   DIV({"class": "sourceLine netRowHeader",
                   onclick: "$onClickRowHeader"},
                        "&nbsp;"
                   )
                ),
                TD({"class": "netHrefCol netCol a11yFocus", "role": "rowheader"},
                    DIV({"class": "netHrefLabel netLabel",
                         style: "margin-left: $file.file|getIndent\\px"},
                        "$file.file|getHref"
                    ),
                    DIV({"class": "netFullHrefLabel netHrefLabel",
                         style: "margin-left: $file.file|getIndent\\px"},
                        "$file.file.href"
                    )
                ),
                TD({"class": "netStatusCol netCol a11yFocus", "role": "gridcell"},
                    DIV({"class": "netStatusLabel netLabel"}, "$file.file|getStatus")
                ),
                TD({"class": "netProtocolCol netCol a11yFocus", "role": "gridcell"},
                    DIV({"class": "netProtocolLabel netLabel"}, "$file.file|getProtocol")
                ),
                TD({"class": "netDomainCol netCol a11yFocus", "role": "gridcell" },
                    DIV({"class": "netDomainLabel netLabel"}, "$file.file|getDomain")
                ),
                TD({"class": "netSizeCol netCol a11yFocus", "role": "gridcell",
                    "aria-describedby": "fbNetSizeInfoTip"},
                    DIV({"class": "netSizeLabel netLabel"}, "$file.file|getSize")
                ),
                TD({"class": "netLocalAddressCol netCol a11yFocus", "role": "gridcell"},
                    DIV({"class": "netAddressLabel netLabel"}, "$file.file|getLocalAddress")
                ),
                TD({"class": "netRemoteAddressCol netCol a11yFocus", "role": "gridcell"},
                    DIV({"class": "netAddressLabel netLabel"}, "$file.file|getRemoteAddress")
                ),
                TD({"class": "netTimeCol netCol a11yFocus", "role": "gridcell",
                    "aria-describedby": "fbNetTimeInfoTip" },
                    DIV({"class": "netLoadingIcon"}),
                    DIV({"class": "netBar"},
                        "&nbsp;",
                        DIV({"class": "netBlockingBar", style: "left: $file.offset"}),
                        DIV({"class": "netResolvingBar", style: "left: $file.offset"}),
                        DIV({"class": "netConnectingBar", style: "left: $file.offset"}),
                        DIV({"class": "netSendingBar", style: "left: $file.offset"}),
                        DIV({"class": "netWaitingBar", style: "left: $file.offset"}),
                        DIV({"class": "netReceivingBar", style: "left: $file.offset; width: $file.width"},
                            SPAN({"class": "netTimeLabel"}, "$file|getElapsedTime")
                        )
                        // Page timings (vertical lines) are dynamically appended here.
                    )
                )
            )
        ),

    netInfoTag:
        TR({"class": "netInfoRow $file|getCategory outerFocusRow", "role" : "row"},
            TD({"class": "sourceLine netRowHeader"}),
            TD({"class": "netInfoCol", colspan: 8, "role" : "gridcell"})
        ),

    activationTag:
        TR({"class": "netRow netActivationRow"},
            TD({"class": "netCol netActivationLabel", colspan: 9, "role": "status"},
                Locale.$STR("net.ActivationMessage")
            )
        ),

    summaryTag:
        TR({"class": "netRow netSummaryRow focusRow outerFocusRow", "role": "row",
            "aria-live": "polite"},
            TD({"class": "netCol"}, "&nbsp;"),
            TD({"class": "netCol netHrefCol a11yFocus", "role" : "rowheader"},
                DIV({"class": "netCountLabel netSummaryLabel",
                    title: Locale.$STR("net.summary.tip.request count")},
                    "-"
                )
            ),
            TD({"class": "netCol netStatusCol a11yFocus", "role" : "gridcell"}),
            TD({"class": "netCol netProtocolCol a11yFocus", "role" : "gridcell"}),
            TD({"class": "netCol netDomainCol a11yFocus", "role" : "gridcell"}),
            TD({"class": "netTotalSizeCol netCol netSizeCol a11yFocus", "role": "gridcell"},
                DIV({"class": "netTotalSizeLabel netSummaryLabel",
                    title: Locale.$STR("net.summary.tip.total size")},
                    "0 B"
                )
            ),
            TD({"class": "netTotalTimeCol netCol netTimeCol a11yFocus", "role":
                "gridcell", colspan: "3"},
                DIV({"class": "netSummaryBar", style: "width: 100%"},
                    DIV({"class": "netCacheSizeLabel netSummaryLabel", collapsed: "true",
                        title: Locale.$STR("net.summary.tip.total cached size")},
                        "(" + Locale.$STRF("net.summary.from_cache", ["0 B"]) + ")"
                    ),
                    DIV({"class": "netTotalTimeLabel netSummaryLabel",
                        title: Locale.$STR("net.summary.tip.total request time")},
                        "0ms"
                    )
                )
            )
        ),

    footerTag:
        TR({"class": "netFooterRow", "style" : "height: 100%"},
            TD({"class": "", colspan: 9})
        ),

    onClickRowHeader: function(event)
    {
        Events.cancelEvent(event);

        var rowHeader = event.target;
        if (!Css.hasClass(rowHeader, "netRowHeader"))
            return;

        var row = Dom.getAncestorByClass(event.target, "netRow");
        if (!row)
            return;

        var context = Firebug.getElementPanel(row).context;
        var panel = context.getPanel(panelName, true);
        if (panel)
            panel.breakOnRequest(row.repObject);
    },

    onClick: function(event)
    {
        if (Events.isLeftClick(event))
        {
            var row = Dom.getAncestorByClass(event.target, "netRow");
            if (row)
            {
                // Click on the rowHeader element inserts a breakpoint.
                if (Dom.getAncestorByClass(event.target, "netRowHeader"))
                    return;

                this.toggleHeadersRow(row);
                Events.cancelEvent(event);
            }
        }
    },

    toggleHeadersRow: function(row)
    {
        if (!Css.hasClass(row, "hasHeaders"))
            return;

        var file = row.repObject;

        Css.toggleClass(row, "opened");
        if (Css.hasClass(row, "opened"))
        {
            var netInfoRow = this.netInfoTag.insertRows({file: file}, row)[0];
            var netInfoCol = netInfoRow.getElementsByClassName("netInfoCol").item(0);
            var netInfoBox = Firebug.NetMonitor.NetInfoBody.tag.replace({file: file}, netInfoCol);

            // Notify listeners so additional tabs can be created.
            Events.dispatch(Firebug.NetMonitor.NetInfoBody.fbListeners, "initTabBody",
                [netInfoBox, file]);

            // Select "Headers" tab by default, if no other tab is selected already.
            // (e.g. by a third party Firebug extension in 'initTabBody' event)
            if (!netInfoBox.selectedTab)
                Firebug.NetMonitor.NetInfoBody.selectTabByName(netInfoBox, "Headers");

            var category = NetUtils.getFileCategory(row.repObject);
            if (category)
                Css.setClass(netInfoBox, "category-" + category);

            row.setAttribute("aria-expanded", "true");
        }
        else
        {
            var netInfoRow = row.nextSibling;
            var netInfoBox = netInfoRow.getElementsByClassName("netInfoBody").item(0);

            Events.dispatch(Firebug.NetMonitor.NetInfoBody.fbListeners, "destroyTabBody",
                [netInfoBox, file]);

            row.parentNode.removeChild(netInfoRow);
            row.setAttribute("aria-expanded", "false");
        }
    },

    getCategory: function(file)
    {
        var category = NetUtils.getFileCategory(file);
        if (category)
            return "category-" + category;

        return "category-undefined";
    },

    getInFrame: function(file)
    {
        return !!(file.document ? file.document.parent : false);
    },

    getIndent: function(file)
    {
        // XXXjoe Turn off indenting for now, it's confusing since we don't
        // actually place nested files directly below their parent
        //return file.document.level * indentWidth;
        return 10;
    },

    isNtlmAuthorizationRequest: function(file)
    {
        if (file.responseStatus != 401)
            return false;

        //xxxsz: file.responseHeaders is undefined here for some reason
        var resp = file.responseHeadersText.match(/www-authenticate:\s(.+)/i)[1];
        return (resp && resp.search(/ntlm|negotiate/i) >= 0);
    },

    isError: function(file)
    {
        if (file.aborted)
            return true;

        if (this.isNtlmAuthorizationRequest(file))
            return false;

        var errorRange = Math.floor(file.responseStatus/100);
        return errorRange == 4 || errorRange == 5;
    },

    isFromBFCache: function(file)
    {
        return file.fromBFCache;
    },

    getHref: function(file)
    {
        var fileName = Url.getFileName(file.href);
        var limit = Options.get("stringCropLength");
        if (limit > 0)
            fileName = Str.cropString(fileName, limit);
        return (file.method ? file.method.toUpperCase() : "?") + " " + fileName;
    },

    getProtocol: function(file)
    {
        var protocol = Url.getProtocol(file.href);
        var text = file.responseHeadersText;
        var spdy = text ? text.search(/X-Firefox-Spdy/i) >= 0 : null;
        return spdy ? protocol + " SPDY" : protocol;
    },

    getStatus: function(file)
    {
        var text = "";

        if (file.responseStatus)
            text += file.responseStatus + " ";

        if (file.responseStatusText)
            text += file.responseStatusText;

        text = text ? Str.cropString(text) : " ";

        if (file.fromAppCache)
            text += " (AppCache)";
        else if (file.fromBFCache)
            text += " (BFCache)";

        return text;
    },

    getDomain: function(file)
    {
        return Url.getPrettyDomain(file.href);
    },

    getSize: function(file)
    {
        var size = (file.size >= 0) ? file.size : 0;
        return this.formatSize(size);
    },

    getLocalAddress: function(file)
    {
        return Str.formatIP(file.localAddress, file.localPort);
    },

    getRemoteAddress: function(file)
    {
        return Str.formatIP(file.remoteAddress, file.remotePort);
    },

    getElapsedTime: function(file)
    {
        if (!file.elapsed || file.elapsed < 0)
            return "";

        return this.formatTime(file.elapsed);
    },

    hasRequestHeaders: function(file)
    {
        return !!file.requestHeaders;
    },

    formatSize: function(bytes)
    {
        return Str.formatSize(bytes);
    },

    formatTime: function(elapsed)
    {
        return Str.formatTime(elapsed);
    }
});

// ********************************************************************************************* //

Firebug.NetMonitor.NetPage = domplate(Rep,
{
    separatorTag:
        TR({"class": "netRow netPageSeparatorRow"},
            TD({"class": "netCol netPageSeparatorLabel", colspan: 8, "role": "separator"})
        ),

    pageTag:
        TR({"class": "netRow netPageRow", onclick: "$onPageClick"},
            TD({"class": "netCol netPageCol", colspan: 8, "role": "separator"},
                DIV({"class": "netLabel netPageLabel netPageTitle"}, "$page|getTitle")
            )
        ),

    getTitle: function(page)
    {
        return page.pageTitle;
    },

    onPageClick: function(event)
    {
        if (!Events.isLeftClick(event))
            return;

        var target = event.target;
        var pageRow = Dom.getAncestorByClass(event.target, "netPageRow");
        var panel = Firebug.getElementPanel(pageRow);

        if (!Css.hasClass(pageRow, "opened"))
        {
            Css.setClass(pageRow, "opened");

            var files = pageRow.files;

            // Move all net-rows from the persistedState to this panel.
            panel.insertRows(files, pageRow);

            for (var i=0; i<files.length; i++)
                panel.queue.push(files[i].file);

            panel.layout();
        }
        else
        {
            Css.removeClass(pageRow, "opened");

            var nextRow = pageRow.nextSibling;
            while (!Css.hasClass(nextRow, "netPageRow") &&
                !Css.hasClass(nextRow, "netPageSeparatorRow"))
            {
                var nextSibling = nextRow.nextSibling;
                nextRow.parentNode.removeChild(nextRow);
                nextRow = nextSibling;
            }
        }
    },
});

// ********************************************************************************************* //

/**
 * @domplate Represents a template that is used to render detailed info about a request.
 * This template is rendered when a request is expanded.
 */
Firebug.NetMonitor.NetInfoBody = domplate(Rep, new EventSource(),
{
    tag:
        DIV({"class": "netInfoBody", _repObject: "$file"},
            TAG("$infoTabs", {file: "$file"}),
            TAG("$infoBodies", {file: "$file"})
        ),

    infoTabs:
        DIV({"class": "netInfoTabs focusRow subFocusRow", "role": "tablist"},
            A({"class": "netInfoParamsTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",
                view: "Params",
                $collapsed: "$file|hideParams"},
                Locale.$STR("URLParameters")
            ),
            A({"class": "netInfoHeadersTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",
                view: "Headers"},
                Locale.$STR("Headers")
            ),
            A({"class": "netInfoPostTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",
                view: "Post",
                $collapsed: "$file|hidePost"},
                Locale.$STR("Post")
            ),
            A({"class": "netInfoPutTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",
                view: "Put",
                $collapsed: "$file|hidePut"},
                Locale.$STR("Put")
            ),
            A({"class": "netInfoPatchTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",
                view: "Patch",
                $collapsed: "$file|hidePatch"},
                Locale.$STR("net.label.Patch")
            ),
            A({"class": "netInfoResponseTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",
                view: "Response",
                $collapsed: "$file|hideResponse"},
                Locale.$STR("Response")
            ),
            A({"class": "netInfoHtmlTab netInfoTab a11yFocus", onclick: "$onClickTab", "role": "tab",
               view: "Html",
               $collapsed: "$file|hideHtml"},
               Locale.$STR("HTML")
            )
        ),

    infoBodies:
        DIV({"class": "netInfoBodies outerFocusRow"},
            TABLE({"class": "netInfoParamsText netInfoText netInfoParamsTable", "role": "tabpanel",
                    cellpadding: 0, cellspacing: 0}, TBODY()),
            DIV({"class": "netInfoHeadersText netInfoText", "role": "tabpanel"}),
            DIV({"class": "netInfoPostText netInfoText", "role": "tabpanel"}),
            DIV({"class": "netInfoPutText netInfoText", "role": "tabpanel"}),
            DIV({"class": "netInfoPatchText netInfoText", "role": "tabpanel"}),
            DIV({"class": "netInfoResponseText netInfoText", "role": "tabpanel"}),
            DIV({"class": "netInfoHtmlText netInfoText", "role": "tabpanel"},
                IFRAME({"class": "netInfoHtmlPreview", "role": "document", "sandbox": ""}),
                DIV({"class": "htmlPreviewResizer"})
            )
        ),

    headerDataTag:
        FOR("param", "$headers",
            TR({"role": "listitem"},
                TD({"class": "netInfoParamName", "role": "presentation"},
                    TAG("$param|getNameTag", {param: "$param"})
                ),
                TD({"class": "netInfoParamValue", "role": "list", "aria-label": "$param.name"},
                    FOR("line", "$param|getParamValueIterator",
                        CODE({"class": "focusRow subFocusRow", "role": "listitem"}, "$line")
                    )
                )
            )
        ),

    responseHeadersFromBFCacheTag:
        TR(
            TD({"class": "headerFromBFCache"},
                Locale.$STR("net.label.ResponseHeadersFromBFCache")
            )
        ),

    customTab:
        A({"class": "netInfo$tabId\\Tab netInfoTab", onclick: "$onClickTab",
            view: "$tabId", "role": "tab"},
            "$tabTitle"
        ),

    customBody:
        DIV({"class": "netInfo$tabId\\Text netInfoText", "role": "tabpanel"}),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    nameTag:
        SPAN("$param|getParamName"),

    nameWithTooltipTag:
        SPAN({title: "$param.name"}, "$param|getParamName"),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    getNameTag: function(param)
    {
        return (this.getParamName(param) == param.name) ? this.nameTag : this.nameWithTooltipTag;
    },

    getParamName: function(param)
    {
        var name = param.name;
        var limit = Firebug.netParamNameLimit;
        if (limit <= 0)
            return name;

        if (name.length > limit)
            name = name.substr(0, limit) + "...";
        return name;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    hideParams: function(file)
    {
        return !file.urlParams || !file.urlParams.length;
    },

    hidePost: function(file)
    {
        return file.method.toUpperCase() != "POST";
    },

    hidePut: function(file)
    {
        return file.method.toUpperCase() != "PUT";
    },

    hidePatch: function(file)
    {
        return file.method.toUpperCase() != "PATCH";
    },

    hideResponse: function(file)
    {
        var headers = file.responseHeaders;
        for (var i=0; headers && i<headers.length; i++)
        {
            if (headers[i].name == "Content-Length")
                return headers[i].value == 0;
        }

        return file.category in NetUtils.binaryFileCategories || file.responseText == "";
    },

    hideHtml: function(file)
    {
        if (!file.mimeType)
            return true;

        var types = ["text/html", "application/xhtml+xml"];
        return !NetUtils.matchesContentType(file.mimeType, types);
    },

    onClickTab: function(event)
    {
        this.selectTab(event.currentTarget);
    },

    getParamValueIterator: function(param)
    {
        // This value is inserted into CODE element and so, make sure the HTML isn't escaped (1210).
        // This is why the second parameter is true.
        // The CODE (with style white-space:pre) element preserves whitespaces so they are
        // displayed the same, as they come from the server (1194).
        // In case of a long header values of post parameters the value must be wrapped (2105).
        return Str.wrapText(param.value, true);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    appendTab: function(netInfoBox, tabId, tabTitle)
    {
        // Create new tab and body.
        var args = {tabId: tabId, tabTitle: tabTitle};
        this.customTab.append(args, netInfoBox.getElementsByClassName("netInfoTabs").item(0));
        this.customBody.append(args, netInfoBox.getElementsByClassName("netInfoBodies").item(0));
    },

    selectTabByName: function(netInfoBox, tabName)
    {
        var tab = Dom.getChildByClass(netInfoBox, "netInfoTabs", "netInfo" + tabName + "Tab");
        if (!tab)
            return false;

        this.selectTab(tab);

        return true;
    },

    selectTab: function(tab)
    {
        var netInfoBox = Dom.getAncestorByClass(tab, "netInfoBody");

        var view = tab.getAttribute("view");
        if (netInfoBox.selectedTab)
        {
            netInfoBox.selectedTab.removeAttribute("selected");
            netInfoBox.selectedText.removeAttribute("selected");
            netInfoBox.selectedTab.setAttribute("aria-selected", "false");
        }
        var textBodyName = "netInfo" + view + "Text";

        netInfoBox.selectedTab = tab;
        netInfoBox.selectedText = netInfoBox.getElementsByClassName(textBodyName).item(0);

        netInfoBox.selectedTab.setAttribute("selected", "true");
        netInfoBox.selectedText.setAttribute("selected", "true");
        netInfoBox.selectedTab.setAttribute("aria-selected", "true");

        var file = Firebug.getRepObject(netInfoBox);
        var panel = Firebug.getElementPanel(netInfoBox);
        if (!panel)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("net.selectTab; ERROR no panel");
            return;
        }

        var context = panel.context;
        this.updateInfo(netInfoBox, file, context);
    },

    updateInfo: function(netInfoBox, file, context)
    {
        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.updateInfo; file", file);

        if (!netInfoBox)
        {
            if (FBTrace.DBG_NET || FBTrace.DBG_ERRORS)
                FBTrace.sysout("net.updateInfo; ERROR netInfo == null " + file.href, file);
            return;
        }

        var tab = netInfoBox.selectedTab;
        if (Css.hasClass(tab, "netInfoParamsTab"))
        {
            if (file.urlParams && !netInfoBox.urlParamsPresented)
            {
                netInfoBox.urlParamsPresented = true;
                this.insertHeaderRows(netInfoBox, file.urlParams, "Params");
            }
        }

        if (Css.hasClass(tab, "netInfoHeadersTab"))
        {
            var headersText = netInfoBox.getElementsByClassName("netInfoHeadersText").item(0);

            if (file.responseHeaders && !netInfoBox.responseHeadersPresented)
            {
                netInfoBox.responseHeadersPresented = true;

                Firebug.NetMonitor.NetInfoHeaders.renderHeaders(headersText,
                    file.responseHeaders, "ResponseHeaders");

                // If the request comes from the BFCache do not display reponse headers.
                // There is not real response from the server and all headers come from
                // the cache. So, the user should see the 'Response Headers From Cache'
                // section (see issue 5573).
                if (file.fromBFCache)
                {
                    // Display a message instead of headers.
                    var body = Dom.getElementByClass(headersText, "netInfoResponseHeadersBody");
                    Firebug.NetMonitor.NetInfoBody.responseHeadersFromBFCacheTag.replace({}, body);
                }
            }

            if (file.cachedResponseHeaders && !netInfoBox.cachedResponseHeadersPresented)
            {
                netInfoBox.cachedResponseHeadersPresented = true;
                Firebug.NetMonitor.NetInfoHeaders.renderHeaders(headersText,
                    file.cachedResponseHeaders, "CachedResponseHeaders");
            }

            if (file.requestHeaders && !netInfoBox.requestHeadersPresented)
            {
                netInfoBox.requestHeadersPresented = true;
                Firebug.NetMonitor.NetInfoHeaders.renderHeaders(headersText,
                    file.requestHeaders, "RequestHeaders");
            }

            if (!file.postRequestsHeaders)
            {
                var text = NetUtils.getPostText(file, context, true);
                file.postRequestsHeaders = Http.getHeadersFromPostText(file.request, text);
            }

            if (file.postRequestsHeaders && !netInfoBox.postRequestsHeadersPresented)
            {
                netInfoBox.postRequestsHeadersPresented = true;
                Firebug.NetMonitor.NetInfoHeaders.renderHeaders(headersText,
                    file.postRequestsHeaders, "PostRequestHeaders");
            }
        }

        if (Css.hasClass(tab, "netInfoPostTab"))
        {
            if (!netInfoBox.postPresented)
            {
                netInfoBox.postPresented = true;
                var postText = netInfoBox.getElementsByClassName("netInfoPostText").item(0);
                Firebug.NetMonitor.NetInfoPostData.render(context, postText, file);
            }
        }

        if (Css.hasClass(tab, "netInfoPutTab"))
        {
            if (!netInfoBox.putPresented)
            {
                netInfoBox.putPresented = true;
                var putText = netInfoBox.getElementsByClassName("netInfoPutText").item(0);
                Firebug.NetMonitor.NetInfoPostData.render(context, putText, file);
            }
        }

        if (Css.hasClass(tab, "netInfoPatchTab"))
        {
            if (!netInfoBox.patchPresented)
            {
                netInfoBox.patchPresented = true;
                var patchText = netInfoBox.getElementsByClassName("netInfoPatchText").item(0);
                Firebug.NetMonitor.NetInfoPostData.render(context, patchText, file);
            }
        }

        if (Css.hasClass(tab, "netInfoResponseTab") && file.loaded && !netInfoBox.responsePresented)
        {
            var responseTextBox = netInfoBox.getElementsByClassName("netInfoResponseText").item(0);

            // Let listeners display the response
            Events.dispatch(this.fbListeners, "updateResponse", [netInfoBox, file, context]);

            if (FBTrace.DBG_NET)
                FBTrace.sysout("netInfoResponseTab", {netInfoBox: netInfoBox, file: file});
            if (!netInfoBox.responsePresented)
            {
                if (file.category == "image")
                {
                    netInfoBox.responsePresented = true;

                    var responseImage = netInfoBox.ownerDocument.createElement("img");
                    responseImage.src = file.href;

                    Dom.clearNode(responseTextBox);
                    responseTextBox.appendChild(responseImage, responseTextBox);
                }
                else if (!(NetUtils.binaryCategoryMap.hasOwnProperty(file.category)))
                {
                    this.setResponseText(file, netInfoBox, responseTextBox, context);
                }
            }
        }

        if (Css.hasClass(tab, "netInfoHtmlTab") && file.loaded && !netInfoBox.htmlPresented)
        {
            netInfoBox.htmlPresented = true;

            var text = NetUtils.getResponseText(file, context);
            this.htmlPreview = netInfoBox.getElementsByClassName("netInfoHtmlPreview").item(0);
            this.htmlPreview.contentWindow.document.body.innerHTML = text;

            // Workaround for issue 5774 (it's not clear why the 'load' event is actually
            // sent to the iframe when the user swithes Firebug panels).
            // The event is sent only for the iframes in the Console panel.
            context.addEventListener(this.htmlPreview, "load", function(event)
            {
                try
                {
                    event.target.contentDocument.body.innerHTML = text;
                }
                catch (err)
                {
                    if (FBTrace.DBG_ERRORS)
                        FBTrace.sysout("net.updateInfo; EXCEPTION " + err, err);
                }
            });

            var defaultHeight = parseInt(Options.get("netHtmlPreviewHeight"));
            if (!isNaN(defaultHeight))
                this.htmlPreview.style.height = defaultHeight + "px";

            var handler = netInfoBox.querySelector(".htmlPreviewResizer");
            this.resizer = new DragDrop.Tracker(handler, {
                onDragStart: Obj.bind(this.onDragStart, this),
                onDragOver: Obj.bind(this.onDragOver, this),
                onDrop: Obj.bind(this.onDrop, this)
            });
        }

        // Notify listeners about update so, content of custom tabs can be updated.
        Events.dispatch(Firebug.NetMonitor.NetInfoBody.fbListeners, "updateTabBody",
            [netInfoBox, file, context]);
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // HTML Preview Resizer

    onDragStart: function(tracker)
    {
        var body = Dom.getBody(this.htmlPreview.ownerDocument);
        body.setAttribute("resizingHtmlPreview", "true");
        this.startHeight = this.htmlPreview.clientHeight;
    },

    onDragOver: function(newPos, tracker)
    {
        var newHeight = (this.startHeight + newPos.y);
        this.htmlPreview.style.height = newHeight + "px";
        Options.setPref(Firebug.prefDomain, "netHtmlPreviewHeight", newHeight);
    },

    onDrop: function(tracker)
    {
        var body = Dom.getBody(this.htmlPreview.ownerDocument);
        body.removeAttribute("resizingHtmlPreview");
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    setResponseText: function(file, netInfoBox, responseTextBox, context)
    {
        // Get response text and make sure it doesn't exceed the max limit.
        var text = NetUtils.getResponseText(file, context);
        var limit = Firebug.netDisplayedResponseLimit + 15;
        var limitReached = text ? (text.length > limit) : false;
        if (limitReached)
            text = text.substr(0, limit) + "...";

        // Insert the response into the UI.
        if (text)
            Str.insertWrappedText(text, responseTextBox);
        else
            Str.insertWrappedText("", responseTextBox);

        // Append a message informing the user that the response isn't fully displayed.
        if (limitReached)
        {
            var object = {
                text: Locale.$STR("net.responseSizeLimitMessage"),
                onClickLink: function() {
                    NetUtils.openResponseInTab(file);
                }
            };
            Firebug.NetMonitor.ResponseSizeLimit.append(object, responseTextBox);
        }

        netInfoBox.responsePresented = true;

        if (FBTrace.DBG_NET)
            FBTrace.sysout("net.setResponseText; response text updated");
    },

    insertHeaderRows: function(netInfoBox, headers, tableName, rowName)
    {
        if (!headers.length)
            return;

        var headersTable = netInfoBox.getElementsByClassName("netInfo"+tableName+"Table").item(0);
        var tbody = Dom.getChildByClass(headersTable, "netInfo" + rowName + "Body");
        if (!tbody)
            tbody = headersTable.firstChild;
        var titleRow = Dom.getChildByClass(tbody, "netInfo" + rowName + "Title");

        headers.sort(function(a, b)
        {
            return a.name > b.name ? 1 : -1;
        });

        this.headerDataTag.insertRows({headers: headers}, titleRow ? titleRow : tbody);
        Css.removeClass(titleRow, "collapsed");
    },
});

// ********************************************************************************************* //

/**
 * @domplate Represents posted data within request info (the info, which is visible when
 * a request entry is expanded. This template renders content of the Post tab.
 */
Firebug.NetMonitor.NetInfoPostData = domplate(Rep, new EventSource(),
{
    // application/x-www-form-urlencoded
    paramsTable:
        TABLE({"class": "netInfoPostParamsTable", cellpadding: 0, cellspacing: 0,
            "role": "presentation"},
            TBODY({"role": "list", "aria-label": Locale.$STR("net.label.Parameters")},
                TR({"class": "netInfoPostParamsTitle", "role": "presentation"},
                    TD({colspan: 2, "role": "presentation"},
                        DIV({"class": "netInfoPostParams"},
                            Locale.$STR("net.label.Parameters"),
                            SPAN({"class": "netInfoPostContentType"},
                                "application/x-www-form-urlencoded"
                            )
                        )
                    )
                )
            )
        ),

    // multipart/form-data
    partsTable:
        TABLE({"class": "netInfoPostPartsTable", cellpadding: 0, cellspacing: 0,
            "role": "presentation"},
            TBODY({"role": "list", "aria-label": Locale.$STR("net.label.Parts")},
                TR({"class": "netInfoPostPartsTitle", "role": "presentation"},
                    TD({colspan: 2, "role":"presentation" },
                        DIV({"class": "netInfoPostParams"},
                            Locale.$STR("net.label.Parts"),
                            SPAN({"class": "netInfoPostContentType"},
                                "multipart/form-data"
                            )
                        )
                    )
                )
            )
        ),

    // application/json
    jsonTable:
        TABLE({"class": "netInfoPostJSONTable", cellpadding: 0, cellspacing: 0,
            "role": "presentation"},
            TBODY({"role": "list", "aria-label": Locale.$STR("jsonviewer.tab.JSON")},
                TR({"class": "netInfoPostJSONTitle", "role": "presentation"},
                    TD({"role": "presentation" },
                        DIV({"class": "netInfoPostParams"},
                            Locale.$STR("jsonviewer.tab.JSON")
                        )
                    )
                ),
                TR(
                    TD({"class": "netInfoPostJSONBody"})
                )
            )
        ),

    // application/xml
    xmlTable:
        TABLE({"class": "netInfoPostXMLTable", cellpadding: 0, cellspacing: 0,
            "role": "presentation"},
            TBODY({"role": "list", "aria-label": Locale.$STR("xmlviewer.tab.XML")},
                TR({"class": "netInfoPostXMLTitle", "role": "presentation"},
                    TD({"role": "presentation" },
                        DIV({"class": "netInfoPostParams"},
                            Locale.$STR("xmlviewer.tab.XML")
                        )
                    )
                ),
                TR(
                    TD({"class": "netInfoPostXMLBody"})
                )
            )
        ),

    // image/svg+xml
    svgTable:
        TABLE({"class": "netInfoPostSVGTable", cellpadding: 0, cellspacing: 0,
            "role": "presentation"},
            TBODY({"role": "list", "aria-label": Locale.$STR("svgviewer.tab.SVG")},
                TR({"class": "netInfoPostSVGTitle", "role": "presentation"},
                    TD({"role": "presentation" },
                        DIV({"class": "netInfoPostParams"},
                            Locale.$STR("svgviewer.tab.SVG")
                        )
                    )
                ),
                TR(
                    TD({"class": "netInfoPostSVGBody"})
                )
            )
        ),

    // application/x-woff
    fontTable:
      TABLE({"class": "netInfoPostFontTable", cellpadding: 0, cellspacing: 0,
        "role": "presentation"},
          TBODY({"role": "list", "aria-label": Locale.$STR("fontviewer.tab.Font")},
              TR({"class": "netInfoPostFontTitle", "role": "presentation"},
                  TD({"role": "presentation" },
                      Locale.$STR("fontviewer.tab.Font")
                  )
              ),
              TR(
                  TD({"class": "netInfoPostFontBody"})
              )
          )
      ),

    sourceTable:
        TABLE({"class": "netInfoPostSourceTable", cellpadding: 0, cellspacing: 0,
            "role": "presentation"},
            TBODY({"role": "list", "aria-label": Locale.$STR("net.label.Source")},
                TR({"class": "netInfoPostSourceTitle", "role": "presentation"},
                    TD({colspan: 2, "role": "presentation"},
                        DIV({"class": "netInfoPostSource"},
                            Locale.$STR("net.label.Source")
                        )
                    )
                )
            )
        ),

    sourceBodyTag:
        TR({"role": "presentation"},
            TD({colspan: 2, "role": "presentation"},
                FOR("line", "$param|getParamValueIterator",
                    CODE({"class":"focusRow subFocusRow", "role": "listitem"}, "$line")
                )
            )
        ),

    getParamValueIterator: function(param)
    {
        return Firebug.NetMonitor.NetInfoBody.getParamValueIterator(param);
    },

    render: function(context, parentNode, file)
    {
        var text = NetUtils.getPostText(file, context, true);
        if (text == undefined)
            return;

        if (NetUtils.isURLEncodedRequest(file, context))
        {
            var lines = text.split("\n");
            var params = Url.parseURLEncodedText(lines[lines.length-1]);
            if (params)
                this.insertParameters(parentNode, params);
        }

        if (NetUtils.isMultiPartRequest(file, context))
        {
            var data = this.parseMultiPartText(file, context);
            if (data)
                this.insertParts(parentNode, data);
        }

        var contentType = NetUtils.findHeader(file.requestHeaders, "content-type");

        // TODO: Trigger an event here instead and register the viewer models as listeners
        if (Firebug.JSONViewerModel.isJSON(contentType, text))
            this.insertJSON(parentNode, file, context);

        if (Firebug.XMLViewerModel.isXML(contentType))
            this.insertXML(parentNode, file, context);

        if (Firebug.SVGViewerModel.isSVG(contentType))
            this.insertSVG(parentNode, file, context);

        if (Firebug.FontViewerModel.isFont(contentType, file.href, text))
            this.insertFont(parentNode, file, context);

        var postText = NetUtils.getPostText(file, context);

        // Make sure headers are not displayed in the 'source' section.
        postText = Http.removeHeadersFromPostText(file.request, postText);
        postText = NetUtils.formatPostText(postText);
        if (postText)
            this.insertSource(parentNode, postText);
    },

    insertParameters: function(parentNode, params)
    {
        if (!params || !params.length)
            return;

        var paramTable = this.paramsTable.append(null, parentNode);
        var row = paramTable.getElementsByClassName("netInfoPostParamsTitle").item(0);

        Firebug.NetMonitor.NetInfoBody.headerDataTag.insertRows({headers: params}, row);
    },

    insertParts: function(parentNode, data)
    {
        if (!data.params || !data.params.length)
            return;

        var partsTable = this.partsTable.append(null, parentNode);
        var row = partsTable.getElementsByClassName("netInfoPostPartsTitle").item(0);

        Firebug.NetMonitor.NetInfoBody.headerDataTag.insertRows({headers: data.params}, row);
    },

    insertJSON: function(parentNode, file, context)
    {
        var text = NetUtils.getPostText(file, context);
        var data = Json.parseJSONString(text, "http://" + file.request.originalURI.host);
        if (!data)
            return;

        var jsonTable = this.jsonTable.append(null, parentNode);
        var jsonBody = jsonTable.getElementsByClassName("netInfoPostJSONBody").item(0);

        if (!this.toggles)
            this.toggles = new ToggleBranch.ToggleBranch();

        Firebug.DOMPanel.DirTable.tag.replace(
            {object: data, toggles: this.toggles}, jsonBody);
    },

    insertXML: function(parentNode, file, context)
    {
        var text = NetUtils.getPostText(file, context);

        var jsonTable = this.xmlTable.append(null, parentNode);
        var jsonBody = jsonTable.getElementsByClassName("netInfoPostXMLBody").item(0);

        Firebug.XMLViewerModel.insertXML(jsonBody, text);
    },

    insertSVG: function(parentNode, file, context)
    {
        var text = NetUtils.getPostText(file, context);

        var jsonTable = this.svgTable.append(null, parentNode);
        var jsonBody = jsonTable.getElementsByClassName("netInfoPostSVGBody").item(0);

        Firebug.SVGViewerModel.insertSVG(jsonBody, text);
    },

    insertFont: function(parentNode, file, context)
    {
        var text = NetUtils.getPostText(file, context);

        var fontTable = this.fontTable.append(null, parentNode);
        var fontBody = fontTable.getElementsByClassName("netInfoPostFontBody").item(0);

        Firebug.FontViewerModel.insertFont(fontBody, text);
    },

    insertSource: function(parentNode, text)
    {
        var sourceTable = this.sourceTable.append(null, parentNode);
        var row = sourceTable.getElementsByClassName("netInfoPostSourceTitle").item(0);

        var param = {value: text};
        this.sourceBodyTag.insertRows({param: param}, row);
    },

    parseMultiPartText: function(file, context)
    {
        var text = NetUtils.getPostText(file, context);
        if (text == undefined)
            return null;

        FBTrace.sysout("net.parseMultiPartText; boundary: ", text);

        var boundary = text.match(/\s*boundary=\s*(.*)/)[1];

        var divider = "\r\n\r\n";
        var bodyStart = text.indexOf(divider);
        var body = text.substr(bodyStart + divider.length);

        var postData = {};
        postData.mimeType = "multipart/form-data";
        postData.params = [];

        var parts = body.split("--" + boundary);
        for (var i=0; i<parts.length; i++)
        {
            var part = parts[i].split(divider);
            if (part.length != 2)
                continue;

            var m = part[0].match(/\s*name=\"(.*)\"(;|$)/);
            postData.params.push({
                name: (m && m.length > 1) ? m[1] : "",
                value: Str.trim(part[1])
            });
        }

        return postData;
    }
});

// ********************************************************************************************* //

/**
 * @domplate Used within the Net panel to display raw source of request and response headers
 * as well as pretty-formatted summary of these headers.
 */
Firebug.NetMonitor.NetInfoHeaders = domplate(Rep, new EventSource(),
{
    tag:
        DIV({"class": "netInfoHeadersTable", "role": "tabpanel"},
            DIV({"class": "netHeadersGroup collapsed", "data-pref": "netResponseHeadersVisible"},
                DIV({"class": "netInfoHeadersGroup netInfoResponseHeadersTitle"},
                    SPAN({"class": "netHeader twisty",
                        onclick: "$toggleHeaderContent"},
                        Locale.$STR("ResponseHeaders")
                    ),
                    SPAN({"class": "netHeadersViewSource response collapsed", onclick: "$onViewSource",
                        _sourceDisplayed: false, _rowName: "ResponseHeaders"},
                        Locale.$STR("net.headers.view source")
                    )
                ),
                TABLE({cellpadding: 0, cellspacing: 0},
                    TBODY({"class": "netInfoResponseHeadersBody", "role": "list",
                        "aria-label": Locale.$STR("ResponseHeaders")})
                )
            ),
            DIV({"class": "netHeadersGroup collapsed", "data-pref": "netRequestHeadersVisible"},
                DIV({"class": "netInfoHeadersGroup netInfoRequestHeadersTitle"},
                    SPAN({"class": "netHeader twisty", 
                        onclick: "$toggleHeaderContent"},
                        Locale.$STR("RequestHeaders")),
                    SPAN({"class": "netHeadersViewSource request collapsed", onclick: "$onViewSource",
                        _sourceDisplayed: false, _rowName: "RequestHeaders"},
                        Locale.$STR("net.headers.view source")
                    )
                ),
                TABLE({cellpadding: 0, cellspacing: 0},
                    TBODY({"class": "netInfoRequestHeadersBody", "role": "list",
                    "aria-label": Locale.$STR("RequestHeaders")})
                )
            ),
            DIV({"class": "netHeadersGroup collapsed", "data-pref": "netCachedHeadersVisible"},
                DIV({"class": "netInfoHeadersGroup netInfoCachedResponseHeadersTitle"},
                    SPAN({"class": "netHeader twisty", 
                        onclick: "$toggleHeaderContent"},
                        Locale.$STR("CachedResponseHeaders"))
                ),
                TABLE({cellpadding: 0, cellspacing: 0},
                    TBODY({"class": "netInfoCachedResponseHeadersBody", "role": "list",
                        "aria-label": Locale.$STR("CachedResponseHeaders")})
                )
            ),
            DIV({"class": "netHeadersGroup collapsed", "data-pref": "netPostRequestHeadersVisible"},
                DIV({"class": "netInfoHeadersGroup netInfoPostRequestHeadersTitle"},
                    SPAN({"class": "netHeader twisty", 
                        onclick: "$toggleHeaderContent"},
                    Locale.$STR("PostRequestHeaders"))
                ),
                TABLE({cellpadding: 0, cellspacing: 0},
                    TBODY({"class": "netInfoPostRequestHeadersBody", "role": "list",
                        "aria-label": Locale.$STR("PostRequestHeaders")})
                )
            )
        ),

    sourceTag:
        TR({"role": "presentation"},
            TD({colspan: 2, "role": "presentation"},
                PRE({"class": "source"})
            )
        ),

    toggleHeaderContent: function(event)
    {
        var target = event.target;
        var headerGroup = Dom.getAncestorByClass(target, "netHeadersGroup");
        
        Css.toggleClass(headerGroup, "opened");
        if (Css.hasClass(headerGroup, "opened")) 
        {
            headerGroup.setAttribute("aria-expanded", "true");
            Options.set(headerGroup.dataset.pref, true);
        }
        else
        {
            headerGroup.setAttribute("aria-expanded", "false");
            Options.set(headerGroup.dataset.pref, false);
        }
    },

    onViewSource: function(event)
    {
        var target = event.target;
        var requestHeaders = (target.rowName == "RequestHeaders");

        var netInfoBox = Dom.getAncestorByClass(target, "netInfoBody");
        var file = netInfoBox.repObject;

        if (target.sourceDisplayed)
        {
            var headers = requestHeaders ? file.requestHeaders : file.responseHeaders;
            this.insertHeaderRows(netInfoBox, headers, target.rowName);
            target.textContent = Locale.$STR("net.headers.view source");
        }
        else
        {
            var source = requestHeaders ? file.requestHeadersText : file.responseHeadersText;
            this.insertSource(netInfoBox, source, target.rowName);
            target.textContent = Locale.$STR("net.headers.pretty print");
        }

        target.sourceDisplayed = !target.sourceDisplayed;

        Events.cancelEvent(event);
    },

    insertSource: function(netInfoBox, source, rowName)
    {
        var tbody = netInfoBox.getElementsByClassName("netInfo" + rowName + "Body").item(0);
        var node = this.sourceTag.replace({}, tbody);
        var sourceNode = node.getElementsByClassName("source").item(0);
        sourceNode.textContent = source;
    },

    insertHeaderRows: function(netInfoBox, headers, rowName)
    {
        var headersTable = netInfoBox.getElementsByClassName("netInfoHeadersTable").item(0);
        var tbody = headersTable.getElementsByClassName("netInfo" + rowName + "Body").item(0);

        Dom.clearNode(tbody);

        if (headers && headers.length)
        {
            headers.sort(function(a, b)
            {
                return a.name > b.name ? 1 : -1;
            });

            Firebug.NetMonitor.NetInfoBody.headerDataTag.insertRows({headers: headers}, tbody);

            var titleRow = headersTable.getElementsByClassName("netInfo" + rowName + "Title").item(0)
            var parent = Dom.getAncestorByClass(titleRow, "netHeadersGroup");
            Css.removeClass(parent, "collapsed");
        }
    },

    init: function(parent)
    {
        var rootNode = this.tag.append({}, parent);

        var netInfoBox = Dom.getAncestorByClass(parent, "netInfoBody");
        var file = netInfoBox.repObject;

        var viewSource;
        var headers = rootNode.getElementsByClassName("netHeadersGroup");

        if (Options.get("netResponseHeadersVisible"))
            Css.setClass(headers[0], "opened");

        if (Options.get("netRequestHeadersVisible"))
            Css.setClass(headers[1], "opened");

        if (Options.get("netCachedHeadersVisible"))
            Css.setClass(headers[2], "opened");

        if (Options.get("netPostRequestHeadersVisible"))
            Css.setClass(headers[3], "opened");

        viewSource = rootNode.getElementsByClassName("netHeadersViewSource request").item(0);
        if (file.requestHeadersText)
            Css.removeClass(viewSource, "collapsed");

        viewSource = rootNode.getElementsByClassName("netHeadersViewSource response").item(0);
        if (file.responseHeadersText)
            Css.removeClass(viewSource, "collapsed");
    },

    renderHeaders: function(parent, headers, rowName)
    {
        if (!parent.firstChild)
            this.init(parent);

        this.insertHeaderRows(parent, headers, rowName);
    }
});

// ********************************************************************************************* //

/**
 * @domplate Represents a template for a pupup tip with detailed size info.
 */
Firebug.NetMonitor.SizeInfoTip = domplate(Rep,
{
    tag:
        TABLE({"class": "sizeInfoTip", "id": "fbNetSizeInfoTip", role:"presentation"},
            TBODY(
                FOR("size", "$sizeInfo",
                    TAG("$size|getRowTag", {size: "$size"})
                )
            )
        ),

    sizeTag:
        TR({"class": "sizeInfoRow", $collapsed: "$size|hideRow"},
            TD({"class": "sizeInfoLabelCol"}, "$size.label"),
            TD({"class": "sizeInfoSizeCol"}, "$size|formatSize"),
            TD({"class": "sizeInfoDetailCol"}, "$size|formatNumber")
        ),

    separatorTag:
        TR(
            TD({"colspan": 3, "height": "7px"})
        ),

    descTag:
        TR(
            TD({"colspan": 3, "class": "sizeInfoDescCol"}, "$size.label")
        ),

    getRowTag: function(size)
    {
        if (size.size == -2)
            return this.descTag;

        return (size.label == "-") ? this.separatorTag : this.sizeTag;
    },

    hideRow: function(size)
    {
        return size.size < 0;
    },

    formatSize: function(size)
    {
        return Str.formatSize(size.size);
    },

    formatNumber: function(size)
    {
        return size.size && size.size >= 1024 ? "(" + size.size.toLocaleString() + " B)" : "";
    },

    render: function(file, parentNode)
    {
        var postText = NetUtils.getPostText(file, Firebug.currentContext, true);
        postText = postText ? postText : "";

        var sizeInfo = [];
        sizeInfo.push({label: Locale.$STR("net.sizeinfo.Response Body"), size: file.size});
        sizeInfo.push({label: Locale.$STR("net.sizeinfo.Post Body"), size: postText.length});

        if (file.requestHeadersText)
        {
            var responseHeaders = file.responseHeadersText ? file.responseHeadersText : 0;
            sizeInfo.push({label: "-", size: 0});
            sizeInfo.push({label: Locale.$STR("net.sizeinfo.Total Received") + "*",
                size: (responseHeaders.length ? responseHeaders.length : 0)  + file.size});
            sizeInfo.push({label: Locale.$STR("net.sizeinfo.Total Sent") + "*",
                size: file.requestHeadersText.length + postText.length});
            sizeInfo.push({label: " ", size: -2});
            sizeInfo.push({label: "* " + Locale.$STR("net.sizeinfo.Including HTTP Headers"),
                size: -2});
        }

        this.tag.replace({sizeInfo: sizeInfo}, parentNode);
    }
});

// ********************************************************************************************* //

Firebug.NetMonitor.ResponseSizeLimit = domplate(Rep,
{
    tag:
        DIV({"class": "netInfoResponseSizeLimit"},
            SPAN("$object.beforeLink"),
            A({"class": "objectLink", onclick: "$onClickLink"},
                "$object.linkText"
            ),
            SPAN("$object.afterLink")
        ),

    reLink: /^(.*)<a>(.*)<\/a>(.*$)/,
    append: function(obj, parent)
    {
        var m = obj.text.match(this.reLink);
        return this.tag.append({onClickLink: obj.onClickLink,
            object: {
            beforeLink: m[1],
            linkText: m[2],
            afterLink: m[3],
        }}, parent, this);
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerRep(Firebug.NetMonitor.NetRequestTable);

return Firebug.NetMonitor.NetRequestTable;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/netUtils",
[
    "firebug/firebug",
    "firebug/lib/locale",
    "firebug/lib/events",
    "firebug/lib/url",
    "firebug/chrome/firefox",
    "firebug/lib/wrapper",
    "firebug/lib/xpcom",
    "firebug/lib/http",
    "firebug/lib/string",
    "firebug/lib/xml"
],
function(Firebug, Locale, Events, Url, Firefox, Wrapper, Xpcom, Http, Str, Xml) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;
const Cu = Components.utils;

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

const mimeExtensionMap =
{
    "html": "text/html",
    "htm": "text/html",
    "xhtml": "text/html",
    "xml": "text/xml",
    "css": "text/css",
    "js": "application/x-javascript",
    "jss": "application/x-javascript",
    "jpg": "image/jpg",
    "jpeg": "image/jpeg",
    "gif": "image/gif",
    "png": "image/png",
    "bmp": "image/bmp",
    "woff": "application/font-woff",
    "ttf": "application/x-font-ttf",
    "otf": "application/x-font-otf",
    "swf": "application/x-shockwave-flash",
    "xap": "application/x-silverlight-app",
    "flv": "video/x-flv",
    "webm": "video/webm"
};

const mimeCategoryMap =
{
    // xxxHonza: note that there is no filter for 'txt' category,
    // shell we use e.g. 'media' instead?
    "text/plain": "txt",

    "application/octet-stream": "bin",
    "text/html": "html",
    "text/xml": "html",
    "application/rss+xml": "html",
    "application/atom+xml": "html",
    "application/xhtml+xml": "html",
    "application/mathml+xml": "html",
    "application/rdf+xml": "html",
    "text/css": "css",
    "application/x-javascript": "js",
    "text/javascript": "js",
    "application/javascript" : "js",
    "text/ecmascript": "js",
    "application/ecmascript" : "js", // RFC4329
    "image/jpeg": "image",
    "image/jpg": "image",
    "image/gif": "image",
    "image/png": "image",
    "image/bmp": "image",
    "application/x-shockwave-flash": "plugin",
    "application/x-silverlight-app": "plugin",
    "video/x-flv": "media",
    "audio/mpeg3": "media",
    "audio/x-mpeg-3": "media",
    "video/mpeg": "media",
    "video/x-mpeg": "media",
    "video/webm": "media",
    "video/mp4": "media",
    "video/ogg": "media",
    "audio/ogg": "media",
    "application/ogg": "media",
    "application/x-ogg": "media",
    "application/x-midi": "media",
    "audio/midi": "media",
    "audio/x-mid": "media",
    "audio/x-midi": "media",
    "music/crescendo": "media",
    "audio/wav": "media",
    "audio/x-wav": "media",
    "application/x-woff": "font",
    "application/font-woff": "font",
    "application/x-font-woff": "font",
    "application/x-ttf": "font",
    "application/x-font-ttf": "font",
    "font/ttf": "font",
    "font/woff": "font",
    "application/x-otf": "font",
    "application/x-font-otf": "font"
};

const fileCategories =
{
    "undefined": 1,
    "html": 1,
    "css": 1,
    "js": 1,
    "xhr": 1,
    "image": 1,
    "plugin": 1,
    "media": 1,
    "font": 1,
    "txt": 1,
    "bin": 1
};

const textFileCategories =
{
    "txt": 1,
    "html": 1,
    "xhr": 1,
    "css": 1,
    "js": 1
};

const binaryFileCategories =
{
    "bin": 1,
    "plugin": 1,
    "media": 1
};

const binaryCategoryMap =
{
    "image": 1,
    "plugin" : 1,
    "font": 1
};

const requestProps =
{
    "allowPipelining": 1,
    "allowSpdy": 1,
    "canceled": 1,
    "channelIsForDownload": 1,
    "contentCharset": 1,
    "contentLength": 1,
    "contentType": 1,
    "forceAllowThirdPartyCookie": 1,
    "loadAsBlocking": 1,
    "loadUnblocked": 1,
    "localAddress": 1,
    "localPort": 1,
    "name": 1,
    "redirectionLimit": 1,
    "remoteAddress": 1,
    "remotePort": 1,
    "requestMethod": 1,
    "requestSucceeded": 1,
    "responseStatus": 1,
    "responseStatusText": 1,
    "status": 1,
};

// ********************************************************************************************* //

var NetUtils =
{
    isXHR: Http.isXHR, // deprecated

    mimeExtensionMap: mimeExtensionMap,
    mimeCategoryMap: mimeCategoryMap,
    fileCategories: fileCategories,
    textFileCategories: textFileCategories,
    binaryFileCategories: binaryFileCategories,
    binaryCategoryMap: binaryCategoryMap,

    now: function()
    {
        return (new Date()).getTime();
    },

    getFrameLevel: function(win)
    {
        var level = 0;
        for (; win && (win != win.parent) && (win.parent instanceof window.Window); win = win.parent)
            ++level;
        return level;
    },

    findHeader: function(headers, name)
    {
        if (!headers)
            return null;

        name = name.toLowerCase();
        for (var i = 0; i < headers.length; ++i)
        {
            var headerName = headers[i].name.toLowerCase();
            if (headerName == name)
                return headers[i].value;
        }
    },

    formatPostText: function(text)
    {
        if (text instanceof window.XMLDocument)
            return Xml.getElementXML(text.documentElement);
        else
            return text;
    },

    getPostText: function(file, context, noLimit)
    {
        if (!file.postText)
        {
            file.postText = Http.readPostTextFromRequest(file.request, context);

            if (!file.postText && context)
                file.postText = Http.readPostTextFromPage(file.href, context);
        }

        if (!file.postText)
            return file.postText;

        var limit = Firebug.netDisplayedPostBodyLimit;
        if (file.postText.length > limit && !noLimit)
        {
            return Str.cropString(file.postText, limit,
                "\n\n... " + Locale.$STR("net.postDataSizeLimitMessage") + " ...\n\n");
        }

        return file.postText;
    },

    getResponseText: function(file, context)
    {
        // The response can be also empty string so, check agains "undefined".
        return (typeof(file.responseText) != "undefined") ?
            file.responseText :
            context.sourceCache.loadText(file.href, file.method, file);
    },

    matchesContentType: function(headerValue, contentType)
    {
        var contentTypes = (typeof contentType == "string" ? [contentType] : contentType);
        for (var i = 0; i < contentTypes.length; ++i)
        {
            // The header value doesn't have to match the content type exactly;
            // there can be a charset specified. So, test for a prefix instead.
            if (Str.hasPrefix(headerValue, contentTypes[i]))
                return true;
        }
        return false;
    },

    isURLEncodedRequest: function(file, context)
    {
        var text = NetUtils.getPostText(file, context);
        if (text && Str.hasPrefix(text.toLowerCase(), "content-type: application/x-www-form-urlencoded"))
            return true;

        var headerValue = NetUtils.findHeader(file.requestHeaders, "content-type");
        return (headerValue &&
                NetUtils.matchesContentType(headerValue, "application/x-www-form-urlencoded"));
    },

    isMultiPartRequest: function(file, context)
    {
        var text = NetUtils.getPostText(file, context);
        if (text && Str.hasPrefix(text.toLowerCase(), "content-type: multipart/form-data"))
            return true;
        return false;
    },

    getMimeType: function(mimeType, uri)
    {
        // Get rid of optional charset, e.g. "text/html; charset=UTF-8".
        // We need pure mime type so, we can use it as a key for look up.
        if (mimeType)
            mimeType = mimeType.split(";")[0];

        // If the mime-type exists and is known just return it...
        if (mimeType && mimeCategoryMap.hasOwnProperty(mimeType))
            return mimeType;

        // ... otherwise we need guess it according to the file extension.
        var ext = Url.getFileExtension(uri);
        if (!ext)
            return mimeType;

        var extMimeType = mimeExtensionMap[ext.toLowerCase()];
        return extMimeType ? extMimeType : mimeType;
    },

    getDateFromSeconds: function(s)
    {
        var d = new Date();
        d.setTime(s*1000);
        return d;
    },

    getHttpHeaders: function(request, file, context)
    {
        if (!(request instanceof Ci.nsIHttpChannel))
            return;

        // xxxHonza: is there any problem to do this in requestedFile method?
        file.method = request.requestMethod;
        file.urlParams = Url.parseURLParams(file.href);

        try
        {
            file.status = request.responseStatus;
        }
        catch (e) { }

        try
        {
            file.mimeType = NetUtils.getMimeType(request.contentType, request.name);
        }
        catch (e) { }

        try
        {
            if (!file.requestHeaders)
            {
                var requestHeaders = [];
                request.visitRequestHeaders({
                    visitHeader: function(name, value)
                    {
                        requestHeaders.push({name: name, value: value});
                    }
                });
                file.requestHeaders = requestHeaders;
            }
        }
        catch (e) { }

        try
        {
            if (!file.responseHeaders)
            {
                var responseHeaders = [];
                request.visitResponseHeaders({
                    visitHeader: function(name, value)
                    {
                        responseHeaders.push({name: name, value: value});
                    }
                });
                file.responseHeaders = responseHeaders;

                if (context)
                {
                    // Response haeaders are available now, dispatch an event to listeners
                    Events.dispatch(Firebug.NetMonitor.fbListeners, "onResponseHeaders",
                        [context, file]);
                }
            }
        }
        catch (e) { }
    },

    /**
     * Returns a category for specific request (file). The logic is as follows:
     * 1) Use file-extension to guess the mime type. This is prefered since
     *    mime-types in HTTP requests are often wrong.
     *    This part is based on mimeExtensionMap map.
     * 2) If the file extension is missing or unknown, try to get the mime-type
     *    from the HTTP request object.
     * 3) If there is still no mime-type, return empty category name.
     * 4) Use the mime-type and look up the right category.
     *    This part is based on mimeCategoryMap map.
     */
    getFileCategory: function(file)
    {
        if (file.category)
            return file.category;

        // All XHRs have its own category.
        if (file.isXHR)
            return file.category = "xhr";

        // Guess mime-type according to the file extension. Using file extension
        // is prefered way since mime-types in HTTP requests are often wrong.
        var mimeType = this.getMimeType(null, file.href);

        // If no luck with file extension, let's try to get the mime-type from
        // the request object.
        if (!mimeType)
            mimeType = this.getMimeType(file.mimeType, file.href);

        // No mime-type, no category.
        if (!mimeType)
            return "";

        // Finally, get the category according to the mime type.
        return file.category = mimeCategoryMap[mimeType];
    },

    getPageTitle: function(context)
    {
        var title = context.getTitle();
        return (title) ? title : context.getName();
    },

    getBlockingEndTime: function(file)
    {
        //var blockingEnd = (file.sendingTime > file.startTime) ? file.sendingTime : file.waitingForTime;

        if (file.resolveStarted && file.connectStarted)
            return file.resolvingTime;

        if (file.connectStarted)
            return file.connectingTime;

        if (file.sendStarted)
            return file.sendingTime;

        return file.waitingForTime;
    },

    getTimeLabelFromMs: function(ms)
    {
        var time = new Date();
        time.setTime(ms);
        return this.getTimeLabel(time);
    },

    getTimeLabel: function(date)
    {
        var m = date.getMinutes() + "";
        var s = date.getSeconds() + "";
        var ms = date.getMilliseconds() + "";
        return "[" + ((m.length > 1) ? m : "0" + m) + ":" +
            ((s.length > 1) ? s : "0" + s) + "." +
            ((ms.length > 2) ? ms : ((ms.length > 1) ? "0" + ms : "00" + ms)) + "]";
    },

    openResponseInTab: function(file)
    {
        try
        {
            var response = NetUtils.getResponseText(file, this.context);
            var inputStream = Http.getInputStreamFromString(response);
            var stream = Xpcom.CCIN("@mozilla.org/binaryinputstream;1", "nsIBinaryInputStream");
            stream.setInputStream(inputStream);
            var encodedResponse = btoa(stream.readBytes(stream.available()));
            var dataURI = "data:" + file.request.contentType + ";base64," + encodedResponse;
        
            var tabBrowser = Firefox.getTabBrowser();
            tabBrowser.selectedTab = tabBrowser.addTab(dataURI);
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("net.openResponseInTab EXCEPTION", err);
        }
    },

    traceRequestTiming: function(msg, file)
    {
        var blockingEnd = this.getBlockingEndTime(file);

        //Helper log for debugging timing problems.
        var timeLog = {};
        timeLog.startTime = this.getTimeLabelFromMs(file.startTime);
        timeLog.resolvingTime = this.getTimeLabelFromMs(file.resolvingTime);
        timeLog.connectingTime = this.getTimeLabelFromMs(file.connectingTime);
        timeLog.connectedTime = this.getTimeLabelFromMs(file.connectedTime);
        timeLog.blockingEnd = this.getTimeLabelFromMs(blockingEnd);
        timeLog.sendingTime = this.getTimeLabelFromMs(file.sendingTime);
        timeLog.waitingForTime = this.getTimeLabelFromMs(file.waitingForTime);
        timeLog.respondedTime = this.getTimeLabelFromMs(file.respondedTime);
        timeLog.endTime = this.getTimeLabelFromMs(file.endTime);

        if (file.request instanceof Ci.nsITimedChannel)
        {
            timeLog.startTime += " - " + this.getTimeLabelFromMs(file.request.channelCreationTime/1000);
            timeLog.startTime += this.getTimeLabelFromMs(file.request.asyncOpenTime/1000);
            timeLog.resolvingTime += " - " + this.getTimeLabelFromMs(file.request.domainLookupStartTime/1000);
            timeLog.resolvingTime += this.getTimeLabelFromMs(file.request.domainLookupEndTime/1000);
            timeLog.connectingTime += " - " + this.getTimeLabelFromMs(file.request.connectStartTime/1000);
            timeLog.connectedTime += " - " + this.getTimeLabelFromMs(file.request.connectEndTime/1000);
            timeLog.sendingTime += " - " + this.getTimeLabelFromMs(file.request.requestStartTime/1000);
            timeLog.respondedTime += " - " + this.getTimeLabelFromMs(file.request.responseStartTime/1000);
            timeLog.endTime += " - " + this.getTimeLabelFromMs(file.request.responseEndTime/1000);
            timeLog.cacheReadStartTime = this.getTimeLabelFromMs(file.request.cacheReadStartTime/1000);
            timeLog.cacheReadEndTime = this.getTimeLabelFromMs(file.request.cacheReadEndTime/1000);
            timeLog.timingEnabled = file.request.timingEnabled;
        }

        FBTrace.sysout(msg + " " + file.href, timeLog);
    },

    /**
     * Returns a content-accessible 'real object' that is used by 'Inspect in DOM Panel'
     * or 'Use in Command Line' features. Firebug is primarily a tool for web developers
     * and thus shouldn't expose internal chrome objects.
     */
    getRealObject: function(file, context)
    {
        var global = context.getCurrentGlobal();
        var clone = {};

        function cloneHeaders(headers)
        {
            var newHeaders = [];
            for (var i=0; headers && i<headers.length; i++)
            {
                var header = {name: headers[i].name, value: headers[i].value};
                header = Wrapper.cloneIntoContentScope(global, header);
                newHeaders.push(header);
            }
            return newHeaders;
        }

        // Iterate over all properties of the request object (nsIHttpChannel)
        // and pick only those that are specified in 'requestProps' list.
        var request = file.request;
        for (var p in request)
        {
            if (!(p in requestProps))
                continue;

            try
            {
                clone[p] = request[p];
            }
            catch (err)
            {
                // xxxHonza: too much unnecessary output
                //if (FBTrace.DBG_ERRORS)
                //    FBTrace.sysout("net.getRealObject EXCEPTION " + err, err);
            }
        }

        // Additional props from |file|
        clone.responseBody = file.responseText;
        clone.postBody = file.postBody;
        clone.requestHeaders = cloneHeaders(file.requestHeaders);
        clone.responseHeaders = cloneHeaders(file.responseHeaders);

        return Wrapper.cloneIntoContentScope(global, clone);
    },

    generateCurlCommand: function(file, addCompressedArgument)
    {
        var command = ["curl"];
        var ignoredHeaders = {};
        var inferredMethod = "GET";

        function escapeCharacter(x)
        {
            var code = x.charCodeAt(0);
            if (code < 256)
            {
                // Add leading zero when needed to not care about the next character.
                return code < 16 ? "\\x0" + code.toString(16) : "\\x" + code.toString(16);
            }
            code = code.toString(16);
            return "\\u" + ("0000" + code).substr(code.length, 4);
        }

        function escape(str)
        {
            // String has unicode characters or single quotes
            if (/[^\x20-\x7E]|'/.test(str))
            {
                // Use ANSI-C quoting syntax
                return "$\'" + str.replace(/\\/g, "\\\\")
                    .replace(/'/g, "\\\'")
                    .replace(/\n/g, "\\n")
                    .replace(/\r/g, "\\r")
                    .replace(/[^\x20-\x7E]/g, escapeCharacter) + "'";
            }
            else
            {
                // Use single quote syntax.
                return "'" + str + "'";
            }
        }

        // Create data
        var data = [];
        var postText = NetUtils.getPostText(file, this.context, true);
        var isURLEncodedRequest = NetUtils.isURLEncodedRequest(file, this.context);
        var isMultipartRequest = NetUtils.isMultiPartRequest(file, this.context);

        if (postText && isURLEncodedRequest || file.method == "PUT")
        {
            var lines = postText.split("\n");
            var params = lines[lines.length - 1];

            data.push("--data");
            data.push(escape(params));

            // Ignore content length as cURL will resolve this
            ignoredHeaders["Content-Length"] = true;

            inferredMethod = "POST";
        }
        else if (postText && isMultipartRequest)
        {
            data.push("--data-binary");
            data.push(escape(this.removeBinaryDataFromMultipartPostText(postText)));

            ignoredHeaders["Content-Length"] = true;
            inferredMethod = "POST";
        }

        // Add URL
        command.push(escape(file.href));

        // Fix method if request is not a GET or POST request
        if (file.method != inferredMethod)
        {
            command.push("-X");
            command.push(file.method);
        }

        // Add request headers
        // fixme: for multipart request, content-type should be omitted
        var requestHeaders = file.requestHeaders;
        var postRequestHeaders = Http.getHeadersFromPostText(file.request, postText);
        var headers = requestHeaders.concat(postRequestHeaders);
        for (var i=0; i<headers.length; i++)
        {
            var header = headers[i];

            if (header.name in ignoredHeaders)
                continue;

            command.push("-H");
            command.push(escape(header.name + ": " + header.value));
        }

        // Add data
        command = command.concat(data);

        // Add --compressed
        if (addCompressedArgument)
            command.push("--compressed");

        return command.join(" ");
    },

    removeBinaryDataFromMultipartPostText: function (postText)
    {
        var textWithoutBinaryData = "";

        var boundaryRe = /^--.+/gm;

        var boundaryString = boundaryRe.exec(postText)[0];

        var parts = postText.split(boundaryRe);

        var part;
        var contentDispositionLine;

        for (var i = 0; i<parts.length; i++)
        {
            part = parts[i];

            // The second line in a part holds the content disposition form-data
            contentDispositionLine = part.split("\r\n")[1];

            if (/^Content-Disposition: form-data/im.test(contentDispositionLine))
            {
                // filename= tells us that the form data is file input type
                if (/filename=/im.test(contentDispositionLine))
                {
                    // For file input parts
                    // Remove binary data. Only the Content-Disposition and Content-Type lines
                    // should remain.
                    textWithoutBinaryData += boundaryString
                        + part.match(/[\r\n]+Content-Disposition.+$[\r\n]+Content-Type.+$[\r\n]+/im).toString();
                }
                else
                {
                    textWithoutBinaryData += boundaryString + part;
                }
            }
        }

        textWithoutBinaryData += boundaryString + "--\r\n";

        return textWithoutBinaryData;
    }

};

// ********************************************************************************************* //
// Registration

return NetUtils;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/requestObserver",
[
    "firebug/lib/xpcom",
    "firebug/lib/trace",
    "firebug/lib/string",
    "firebug/lib/http",
    "firebug/trace/traceModule",
    "firebug/trace/traceListener"
],
function(Xpcom, FBTrace, Str, Http, TraceModule, TraceListener) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;

var observerService = Cc["@mozilla.org/observer-service;1"].getService(Ci.nsIObserverService);
var categoryManager = Cc["@mozilla.org/categorymanager;1"].getService(Ci.nsICategoryManager);

// ********************************************************************************************* //
// HTTP Request Observer implementation

/**
 * @service This service is intended as the only HTTP observer registered by Firebug.
 * All FB extensions and Firebug itself should register a listener within this
 * service in order to listen for http-on-modify-request, http-on-examine-response and
 * http-on-examine-cached-response events.
 *
 * See also: <a href="http://developer.mozilla.org/en/Setting_HTTP_request_headers">
 * Setting_HTTP_request_headers</a>
 */
var HttpRequestObserver =
/** lends HttpRequestObserver */
{
    observers: [],
    observing: false,

    registerObservers: function()
    {
        if (FBTrace.DBG_HTTPOBSERVER)
            FBTrace.sysout("httpObserver.registerObservers; (" + this.observers.length + "), " +
                "active: " + this.observing, getObserverList());

        if (!this.observing)
        {
            observerService.addObserver(this, "http-on-opening-request", false);
            observerService.addObserver(this, "http-on-modify-request", false);
            observerService.addObserver(this, "http-on-examine-response", false);
            observerService.addObserver(this, "http-on-examine-cached-response", false);
        }

        this.observing = true;
    },

    unregisterObservers: function()
    {
        if (FBTrace.DBG_HTTPOBSERVER)
            FBTrace.sysout("httpObserver.unregisterObservers; (" + this.observers.length + "), " +
                "active: " + this.observing, getObserverList());

        if (this.observing)
        {
            observerService.removeObserver(this, "http-on-opening-request");
            observerService.removeObserver(this, "http-on-modify-request");
            observerService.removeObserver(this, "http-on-examine-response");
            observerService.removeObserver(this, "http-on-examine-cached-response");
        }

        this.observing = false;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // nsIObserver

    observe: function(subject, topic, data)
    {
        try
        {
            if (!(subject instanceof Ci.nsIHttpChannel))
                return;

            // Notify all registered observers.
            if (topic == "http-on-modify-request" ||
                topic == "http-on-examine-response" ||
                topic == "http-on-examine-cached-response" ||
                topic == "http-on-opening-request")
            {
                this.notifyObservers(subject, topic, data);
            }
        }
        catch (err)
        {
            if (FBTrace.DBG_ERRORS)
                FBTrace.sysout("httpObserver.observe EXCEPTION", err);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // nsIObserverService

    addObserver: function(observer, topic, weak)
    {
        if (!topic)
            topic = "firebug-http-event";

        if (topic != "firebug-http-event")
            throw Cr.NS_ERROR_INVALID_ARG;

        // Do not add an observer twice.
        for (var i=0; i<this.observers.length; i++)
        {
            if (this.observers[i] == observer)
            {
                // xxxHonza: firebug/debugger is registering itself more times,
                // not sure if it's on purpose, but it causes following error message:
                // Error: attempt to run compile-and-go script on a cleared scope
                // (on the first line of the observe method)
                if (FBTrace.DBG_HTTPOBSERVER)
                    FBTrace.sysout("httpObserver.addObserver; ERROR? Observer already registered: " +
                        observer.dispatchName, getObserverList());
                return;
            }
        }

        this.observers.push(observer);

        if (FBTrace.DBG_HTTPOBSERVER)
            FBTrace.sysout("httpObserver.addObserver; (" + this.observers.length +
                "), added: " + observer.dispatchName);

        if (this.observers.length > 0)
            this.registerObservers();
    },

    removeObserver: function(observer, topic)
    {
        if (!topic)
            topic = "firebug-http-event";

        if (topic != "firebug-http-event")
            throw Cr.NS_ERROR_INVALID_ARG;

        for (var i=0; i<this.observers.length; i++)
        {
            if (this.observers[i] == observer)
            {
                this.observers.splice(i, 1);

                if (this.observers.length == 0)
                    this.unregisterObservers();

                if (FBTrace.DBG_HTTPOBSERVER)
                    FBTrace.sysout("httpObserver.removeObserver; (" + this.observers.length +
                        "), removed: " + observer.dispatchName, getObserverList());
                return;
            }
        }

        if (FBTrace.DBG_HTTPOBSERVER)
            FBTrace.sysout("httpObserver.removeObserver ERROR? (no such observer): " +
                observer.dispatchName);
    },

    notifyObservers: function(subject, topic, data)
    {
        if (FBTrace.DBG_HTTPOBSERVER)
        {
            FBTrace.sysout("httpObserver.notifyObservers (" + this.observers.length + ") " +
                (topic ? topic.toUpperCase() : topic) + ", " + Http.safeGetRequestName(subject),
                getObserverList());
        }

        for (var i=0; i<this.observers.length; i++)
        {
            var observer = this.observers[i];
            try
            {
                if (observer.observe)
                    observer.observe(subject, topic, data);
            }
            catch (err)
            {
                if (FBTrace.DBG_HTTPOBSERVER)
                    FBTrace.sysout("httpObserver.notifyObservers; EXCEPTION " + err, err);
            }
        }
    }
};

// ********************************************************************************************* //
// Tracing Support

function getObserverList()
{
    var observerNames = [];
    for (var i=0; i<HttpRequestObserver.observers.length; i++)
        observerNames.push(HttpRequestObserver.observers[i].dispatchName);

    return observerNames;
}

// ********************************************************************************************* //
// Registration

// Compatibility with Firebug 1.7 extensions: deprecated, obsolete
FBL.httpObserver = HttpRequestObserver;

// xxxHonza: Do we need to remove the listener?
TraceModule.addListener(new TraceListener("httpObserver.", "DBG_HTTPOBSERVER", true));

return HttpRequestObserver;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/responseObserver",
[
    "firebug/lib/xpcom",
    "firebug/lib/trace",
    "firebug/lib/http"
],
function(Xpcom, FBTrace, Http) {

// ********************************************************************************************* //
// Constants

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;
const Cu = Components.utils;

const PrefService = Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
var redirectionLimit = PrefService.getIntPref("network.http.redirection-limit");

// ********************************************************************************************* //
// ChannelListener implementation

/**
 * This object implements nsIStreamListener interface and is intended to monitor all network
 * channels (nsIHttpChannel). A new instance of this object is created and registered an HTTP
 * channel. See Firebug.TabCacheModel.onExamineResponse method.
 */
function ChannelListener(win, request, listener)
/** lends ChannelListener */
{
    this.window = win;
    this.request = request;
    this.proxyListener = listener;

    this.endOfLine = false;
    this.ignore = false;

    // The original channel listener (see nsITraceableChannel for more).
    this.listener = null;

    // The response will be written into the outputStream of this pipe.
    // Both ends of the pipe must be blocking.
    this.sink = Xpcom.CCIN("@mozilla.org/pipe;1", "nsIPipe");
    this.sink.init(false, false, 0x20000, 0x4000, null);

    // Remember the input stream, so it isn't released by GC.
    // See issue 2788 for more details.
    this.inputStream = this.sink.inputStream;

    this.downloadCounter = 0;

    // Add tee listener into the chain of request stream listeners so, the chain
    // doesn't include a JS code. This way all exceptions are propertly distributed
    // (#515051).
    var tee = Xpcom.CCIN("@mozilla.org/network/stream-listener-tee;1", "nsIStreamListenerTee");
    tee = tee.QueryInterface(Ci.nsIStreamListenerTee);

    var originalListener = request.setNewListener(tee);
    tee.init(originalListener, this.sink.outputStream, this);
}

ChannelListener.prototype =
{
    setAsyncListener: function(request, stream, listener)
    {
        try
        {
            // xxxHonza: is there any other way how to find out the stream is closed?
            // Throws NS_BASE_STREAM_CLOSED if the stream is closed normally or at end-of-file.
            var available = stream.available();
        }
        catch (err)
        {
            if (err.name == "NS_BASE_STREAM_CLOSED")
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("ChannelListener.setAsyncListener; " +
                        "Don't set, the stream is closed.");
                return;
            }

            if (FBTrace.DBG_CACHE || FBTrace.DBG_ERRORS)
                FBTrace.sysout("ChannelListener.setAsyncListener; EXCEPTION " +
                    Http.safeGetRequestName(request), err);
            return;
        }

        try
        {
            // Asynchronously wait for the stream to be readable or closed.
            stream.asyncWait(listener, 0, 0, null);
        }
        catch (err)
        {
            if (FBTrace.DBG_CACHE || FBTrace.DBG_ERRORS)
                FBTrace.sysout("ChannelListener.setAsyncListener; EXCEPTION " +
                    Http.safeGetRequestName(request), err);
        }
    },

    onCollectData: function(request, context, inputStream, offset, count)
    {
        if (FBTrace.DBG_CACHE && this.ignore)
            FBTrace.sysout("ChannelListener.onCollectData; IGNORE stopping further onCollectData");

        try
        {
            if (this.sink)
            {
                var bis = Xpcom.CCIN("@mozilla.org/binaryinputstream;1", "nsIBinaryInputStream");
                bis.setInputStream(inputStream);
                var data = bis.readBytes(count);

                // Data from the pipe has been consumed (to avoid mem leaks) so, we can end now.
                if (this.ignore)
                    return;
            }
            else
            {
                // In this case, we don't need to read the data.
                if (this.ignore)
                    return;

                var binaryInputStream =
                    Xpcom.CCIN("@mozilla.org/binaryinputstream;1", "nsIBinaryInputStream");
                var storageStream =
                    Xpcom.CCIN("@mozilla.org/storagestream;1", "nsIStorageStream");
                var binaryOutputStream =
                    Xpcom.CCIN("@mozilla.org/binaryoutputstream;1", "nsIBinaryOutputStream");

                binaryInputStream.setInputStream(inputStream);
                storageStream.init(8192, count, null);
                binaryOutputStream.setOutputStream(storageStream.getOutputStream(0));

                var data = binaryInputStream.readBytes(count);
                binaryOutputStream.writeBytes(data, count);
            }

            // Avoid creating additional empty line if response comes in more pieces
            // and the split is made just between "\r" and "\n" (Win line-end).
            // So, if the response starts with "\n" while the previous part ended with "\r",
            // remove the first character.
            if (this.endOfLine && data.length && data[0] == "\n")
                data = data.substring(1);

            if (data.length)
                this.endOfLine = data[data.length-1] == "\r";

            // If the method returns false, the rest of the response is ignored (not cached).
            // This is used to limit size of a cached response.
            if (!this.proxyListener.onCollectData(request, data, offset))
            {
                this.ignore = true;
            }

            // Let other listeners use the stream.
            if (storageStream)
                return storageStream.newInputStream(0);
        }
        catch (err)
        {
            if (FBTrace.DBG_CACHE || FBTrace.DBG_ERRORS)
                FBTrace.sysout("ChannelListener.onCollectData EXCEPTION\n", err);
        }

        return null;
    },

    /* nsIStreamListener */
    onDataAvailable: function(request, requestContext, inputStream, offset, count)
    {
        try
        {
            // Force a garbage collection cycle, see:
            // https://bugzilla.mozilla.org/show_bug.cgi?id=638075
            this.downloadCounter += count;
            if (this.downloadCounter > (1024*1024*2))
            {
                this.downloadCounter = 0;
                Cu.forceGC();
            }

            var newStream = this.proxyListener.onDataAvailable(request, requestContext,
                inputStream, offset, count);

            if (newStream)
                inputStream = newStream;

            newStream = this.onCollectData(request, null, inputStream, offset, count);
            if (newStream)
                inputStream = newStream;
        }
        catch (err)
        {
            if (FBTrace.DBG_CACHE || FBTrace.DBG_ERRORS)
                FBTrace.sysout("ChannelListener.onDataAvailable onCollectData FAILS " +
                    "(" + offset + ", " + count + ") EXCEPTION: " +
                    Http.safeGetRequestName(request), err);
        }

        if (this.listener)
        {
            try  // https://bugzilla.mozilla.org/show_bug.cgi?id=492534
            {
                this.listener.onDataAvailable(request, requestContext, inputStream, offset, count);
            }
            catch(exc)
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("ChannelListener.onDataAvailable canceling request at " +
                        "(" + offset + ", " + count + ") EXCEPTION: " +
                        Http.safeGetRequestName(request), exc);

                request.cancel(exc.result);
            }
        }
    },

    onStartRequest: function(request, requestContext)
    {
        try
        {
            this.request = request.QueryInterface(Ci.nsIHttpChannel);

            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("ChannelListener.onStartRequest; " +
                    this.request.contentType + ", " + Http.safeGetRequestName(this.request));

            // Don't register listener twice (redirects, see also bug529536).
            // xxxHonza: I don't know any way how to find out that a listener
            // has been already registered for the channel. So, use the redirection limit
            // to see that the channel has been redirected and so, listener is there.
            if (request.redirectionLimit < redirectionLimit)
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("ChannelListener.onStartRequest; redirected request " +
                        request.redirectionLimit + " (max=" + redirectionLimit + ")");
                return;
            }

            // Due to #489317, the check whether this response should be cached
            // must be done here (the content type is not valid before calling
            // onStartRequest). Let's ignore the response if it should not be cached.
            this.ignore = !this.proxyListener.shouldCacheRequest(request);

            // Notify proxy listener.
            this.proxyListener.onStartRequest(request, requestContext);

            // Listen for incoming data.
            if (FBTrace.DBG_CACHE && !this.sink)
                FBTrace.sysout("ChannelListener.onStartRequest NO SINK stopping setAsyncListener");

            if (FBTrace.DBG_CACHE && this.ignore && this.sink)
                FBTrace.sysout("ChannelListener.onStartRequest IGNORE(shouldCacheRequest) " +
                    "stopping setAsyncListener");

            // Even if the response is marked as ignored we need to read the sink
            // to avoid mem leaks.
            if (this.sink)
                this.setAsyncListener(request, this.sink.inputStream, this);
        }
        catch (err)
        {
            if (FBTrace.DBG_CACHE || FBTrace.DBG_ERRORS)
                FBTrace.sysout("ChannelListener.onStartRequest EXCEPTION\n", err);
        }

        if (this.listener)
        {
            try  // https://bugzilla.mozilla.org/show_bug.cgi?id=492534
            {
                this.listener.onStartRequest(request, requestContext);
            }
            catch(exc)
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("ChannelListener.onStartRequest canceling request " +
                    "EXCEPTION: " + Http.safeGetRequestName(request), exc);

                request.cancel(exc.result);
            }
        }
    },

    onStopRequest: function(request, requestContext, statusCode)
    {
        try
        {
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("ChannelListener.onStopRequest; " +
                    request.contentType + ", " + Http.safeGetRequestName(request));

            this.proxyListener.onStopRequest(request, requestContext, statusCode);
        }
        catch (err)
        {
            if (FBTrace.DBG_CACHE || FBTrace.DBG_ERRORS)
                FBTrace.sysout("ChannelListener.onStopRequest EXCEPTION\n", err);
        }

        // The request body has been downloaded. Remove the listener (the last parameter
        // is null) since it's not needed now.
        if (this.sink)
            this.setAsyncListener(request, this.sink.inputStream, null);

        if (this.listener)
            this.listener.onStopRequest(request, requestContext, statusCode);
    },

    /* nsITraceableChannel */
    setNewListener: function(listener)
    {
        this.proxyListener = listener;
        return null;
    },

    /* nsIInputStreamCallback */
    onInputStreamReady : function(stream)
    {
        try
        {
            if (FBTrace.DBG_CACHE)
                FBTrace.sysout("ChannelListener.onInputStreamReady " +
                    Http.safeGetRequestName(this.request));

            if (stream instanceof Ci.nsIAsyncInputStream)
            {
                try
                {
                    var offset = stream.tell();
                    var available = stream.available();
                    this.onDataAvailable(this.request, null, stream, offset, available);
                }
                catch (err)
                {
                    // stream.available throws an exception if the stream is closed,
                    // which is ok, since this callback can be called even in this
                    // situations.
                    if (FBTrace.DBG_CACHE)
                        FBTrace.sysout("ChannelListener.onInputStreamReady EXCEPTION calling onDataAvailable: " +
                            Http.safeGetRequestName(this.request), err);
                }

                // Listen for further incoming data.
                if (FBTrace.DBG_CACHE && this.ignore)
                    FBTrace.sysout("ChannelListener.onInputStreamReady IGNORE stopping setAsyncListener");

                this.setAsyncListener(this.request, stream, this);
            }
            else
            {
                if (FBTrace.DBG_CACHE)
                    FBTrace.sysout("ChannelListener.onInputStreamReady NOT a nsIAsyncInputStream",stream);
            }
        }
        catch (err)
        {
            if (FBTrace.DBG_CACHE || FBTrace.DBG_ERRORS)
                FBTrace.sysout("ChannelListener.onInputStreamReady EXCEPTION " +
                    Http.safeGetRequestName(this.request), err);
        }
    },

    /* nsISupports */
    QueryInterface: function(iid)
    {
        if (iid.equals(Ci.nsIStreamListener) ||
            iid.equals(Ci.nsIInputStreamCallback) ||
            iid.equals(Ci.nsISupportsWeakReference) ||
            iid.equals(Ci.nsITraceableChannel) ||
            iid.equals(Ci.nsISupports))
        {
            return this;
        }

        throw Components.results.NS_NOINTERFACE;
    }
};

// ********************************************************************************************* //

var HttpResponseObserver =
{
    register: function(win, request, listener)
    {
        if (request instanceof Ci.nsITraceableChannel)
            return new ChannelListener(win, request, listener);

        return null;
    }
};

return HttpResponseObserver;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/spy",
[
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/object",
    "firebug/firebug",
    "firebug/lib/domplate",
    "firebug/chrome/reps",
    "firebug/lib/events",
    "firebug/net/requestObserver",
    "firebug/js/stackFrame",
    "firebug/lib/http",
    "firebug/lib/css",
    "firebug/lib/dom",
    "firebug/chrome/window",
    "firebug/lib/system",
    "firebug/lib/string",
    "firebug/lib/url",
    "firebug/lib/array",
    "firebug/trace/debug",
    "firebug/net/httpActivityObserver",
    "firebug/net/netUtils",
    "firebug/trace/traceListener",
    "firebug/trace/traceModule",
    "firebug/lib/wrapper",
    "firebug/lib/options",
    "firebug/net/netPanel",
    "firebug/console/errors"
],
function(Module, Rep, Obj, Firebug, Domplate, FirebugReps, Events, HttpRequestObserver,
    StackFrame, Http, Css, Dom, Win, System, Str, Url, Arr, Debug, NetHttpActivityObserver,
    NetUtils, TraceListener, TraceModule, Wrapper, Options) {

// ********************************************************************************************* //
// Constants

var {domplate, TAG, DIV, SPAN, TD, TR, TABLE, TBODY, P, A} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;

var eventListenerService = Cc["@mozilla.org/eventlistenerservice;1"].
    getService(Ci.nsIEventListenerService);

// List of contexts with XHR spy attached.
var contexts = [];

var redirectionLimit = Options.getPref("network.http", "redirection-limit");

// Tracing
var TraceError = FBTrace.to("DBG_ERRORS");
var Trace = FBTrace.to("DBG_SPY");

// ********************************************************************************************* //
// Spy Module

/**
 * @module Represents a XHR Spy module. The main purpose of the XHR Spy feature is to monitor
 * XHR activity of the current page and create appropriate log into the Console panel.
 * This feature can be controlled by an option <i>Show XMLHttpRequests</i> (from within the
 * console panel).
 *
 * The module is responsible for attaching/detaching a HTTP Observers when Firebug is
 * activated/deactivated for a site.
 */
Firebug.Spy = Obj.extend(Module,
/** @lends Firebug.Spy */
{
    dispatchName: "spy",

    initialize: function()
    {
        this.traceListener = new TraceListener("spy.", "DBG_SPY", true);
        TraceModule.addListener(this.traceListener);

        Module.initialize.apply(this, arguments);
    },

    shutdown: function()
    {
        Module.shutdown.apply(this, arguments);

        TraceModule.removeListener(this.traceListener);
    },

    initContext: function(context)
    {
        context.spies = [];

        if (Firebug.showXMLHttpRequests && Firebug.Console.isAlwaysEnabled())
            this.attachObserver(context, context.window);

        Trace.sysout("spy.initContext " + contexts.length + " ", context.getName());
    },

    destroyContext: function(context)
    {
        // For any spies that are in progress, remove our listeners so that they don't leak
        this.detachObserver(context, null);

        if (context.spies && context.spies.length)
        {
            Trace.sysout("spy.destroyContext; ERROR There are spies in progress ("
                + context.spies.length + ") " + context.getName());
        }

        // Make sure that all Spies in progress are detached at this moment.
        // Clone the array beforehand since the spy object is removed from the
        // original array within detach.
        var spies = context.spies ? Arr.cloneArray(context.spies) : [];
        for (var i=0; i<spies.length; i++)
            spies[i].detach(true);

        delete context.spies;

        SpyHttpActivityObserver.cleanUp(context.window);

        Trace.sysout("spy.destroyContext " + contexts.length + " ", context.getName());
    },

    watchWindow: function(context, win)
    {
        if (Firebug.showXMLHttpRequests && Firebug.Console.isAlwaysEnabled())
            this.attachObserver(context, win);
    },

    unwatchWindow: function(context, win)
    {
        Trace.sysout("spy.unwatchWindow; " + (context ? context.getName() : "no context"));

        try
        {
            // This make sure that the existing context is properly removed from "contexts" array.
            this.detachObserver(context, win);

            SpyHttpActivityObserver.cleanUp(win);
        }
        catch (ex)
        {
            // Get exceptions here sometimes, so let's just ignore them
            // since the window is going away anyhow
            Debug.ERROR(ex);
        }
    },

    updateOption: function(name, value)
    {
        // XXXjjb Honza, if Console.isEnabled(context) false, then this can't be called,
        // but somehow seems not correct

        // XHR Spy needs to be detached/attached when:
        // 1) The Show XMLHttpRequests options is off/on
        // 2) The Console panel is disabled/enabled
        // See also issue 5109
        if (name == "showXMLHttpRequests" || name == "console.enableSites")
        {
            var tach = value ? this.attachObserver : this.detachObserver;

            Firebug.connection.eachContext(function tachAll(context)
            {
                Win.iterateWindows(context.window, function(win)
                {
                    tach.apply(this, [context, win]);
                });
            });
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Attaching Spy to XHR requests.

    /**
     * Returns false if Spy should not be attached to XHRs executed by the specified window.
     */
    skipSpy: function(win)
    {
        if (!win)
            return true;

        // Don't attach spy to chrome.
        var uri = Win.safeGetWindowLocation(win);
        if (uri && (Str.hasPrefix(uri, "about:") || Str.hasPrefix(uri, "chrome:")))
            return true;
    },

    attachObserver: function(context, win)
    {
        if (Firebug.Spy.skipSpy(win))
            return;

        for (var i=0; i<contexts.length; ++i)
        {
            if ((contexts[i].context == context) && (contexts[i].win == win))
                return;
        }

        // Register HTTP observers only once.
        if (contexts.length == 0)
        {
            HttpRequestObserver.addObserver(SpyHttpObserver, "firebug-http-event", false);
            SpyHttpActivityObserver.registerObserver();
        }

        contexts.push({context: context, win: win});

        Trace.sysout("spy.attachObserver (HTTP) " + contexts.length + " ", context.getName());
    },

    detachObserver: function(context, win)
    {
        for (var i=0; i<contexts.length; ++i)
        {
            if (contexts[i].context == context)
            {
                if (win && (contexts[i].win != win))
                    continue;

                contexts.splice(i, 1);

                // If no context is using spy, remove the (only one) HTTP observer.
                if (contexts.length == 0)
                {
                    HttpRequestObserver.removeObserver(SpyHttpObserver, "firebug-http-event");
                    SpyHttpActivityObserver.unregisterObserver();
                }

                Trace.sysout("spy.detachObserver (HTTP) " + contexts.length + " ",
                    context.getName());

                return;
            }
        }
    },

    /**
     * Return XHR object that is associated with specified request <i>nsIHttpChannel</i>.
     * Returns null if the request doesn't represent XHR.
     */
    getXHR: function(request)
    {
        // Does also query-interface for nsIHttpChannel.
        if (!(request instanceof Ci.nsIHttpChannel))
            return null;

        try
        {
            var callbacks = request.notificationCallbacks;
            if (callbacks)
            {
                StackFrame.suspendShowStackTrace();
                return callbacks.getInterface(Ci.nsIXMLHttpRequest);
            }
        }
        catch (exc)
        {
            if (exc.name == "NS_NOINTERFACE")
            {
                Trace.sysout("spy.getXHR; Request is not nsIXMLHttpRequest: " +
                    Http.safeGetRequestName(request));
            }
        }
        finally
        {
            StackFrame.resumeShowStackTrace();
        }

       return null;
    },
});

// ********************************************************************************************* //

/**
 * @class This observer uses {@link HttpRequestObserver} to monitor start and end of all XHRs.
 * using <code>http-on-modify-request</code>, <code>http-on-examine-response</code> and
 * <code>http-on-examine-cached-response</code> events. For every monitored XHR a new
 * instance of {@link Firebug.Spy.XMLHttpRequestSpy} object is created. This instance is removed
 * when the XHR is finished.
 */
var SpyHttpObserver =
/** @lends SpyHttpObserver */
{
    dispatchName: "SpyHttpObserver",

    observe: function(request, topic, data)
    {
        try
        {
            var redirect = (request.redirectionLimit < redirectionLimit);

            // There is no http-on-opening-request in case of redirect so, we need
            // to use http-on-modify-request.
            if ((topic == "http-on-modify-request" && redirect) ||
                topic == "http-on-opening-request" ||
                topic == "http-on-examine-response" ||
                topic == "http-on-examine-cached-response")
            {
                this.observeRequest(request, topic);
            }
        }
        catch (exc)
        {
            TraceError.sysout("spy.SpyHttpObserver EXCEPTION", exc);
        }
    },

    observeRequest: function(request, topic)
    {
        var win = Http.getWindowForRequest(request);
        var xhr = Firebug.Spy.getXHR(request);

        // The request must be associated with window (i.e. tab) and it also must be
        // real XHR request.
        if (!win || !xhr)
            return;

        var redirect = (request.redirectionLimit < redirectionLimit);

        for (var i=0; i<contexts.length; ++i)
        {
            var context = contexts[i];
            if (context.win == win)
            {
                var spyContext = context.context;
                var requestName = request.URI.asciiSpec;
                var requestMethod = request.requestMethod;

                if (topic == "http-on-modify-request" && redirect)
                    this.requestStarted(request, xhr, spyContext, requestMethod, requestName);
                else if (topic == "http-on-opening-request")
                    this.requestStarted(request, xhr, spyContext, requestMethod, requestName);
                else if (topic == "http-on-examine-response")
                    this.requestStopped(request, xhr, spyContext, requestMethod, requestName);
                else if (topic == "http-on-examine-cached-response")
                    this.requestStopped(request, xhr, spyContext, requestMethod, requestName);

                return;
            }
        }
    },

    requestStarted: function(request, xhr, context, method, url)
    {
        var spy = getSpyForXHR(request, xhr, context);
        spy.method = method;
        spy.href = url;

        Trace.sysout("spy.requestStarted; " + spy.href);

        // Get "body" for POST and PUT requests. It will be displayed in
        // appropriate tab of the XHR.
        if (method == "POST" || method == "PUT" || method == "PATCH")
            spy.postText = Http.readPostTextFromRequest(request, context);

        spy.urlParams = Url.parseURLParams(spy.href);

        // In case of redirects there is no stack and the source link is null.
        spy.sourceLink = StackFrame.getStackSourceLink();

        if (!spy.requestHeaders)
            spy.requestHeaders = getRequestHeaders(spy);

        // If it's enabled log the request into the console tab.
        if (Firebug.showXMLHttpRequests && Firebug.Console.isAlwaysEnabled())
        {
            spy.logRow = Firebug.Console.log(spy, spy.context, "spy", null, true);
            Css.setClass(spy.logRow, "loading");
        }

        // Notify registered listeners. The onStart event is fired once for entire XHR
        // (even if there is more redirects within the process).
        if (!isRedirect(request))
            Events.dispatch(Firebug.Spy.fbListeners, "onStart", [context, spy]);

        // Remember the start time et the end, so it's most accurate.
        spy.sendTime = new Date().getTime();
    },

    requestStopped: function(request, xhr, context, method, url)
    {
        var spy = getSpyForXHR(request, xhr, context);
        if (!spy)
            return;

        spy.endTime = new Date().getTime();
        spy.responseTime = spy.endTime - spy.sendTime;
        spy.mimeType = NetUtils.getMimeType(request.contentType, request.name);

        if (!spy.responseHeaders)
            spy.responseHeaders = getResponseHeaders(spy);

        if (!spy.statusText)
        {
            try
            {
                spy.statusCode = request.responseStatus;
                spy.statusText = request.responseStatusText;
            }
            catch (exc)
            {
                TraceError.sysout("spy.requestStopped " + spy.href + ", status access ERROR", exc);
            }
        }

        if (spy.logRow)
        {
            updateLogRow(spy);
            updateHttpSpyInfo(spy);
        }

        // Remove only the Spy object that has been created for an intermediate rediret
        // request. These exist only to be also displayed in the console and they
        // don't attach any listeners to the original XHR object (which is always created
        // only once even in case of redirects).
        // xxxHonza: These requests are not observer by the activityObserver now
        // (if they should be observed we have to remove them in the activityObserver)
        if (!spy.onLoad && spy.context.spies)
            Arr.remove(spy.context.spies, spy);

        Trace.sysout("spy.requestStopped: " + spy.href + ", responseTime: " +
            spy.responseTime + "ms, spy.responseText: " +
            (spy.reponseText ? spy.responseText.length : 0) + " bytes");
    }
};

// ************************************************************************************************
// Activity Observer

/**
 * @class This observer is used to properly monitor even multipart XHRs. It's based on
 * an activity-observer component that has been introduced in Firefox 3.6.
 */
var SpyHttpActivityObserver = Obj.extend(NetHttpActivityObserver,
/** @lends SpyHttpActivityObserver */
{
    dispatchName: "SpyHttpActivityObserver",
    activeRequests: [],

    observeRequest: function(request, activityType, activitySubtype, timestamp,
        extraSizeData, extraStringData)
    {
        if (activityType != Ci.nsIHttpActivityObserver.ACTIVITY_TYPE_HTTP_TRANSACTION &&
           (activityType == Ci.nsIHttpActivityObserver.ACTIVITY_TYPE_SOCKET_TRANSPORT &&
            activitySubtype != Ci.nsISocketTransport.STATUS_RECEIVING_FROM))
            return;

        // xxxHonza: this code is duplicated in net.js, it should be refactored.
        var win = Http.getWindowForRequest(request);
        if (!win)
        {
            var index = this.activeRequests.indexOf(request);
            if (index == -1)
                return;

            if (!(win = this.activeRequests[index+1]))
                return;
        }

        for (var i=0; i<contexts.length; ++i)
        {
            var context = contexts[i];
            if (context.win == win)
            {
                var spyContext = context.context;
                var spy = getSpyForXHR(request, null, spyContext, true);
                if (spy)
                    this.observeXHRActivity(win, spy, request, activitySubtype, timestamp);
                return;
            }
        }
    },

    observeXHRActivity: function(win, spy, request, activitySubtype, timestamp)
    {
        // Activity observer has precise time info; use it.
        var time = new Date();
        time.setTime(timestamp/1000);

        if (activitySubtype == Ci.nsIHttpActivityObserver.ACTIVITY_SUBTYPE_REQUEST_HEADER)
        {
            Trace.sysout("spy.observeXHRActivity REQUEST_HEADER " +
                Http.safeGetRequestName(request));

            this.activeRequests.push(request);
            this.activeRequests.push(win);

            spy.sendTime = time;
            spy.transactionStarted = true;
        }
        else if (activitySubtype == Ci.nsIHttpActivityObserver.ACTIVITY_SUBTYPE_TRANSACTION_CLOSE)
        {
            Trace.sysout("spy.observeXHRActivity TRANSACTION_CLOSE " +
                Http.safeGetRequestName(request));

            var index = this.activeRequests.indexOf(request);
            this.activeRequests.splice(index, 2);

            spy.endTime = time;
            spy.transactionClosed = true;

            updateTime(spy);

            // This should be the proper time to detach the Spy object, but only
            // in the case when the XHR is already loaded. If the XHR is made as part of the
            // page load, it may happen that the event (readyState == 4) comes later
            // than actual TRANSACTION_CLOSE.
            if (spy.loaded)
                spy.detach(false);
        }
        else if (activitySubtype == Ci.nsISocketTransport.STATUS_RECEIVING_FROM)
        {
            spy.endTime = time;
        }
    },

    cleanUp: function(win)
    {
        // https://bugzilla.mozilla.org/show_bug.cgi?id=669730
        for (var i=0; i<this.activeRequests.length; i+=2)
        {
            if (this.activeRequests[i+1] == win)
            {
                this.activeRequests.splice(i, 2);
                i -= 2;
            }
        }
    }
});

// ********************************************************************************************* //

function getSpyForXHR(request, xhrRequest, context, noCreate)
{
    var spy = null;

    if (!context.spies)
    {
        Trace.sysout("spy.getSpyForXHR; ERROR no spies array " +
            Http.safeGetRequestName(request));
        return;
    }

    // Iterate all existing spy objects in this context and look for one that is
    // already created for this request.
    var length = context.spies.length;
    for (var i=0; i<length; i++)
    {
        spy = context.spies[i];
        if (spy.request == request)
        {
            // Use the trace condition here to avoid additional code execution (Url.getFileName)
            // when the tracing is switched off
            if (Trace.active)
            {
                var name = Url.getFileName(spy.request.URI.asciiSpec);
                var origName = Url.getFileName(spy.request.originalURI.asciiSpec);
                Trace.sysout("spy.getSpyForXHR; FOUND spy object " + name + ", " + origName);
            }

            return spy;
        }
    }

    if (noCreate)
        return null;

    spy = new Firebug.Spy.XMLHttpRequestSpy(request, xhrRequest, context);
    context.spies.push(spy);

    var name = request.URI.asciiSpec;
    var origName = request.originalURI.asciiSpec;

    if (Trace.active)
    {
        var redirect = isRedirect(request);
        Trace.sysout("spy.getSpyForXHR; NEW spy object (" +
            (redirect ? "redirected XHR" : "new XHR") + ") for: " +
            Url.getFileName(name) + ", " + Url.getFileName(origName));
    }

    // Attach spy only to the original request. Notice that there can be more network requests
    // made by the same XHR if redirects are involved.

    // The Console panel should display XHR entry for evere redirect so we need to
    // attach spy for each request (even redirects). See issue 4009
    //if (name == origName)
        spy.attach();

    return spy;
}

// ********************************************************************************************* //

/**
 * @class This class represents a Spy object that is attached to XHR. This object
 * registers various listeners into the XHR in order to monitor various events fired
 * during the request process (onLoad, onAbort, etc.)
 */
Firebug.Spy.XMLHttpRequestSpy = function(request, xhrRequest, context)
{
    this.request = request;
    this.xhrRequest = xhrRequest;
    this.context = context;
    this.responseText = "";

    // For compatibility with the Net templates.
    this.isXHR = true;

    // Support for activity-observer
    this.transactionStarted = false;
    this.transactionClosed = false;
};

Firebug.Spy.XMLHttpRequestSpy.prototype =
/** @lends Firebug.Spy.XMLHttpRequestSpy */
{
    attach: function()
    {
        var spy = this;

        this.onReadyStateChange = function(event) { onHTTPSpyReadyStateChange(spy, event); };
        this.onLoad = function() { onHTTPSpyLoad(spy); };
        this.onError = function() { onHTTPSpyError(spy); };
        this.onAbort = function() { onHTTPSpyAbort(spy); };

        this.onEventListener = function(event)
        {
            switch (event.type)
            {
                case "readystatechange":
                    onHTTPSpyReadyStateChange(spy, event);
                break;
                case "load":
                    onHTTPSpyLoad(spy);
                break;
                case "error":
                    onHTTPSpyError(spy);
                break;
                case "abort":
                    onHTTPSpyAbort(spy);
                break;
            }
        };

        if (typeof(eventListenerService.addListenerForAllEvents) == "function")
        {
            eventListenerService.addListenerForAllEvents(this.xhrRequest,
                this.onEventListener, true, false, false);
        }
        else
        {
            this.onreadystatechange = this.xhrRequest.onreadystatechange;
            this.xhrRequest.onreadystatechange = this.onReadyStateChange;

            this.xhrRequest.addEventListener("load", this.onLoad, false);
            this.xhrRequest.addEventListener("error", this.onError, false);
            this.xhrRequest.addEventListener("abort", this.onAbort, false);
        }

        Trace.sysout("spy.attach; " + Http.safeGetRequestName(this.request));
    },

    detach: function(force)
    {
        // Bubble out if already detached.
        if (!this.onEventListener)
            return;

        // If the activity distributor is available, let's detach it when the XHR
        // transaction is closed. Since, in case of multipart XHRs the onLoad method
        // (readyState == 4) can be called mutliple times.
        // Keep in mind:
        // 1) It can happen that the TRANSACTION_CLOSE event comes before onload (if
        // the XHR is made as part of the page load), so detach if it's already closed.
        // 2) In case of immediate cache responses, the transaction doesn't have to
        // be started at all (or the activity observer is not available in Firefox 3.5).
        // So, also detach in this case.
        // Make sure spy will detach if force is true.
        if (!force && this.transactionStarted && !this.transactionClosed)
            return;

        Trace.sysout("spy.detach; " + Http.safeGetRequestName(this.request) + ", " +
            Url.getFileName(this.href));

        // Remove itself from the list of active spies.
        Arr.remove(this.context.spies, this);

        if (typeof(eventListenerService.addListenerForAllEvents) == "function")
        {
            eventListenerService.removeListenerForAllEvents(this.xhrRequest,
                this.onEventListener, true, false);
        }
        else
        {
            if (this.onreadystatechange)
                this.xhrRequest.onreadystatechange = this.onreadystatechange;

            try { this.xhrRequest.removeEventListener("load", this.onLoad, false); } catch (e) {}
            try { this.xhrRequest.removeEventListener("error", this.onError, false); } catch (e) {}
            try { this.xhrRequest.removeEventListener("abort", this.onAbort, false); } catch (e) {}
        }

        this.onreadystatechange = null;
        this.onLoad = null;
        this.onError = null;
        this.onAbort = null;

        this.onEventListener = null;
    },

    getURL: function()
    {
        // Don't use this.xhrRequest.channel.name to get the URL. In cases where the
        // same XHR object is reused for more requests, the URL can be wrong (issue 4738).
        return this.href;
    },

    // Cache listener
    onStopRequest: function(context, request, responseText)
    {
        Trace.sysout("spy.onStopRequest: " + Http.safeGetRequestName(request));

        if (!responseText)
            return;

        if (request == this.request)
            this.responseText = responseText;
    },
};

// ********************************************************************************************* //

function onHTTPSpyReadyStateChange(spy, event)
{
    if (Trace.active)
    {
        var name = Url.getFileName(spy.request.URI.asciiSpec);
        var origName = Url.getFileName(spy.request.originalURI.asciiSpec);

        Trace.sysout("spy.onHTTPSpyReadyStateChange " + spy.xhrRequest.readyState +
            " (multipart: " + spy.xhrRequest.multipart + ") " + name + ", " + origName);
    }

    // Remember just in case spy is detached (readyState == 4).
    var originalHandler = spy.onreadystatechange;

    // ReadyStateChange event with readyState == 1 is fired when the page calls  the |open| method.
    // This event is usually not cought since spy object is attached when HTTP-ON-OPENING-REQUEST
    // http even is fired - which happens after |readyState == 1|
    // This scenario happens if the xhr object is reused synchronously in page callback handler
    // (onreadystatechange) for another request. In such case we need to quickly detach our
    // Spy object. New one will be immediatelly created when HTTP-ON-OPENING-REQUEST is fired.
    // See issue 5049
    if (spy.xhrRequest.readyState == 1)
    {
        if (Trace.active)
        {
            Trace.sysout("spy.onHTTPSpyReadyStateChange; ready state == 1, XHR probably being " +
                "reused, detach" + Http.safeGetRequestName(spy.request) + ", " +
                Url.getFileName(spy.href));
        }

        spy.detach(false);
        return;
    }

    // Force response text to be updated in the UI (in case the console entry
    // has been already expanded and the response tab selected).
    if (spy.logRow && spy.xhrRequest.readyState >= 3)
    {
        var netInfoBox = getInfoBox(spy);
        if (netInfoBox)
        {
            netInfoBox.htmlPresented = false;
            netInfoBox.responsePresented = false;
        }
    }

    // If the request is loading update the end time.
    if (spy.logRow && spy.xhrRequest.readyState == 3 && spy.sendTime && spy.endTime)
    {
        spy.responseTime = spy.endTime - spy.sendTime;
        updateTime(spy);
    }

    // Request loaded. Get all the info from the request now, just in case the
    // XHR would be aborted in the original onReadyStateChange handler.
    if (spy.xhrRequest.readyState == 4)
    {
        // Cumulate response so that multipart response content is properly displayed.
        spy.responseText += Http.safeGetXHRResponseText(spy.xhrRequest);

        // The XHR is loaded now (used also by the activity observer).
        spy.loaded = true;

        // Update UI.
        updateLogRow(spy);
        updateHttpSpyInfo(spy, true);

        // Notify the Net panel about a request being loaded.
        // xxxHonza: I don't think this is necessary.
        // stopFile this breaks layout of the net panel in case of redirects.
        var netProgress = spy.context.netProgress;
        if (netProgress && !isRedirect(spy.request))
            netProgress.post(netProgress.stopFile, [spy.request, spy.endTime, spy.postText,
                spy.responseText]);

        // Notify registered listeners about finish of the XHR.
        Events.dispatch(Firebug.Spy.fbListeners, "onLoad", [spy.context, spy]);
    }

    // Pass the event to the original page handler.
    if (typeof(eventListenerService.addListenerForAllEvents) == "undefined")
        callPageHandler(spy, event, originalHandler);
}

function callPageHandler(spy, event, originalHandler)
{
    try
    {
        // Calling the page handler throwed an exception (see #502959)
        // This should be fixed in Firefox 3.5
        if (originalHandler && event)
        {
            if (originalHandler.handleEvent)
                originalHandler.handleEvent(event);
            else
                originalHandler.call(spy.xhrRequest, event);
        }
    }
    catch (exc)
    {
        TraceError.sysout("spy.onHTTPSpyReadyStateChange: EXCEPTION " + exc, [exc, event]);

        var xpcError = Firebug.Errors.reparseXPC(exc, spy.context);
        if (xpcError)
        {
            // TODO attach trace
            TraceError.sysout("spy.onHTTPSpyReadyStateChange: reparseXPC", xpcError);

            // Make sure the exception is displayed in both Firefox & Firebug console.
            throw new Error(xpcError.message, xpcError.href, xpcError.lineNo);
        }
        else
        {
            throw exc;
        }
    }
}

function onHTTPSpyLoad(spy)
{
    if (Trace.active)
    {
        Trace.sysout("spy.onHTTPSpyLoad: " + Http.safeGetRequestName(spy.request) + ", " +
            Url.getFileName(spy.href) + ", state: " + spy.xhrRequest.readyState);
    }

    // Detach must be done in onLoad (not in onreadystatechange) otherwise onAbort would
    // not be handled. Note that onAbort, onError and onLoad events are fired after
    // onreadystatechange and must also be handled.
    // Issue 5049: only detach if XHR state == 4. It can happen that XHR object is being
    // reused for another request and onLoad fires too soon. See also onHTTPSpyReadyStateChange
    // for more details.
    if (spy.xhrRequest.readyState == 4)
        spy.detach(false);

    // If the spy is not loaded yet (and so, the response was not cached), do it now.
    // This can happen since synchronous XHRs don't fire onReadyStateChange event (issue 2868).
    if (!spy.loaded)
    {
        spy.loaded = true;
        spy.responseText = Http.safeGetXHRResponseText(spy.xhrRequest);

        updateLogRow(spy);
        updateHttpSpyInfo(spy, true);
    }
}

function onHTTPSpyError(spy)
{
    Trace.sysout("spy.onHTTPSpyError; " + spy.href);

    spy.detach(false);
    spy.loaded = true;
    spy.error= true;

    updateLogRow(spy);
}

function onHTTPSpyAbort(spy)
{
    Trace.sysout("spy.onHTTPSpyAbort: " + spy.href);

    spy.detach(false);
    spy.loaded = true;

    // Ignore aborts if the request already has a response status.
    if (spy.xhrRequest.status)
    {
        updateLogRow(spy);
        return;
    }

    spy.aborted = true;
    spy.statusText = "Aborted";

    updateLogRow(spy);

    // Notify Net pane about a request beeing aborted.
    // xxxHonza: the net panel shoud find out this itself.
    var netProgress = spy.context.netProgress;
    if (netProgress)
    {
        netProgress.post(netProgress.abortFile, [spy.request, spy.endTime, spy.postText,
            spy.responseText]);
    }
}

// ********************************************************************************************* //

/**
 * @domplate Represents a template for XHRs logged in the Console panel. The body of the
 * log (displayed when expanded) is rendered using {@link Firebug.NetMonitor.NetInfoBody}.
 */
Firebug.Spy.XHR = domplate(Rep,
/** @lends Firebug.Spy.XHR */
{
    tag:
        DIV({"class": "spyHead", _repObject: "$object"},
            TABLE({"class": "spyHeadTable focusRow outerFocusRow", cellpadding: 0, cellspacing: 0,
                "role": "listitem", "aria-expanded": "false"},
                TBODY({"role": "presentation"},
                    TR({"class": "spyRow"},
                        TD({"class": "spyTitleCol spyCol", onclick: "$onToggleBody"},
                            DIV({"class": "spyTitle"},
                                "$object|getCaption"
                            ),
                            DIV({"class": "spyFullTitle spyTitle"},
                                "$object|getFullUri"
                            )
                        ),
                        TD({"class": "spyCol"},
                            DIV({"class": "spyStatus"}, "$object|getStatus")
                        ),
                        TD({"class": "spyCol"},
                            SPAN({"class": "spyIcon"})
                        ),
                        TD({"class": "spyCol"},
                            SPAN({"class": "spyTime"})
                        ),
                        TD({"class": "spyCol"},
                            TAG(FirebugReps.SourceLink.tag, {object: "$object.sourceLink"})
                        )
                    )
                )
            )
        ),

    getCaption: function(spy)
    {
        return spy.method.toUpperCase() + " " + Str.cropString(spy.getURL(), 100);
    },

    getFullUri: function(spy)
    {
        return spy.method.toUpperCase() + " " + spy.getURL();
    },

    getStatus: function(spy)
    {
        var text = "";
        if (spy.statusCode)
            text += spy.statusCode + " ";

        if (spy.statusText)
            return text += spy.statusText;

        return text;
    },

    onToggleBody: function(event)
    {
        var target = event.currentTarget;
        var logRow = Dom.getAncestorByClass(target, "logRow-spy");

        if (Events.isLeftClick(event))
        {
            Css.toggleClass(logRow, "opened");

            var spy = logRow.getElementsByClassName("spyHead")[0].repObject;
            var spyHeadTable = Dom.getAncestorByClass(target, "spyHeadTable");

            if (Css.hasClass(logRow, "opened"))
            {
                updateHttpSpyInfo(spy);

                if (spyHeadTable)
                    spyHeadTable.setAttribute("aria-expanded", "true");
            }
            else
            {
                // Notify all listeners about closing XHR entry and destroying the body.
                // Any custom tabs should be removed now.
                var netInfoBox = getInfoBox(spy);
                Events.dispatch(Firebug.NetMonitor.NetInfoBody.fbListeners, "destroyTabBody",
                    [netInfoBox, spy]);

                if (spyHeadTable)
                    spyHeadTable.setAttribute("aria-expanded", "false");

                // Remove the info box, it'll be re-created (together with custom tabs)
                // the next time the XHR entry is opened/updated.
                netInfoBox.parentNode.removeChild(netInfoBox);
            }
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    copyURL: function(spy)
    {
        System.copyToClipboard(spy.getURL());
    },

    copyParams: function(spy)
    {
        var text = spy.postText;
        if (!text)
            return;

        var url = Url.reEncodeURL(spy, text, true);
        System.copyToClipboard(url);
    },

    copyAsCurl: function(spy)
    {
        System.copyToClipboard(NetUtils.generateCurlCommand(spy,
            Options.get("net.curlAddCompressedArgument")));
    },

    copyResponse: function(spy)
    {
        System.copyToClipboard(spy.responseText);
    },

    openInTab: function(spy)
    {
        Win.openNewTab(spy.getURL(), spy.postText);
    },

    resend: function(spy, context)
    {
        try
        {
            if (!context.window)
            {
                TraceError.sysout("spy.resend; ERROR no context");
                return;
            }

            // xxxHonza: must be done through Console RDP
            var win = Wrapper.unwrapObject(context.window);
            var request = new win.XMLHttpRequest();
            request.open(spy.method, spy.href, true);

            var headers = spy.requestHeaders;
            for (var i=0; headers && i<headers.length; i++)
            {
                var header = headers[i];
                request.setRequestHeader(header.name, header.value);
            }

            var postData = NetUtils.getPostText(spy, context, true);
            request.send(postData);
        }
        catch (err)
        {
            TraceError.sysout("spy.resend; EXCEPTION " + err, err);
        }
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

    supportsObject: function(object, type)
    {
        return object instanceof Firebug.Spy.XMLHttpRequestSpy;
    },

    browseObject: function(spy, context)
    {
        var url = spy.getURL();
        Win.openNewTab(url);
        return true;
    },

    getRealObject: function(spy, context)
    {
        return spy.xhrRequest;
    },

    getContextMenuItems: function(spy, target, context)
    {
        var items = [{
            label: "CopyLocation",
            tooltiptext: "clipboard.tip.Copy_Location",
            id: "fbSpyCopyLocation",
            command: Obj.bindFixed(this.copyURL, this, spy)
        }];

        if (spy.postText)
        {
            items.push({
                label: "CopyLocationParameters",
                tooltiptext: "net.tip.Copy_Location_Parameters",
                command: Obj.bindFixed(this.copyParams, this, spy)
            });
        }

        items.push({
            label: "CopyResponse",
            id: "fbSpyCopyResponse",
            command: Obj.bindFixed(this.copyResponse, this, spy)
        });

        items.push(
            {
                id: "fbCopyAsCurl",
                label: "CopyAsCurl",
                tooltiptext: "net.tip.Copy_as_cURL",
                command: Obj.bindFixed(this.copyAsCurl, this, spy)
            }
        );

        items.push("-");

        items.push({
            label: "OpenInTab",
            tooltiptext: "firebug.tip.Open_In_Tab",
            id: "fbSpyOpenInTab",
            command: Obj.bindFixed(this.openInTab, this, spy)
        });

        items.push({
            label: "Open_Response_In_New_Tab",
            tooltiptext: "net.tip.Open_Response_In_New_Tab",
            id: "fbSpyOpenResponseInTab",
            command: Obj.bindFixed(NetUtils.openResponseInTab, this, spy)
        });

        items.push("-");

        items.push({
            label: "net.label.Resend",
            tooltiptext: "net.tip.Resend",
            id: "fbSpyResend",
            command: Obj.bindFixed(this.resend, this, spy, context)
        });

        return items;
    }
});

// ********************************************************************************************* //

Firebug.XHRSpyListener =
{
    onStart: function(context, spy)
    {
    },

    onLoad: function(context, spy)
    {
    }
};

// ********************************************************************************************* //

function updateTime(spy)
{
    if (spy.logRow)
    {
        var timeBox = spy.logRow.getElementsByClassName("spyTime").item(0);
        if (spy.sendTime && spy.endTime)
            timeBox.textContent = " " + Str.formatTime(spy.endTime - spy.sendTime);
    }
}

function updateLogRow(spy)
{
    updateTime(spy);

    if(spy.logRow)
    {
        var statusBox = spy.logRow.getElementsByClassName("spyStatus").item(0);
        statusBox.textContent = Firebug.Spy.XHR.getStatus(spy);
    }

    if (spy.loaded)
    {
        Css.removeClass(spy.logRow, "loading");
        Css.setClass(spy.logRow, "loaded");
    }

    if (spy.error || spy.aborted)
    {
        Css.setClass(spy.logRow, "error");
    }

    try
    {
        var errorRange = Math.floor(spy.xhrRequest.status/100);
        if (errorRange == 4 || errorRange == 5)
            Css.setClass(spy.logRow, "error");
    }
    catch (exc)
    {
    }
}

function updateHttpSpyInfo(spy, updateInfoBody)
{
    if (!spy.logRow || !Css.hasClass(spy.logRow, "opened"))
        return;

    if (!spy.params)
        spy.params = Url.parseURLParams(spy.href + "");

    if (!spy.requestHeaders)
        spy.requestHeaders = getRequestHeaders(spy);

    if (!spy.responseHeaders && spy.loaded)
        spy.responseHeaders = getResponseHeaders(spy);

    var template = Firebug.NetMonitor.NetInfoBody;
    var netInfoBox = getInfoBox(spy);

    var defaultTab;

    // If the associated XHR row is currently expanded, make sure to recreate
    // the info bodies if the flag says so.
    if (updateInfoBody)
    {
        // Remember the current selected info tab.
        if (netInfoBox.selectedTab)
            defaultTab = netInfoBox.selectedTab.getAttribute("view");

        // Remove the info box so, it's recreated below.
        netInfoBox.parentNode.removeChild(netInfoBox);
        netInfoBox = null;
    }

    if (!netInfoBox)
    {
        var head = spy.logRow.getElementsByClassName("spyHead")[0];
        netInfoBox = template.tag.append({"file": spy}, head);

        // Notify listeners so, custom info tabs can be appended
        Events.dispatch(template.fbListeners, "initTabBody", [netInfoBox, spy]);

        // If the response tab isn't available/visible (perhaps the response didn't came yet),
        // select the 'Headers' tab by default or keep the default tab.
        defaultTab = defaultTab || (template.hideResponse(spy) ? "Headers" : "Response");
        template.selectTabByName(netInfoBox, defaultTab);
    }
    else
    {
        template.updateInfo(netInfoBox, spy, spy.context);
    }
}

function getInfoBox(spy)
{
    return spy.logRow.querySelector(".spyHead > .netInfoBody");
}

function getInfoBox(spy)
{
    return spy.logRow.querySelector(".spyHead > .netInfoBody");
}

// ********************************************************************************************* //

function getRequestHeaders(spy)
{
    var headers = [];

    var channel = spy.xhrRequest.channel;
    if (channel instanceof Ci.nsIHttpChannel)
    {
        channel.visitRequestHeaders(
        {
            visitHeader: function(name, value)
            {
                headers.push({name: name, value: value});
            }
        });
    }

    return headers;
}

function getResponseHeaders(spy)
{
    var headers = [];

    try
    {
        var channel = spy.xhrRequest.channel;
        if (channel instanceof Ci.nsIHttpChannel)
        {
            channel.visitResponseHeaders(
            {
                visitHeader: function(name, value)
                {
                    headers.push({name: name, value: value});
                }
            });
        }
    }
    catch (exc)
    {
        TraceError.sysout("spy.getResponseHeaders; EXCEPTION " +
            Http.safeGetRequestName(spy.request), exc);
    }

    return headers;
}

function isRedirect(request)
{
    try
    {
        var name = request.URI.asciiSpec;
        var origName = request.originalURI.asciiSpec;
        return (name != origName);
    }
    catch (e)
    {
    }

    return false;
}

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.Spy);
Firebug.registerRep(Firebug.Spy.XHR);

return Firebug.Spy;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/svgViewer",
[
    "firebug/firebug",
    "firebug/chrome/activableModule",
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/xpcom",
    "firebug/lib/css",
    "firebug/lib/http",
    "firebug/net/netUtils"
],
function(Firebug, ActivableModule, Module, Rep, FBTrace, Obj, Domplate, Locale, Xpcom, Css, Http,
    NetUtils) {

"use strict";

// ********************************************************************************************* //
// Constants

var {domplate, DIV, PRE} = Domplate;

var Trace = FBTrace.to("DBG_SVGVIEWER");

// List of SVG related content types.
var contentTypes =
[
    "image/svg+xml",
];

// ********************************************************************************************* //
// Model implementation

/**
 * @module Implements viewer for SVG based network responses. In order to create a new
 * tab within network request detail, a listener is registered into
 * <code>Firebug.NetMonitor.NetInfoBody</code> object.
 */
Firebug.SVGViewerModel = Obj.extend(Module,
/** lends Firebug.SVGViewerModel */
{
    dispatchName: "svgViewer",

    initialize: function()
    {
        ActivableModule.initialize.apply(this, arguments);
        Firebug.NetMonitor.NetInfoBody.addListener(this);
    },

    shutdown: function()
    {
        ActivableModule.shutdown.apply(this, arguments);
        Firebug.NetMonitor.NetInfoBody.removeListener(this);
    },

    /**
     * Check response's content-type and if it's a SVG, create a new tab with SVG preview.
     */
    initTabBody: function(infoBox, file)
    {
        Trace.sysout("svgviewer.initTabBody", infoBox);

        // If the response is SVG let's display a pretty preview.
        if (this.isSVG(Http.safeGetContentType(file.request)))
        {
            Firebug.NetMonitor.NetInfoBody.appendTab(infoBox, "SVG",
                Locale.$STR("svgviewer.tab.SVG"));

            Trace.sysout("svgviewer.initTabBody; SVG response available");
        }
    },

    isSVG: function(contentType)
    {
        if (!contentType)
            return false;

        return NetUtils.matchesContentType(contentType, contentTypes);
    },

    /**
     * Parse SVG response and render pretty printed preview.
     */
    updateTabBody: function(infoBox, file, context)
    {
        var tab = infoBox.selectedTab;
        var tabBody = infoBox.getElementsByClassName("netInfoSVGText").item(0);
        if (!Css.hasClass(tab, "netInfoSVGTab") || tabBody.updated)
            return;

        tabBody.updated = true;

        this.insertSVG(tabBody, file.responseText);
    },

    insertSVG: function(parentNode, text)
    {
        var parser = Xpcom.CCIN("@mozilla.org/xmlextras/domparser;1", "nsIDOMParser");
        var doc = parser.parseFromString(text, "text/xml");
        var root = doc.documentElement;

        // Error handling
        var nsURI = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
        if (root.namespaceURI == nsURI && root.nodeName == "parsererror")
        {
            this.ParseError.tag.replace({error: {
                message: root.firstChild.nodeValue,
                source: root.lastChild.textContent
            }}, parentNode);
            return;
        }

        Trace.sysout("svgviewer.updateTabBody; SVG response parsed", doc);

        // Override getHidden in these templates. The parsed SVG document is
        // hidden, but we want to display it using 'visible' styling.
        var templates = [
            Firebug.HTMLPanel.CompleteElement,
            Firebug.HTMLPanel.Element,
            Firebug.HTMLPanel.TextElement,
            Firebug.HTMLPanel.EmptyElement,
            Firebug.HTMLPanel.XEmptyElement,
        ];

        var originals = [];
        for (var i=0; i<templates.length; i++)
        {
            originals[i] = templates[i].getHidden;
            templates[i].getHidden = function() {
                return "";
            };
        }

        // Generate SVG preview.
        Firebug.HTMLPanel.CompleteElement.tag.replace({object: doc.documentElement}, parentNode);

        for (var i=0; i<originals.length; i++)
            templates[i].getHidden = originals[i];
    }
});

// ********************************************************************************************* //
// Domplate

/**
 * @domplate Represents a template for displaying SVG parser errors. Used by
 * <code>Firebug.SVGViewerModel</code>.
 */
Firebug.SVGViewerModel.ParseError = domplate(Rep,
{
    tag:
        DIV({"class": "svgInfoError"},
            DIV({"class": "svgInfoErrorMsg"}, "$error.message"),
            PRE({"class": "svgInfoErrorSource"}, "$error|getSource")
        ),

    getSource: function(error)
    {
        var parts = error.source.split("\n");
        if (parts.length != 2)
            return error.source;

        var limit = 50;
        var column = parts[1].length;
        if (column >= limit) {
            parts[0] = "..." + parts[0].substr(column - limit);
            parts[1] = "..." + parts[1].substr(column - limit);
        }

        if (parts[0].length > 80)
            parts[0] = parts[0].substr(0, 80) + "...";

        return parts.join("\n");
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.SVGViewerModel);

return Firebug.SVGViewerModel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/timeInfoTip",
[
    "firebug/firebug",
    "firebug/chrome/rep",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/string",
    "firebug/net/netUtils",
    "firebug/lib/dom",
],
function(Firebug, Rep, Domplate, Locale, Str, NetUtils, Dom) {

// ********************************************************************************************* //
// Constants

var {domplate, FOR, DIV, SPAN, TD, TR, TABLE, TBODY, P, A} = Domplate;

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cr = Components.results;

// ********************************************************************************************* //
// Implementation

/**
 * @domplate This template is used to render an info tip with detailed timing for network
 * requests. The info tip is used on the Net panel.
 */
var TimeInfoTip = domplate(Rep,
{
    startTimeTag:
        TABLE({"class": "timeInfoTip"},
            TBODY(
                TR(
                    TD("$startTime.time|formatStartTime"),
                    TD({"class": "timeInfoTipStartLabel"},
                        "$startTime|getLabel"
                    )
                )
            )
        ),

    timingsTag:
        TABLE({"class": "timeInfoTip", "id": "fbNetTimeInfoTip", cellpadding: 0, cellspacing: 0},
            TBODY(
                TR(
                    TD({width: "5%"}),
                    TD({width: "5%"}),
                    TD({width: "90%"})
                ),
                FOR("time", "$timings",
                    TR({"class": "timeInfoTipRow", $collapsed: "$time|hideBar"},
                        TD("$time|getLabel"),
                        TD({"class": "timeInfoTipCell startTime"},
                            "$time.start|formatStartTime"
                        ),
                        TD({"class": "timeInfoTipCell bars"},
                            DIV({"class": "timeInfoTipBox"},
                                DIV({"class": "timeInfoTipBar $time|getBarClass",
                                    style: "left: $time.left%; width: $time.width%"},
                                    SPAN({"class": "perfTimingBarLabel"}, "$time.elapsed|formatTime")
                                )
                            )
                        )
                    )
                )
            )
        ),

    descriptionTag:
        DIV({"class": "timeInfoTipDesc"},
            "$label"
        ),

    eventsTag:
        TABLE({"class": "timeInfoTip"},
            TBODY(
                FOR("event", "$events",
                    TR({"class": "timeInfoTipEventRow"},
                        TD({"class": "timeInfoTipBar", align: "center"},
                            DIV({"class": "$event|getTimeStampClass timeInfoTipEventBar"})
                        ),
                        TD("$event.start|formatStartTime"),
                        TD({"class": "timeInfotTipEventName"},
                            "$event|getTimeStampLabel"
                        )
                    )
                )
            )
        ),

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Template Getters

    hideBar: function(obj)
    {
        return !obj.elapsed && obj.bar == "Blocking";
    },

    getBarClass: function(obj)
    {
        return "net" + obj.bar + "Bar";
    },

    getTimeStampClass: function(obj)
    {
        return obj.classes;
    },

    formatTime: function(time)
    {
        return Str.formatTime(time);
    },

    formatStartTime: function(time)
    {
        var label = Str.formatTime(time);
        if (!time)
            return label;

        return (time > 0 ? "+" : "") + label;
    },

    getLabel: function(obj)
    {
        return Locale.$STR("requestinfo." + obj.bar);
    },

    getTimeStampLabel: function(obj)
    {
        return obj.name;
    },

    // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //
    // Render

    render: function(context, file, parentNode)
    {
        Dom.clearNode(parentNode);

        var elapsed = file.loaded ? file.endTime - file.startTime :
            file.phase.phaseEndTime - file.startTime;
        var blockingEnd = NetUtils.getBlockingEndTime(file);

        //Helper log for debugging timing problems.
        //NetUtils.traceRequestTiming("net.timeInfoTip.render;", file);

        var startTime = 0;

        var timings = [];
        timings.push({bar: "Blocking",
            elapsed: blockingEnd - file.startTime,
            start: startTime});

        timings.push({bar: "Resolving",
            elapsed: file.connectingTime - file.resolvingTime,
            start: startTime += timings[0].elapsed});

        // Connecting time is measured till the sending time in order to include
        // also SSL negotiation.
        // xxxHonza: time between "connected" and "sending" is SSL negotiation?
        timings.push({bar: "Connecting",
            elapsed: file.connectStarted ? file.sendingTime - file.connectingTime : 0,
            start: startTime += timings[1].elapsed});

        // In Fx3.6 the STATUS_SENDING_TO is always fired (nsIHttpActivityDistributor)
        // In Fx3.5 the STATUS_SENDING_TO (nsIWebProgressListener) doesn't have to come
        // This workaround is for 3.5
        var sendElapsed = file.sendStarted ? file.waitingForTime - file.sendingTime : 0;
        var sendStarted = timings[0].elapsed + timings[1].elapsed + timings[2].elapsed;

        timings.push({bar: "Sending",
            elapsed: sendElapsed,
            start: file.sendStarted ? file.sendingTime - file.startTime : sendStarted});

        timings.push({bar: "Waiting",
            elapsed: file.respondedTime - file.waitingForTime,
            start: file.waitingForTime - file.startTime});

        timings.push({bar: "Receiving",
            elapsed: file.endTime - file.respondedTime,
            start: file.respondedTime - file.startTime,
            loaded: file.loaded, fromCache: file.fromCache});

        // Calculate position of waterfall bars.
        for (var i=0; i<timings.length; i++)
        {
            var time = timings[i];
            time.left = calculatePos(time.start, elapsed);
            time.width = calculatePos(time.elapsed, elapsed);
        }

        // Include custom time stamps
        var events = [];
        var timeStamps = file.phase.timeStamps;
        for (var i=0; i<timeStamps.length; i++)
        {
            var timeStamp = timeStamps[i];
            events.push({
                name: timeStamp.label,
                classes: timeStamp.classes,
                start: timeStamp.time - file.startTime
            });
        }

        events.sort(function(a, b) {
            return a.start < b.start ? -1 : 1;
        });

        var phases = context.netProgress.phases;

        if (FBTrace.DBG_ERROR && phases.length == 0)
            FBTrace.sysout("net.render; ERROR no phases");

        // Insert start request time. It's computed since the beginning (page load start time)
        // i.e. from the first phase start.
        var firstPhaseStartTime = (phases.length > 0) ? phases[0].startTime : file.startTime;

        var startTime = {};
        startTime.time = file.startTime - firstPhaseStartTime;
        startTime.bar = "started.label";
        this.startTimeTag.append({startTime: startTime}, parentNode);

        // Insert separator.
        this.descriptionTag.append(
            {label: Locale.$STR("requestinfo.phases.label")},
            parentNode);

        // Insert request timing info.
        this.timingsTag.append({timings: timings}, parentNode);

        // Insert events timing info.
        if (events.length)
        {
            // Insert separator.
            this.descriptionTag.append(
                {label: Locale.$STR("requestinfo.timings.label")},
                parentNode);

            this.eventsTag.append({events: events}, parentNode);
        }

        return true;
    }
});

// ********************************************************************************************* //
// Helpers

function calculatePos(time, elapsed)
{
    return Math.round((time / elapsed) * 100);
}

// ********************************************************************************************* //
// Registration

return TimeInfoTip;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/net/xmlViewer",
[
    "firebug/firebug",
    "firebug/chrome/activableModule",
    "firebug/chrome/module",
    "firebug/chrome/rep",
    "firebug/lib/trace",
    "firebug/lib/object",
    "firebug/lib/domplate",
    "firebug/lib/locale",
    "firebug/lib/xpcom",
    "firebug/lib/css",
    "firebug/lib/http",
    "firebug/net/netUtils"
],
function(Firebug, ActivableModule, Module, Rep, FBTrace, Obj, Domplate, Locale, Xpcom, Css, Http,
    NetUtils) {

"use strict";

// ********************************************************************************************* //
// Constants

var {domplate, DIV, PRE} = Domplate;

var Trace = FBTrace.to("DBG_XMLVIEWER");

// List of XML related content types.
var xmlContentTypes =
[
    "text/xml",
    "application/xml",
    "application/xhtml+xml",
    "application/rss+xml",
    "application/atom+xml",,
    "application/vnd.mozilla.maybe.feed",
    "application/mathml+xml",
    "application/rdf+xml",
    "application/vnd.mozilla.xul+xml"
];

// ********************************************************************************************* //
// Model implementation

/**
 * @module Implements viewer for XML based network responses. In order to create a new
 * tab within network request detail, a listener is registered into
 * <code>Firebug.NetMonitor.NetInfoBody</code> object.
 */
Firebug.XMLViewerModel = Obj.extend(Module,
/** lends Firebug.XMLViewerModel */
{
    dispatchName: "xmlViewer",

    initialize: function()
    {
        ActivableModule.initialize.apply(this, arguments);
        Firebug.NetMonitor.NetInfoBody.addListener(this);
    },

    shutdown: function()
    {
        ActivableModule.shutdown.apply(this, arguments);
        Firebug.NetMonitor.NetInfoBody.removeListener(this);
    },

    /**
     * Check response's content-type and if it's a XML, create a new tab with XML preview.
     */
    initTabBody: function(infoBox, file)
    {
        Trace.sysout("xmlviewer.initTabBody", infoBox);

        // If the response is XML let's display a pretty preview.
        if (this.isXML(Http.safeGetContentType(file.request)))
        {
            Firebug.NetMonitor.NetInfoBody.appendTab(infoBox, "XML",
                Locale.$STR("xmlviewer.tab.XML"));

            Trace.sysout("xmlviewer.initTabBody; XML response available");
        }
    },

    isXML: function(contentType)
    {
        if (!contentType)
            return false;

        return NetUtils.matchesContentType(contentType, xmlContentTypes);
    },

    /**
     * Parse XML response and render pretty printed preview.
     */
    updateTabBody: function(infoBox, file, context)
    {
        var tab = infoBox.selectedTab;
        var tabBody = infoBox.getElementsByClassName("netInfoXMLText").item(0);
        if (!Css.hasClass(tab, "netInfoXMLTab") || tabBody.updated)
            return;

        tabBody.updated = true;

        this.insertXML(tabBody, NetUtils.getResponseText(file, context));
    },

    insertXML: function(parentNode, text)
    {
        var parser = Xpcom.CCIN("@mozilla.org/xmlextras/domparser;1", "nsIDOMParser");
        var doc = parser.parseFromString(text, "text/xml");
        var root = doc.documentElement;

        // Error handling
        var nsURI = "http://www.mozilla.org/newlayout/xml/parsererror.xml";
        if (root.namespaceURI == nsURI && root.nodeName == "parsererror")
        {
            this.ParseError.tag.replace({error: {
                message: root.firstChild.nodeValue,
                source: root.lastChild.textContent
            }}, parentNode);
            return;
        }

        Trace.sysout("xmlviewer.updateTabBody; XML response parsed", doc);

        // Override getHidden in these templates. The parsed XML document is
        // hidden, but we want to display it using 'visible' styling.
        var templates = [
            Firebug.HTMLPanel.CompleteElement,
            Firebug.HTMLPanel.Element,
            Firebug.HTMLPanel.TextElement,
            Firebug.HTMLPanel.EmptyElement,
            Firebug.HTMLPanel.XEmptyElement,
        ];

        var originals = [];
        for (var i=0; i<templates.length; i++)
        {
            originals[i] = templates[i].getHidden;
            templates[i].getHidden = function() {
                return "";
            };
        }

        // Generate XML preview.
        Firebug.HTMLPanel.CompleteElement.tag.replace({object: doc.documentElement}, parentNode);

        for (var i=0; i<originals.length; i++)
            templates[i].getHidden = originals[i];
    }
});

// ********************************************************************************************* //
// Domplate

/**
 * @domplate Represents a template for displaying XML parser errors. Used by
 * <code>Firebug.XMLViewerModel</code>.
 */
Firebug.XMLViewerModel.ParseError = domplate(Rep,
{
    tag:
        DIV({"class": "xmlInfoError"},
            DIV({"class": "xmlInfoErrorMsg"}, "$error.message"),
            PRE({"class": "xmlInfoErrorSource"}, "$error|getSource")
        ),

    getSource: function(error)
    {
        var parts = error.source.split("\n");
        if (parts.length != 2)
            return error.source;

        var limit = 50;
        var column = parts[1].length;
        if (column >= limit) {
            parts[0] = "..." + parts[0].substr(column - limit);
            parts[1] = "..." + parts[1].substr(column - limit);
        }

        if (parts[0].length > 80)
            parts[0] = parts[0].substr(0, 80) + "...";

        return parts.join("\n");
    }
});

// ********************************************************************************************* //
// Registration

Firebug.registerModule(Firebug.XMLViewerModel);

return Firebug.XMLViewerModel;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/trace/debug",
[
    "firebug/lib/trace"
],
function(FBTrace) {

// ********************************************************************************************* //
// Debug APIs

const Cc = Components.classes;
const Ci = Components.interfaces;

var consoleService = Cc["@mozilla.org/consoleservice;1"].getService(Ci["nsIConsoleService"]);
var observerService = Cc["@mozilla.org/observer-service;1"].getService(Ci["nsIObserverService"]);

var Debug = {};

//************************************************************************************************
// Debug Logging

Debug.ERROR = function(exc)
{
    if (typeof(FBTrace) !== undefined)
    {
        if (exc.stack)
            exc.stack = exc.stack.split('\n');

        FBTrace.sysout("debug.ERROR: " + exc, exc);
    }

    if (consoleService)
        consoleService.logStringMessage("FIREBUG ERROR: " + exc);
};

// ********************************************************************************************* //
// Tracing for observer service

Debug.traceObservers = function(msg, topic)
{
    var counter = 0;
    var enumerator = observerService.enumerateObservers(topic);
    while (enumerator.hasMoreElements())
    {
        var observer = enumerator.getNext();
        counter++;
    }

    var label = "observer";
    if (counter > 1)
        label = "observers";

    FBTrace.sysout("debug.observers: " + msg + " There is " + counter + " " +
        label + " for " + topic);
};

// ********************************************************************************************* //

return Debug;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/trace/traceListener",
[
    "firebug/lib/string",
    "firebug/lib/css",
],
function(Str, Css) {

// ********************************************************************************************* //
// Trace Listener

/**
 * Default implementation of a Trace listener. Can be used to customize tracing logs
 * in the console in order to easily distinguish logs.
 */
function TraceListener(prefix, type, removePrefix, stylesheetURL)
{
    this.prefix = prefix;
    this.type = type;
    this.removePrefix = removePrefix;
    this.stylesheetURL = stylesheetURL;
}

TraceListener.prototype =
/** @lends TraceListener */
{
    // Called when console window is loaded.
    onLoadConsole: function(win, rootNode)
    {
        if (this.stylesheetURL)
            Css.appendStylesheet(rootNode.ownerDocument, this.stylesheetURL);
    },

    // Called when a new message is logged in to the trace-console window.
    onDump: function(message)
    {
        var index = message.text.indexOf(this.prefix);
        if (index == 0)
        {
            if (this.removePrefix)
                message.text = message.text.substr(this.prefix.length);

            message.text = Str.trim(message.text);
            message.type = this.type;
        }
    }
};

// ********************************************************************************************* //
// Registration

return TraceListener;

// ********************************************************************************************* //
});
/* See license.txt for terms of usage */

define("firebug/trace/traceModule",
[
    "firebug/firebug",
    "firebug/lib/object",
    "firebug/chrome/module",
],
function(Firebug, Obj, Module) {

// ************************************************************************************************
// Trace Module

/**
 * @module Use Firebug.TraceModule to register/unregister a trace listener that can be
 * used to customize look and feel of log messages in Tracing Console.
 *
 * Firebug.TraceModule.addListener - appends a tracing listener.
 * Firebug.TraceModule.removeListener - removes a tracing listener.
 */
Firebug.TraceModule = Obj.extend(Module,
{
    dispatchName: "traceModule",

    getListenerByPrefix: function(prefix)
    {
        for (var i=0; i<this.fbListeners.length; i++)
        {
            var listener = this.fbListeners[i];
            if (listener.prefix == prefix)
                return listener;
        }
    }
});

return Firebug.TraceModule;

// ************************************************************************************************
});
/* See license.txt for terms of usage */

(function() {

// ********************************************************************************************* //

const Cc = Components.classes;
const Ci = Components.interfaces;
const Cu = Components.utils;

var prefDomain = "extensions.firebug";

// xxxHonza: I am getting the following exception sometimes:
// Console Firebug.getModuleLoaderConfig is not a function"
// This could be be the reason why users can't open Firebug even if clicking on the start button.
// Looks like 'moduleConfig.js' is not loaded yet? (reported as Issue 6731)
if (typeof(Firebug.getModuleLoaderConfig) != "function")
{
    FBTrace.sysout("main; ERROR Firebug.getModuleLoaderConfig is not a function!");
    Cu.reportError("main; ERROR Firebug.getModuleLoaderConfig is not a function!");
    return;
}

var config = Firebug.getModuleLoaderConfig();

if (FBTrace.DBG_INITIALIZE || FBTrace.DBG_MODULES)
{
    if (FBTrace.DBG_MODULES)
        config.debug = true;

    FBTrace.sysout("main.js; Loading Firebug modules...", config);
    var startLoading = new Date().getTime();
}

// ********************************************************************************************* //

try
{
    // xxxHonza: temporary hack for Crossfire to provide custom set of modules.
    var prefService = Cc["@mozilla.org/preferences-service;1"].getService(Ci.nsIPrefBranch);
    var value = prefService.getCharPref("extensions.firebug.defaultModuleList");
    if (value)
    {
        var modules = value.split(",");
        if (modules.length)
            config.modules = modules;
    }
}
catch (err)
{
}

// ********************************************************************************************* //

// Backward compatibility (some modules changed location)
// http://getfirebug.com/wiki/index.php/Extension_Migration
// http://code.google.com/p/fbug/issues/detail?id=5199
var paths = {};
paths["firebug/css/cssComputedElementPanel"] = "firebug/css/computedPanel";
paths["firebug/css/cssElementPanel"] = "firebug/css/stylePanel";
paths["firebug/firefox/annotations"] = "firebug/chrome/annotations";
paths["firebug/firefox/privacy"] = "firebug/chrome/privacy";
paths["firebug/firefox/system"] = "firebug/lib/system";
paths["firebug/firefox/tabWatcher"] = "firebug/chrome/tabWatcher";
paths["firebug/firefox/xpcom"] = "firebug/lib/xpcom";
paths["firebug/firefox/window"] = "firebug/chrome/window";
paths["firebug/firefox/firefox"] = "firebug/chrome/firefox";
paths["firebug/net/httpLib"] = "firebug/lib/http";

var originalLoad = require.load;
require.load = function(context, fullName, url)
{
    if (paths[fullName])
    {
        var newUrl = paths[fullName].replace("firebug/", "firebug/content/");
        url = "chrome://" + newUrl + ".js";
    }

    return originalLoad.apply(require, [context, fullName, url]);
};

// ********************************************************************************************* //

// For now extensions should use 'Firebug.require' to load it's modules, so
// initialize the field. It should be done now since overlays can be applied
// before the core Firebug modules are (asynchronously) loaded.
Firebug.require = require;

// Load core Firebug modules.
var modules = [
    "firebug/chrome/chrome",
    "firebug/lib/lib",
    "firebug/firebug",
    "firebug/bti/inProcess/browser"
].concat(config.modules);

// ********************************************************************************************* //

require(config, modules, function(ChromeFactory, FBL, Firebug, Browser)
{
    try
    {
        // Wait till all modules (including those coming from Firebug extensions)
        // are loaded and thus all panels, firebug-modules, bundles, etc. are properly
        // registered and Firebug can start to send initialization events.
        if (typeof(requirejs) != "undefined")
        {
            var prevResourcesReady = requirejs.resourcesReady;
            requirejs.resourcesReady = function(isReady)
            {
                if (isReady && requirejs.resourcesDone)
                    onModulesLoaded(ChromeFactory, FBL, Firebug, Browser);

                if (prevResourcesReady)
                    prevResourcesReady(isReady);
            };
        }
        else
        {
            onModulesLoaded(ChromeFactory, FBL, Firebug, Browser);
        }
    }
    catch(exc)
    {
        if (FBTrace)
            FBTrace.sysout("Firebug main initialization ERROR " + exc, exc);

        window.dump("Firebug main initialization ERROR " + exc);

        if (Components)
            Components.utils.reportError(exc);
    }
});

// ********************************************************************************************* //

function onModulesLoaded(ChromeFactory, FBL, Firebug, Browser)
{
    // Extensions are using the same loader, so make sure to not
    // initialize Firebug twice.
    if (Firebug.isInitialized)
        return;

    if (FBTrace.DBG_INITIALIZE || FBTrace.DBG_MODULES)
    {
        var delta = (new Date().getTime()) - startLoading;
        FBTrace.sysout("main.js; Firebug modules loaded using RequireJS in " + delta + " ms");
    }

    // Extensions also shouldn't use the global require since it should be removed
    // in the future (if possible). Global 'require' could collide with other
    // extensions.
    Firebug.connection = new Browser();  // prepare for addListener calls

    Browser.onDebug = function()
    {
        FBTrace.sysout.apply(FBTrace, arguments);
    };

    Firebug.Options.initialize(prefDomain);

    function connect()
    {
        Firebug.connection.connect();  // start firing events
    }

    if (FBTrace.DBG_INITIALIZE || FBTrace.DBG_MODULES)
        FBTrace.sysout("main.js; All RequireJS modules loaded");

    if (window.FBL.legacyPatch)
    {
        if (FBTrace.DBG_MODULES)
            FBTrace.sysout("firebug main.js; legacyPatch");

        window.FBL.legacyPatch(FBL, Firebug);
    }

    if (!window.panelBarWaiter && FBTrace.DBG_ERRORS)
        FBTrace.sysout("main; ERROR window.panelBarWaiter is not available " +
            ", Firebug already initialized: " + Firebug.isInitialized);

    if (window.panelBarWaiter)
        window.panelBarWaiter.waitForPanelBar(ChromeFactory, null, connect);
}

// ********************************************************************************************* //
})();

// ********************************************************************************************* //
